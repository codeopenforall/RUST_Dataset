[
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "    fn sift_up(&mut self, start: usize, pos: usize) {\n        unsafe {\n            let mut hole = Hole::new(&mut self.data, pos);\n            while hole.pos() > start {\n                let parent = (hole.pos() - 1) / 2;\n                if hole.removed() <= hole.get(parent) { break }\n                hole.move_to(parent);\n            }\n        }\n    }\nfn sift_down_range(&mut self, mut pos: usize, end: usize) {\n        let start = pos;\n        unsafe {\n            let mut hole = Hole::new(&mut self.data, pos);\n            let mut child = 2 * pos + 1;\n            while child < end {\n                let right = child + 1;\n                if right < end && !(hole.get(child) > hole.get(right)) {\n                    child = right;\n                }\n                hole.move_to(child);\n                child = 2 * hole.pos() + 1;\n            }\n            pos = hole.pos;\n        }\n        self.sift_up(start, pos);\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "_WM_ParseNewMus(uint8_t *mus_data, uint32_t mus_size) {\n    uint8_t mus_hdr[] = { 'M', 'U', 'S', 0x1A };\n    uint32_t mus_song_ofs = 0;\n    uint32_t mus_song_len = 0;\n    uint16_t mus_ch_cnt1 = 0;\n    uint16_t mus_ch_cnt2 = 0;\n    uint16_t mus_no_instr = 0;\n    uint32_t mus_data_ofs = 0;\n    uint16_t * mus_mid_instr = NULL;\n    uint16_t mus_instr_cnt = 0;\n    struct _mdi *mus_mdi;\n    uint32_t mus_divisions = 60;\n    float tempo_f = 0.0;\n    uint16_t mus_freq = 0;\n    float samples_per_tick_f = 0.0;\n#define MUS_SZ 4\n    uint8_t mus_event[MUS_SZ] = { 0, 0, 0, 0 };\n    uint8_t mus_event_size = 0;\n    uint8_t mus_prev_vol[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n    uint32_t setup_ret = 0;\n    uint32_t mus_ticks = 0;\n    uint32_t sample_count = 0;\n    float sample_count_f = 0.0;\n    float sample_remainder = 0.0;\n    uint16_t pitchbend_tmp = 0;\n    if (mus_size < 17) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_MUS, \"File too short\", 0);\n        return NULL;\n    }\n    if (memcmp(mus_data, mus_hdr, 4)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_MUS, NULL, 0);\n        return NULL;\n    }\n    // Get Song Length\n    mus_song_len = (mus_data[5] << 8) | mus_data[4];\n    // Get Song Offset\n    mus_song_ofs = (mus_data[7] << 8) | mus_data[6];\n    // Have yet to determine what this actually is.\n    mus_ch_cnt1 = (mus_data[9] << 8) | mus_data[8];\n    mus_ch_cnt2 = (mus_data[11] << 8) | mus_data[10];\n    UNUSED(mus_ch_cnt1);\n    UNUSED(mus_ch_cnt2);\n    // Number of instruments defined\n    mus_no_instr = (mus_data[13] << 8) | mus_data[12];\n    // Skip next 2 data bytes\n    mus_data_ofs = 16;\n    // Check that we have enough data to check the rest\n    if (mus_size < (mus_data_ofs + (mus_no_instr << 1) + mus_song_len)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_MUS, \"File too short\", 0);\n        return NULL;\n    }\n    // Instrument definition\n    mus_mid_instr = malloc(mus_no_instr * sizeof(uint16_t));\n    for (mus_instr_cnt = 0; mus_instr_cnt < mus_no_instr; mus_instr_cnt++) {\n        mus_mid_instr[mus_instr_cnt] = (mus_data[mus_data_ofs + 1] << 8) | mus_data[mus_data_ofs];\n        mus_data_ofs += 2;\n    }\n    // make sure we are at song offset\n    mus_data_ofs = mus_song_ofs;\n    // do some calculations so we know how many samples per mus tick\n    mus_freq = _cvt_get_option(WM_CO_FREQUENCY);\n    if (mus_freq == 0) mus_freq = 140;\n    if ((_WM_MixerOptions & WM_MO_ROUNDTEMPO)) {\n        tempo_f = (float) (60000000 / mus_freq) + 0.5f;\n    } else {\n        tempo_f = (float) (60000000 / mus_freq);\n    }\n    samples_per_tick_f = _WM_GetSamplesPerTick(mus_divisions, (uint32_t)tempo_f);\n    // initialise the mdi structure\n    mus_mdi = _WM_initMDI();\n    _WM_midi_setup_divisions(mus_mdi, mus_divisions);\n    _WM_midi_setup_tempo(mus_mdi, (uint32_t)tempo_f);\n    // lets do this\n    do {\n        // Build the event\n    _mus_build_event:\n#if 1\n        // Mus drums happen on channel 15, swap channel 9 & 15\n        // DEBUG\n        MUS_EVENT_DEBUG(\"Before\", mus_data[mus_data_ofs], 0);\n        if ((mus_data[mus_data_ofs] & 0x0f) == 0x0f) {\n            mus_data[mus_data_ofs] = (mus_data[mus_data_ofs] & 0xf0) | 0x09;\n        } else if ((mus_data[mus_data_ofs] & 0x0f) == 0x09) {\n            mus_data[mus_data_ofs] = (mus_data[mus_data_ofs] & 0xf0) | 0x0f;\n        }\n        // DEBUG\n        MUS_EVENT_DEBUG(\"After\", mus_data[mus_data_ofs], 0);\n#endif\n        switch ((mus_data[mus_data_ofs] >> 4) & 0x07) {\n            case 0: // Note Off\n                mus_event_size = 2;\n                mus_event[0] = 0x80 | (mus_data[mus_data_ofs] & 0x0f);\n                mus_event[1] = mus_data[mus_data_ofs + 1];\n                mus_event[2] = 0;\n                mus_event[3] = 0;\n                break;\n            case 1: // Note On\n                if (mus_data[mus_data_ofs + 1] & 0x80) {\n                    mus_event_size = 3;\n                    mus_event[0] = 0x90 | (mus_data[mus_data_ofs] & 0x0f);\n                    mus_event[1] = mus_data[mus_data_ofs + 1] & 0x7f;\n                    mus_event[2] = mus_data[mus_data_ofs + 2];\n                    mus_event[3] = 0;\n                    mus_prev_vol[mus_data[mus_data_ofs] & 0x0f] = mus_event[2];\n                } else {\n                    mus_event_size = 2;\n                    mus_event[0] = 0x90 | (mus_data[mus_data_ofs] & 0x0f);\n                    mus_event[1] = mus_data[mus_data_ofs + 1];\n                    mus_event[2] = mus_prev_vol[mus_data[mus_data_ofs] & 0x0f];\n                    mus_event[3] = 0;\n                }\n                break;\n            case 2: // Pitch Bend\n                mus_event_size = 2;\n                mus_event[0] = 0xe0 | (mus_data[mus_data_ofs] & 0x0f);\n                pitchbend_tmp = mus_data[mus_data_ofs + 1] << 6;\n                mus_event[1] = pitchbend_tmp & 0x7f;\n                mus_event[2] = (pitchbend_tmp >> 7) & 0x7f;\n                mus_event[3] = 0;\n                break;\n            case 3:\n                mus_event_size = 2;\n                switch (mus_data[mus_data_ofs + 1]) {\n                    case 10: // All Sounds Off\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 120;\n                        mus_event[2] = 0;\n                        mus_event[3] = 0;\n                        break;\n                    case 11: // All Notes Off\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 123;\n                        mus_event[2] = 0;\n                        mus_event[3] = 0;\n                        break;\n                    case 12: // Mono (Not supported by WildMIDI)\n                        /*\n                         **************************\n                         FIXME: Add dummy mdi event\n                         **************************\n                         */\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 126;\n                        mus_event[2] = 0;\n                        mus_event[3] = 0;\n                        break;\n                    case 13: // Poly (Not supported by WildMIDI)\n                        /*\n                         **************************\n                         FIXME: Add dummy mdi event\n                         **************************\n                         */\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 127;\n                        mus_event[2] = 0;\n                        mus_event[3] = 0;\n                        break;\n                    case 14: // Reset All Controllers\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 121;\n                        mus_event[2] = 0;\n                        mus_event[3] = 0;\n                        break;\n                    default: // Unsupported\n                        goto _mus_next_data;\n                }\n                break;\n            case 4:\n                mus_event_size = 3;\n                switch (mus_data[mus_data_ofs + 1]) {\n                    case 0: // Patch\n                        /*\n                         *************************************************\n                         FIXME: Check if setting is MIDI or MUS instrument\n                         *************************************************\n                         */\n                        mus_event[0] = 0xc0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = mus_data[mus_data_ofs + 2];\n                        mus_event[2] = 0;\n                        mus_event[3] = 0;\n                        break;\n                    case 1: // Bank Select\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 0;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 2: // Modulation (Not supported by WildMidi)\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 1;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 3: // Volume\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 7;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 4: // Pan\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 10;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 5: // Expression\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 11;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 6: // Reverb (Not supported by WildMidi)\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 91;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 7: // Chorus (Not supported by WildMidi)\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 93;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 8: // Sustain\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 64;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 9: // Soft Peddle (Not supported by WildMidi)\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 67;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    default: // Unsupported\n                        goto _mus_next_data;\n                }\n                break;\n            case 5:\n                mus_event_size = 1;\n                goto _mus_next_data;\n                break;\n            case 6:\n                goto _mus_end_of_song;\n                break;\n            case 7:\n                mus_event_size = 1;\n                goto _mus_next_data;\n                break;\n        }\n        setup_ret = _WM_SetupMidiEvent(mus_mdi, (uint8_t *)mus_event, MUS_SZ, 0);\n        if (setup_ret == 0) {\n            goto _mus_end;\n        }\n    _mus_next_data:\n        if (!(mus_data[mus_data_ofs] & 0x80)) {\n            mus_data_ofs += mus_event_size;\n            goto _mus_build_event;\n        }\n        mus_data_ofs += mus_event_size;\n        mus_ticks = 0;\n        do {\n            mus_ticks = (mus_ticks << 7) | (mus_data[mus_data_ofs++] & 0x7f);\n        } while (mus_data[mus_data_ofs - 1] & 0x80);\n        sample_count_f = ((float)mus_ticks * samples_per_tick_f) + sample_remainder;\n        sample_count = (uint32_t)sample_count_f;\n        sample_remainder = sample_count_f - (float)sample_count;\n        mus_mdi->events[mus_mdi->event_count - 1].samples_to_next = sample_count;\n        mus_mdi->extra_info.approx_total_samples += sample_count;\n    } while (mus_data_ofs < mus_size);\n_mus_end_of_song:\n    // Finalise mdi structure\n    if ((mus_mdi->reverb = _WM_init_reverb(_WM_SampleRate, _WM_reverb_room_width, _WM_reverb_room_length, _WM_reverb_listen_posx, _WM_reverb_listen_posy)) == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \"to init reverb\", 0);\n        goto _mus_end;\n    }\n    _WM_midi_setup_endoftrack(mus_mdi);\n    mus_mdi->extra_info.current_sample = 0;\n    mus_mdi->current_event = &mus_mdi->events[0];\n    mus_mdi->samples_to_mix = 0;\n    mus_mdi->note = NULL;\n    _WM_ResetToStart(mus_mdi);\n_mus_end:\n    free(mus_mid_instr);\n    if (mus_mdi->reverb) return (mus_mdi);\n    _WM_freeMDI(mus_mdi);\n    return NULL;\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "\tfn domain(&self, token: &str) -> Option<Origin>;\n}\nimpl<F> WebProxyTokens for F where F: Fn(String) -> Option<Origin> + Send + Sync {\n\tfn domain(&self, token: &str) -> Option<Origin> { self(token.to_owned()) }\n}\nfn should_correctly_handle_long_label_when_splitted() {\n\tlet (server, fetch) = serve_with_fetch(\"xolrg9fePeQyKLnL\", \"https://contribution.melonport.com\");\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET /styles.css?test=123 HTTP/1.1\\r\\n\\\n\t\t\tHost: f1qprwk775k6am35a5wmpk3e9gnpgx3me1sk.mbsfcdqpwx3jd5h7ax39dxq2wvb5dhqpww3fe9t2wrvfdm.web.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\tresponse.assert_status(\"HTTP/1.1 200 OK\");\n\tassert_security_headers_for_embed(&response.headers);\n\tfetch.assert_requested(\"https://contribution.melonport.com/styles.css?test=123\");\n\tfetch.assert_no_more_requests();\n}\nfn should_disallow_non_get_requests() {\n\tlet (server, fetch) = serve_with_fetch(\"token\", \"https://parity.io\");\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tPOST / HTTP/1.1\\r\\n\\\n\t\t\tHost: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\\r\\n\\\n\t\t\tContent-Type: application/json\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\t123\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\tresponse.assert_status(\"HTTP/1.1 405 Method Not Allowed\");\n\tassert_security_headers_for_embed(&response.headers);\n\tfetch.assert_no_more_requests();\n}\nfn should_fix_absolute_requests_based_on_referer() {\n\tlet (server, fetch) = serve_with_fetch(\"token\", \"https://parity.io\");\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET /styles.css HTTP/1.1\\r\\n\\\n\t\t\tHost: localhost:8080\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\tReferer: http://localhost:8080/web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\tresponse.assert_status(\"HTTP/1.1 302 Found\");\n\tresponse.assert_header(\"Location\", \"/web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/styles.css\");\n\tfetch.assert_no_more_requests();\n}\nfn should_fix_absolute_requests_based_on_referer_in_url() {\n\tlet (server, fetch) = serve_with_fetch(\"token\", \"https://parity.io\");\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET /styles.css HTTP/1.1\\r\\n\\\n\t\t\tHost: localhost:8080\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\tReferer: http://localhost:8080/?__referer=web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\tresponse.assert_status(\"HTTP/1.1 302 Found\");\n\tresponse.assert_header(\"Location\", \"/web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/styles.css\");\n\tfetch.assert_no_more_requests();\n}\nfn should_return_error_on_invalid_protocol() {\n\tlet (server, fetch) = serve_with_fetch(\"token\", \"ftp://parity.io\");\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET /web/token/ftp/parity.io/ HTTP/1.1\\r\\n\\\n\t\t\tHost: localhost:8080\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\tresponse.assert_status(\"HTTP/1.1 400 Bad Request\");\n\tassert_security_headers_for_embed(&response.headers);\n\tfetch.assert_no_more_requests();\n}\nfn should_return_error_on_invalid_token() {\n\tlet (server, fetch) = serve_with_fetch(\"test\", \"https://parity.io\");\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET / HTTP/1.1\\r\\n\\\n\t\t\tHost: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\tresponse.assert_status(\"HTTP/1.1 400 Bad Request\");\n\tassert_security_headers_for_embed(&response.headers);\n\tfetch.assert_no_more_requests();\n}\nfn should_return_error_on_non_whitelisted_domain() {\n\tlet (server, fetch) = serve_with_fetch(\"token\", \"https://ethcore.io\");\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET / HTTP/1.1\\r\\n\\\n\t\t\tHost: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\tresponse.assert_status(\"HTTP/1.1 400 Bad Request\");\n\tassert_security_headers_for_embed(&response.headers);\n\tfetch.assert_no_more_requests();\n}\nfn should_stream_web_content() {\n\tlet (server, fetch) = serve_with_fetch(\"token\", \"https://parity.io\");\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET / HTTP/1.1\\r\\n\\\n\t\t\tHost: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\tresponse.assert_status(\"HTTP/1.1 200 OK\");\n\tassert_security_headers_for_embed(&response.headers);\n\tfetch.assert_requested(\"https://parity.io/\");\n\tfetch.assert_no_more_requests();\n}\nfn should_support_base32_encoded_web_urls() {\n\tlet (server, fetch) = serve_with_fetch(\"token\", \"https://parity.io\");\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET /styles.css?test=123 HTTP/1.1\\r\\n\\\n\t\t\tHost: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\tresponse.assert_status(\"HTTP/1.1 200 OK\");\n\tassert_security_headers_for_embed(&response.headers);\n\tfetch.assert_requested(\"https://parity.io/styles.css?test=123\");\n\tfetch.assert_no_more_requests();\n}\nfn should_support_base32_encoded_web_urls_as_path() {\n\tlet (server, fetch) = serve_with_fetch(\"token\", \"https://parity.io\");\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET /web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/styles.css?test=123 HTTP/1.1\\r\\n\\\n\t\t\tHost: localhost:8080\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\tresponse.assert_status(\"HTTP/1.1 200 OK\");\n\tassert_security_headers_for_embed(&response.headers);\n\tfetch.assert_requested(\"https://parity.io/styles.css?test=123\");\n\tfetch.assert_no_more_requests();\n}\n\tpub fn new<P: AsRef<Path>>(dapps_path: P, registrar: Arc<ContractClient>, remote: Remote) -> Self {\n\t\tServerBuilder {\n\t\t\tdapps_path: dapps_path.as_ref().to_owned(),\n\t\t\tregistrar: registrar,\n\t\t\tsync_status: Arc::new(|| false),\n\t\t\tweb_proxy_tokens: Arc::new(|_| None),\n\t\t\tsigner_address: None,\n\t\t\tallowed_hosts: DomainsValidation::Disabled,\n\t\t\tremote: remote,\n\t\t\tfetch: None,\n\t\t}\n\t}\npub fn serve_with_fetch(web_token: &'static str, domain: &'static str) -> (Server, FakeFetch) {\n\tlet fetch = FakeFetch::default();\n\tlet f = fetch.clone();\n\tlet (server, _) = init_server(move |builder| {\n\t\tbuilder\n\t\t\t.fetch(f.clone())\n\t\t\t.web_proxy_tokens(Arc::new(move |token| {\n\t\t\t\tif &token == web_token { Some(domain.into()) } else { None }\n\t\t\t}))\n\t}, Default::default(), Remote::new_sync());\n\t(server, fetch)\n}\n\tfn extract_target_url(&self, url: Option<Url>) -> Result<String, State<F>> {\n\t\tlet token_and_url = self.path.app_params.get(0)\n\t\t\t.map(|encoded| encoded.replace('.', \"\"))\n\t\t\t.and_then(|encoded| base32::decode(base32::Alphabet::Crockford, &encoded.to_uppercase()))\n\t\t\t.and_then(|data| String::from_utf8(data).ok())\n\t\t\t.ok_or_else(|| State::Error(ContentHandler::error(\n\t\t\t\tStatusCode::BadRequest,\n\t\t\t\t\"Invalid parameter\",\n\t\t\t\t\"Couldn't parse given parameter:\",\n\t\t\t\tself.path.app_params.get(0).map(String::as_str),\n\t\t\t\tself.embeddable_on.clone()\n\t\t\t)))?;\n\t\tlet mut token_it = token_and_url.split('+');\n\t\tlet token = token_it.next();\n\t\tlet target_url = token_it.next();\n\t\tlet domain = match token.and_then(|token| self.web_proxy_tokens.domain(token)) {\n\t\t\tSome(domain) => domain,\n\t\t\t_ => {\n\t\t\t\treturn Err(State::Error(ContentHandler::error(\n\t\t\t\t\tStatusCode::BadRequest, \"Invalid Access Token\", \"Invalid or old web proxy access token supplied.\", Some(\"Try refreshing the page.\"), self.embeddable_on.clone()\n\t\t\t\t)));\n\t\t\t}\n\t\t};\n\t\tlet mut target_url = match target_url {\n\t\t\tSome(url) if url.starts_with(\"http://\") || url.starts_with(\"https://\") => url.to_owned(),\n\t\t\t_ => {\n\t\t\t\treturn Err(State::Error(ContentHandler::error(\n\t\t\t\t\tStatusCode::BadRequest, \"Invalid Protocol\", \"Invalid protocol used.\", None, self.embeddable_on.clone()\n\t\t\t\t)));\n\t\t\t}\n\t\t};\n\t\tif !target_url.starts_with(&*domain) {\n\t\t\treturn Err(State::Error(ContentHandler::error(\n\t\t\t\tStatusCode::BadRequest, \"Invalid Domain\", \"Dapp attempted to access invalid domain.\", Some(&target_url), self.embeddable_on.clone(),\n\t\t\t)));\n\t\t}\n\t\tif !target_url.ends_with(\"/\") {\n\t\t\ttarget_url = format!(\"{}/\", target_url);\n\t\t}\n\t\tlet (path, query) = match (&url, self.path.using_dapps_domains) {\n\t\t\t(&Some(ref url), true) => (&url.path[..], &url.query),\n\t\t\t(&Some(ref url), false) => (&url.path[2..], &url.query),\n\t\t\t_ => {\n\t\t\t\treturn Err(State::Error(ContentHandler::error(\n\t\t\t\t\tStatusCode::BadRequest, \"Invalid URL\", \"Couldn't parse URL\", None, self.embeddable_on.clone()\n\t\t\t\t)));\n\t\t\t}\n\t\t};\n\t\tlet query = match *query {\n\t\t\tSome(ref query) => format!(\"?{}\", query),\n\t\t\tNone => \"\".into(),\n\t\t};\n\t\tOk(format!(\"{}{}{}\", target_url, path.join(\"/\"), query))\n\t}\n\tpub fn dapps_middleware(\n\t\tdeps: Dependencies,\n\t\tdapps_path: PathBuf,\n\t\textra_dapps: Vec<PathBuf>,\n\t\tdapps_domain: String,\n\t) -> Result<Middleware, String> {\n\t\tlet signer = deps.signer;\n\t\tlet parity_remote = parity_reactor::Remote::new(deps.remote.clone());\n\t\tlet web_proxy_tokens = Arc::new(move |token| signer.web_proxy_access_token_domain(&token));\n\t\tOk(parity_dapps::Middleware::dapps(\n\t\t\tparity_remote,\n\t\t\tdeps.ui_address,\n\t\t\tdapps_path,\n\t\t\textra_dapps,\n\t\t\tdapps_domain,\n\t\t\tdeps.contract_client,\n\t\t\tdeps.sync_status,\n\t\t\tweb_proxy_tokens,\n\t\t\tdeps.fetch,\n\t\t))\n\t}\n\tpub fn generate_web_proxy_access_token(&self, domain: Origin) -> String {\n\t\tlet token = random_string(16);\n\t\tlet mut tokens = self.web_proxy_tokens.lock();\n\t\ttokens.prune();\n\t\ttokens.insert(token.clone(), domain);\n\t\ttoken\n\t}\n\tpub fn web_proxy_access_token_domain(&self, token: &String) -> Option<Origin> {\n\t\tself.web_proxy_tokens.lock().get(token).cloned()\n\t}\n\tfn generate_web_proxy_token(&self, domain: String) -> Result<String, Error> {\n\t\tOk(self.signer.generate_web_proxy_access_token(domain.into()))\n\t}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn reserve(&mut self, additional: usize) {\n        let old_cap = self.cap();\n        let used_cap = self.len() + 1;\n        let new_cap = used_cap.checked_add(additional)\n            .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n            .expect(\"capacity overflow\");\n        if new_cap > old_cap {\n            self.buf.reserve_exact(used_cap, new_cap - used_cap);\n            unsafe {\n                self.handle_cap_increase(old_cap);\n            }\n        }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn repeat(&self, n: usize) -> Vec<T> where T: Copy {\n        if n == 0 {\n            return Vec::new();\n        }\n        let mut buf = Vec::with_capacity(self.len().checked_mul(n).expect(\"capacity overflow\"));\n        buf.extend(self);\n        {\n            let mut m = n >> 1;\n            while m > 0 {\n                unsafe {\n                    ptr::copy_nonoverlapping(\n                        buf.as_ptr(),\n                        (buf.as_mut_ptr() as *mut T).add(buf.len()),\n                        buf.len(),\n                    );\n                    let buf_len = buf.len();\n                    buf.set_len(buf_len * 2);\n                }\n                m >>= 1;\n            }\n        }\n        let rem_len = self.len() * n - buf.len(); \n        if rem_len > 0 {\n            unsafe {\n                ptr::copy_nonoverlapping(\n                    buf.as_ptr(),\n                    (buf.as_mut_ptr() as *mut T).add(buf.len()),\n                    rem_len,\n                );\n                let buf_cap = buf.capacity();\n                buf.set_len(buf_cap);\n            }\n        }\n        buf\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub unsafe fn guarded_transmute_vec_permissive<T>(mut bytes: Vec<u8>) -> Vec<T> {\n    PermissiveGuard::check::<T>(&bytes).unwrap();\n    let ptr = bytes.as_mut_ptr();\n    let capacity = bytes.capacity() / size_of::<T>();\n    let len = bytes.len() / size_of::<T>();\n    forget(bytes);\n    Vec::from_raw_parts(ptr as *mut T, len, capacity)\n}\npub unsafe fn guarded_transmute_to_bytes_vec<T>(mut from: Vec<T>) -> Vec<u8> {\n    let capacity = from.capacity() * size_of::<T>();\n    let len = from.len() * size_of::<T>();\n    let ptr = from.as_mut_ptr();\n    forget(from);\n    Vec::from_raw_parts(ptr as *mut u8, len, capacity)\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn is_unique(&mut self) -> bool {\n        if self.inner().weak.compare_exchange(1, usize::MAX, Acquire, Relaxed).is_ok() {\n            let unique = self.inner().strong.load(Acquire) == 1;\n            self.inner().weak.store(1, Release); \n            unique\n        } else {\n            false\n        }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn from_buf(buf: A) -> SmallVec<A> {\n        SmallVec {\n            capacity: A::size(),\n            data: SmallVecData::from_inline(MaybeUninit::new(buf)),\n        }\n    }\npub unsafe fn from_buf_and_len_unchecked(buf: A, len: usize) -> SmallVec<A> {\n        SmallVec {\n            capacity: len,\n            data: SmallVecData::from_inline(MaybeUninit::new(buf)),\n        }\n    }\nfn from_inline(inline: MaybeUninit<A>) -> SmallVecData<A> {\n        SmallVecData { inline }\n    }\npub fn from_slice(slice: &[A::Item]) -> Self {\n        let len = slice.len();\n        if len <= A::size() {\n            SmallVec {\n                capacity: len,\n                data: SmallVecData::from_inline(unsafe {\n                    let mut data: MaybeUninit<A> = MaybeUninit::uninit();\n                    ptr::copy_nonoverlapping(\n                        slice.as_ptr(),\n                        data.as_mut_ptr() as *mut A::Item,\n                        len,\n                    );\n                    data\n                })\n            }\n        } else {\n            let mut b = slice.to_vec();\n            let (ptr, cap) = (b.as_mut_ptr(), b.capacity());\n            mem::forget(b);\n            SmallVec {\n                capacity: cap,\n                data: SmallVecData::from_heap(ptr, len),\n            }\n        }\n    }\npub fn from_vec(mut vec: Vec<A::Item>) -> SmallVec<A> {\n        if vec.capacity() <= A::size() {\n            unsafe {\n                let mut data = SmallVecData::<A>::from_inline(MaybeUninit::uninit());\n                let len = vec.len();\n                vec.set_len(0);\n                ptr::copy_nonoverlapping(vec.as_ptr(), data.inline_mut(), len);\n                SmallVec {\n                    capacity: len,\n                    data,\n                }\n            }\n        } else {\n            let (ptr, cap, len) = (vec.as_mut_ptr(), vec.capacity(), vec.len());\n            mem::forget(vec);\n            SmallVec {\n                capacity: cap,\n                data: SmallVecData::from_heap(ptr, len),\n            }\n        }\n    }\npub fn grow(&mut self, new_cap: usize) {\n        unsafe {\n            let (ptr, &mut len, cap) = self.triple_mut();\n            let unspilled = !self.spilled();\n            assert!(new_cap >= len);\n            if new_cap <= self.inline_size() {\n                if unspilled {\n                    return;\n                }\n                self.data = SmallVecData::from_inline(MaybeUninit::uninit());\n                ptr::copy_nonoverlapping(ptr, self.data.inline_mut(), len);\n                self.capacity = len;\n            } else if new_cap != cap {\n                let mut vec = Vec::with_capacity(new_cap);\n                let new_alloc = vec.as_mut_ptr();\n                mem::forget(vec);\n                ptr::copy_nonoverlapping(ptr, new_alloc, len);\n                self.data = SmallVecData::from_heap(new_alloc, len);\n                self.capacity = new_cap;\n                if unspilled {\n                    return;\n                }\n            } else {\n                return;\n            }\n            deallocate(ptr, cap);\n        }\n    }\nunsafe fn inline(&self) -> *const A::Item {\n        self.inline.as_ptr() as *const A::Item\n    }\nunsafe fn inline_mut(&mut self) -> *mut A::Item {\n        self.inline.as_mut_ptr() as *mut A::Item\n    }\nunsafe fn into_inline(self) -> MaybeUninit<A> {\n        self.inline\n    }\npub fn into_inner(self) -> Result<A, Self> {\n        if self.spilled() || self.len() != A::size() {\n            Err(self)\n        } else {\n            unsafe {\n                let data = ptr::read(&self.data);\n                mem::forget(self);\n                Ok(data.into_inline().assume_init())\n            }\n        }\n    }\npub fn new() -> SmallVec<A> {\n        assert!(\n            mem::size_of::<A>() == A::size() * mem::size_of::<A::Item>()\n                && mem::align_of::<A>() >= mem::align_of::<A::Item>()\n        );\n        SmallVec {\n            capacity: 0,\n            data: SmallVecData::from_inline(MaybeUninit::uninit()),\n        }\n    }\npub fn shrink_to_fit(&mut self) {\n        if !self.spilled() {\n            return;\n        }\n        let len = self.len();\n        if self.inline_size() >= len {\n            unsafe {\n                let (ptr, len) = self.data.heap();\n                self.data = SmallVecData::from_inline(MaybeUninit::uninit());\n                ptr::copy_nonoverlapping(ptr, self.data.inline_mut(), len);\n                deallocate(ptr, self.capacity);\n                self.capacity = len;\n            }\n        } else if self.capacity() > len {\n            self.grow(len);\n        }\n    }\nfn triple(&self) -> (*const A::Item, usize, usize) {\n        unsafe {\n            if self.spilled() {\n                let (ptr, len) = self.data.heap();\n                (ptr, len, self.capacity)\n            } else {\n                (self.data.inline(), self.capacity, A::size())\n            }\n        }\n    }\nfn triple_mut(&mut self) -> (*mut A::Item, &mut usize, usize) {\n        unsafe {\n            if self.spilled() {\n                let &mut (ptr, ref mut len_ptr) = self.data.heap_mut();\n                (ptr, len_ptr, self.capacity)\n            } else {\n                (self.data.inline_mut(), &mut self.capacity, A::size())\n            }\n        }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n        f.debug_tuple(\"Iter\")\n            .field(&front)\n            .field(&back)\n            .finish()\n    }\nfn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let (front, back) = RingSlices::ring_slices(&*self.ring, self.head, self.tail);\n        f.debug_tuple(\"IterMut\")\n            .field(&front)\n            .field(&back)\n            .finish()\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "    fn ready(&mut self, poll: &mut mio::Poll, ev: &mio::Event) {\n        if ev.readiness().is_readable() {\n            self.do_tls_read();\n            self.try_plain_read();\n            self.try_back_read();\n        }\n        if ev.readiness().is_writable() {\n            self.do_tls_write_and_handle_error();\n        }\n        if self.closing {\n            let _ = self.socket.shutdown(Shutdown::Both);\n            self.close_back();\n            self.closed = true;\n        } else {\n            self.reregister(poll);\n        }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn parse_short_str_(&mut self) -> Result<&'de str> {\n        let mut padding = [0u8; 32];\n        let idx = self.iidx + 1;\n        let src: &[u8] = unsafe { &self.input.get_unchecked(idx..) };\n        #[allow(clippy::cast_ptr_alignment)]\n        let v: __m256i = if src.len() >= 32 {\n            #[allow(clippy::cast_ptr_alignment)]\n            unsafe {\n                _mm256_loadu_si256(src.get_unchecked(..32).as_ptr() as *const __m256i)\n            }\n        } else {\n            unsafe {\n                padding\n                    .get_unchecked_mut(..src.len())\n                    .clone_from_slice(&src);\n                #[allow(clippy::cast_ptr_alignment)]\n                _mm256_loadu_si256(padding.get_unchecked(..32).as_ptr() as *const __m256i)\n            }\n        };\n        let bs_bits: u32 = unsafe {\n            static_cast_u32!(_mm256_movemask_epi8(_mm256_cmpeq_epi8(\n                v,\n                _mm256_set1_epi8(b'\\\\' as i8)\n            )))\n        };\n        let quote_mask = unsafe { _mm256_cmpeq_epi8(v, _mm256_set1_epi8(b'\"' as i8)) };\n        let quote_bits = unsafe { static_cast_u32!(_mm256_movemask_epi8(quote_mask)) };\n        if (bs_bits.wrapping_sub(1) & quote_bits) != 0 {\n            let quote_dist: u32 = trailingzeroes(u64::from(quote_bits)) as u32;\n            let v = unsafe {\n                self.input.get_unchecked(idx..idx + quote_dist as usize) as *const [u8]\n                    as *const str\n            };\n            self.str_offset = idx + quote_dist as usize;\n            unsafe {\n                return Ok(&*v);\n            }\n        }\n        self.parse_str_()\n    }\nfn parse_str_(&mut self) -> Result<&'de str> {\n        use std::slice::from_raw_parts_mut;\n        let idx = self.iidx + 1;\n        let mut padding = [0u8; 32];\n        let needs_relocation = idx - self.str_offset <= 32;\n        let dst: &mut [u8] = if needs_relocation {\n            &mut self.strings\n        } else {\n            let ptr = self.input.as_mut_ptr();\n            unsafe {\n                from_raw_parts_mut(ptr.add(self.str_offset), self.input.len() - self.str_offset)\n            }\n        };\n        let src: &[u8] = unsafe { &self.input.get_unchecked(idx..) };\n        let mut src_i: usize = 0;\n        let mut dst_i: usize = 0;\n        loop {\n            let v: __m256i = if src.len() >= src_i + 32 {\n                #[allow(clippy::cast_ptr_alignment)]\n                unsafe {\n                    _mm256_loadu_si256(src.as_ptr().add(src_i) as *const __m256i)\n                }\n            } else {\n                unsafe {\n                    padding\n                        .get_unchecked_mut(..src.len() - src_i)\n                        .clone_from_slice(src.get_unchecked(src_i..));\n                    #[allow(clippy::cast_ptr_alignment)]\n                    _mm256_loadu_si256(padding.as_ptr() as *const __m256i)\n                }\n            };\n            #[allow(clippy::cast_ptr_alignment)]\n            unsafe {\n                _mm256_storeu_si256(dst.as_mut_ptr().add(dst_i) as *mut __m256i, v)\n            };\n            let bs_bits: u32 = unsafe {\n                static_cast_u32!(_mm256_movemask_epi8(_mm256_cmpeq_epi8(\n                    v,\n                    _mm256_set1_epi8(b'\\\\' as i8)\n                )))\n            };\n            let quote_mask = unsafe { _mm256_cmpeq_epi8(v, _mm256_set1_epi8(b'\"' as i8)) };\n            let quote_bits = unsafe { static_cast_u32!(_mm256_movemask_epi8(quote_mask)) };\n            if (bs_bits.wrapping_sub(1) & quote_bits) != 0 {\n                let quote_dist: u32 = trailingzeroes(u64::from(quote_bits)) as u32;\n                dst_i += quote_dist as usize;\n                unsafe {\n                    if needs_relocation {\n                        self.input\n                            .get_unchecked_mut(self.str_offset..self.str_offset + dst_i as usize)\n                            .clone_from_slice(&self.strings.get_unchecked(..dst_i));\n                    }\n                    let v = self\n                        .input\n                        .get_unchecked(self.str_offset..self.str_offset + dst_i as usize)\n                        as *const [u8] as *const str;\n                    self.str_offset += dst_i as usize;\n                    return Ok(&*v);\n                }\n            }\n            if (quote_bits.wrapping_sub(1) & bs_bits) != 0 {\n                let bs_dist: u32 = trailingzeroes(u64::from(bs_bits));\n                let escape_char: u8 = unsafe { *src.get_unchecked(src_i + bs_dist as usize + 1) };\n                if escape_char == b'u' {\n                    // move src/dst up to the start; they will be further adjusted\n                    // within the unicode codepoint handling code.\n                    src_i += bs_dist as usize;\n                    dst_i += bs_dist as usize;\n                    let (o, s) = if let Ok(r) =\n                        handle_unicode_codepoint(unsafe { src.get_unchecked(src_i..) }, unsafe {\n                            dst.get_unchecked_mut(dst_i..)\n                        }) {\n                        r\n                    } else {\n                        return Err(self.error(ErrorType::InvlaidUnicodeCodepoint));\n                    };\n                    if o == 0 {\n                        return Err(self.error(ErrorType::InvlaidUnicodeCodepoint));\n                    };\n                    // We moved o steps forword at the destiation and 6 on the source\n                    src_i += s;\n                    dst_i += o;\n                } else {\n                    // simple 1:1 conversion. Will eat bs_dist+2 characters in input and\n                    // write bs_dist+1 characters to output\n                    // note this may reach beyond the part of the buffer we've actually\n                    let escape_result: u8 =\n                        unsafe { *ESCAPE_MAP.get_unchecked(escape_char as usize) };\n                    if escape_result == 0 {\n                        return Err(self.error(ErrorType::InvalidEscape));\n                    }\n                    unsafe {\n                        *dst.get_unchecked_mut(dst_i + bs_dist as usize) = escape_result;\n                    }\n                    src_i += bs_dist as usize + 2;\n                    dst_i += bs_dist as usize + 1;\n                }\n            } else {\n                src_i += 32;\n                dst_i += 32;\n            }\n        }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn is_permitted_char(c: char) -> bool {\n    is_permitted_printable_char(c) || is_permitted_newline_char(c)\n}\npub fn is_permitted_newline_char(c: char) -> bool {\n    let x = c as u32;\n    x == 0x0A\n}\npub fn is_permitted_printable_char(c: char) -> bool {\n    let x = c as u32;\n    let is_above_space = x >= 0x20; \n    let is_below_tilde = x <= 0x7E; \n    let is_tab = x == 0x09; \n    (is_above_space && is_below_tilde) || is_tab\n}\npub fn parse_cmd(cmd_str: &str, _sender_address: AccountAddress) -> Result<ast::Cmd> {\n    let stripped_string = &strip_comments_and_verify(cmd_str)?;\n    let parser = syntax::CmdParser::new();\n    match parser.parse(stripped_string) {\n        Ok(cmd) => Ok(cmd),\n        Err(e) => handle_error(e, stripped_string),\n    }\n}\npub fn parse_module(modules_str: &str) -> Result<ast::ModuleDefinition> {\n    let stripped_string = &strip_comments_and_verify(modules_str)?;\n    let parser = syntax::ModuleParser::new();\n    match parser.parse(stripped_string) {\n        Ok(module) => Ok(module),\n        Err(e) => handle_error(e, stripped_string),\n    }\n}\npub fn parse_program(program_str: &str) -> Result<ast::Program> {\n    let stripped_string = &strip_comments_and_verify(program_str)?;\n    let parser = syntax::ProgramParser::new();\n    match parser.parse(stripped_string) {\n        Ok(program) => Ok(program),\n        Err(e) => handle_error(e, stripped_string),\n    }\n}\npub fn parse_script(script_str: &str) -> Result<ast::Script> {\n    let stripped_string = &strip_comments_and_verify(script_str)?;\n    let parser = syntax::ScriptParser::new();\n    match parser.parse(stripped_string) {\n        Ok(script) => Ok(script),\n        Err(e) => handle_error(e, stripped_string),\n    }\n}\nfn strip_comments(source: &str) -> String {\n    const SLASH: char = '/';\n    const SPACE: char = ' ';\n    let mut in_comment = false;\n    let mut acc = String::with_capacity(source.len());\n    let mut char_iter = source.chars().peekable();\n    while let Some(chr) = char_iter.next() {\n        let at_newline = is_permitted_newline_char(chr);\n        let at_or_after_slash_slash =\n            in_comment || (chr == SLASH && char_iter.peek().map(|c| *c == SLASH).unwrap_or(false));\n        in_comment = !at_newline && at_or_after_slash_slash;\n        acc.push(if in_comment { SPACE } else { chr });\n    }\n    acc\n}\nfn strip_comments_and_verify(string: &str) -> Result<String> {\n    verify_string(string)?;\n    Ok(strip_comments(string))\n}\nfn verify_string(string: &str) -> Result<()> {\n    match string.chars().find(|c| !is_permitted_char(*c)) {\n        None => Ok(()),\n        Some(chr) => bail!(\n            \"Parser Error: invalid character {} found when reading file.\\\n             Only ascii printable, tabs (\\\\t), and \\\\n line ending characters are permitted.\",\n            chr\n        ),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn map_elements<B, F: FnMut(A) -> B>(self, mut f: F) -> Matrix<B, M, N>\n      where M: ArrayLength<B>, N: ArrayLength<GenericArray<B, M>> {\n        let Matrix(a) = self;\n        let _wrapper = mem::ManuallyDrop::new(a);\n        let mut c: GenericArray<GenericArray<B, M>, N> = unsafe { mem::uninitialized() };\n        for i in 0..N::to_usize() { for j in 0..M::to_usize() { unsafe {\n            ptr::write(&mut c[i][j], f(ptr::read(&_wrapper[i][j])))\n        } } }\n        Matrix(c)\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "    fn resolve_index_to_str(&self, index: usize) -> Option<&str> {\n        let len_bytes = self.buffer.get(index - LEN_LOOKBEHIND..index)?;\n        let len_bytes = <&[u8; LEN_LOOKBEHIND]>::try_from(len_bytes).unwrap();\n        let len = decode_len_backwards(len_bytes);\n        let str_bytes = self.buffer.get(index..index + len)?;\n        let string = unsafe { str::from_utf8_unchecked(str_bytes) };\n        Some(string)\n    }\nunsafe fn resolve_index_to_str_unchecked(&self, index: usize) -> &str {\n        let len_bytes =\n            unsafe { self.buffer.get_unchecked(index - LEN_LOOKBEHIND..index) };\n        let len_bytes = <&[u8; LEN_LOOKBEHIND]>::try_from(len_bytes).unwrap();\n        let len = decode_len_backwards(len_bytes);\n        let str_bytes = unsafe { self.buffer.get_unchecked(index..index + len) };\n        unsafe { str::from_utf8_unchecked(str_bytes) }\n    }\nfn push_string(&mut self, string: &str) -> S {\n        if self.buffer.is_empty() {\n            self.buffer.resize(LONG_LEN, 0);\n        }\n        if string.len() <= MAX_SHORT_LEN {\n            self.buffer.reserve(SHORT_LEN + string.len());\n            self.buffer.push(string.len() as u8);\n        } else {\n            self.buffer\n                .reserve(SHORT_LEN + LONG_LEN + SHORT_LEN + string.len());\n            self.buffer.push(SENTINEL_SHORT_LEN);\n            self.buffer.extend_from_slice(&string.len().to_ne_bytes());\n            self.buffer.push(SENTINEL_SHORT_LEN);\n        }\n        let symbol = expect_valid_symbol(self.buffer.len());\n        self.buffer.extend_from_slice(string.as_bytes());\n        self.len_strings += 1;\n        symbol\n    }\nfn with_capacity(capacity: usize) -> Self {\n        const DEFAULT_STR_LEN: usize = 5;\n        let bytes_per_string = DEFAULT_STR_LEN + SHORT_LEN;\n        Self {\n            len_strings: 0,\n            buffer: Vec::with_capacity(capacity * bytes_per_string),\n            marker: Default::default(),\n        }\n    }\nfn resolve(&self, symbol: Self::Symbol) -> Option<&str> {\n        self.resolve_index_to_str(symbol.to_usize())\n    }\npub fn new(backend: &'a BufferBackend<S>) -> Self {\n        Self {\n            backend,\n            yielded: 0,\n            current: LONG_LEN,\n        }\n    }\nfn next(&mut self) -> Option<Self::Item> {\n        if self.backend.len_strings == self.yielded {\n            return None\n        }\n        let i = self.current;\n        let short_len = unsafe { *self.backend.buffer.get_unchecked(i) };\n        let (len, len_len) = if short_len == SENTINEL_SHORT_LEN {\n            self.current += 1;\n            let len_bytes = unsafe {\n                self.backend\n                    .buffer\n                    .get_unchecked(i + SHORT_LEN..i + SHORT_LEN + LONG_LEN)\n            };\n            let len = usize::from_ne_bytes(<[u8; LONG_LEN]>::try_from(len_bytes).unwrap())\n                as usize;\n            (len, SHORT_LEN + LONG_LEN + SHORT_LEN)\n        } else {\n            (short_len as usize, SHORT_LEN)\n        };\n        let str_bytes = unsafe {\n            self.backend\n                .buffer\n                .get_unchecked(i + len_len..i + len_len + len)\n        };\n        let str = unsafe { str::from_utf8_unchecked(str_bytes) };\n        self.current += len_len + len;\n        self.yielded += 1;\n        Some((expect_valid_symbol(i + len_len), str))\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "    fn check_overflow(&self) -> bool {\n        let mut yes: Choice = 0.into();\n        let mut no: Choice = 0.into();\n        no |= Choice::from((self.0[7] < SECP256K1_N_7) as u8); \n        no |= Choice::from((self.0[6] < SECP256K1_N_6) as u8); \n        no |= Choice::from((self.0[5] < SECP256K1_N_5) as u8); \n        no |= Choice::from((self.0[4] < SECP256K1_N_4) as u8);\n        yes |= Choice::from((self.0[4] > SECP256K1_N_4) as u8) & !no;\n        no |= Choice::from((self.0[3] < SECP256K1_N_3) as u8) & !yes;\n        yes |= Choice::from((self.0[3] > SECP256K1_N_3) as u8) & !no;\n        no |= Choice::from((self.0[2] < SECP256K1_N_2) as u8) & !yes;\n        yes |= Choice::from((self.0[2] > SECP256K1_N_2) as u8) & !no;\n        no |= Choice::from((self.0[1] < SECP256K1_N_1) as u8) & !yes;\n        yes |= Choice::from((self.0[1] > SECP256K1_N_1) as u8) & !no;\n        yes |= Choice::from((self.0[0] >= SECP256K1_N_0) as u8) & !no;\n        return yes.into();\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn into_iter(mut self) -> IntoIter<K, V> {\n        let (head, tail) = if !self.head.is_null() {\n            unsafe { ((*self.head).prev, (*self.head).next) }\n        } else {\n            (ptr::null_mut(), ptr::null_mut())\n        };\n        let len = self.len();\n        if !self.head.is_null() {\n            unsafe { drop_empty_node(self.head) }\n        }\n        self.clear_free_list();\n        unsafe { ptr::drop_in_place(&mut self.map); }\n        mem::forget(self);\n        IntoIter {\n            head: head,\n            tail: tail,\n            remaining: len,\n            marker: marker::PhantomData,\n        }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn formatSearchResult(result, searchterms) {\n        var teaser = makeTeaser(escapeHTML(result.doc.body), searchterms);\n        teaser_count++;\n        var url = doc_urls[result.ref].split(\"#\");\n        if (url.length == 1) { \n            url.push(\"\");\n        }\n        var searchterms = encodeURIComponent(searchterms.join(\" \")).replace(/\\'/g, \"%27\");\n        return '<a href=\"' + path_to_root + url[0] + '?' + URL_MARK_PARAM + '=' + searchterms + '#' + url[1]\n            + '\" aria-details=\"teaser_' + teaser_count + '\">' + result.doc.breadcrumbs + '</a>'\n            + '<span class=\"teaser\" id=\"teaser_' + teaser_count + '\" aria-label=\"Search Result Teaser\">' \n            + teaser + '</span>';\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn inner_lookup_wildcard(\n        &self,\n        name: &LowerName,\n        record_type: RecordType,\n        and_rrsigs: bool,\n        supported_algorithms: SupportedAlgorithms,\n    ) -> Option<Arc<RecordSet>> {\n        let wildcard = if name.is_wildcard() || name.is_root() {\n            return None;\n        } else {\n            name.clone().into_wildcard()\n        };\n        self.inner_lookup(&wildcard, record_type, and_rrsigs, supported_algorithms)\n            .map(|rrset| {\n                let mut new_answer =\n                    RecordSet::new(name.borrow(), rrset.record_type(), rrset.ttl());\n                let (records, _rrsigs): (Vec<&Record>, Vec<&Record>) = rrset\n                    .records(and_rrsigs, supported_algorithms)\n                    .partition(|r| r.record_type() != RecordType::DNSSEC(DNSSECRecordType::RRSIG));\n                for record in records {\n                    new_answer.add_rdata(record.rdata().clone());\n                }\n                #[cfg(feature = \"dnssec\")]\n                for rrsig in _rrsigs {\n                    new_answer.insert_rrsig(rrsig.clone())\n                }\n                Arc::new(new_answer)\n            })\n    }\npub fn try_from_config(\n        origin: Name,\n        zone_type: ZoneType,\n        allow_axfr: bool,\n        root_dir: Option<&Path>,\n        config: &FileConfig,\n    ) -> Result<Self, String> {\n        use std::fs::File;\n        use std::io::Read;\n        use trust_dns_client::serialize::txt::{Lexer, Parser};\n        let zone_path = root_dir\n            .map(PathBuf::from)\n            .unwrap_or_else(PathBuf::new)\n            .join(&config.zone_file_path);\n        info!(\"loading zone file: {:?}\", zone_path);\n        let mut file = File::open(&zone_path)\n            .map_err(|e| format!(\"error opening {}: {:?}\", zone_path.display(), e))?;\n        let mut buf = String::new();\n        file.read_to_string(&mut buf)\n            .map_err(|e| format!(\"failed to read {}: {:?}\", zone_path.display(), e))?;\n        let lexer = Lexer::new(&buf);\n        let (origin, records) = Parser::new()\n            .parse(lexer, Some(origin))\n            .map_err(|e| format!(\"failed to parse {}: {:?}\", zone_path.display(), e))?;\n        info!(\n            \"zone file loaded: {} with {} records\",\n            origin,\n            records.len()\n        );\n        debug!(\"zone: {:#?}\", records);\n        FileAuthority::new(origin, records, zone_type, allow_axfr)\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn try_alloc_layout_fast(&self, layout: Layout) -> Option<NonNull<u8>> {\n        let footer = self.current_chunk_footer.get();\n        let footer = unsafe { footer.as_ref() };\n        let ptr = footer.ptr.get().as_ptr();\n        let start = footer.data.as_ptr();\n        debug_assert!(start <= ptr);\n        debug_assert!(ptr as *const u8 <= footer as *const _ as *const u8);\n        debug_assert!(is_pointer_aligned_to(ptr, MIN_ALIGN));\n        if (ptr as usize) < layout.size() {\n            return None;\n        }\n        let aligned_ptr = reserve_space_for(layout, ptr);\n        if aligned_ptr >= start {\n            let aligned_ptr = unsafe { NonNull::new_unchecked(aligned_ptr) };\n            footer.ptr.set(aligned_ptr);\n            Some(aligned_ptr)\n        } else {\n            None\n        }\n    }\nfn alloc_layout_slow(&self, layout: Layout) -> Option<NonNull<u8>> {\n        unsafe {\n            let allocation_limit_remaining = self.allocation_limit_remaining();\n            let current_footer = self.current_chunk_footer.get();\n            let current_layout = current_footer.as_ref().layout;\n            let min_new_chunk_size = layout.size().max(DEFAULT_CHUNK_SIZE_WITHOUT_FOOTER);\n            let mut base_size = (current_layout.size() - FOOTER_SIZE)\n                .checked_mul(2)?\n                .max(min_new_chunk_size);\n            let chunk_memory_details = iter::from_fn(|| {\n                let bypass_min_chunk_size_for_small_limits = matches!(self.allocation_limit(), Some(limit) if layout.size() < limit\n                            && base_size >= layout.size()\n                            && limit < DEFAULT_CHUNK_SIZE_WITHOUT_FOOTER\n                            && self.allocated_bytes() == 0);\n                if base_size >= min_new_chunk_size || bypass_min_chunk_size_for_small_limits {\n                    let size = base_size;\n                    base_size /= 2;\n                    Bump::new_chunk_memory_details(Some(size), layout)\n                } else {\n                    None\n                }\n            });\n            let new_footer = chunk_memory_details\n                .filter_map(|chunk_memory_details| {\n                    if Bump::chunk_fits_under_limit(\n                        allocation_limit_remaining,\n                        chunk_memory_details,\n                    ) {\n                        Bump::new_chunk(chunk_memory_details, layout, current_footer)\n                    } else {\n                        None\n                    }\n                })\n                .next()?;\n            debug_assert_eq!(\n                new_footer.as_ref().data.as_ptr() as usize % layout.align(),\n                0\n            );\n            self.current_chunk_footer.set(new_footer);\n            let new_footer = new_footer.as_ref();\n            debug_assert!(is_pointer_aligned_to(new_footer.ptr.get().as_ptr(), MIN_ALIGN));\n            let ptr = reserve_space_for(layout, new_footer.ptr.get().as_ptr());\n            debug_assert!(\n                ptr as *const _ <= new_footer,\n                \"{:p} <= {:p}\",\n                ptr,\n                new_footer\n            );\n            let ptr = NonNull::new_unchecked(ptr);\n            new_footer.ptr.set(ptr);\n            Some(ptr)\n        }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn log(err_code: c_int, msg: &str) {\n    let msg = CString::new(msg).expect(\"SQLite log messages cannot contain embedded zeroes\");\n    unsafe {\n        ffi::sqlite3_log(err_code, msg.as_ptr());\n        ffi::sqlite3_log(err_code, b\"%s\\0\" as *const _ as *const c_char, msg.as_ptr());\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn get_or_create_aux<T, E, F>(&self, arg: c_int, func: F) -> Result<Arc<T>>\n    where\n        T: Send + Sync + 'static,\n        E: Into<Box<dyn std::error::Error + Send + Sync + 'static>>,\n        F: FnOnce(ValueRef<'_>) -> Result<T, E>,\n    {\n        if let Some(v) = self.get_aux(arg)? {\n            Ok(v)\n        } else {\n            let vr = self.get_raw(arg as usize);\n            self.set_aux(\n                arg,\n                func(vr).map_err(|e| Error::UserFunctionError(e.into()))?,\n            )\n        }\n    }\n    pub fn set_aux<T: Send + Sync + 'static>(&self, arg: c_int, value: T) -> Result<Arc<T>> {\n        let orig: Arc<T> = Arc::new(value);\n        let inner: AuxInner = orig.clone();\n        let outer = Box::new(inner);\n        let raw: *mut AuxInner = Box::into_raw(outer);\n        unsafe {\n            ffi::sqlite3_set_auxdata(\n                self.ctx,\n                arg,\n                raw as *mut _,\n                Some(free_boxed_value::<AuxInner>),\n            )\n        };\n        Ok(orig)\n    }\n    pub fn get_aux<T: Send + Sync + 'static>(&self, arg: c_int) -> Result<Option<Arc<T>>> {\n        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxInner };\n        if p.is_null() {\n            Ok(None)\n        } else {\n            let v: AuxInner = AuxInner::clone(unsafe { &*p });\n            v.downcast::<T>()\n                .map(Some)\n                .map_err(|_| Error::GetAuxWrongType)\n        }\n    }\nfn regexp_with_auxilliary(ctx: &Context<'_>) -> Result<bool> {\n        assert_eq!(ctx.len(), 2, \"called with unexpected number of arguments\");\n        type BoxError = Box<dyn std::error::Error + Send + Sync + 'static>;\n        let regexp: std::sync::Arc<Regex> = ctx\n            .get_or_create_aux(0, |vr| -> Result<_, BoxError> {\n                Ok(Regex::new(vr.as_str()?)?)\n            })?;\n        let is_match = {\n            let text = ctx\n                .get_raw(1)\n                .as_str()\n                .map_err(|e| Error::UserFunctionError(e.into()))?;\n            regexp.is_match(text)\n        };\n        Ok(is_match)\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn with_capacity(cap: usize) -> Self {\n        assert!(cap > 0, \"capacity must be positive\");\n        let mark_bit = (cap + 1).next_power_of_two();\n        let one_lap = mark_bit * 2;\n        let head = 0;\n        let tail = 0;\n        let buffer = {\n            let mut boxed: Box<[Slot<T>]> = (0..cap)\n                .map(|i| {\n                    Slot {\n                        stamp: AtomicUsize::new(i),\n                        msg: UnsafeCell::new(MaybeUninit::uninit()),\n                    }\n                })\n                .collect();\n            let ptr = boxed.as_mut_ptr();\n            mem::forget(boxed);\n            ptr\n        };\n        Channel {\n            buffer,\n            cap,\n            one_lap,\n            mark_bit,\n            head: CachePadded::new(AtomicUsize::new(head)),\n            tail: CachePadded::new(AtomicUsize::new(tail)),\n            senders: SyncWaker::new(),\n            receivers: SyncWaker::new(),\n            _marker: PhantomData,\n        }\n    }\nfn drop(&mut self) {\n        let hix = self.head.load(Ordering::Relaxed) & (self.mark_bit - 1);\n        for i in 0..self.len() {\n            let index = if hix + i < self.cap {\n                hix + i\n            } else {\n                hix + i - self.cap\n            };\n            unsafe {\n                let p = {\n                    let slot = &mut *self.buffer.add(index);\n                    let msg = &mut *slot.msg.get();\n                    msg.as_mut_ptr()\n                };\n                p.drop_in_place();\n            }\n        }\n        unsafe {\n            let ptr = std::slice::from_raw_parts_mut(self.buffer, self.cap) as *mut [Slot<T>];\n            Box::from_raw(ptr);\n        }\n    }\npub fn new(cap: usize) -> ArrayQueue<T> {\n        assert!(cap > 0, \"capacity must be non-zero\");\n        let head = 0;\n        let tail = 0;\n        let buffer = {\n            let mut boxed: Box<[Slot<T>]> = (0..cap)\n                .map(|i| {\n                    Slot {\n                        stamp: AtomicUsize::new(i),\n                        value: UnsafeCell::new(MaybeUninit::uninit()),\n                    }\n                })\n                .collect();\n            let ptr = boxed.as_mut_ptr();\n            mem::forget(boxed);\n            ptr\n        };\n        let one_lap = (cap + 1).next_power_of_two();\n        ArrayQueue {\n            buffer,\n            cap,\n            one_lap,\n            head: CachePadded::new(AtomicUsize::new(head)),\n            tail: CachePadded::new(AtomicUsize::new(tail)),\n            _marker: PhantomData,\n        }\n    }\nfn drop(&mut self) {\n        let hix = self.head.load(Ordering::Relaxed) & (self.one_lap - 1);\n        for i in 0..self.len() {\n            let index = if hix + i < self.cap {\n                hix + i\n            } else {\n                hix + i - self.cap\n            };\n            unsafe {\n                let p = {\n                    let slot = &mut *self.buffer.add(index);\n                    let value = &mut *slot.value.get();\n                    value.as_mut_ptr()\n                };\n                p.drop_in_place();\n            }\n        }\n        unsafe {\n            let ptr = core::slice::from_raw_parts_mut(self.buffer, self.cap) as *mut [Slot<T>];\n            Box::from_raw(ptr);\n        }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn waker<W>(wake: Arc<W>) -> Waker\nwhere\n    W: ArcWake + 'static,\n{\n    let ptr = Arc::into_raw(wake) as *const ();\n    unsafe {\n        Waker::from_raw(RawWaker::new(ptr, waker_vtable::<W>()))\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn from(other: Py<T>) -> Self {\n        unsafe { Self::from_non_null(other.into_non_null()) }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn add_assign(&mut self, other: T) {\n        *self = *self + other;\n    }\nfn sub_assign(&mut self, other: T) {\n        *self = *self - other;\n    }\nfn mul_assign(&mut self, other: T) {\n        *self = *self * other;\n    }\nfn div_assign(&mut self, other: T) {\n        *self = *self / other;\n    }\nfn rem_assign(&mut self, other: T) {\n        *self = *self % other;\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn random() -> Self {\n                unsafe {\n                    let mut array = MaybeUninit::<[T; $s]>::uninit();\n                    let ptr = &mut *array.as_mut_ptr();\n                    for i in 0..$s {\n                        std::ptr::write(&mut array[i], T::random());\n                        std::ptr::write(&mut ptr[i], T::random());\n                    }\n                    array.assume_init()\n                }\n            }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn retain<F>(&mut self, mut f: F)\n    where\n        F: FnMut(char) -> bool,\n    {\n        let len = self.len();\n        let mut del_bytes = 0;\n        let mut idx = 0;\n        unsafe {\n            self.vec.set_len(0);\n        }\n        while idx < len {\n            let ch = unsafe { self.get_unchecked(idx..len).chars().next().unwrap() };\n            let ch_len = ch.len_utf8();\n            if !f(ch) {\n                del_bytes += ch_len;\n            } else if del_bytes > 0 {\n                unsafe {\n                    ptr::copy(\n                        self.vec.as_ptr().add(idx),\n                        self.vec.as_mut_ptr().add(idx - del_bytes),\n                        ch_len,\n                    );\n                }\n            }\n            idx += ch_len;\n        }\n        unsafe {\n            self.vec.set_len(len - del_bytes);\n        }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn make_contiguous(&mut self) -> &mut [T] {\n        if self.is_contiguous() {\n            let tail = self.tail;\n            let head = self.head;\n            return unsafe { RingSlices::ring_slices(self.buffer_as_mut_slice(), head, tail).0 };\n        }\n        let buf = self.buf.ptr();\n        let cap = self.cap();\n        let len = self.len();\n        let free = self.tail - self.head;\n        let tail_len = cap - self.tail;\n        if free >= tail_len {\n            unsafe {\n                ptr::copy(buf, buf.add(tail_len), self.head);\n                ptr::copy_nonoverlapping(buf.add(self.tail), buf, tail_len);\n                self.tail = 0;\n                self.head = len;\n            }\n        } else if free > self.head {\n            unsafe {\n                ptr::copy(buf.add(self.tail), buf.add(self.head), tail_len);\n                ptr::copy_nonoverlapping(buf, buf.add(self.head + tail_len), self.head);\n                self.tail = self.head;\n                self.head = self.wrap_add(self.tail, len);\n            }\n        } else {\n            let mut left_edge: usize = 0;\n            let mut right_edge: usize = self.tail;\n            unsafe {\n                while left_edge < len && right_edge != cap {\n                    let mut right_offset = 0;\n                    for i in left_edge..right_edge {\n                        right_offset = (i - left_edge) % (cap - right_edge);\n                        let src: isize = (right_edge + right_offset) as isize;\n                        ptr::swap(buf.add(i), buf.offset(src));\n                    }\n                    let n_ops = right_edge - left_edge;\n                    left_edge += n_ops;\n                    right_edge += right_offset + 1;\n                }\n                self.tail = 0;\n                self.head = len;\n            }\n        }\n        let tail = self.tail;\n        let head = self.head;\n        unsafe { RingSlices::ring_slices(self.buffer_as_mut_slice(), head, tail).0 }\n    }\nfn from(mut other: VecDeque<T>) -> Self {\n        other.make_contiguous();\n        unsafe {\n            let other = ManuallyDrop::new(other);\n            let buf = other.buf.ptr();\n            let len = other.len();\n            let cap = other.cap();\n            if other.tail != 0 {\n                    ptr::copy(buf.add(other.tail), buf, len);\n            }\n            Vec::from_raw_parts(buf, len, cap)\n        }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "    fn discard_exact(&mut self, len: usize) -> io::Result<()>;\n\t{\nimpl<T> BufReadExt for T where T: io::BufRead {\n    fn discard_exact(&mut self, mut len: usize) -> io::Result<()> {\n        while len > 0 {\n            let consume_len = match self.fill_buf() {\n                Ok(buf) if buf.is_empty() =>\n                    return Err(io::Error::new(\n                        io::ErrorKind::UnexpectedEof, \"unexpected EOF\")),\n                Ok(buf) => buf.len().min(len),\n                Err(e) if e.kind() == io::ErrorKind::Interrupted => continue,\n                Err(e) => return Err(e),\n            };\n            self.consume(consume_len);\n            len -= consume_len;\n        }\n        Ok(())\n    }\n}\n\t}\n    fn discard_exact(&mut self, mut len: usize) -> io::Result<()> {\n        while len > 0 {\n            let consume_len = match self.fill_buf() {\n                Ok(buf) if buf.is_empty() =>\n                    return Err(io::Error::new(\n                        io::ErrorKind::UnexpectedEof, \"unexpected EOF\")),\n                Ok(buf) => buf.len().min(len),\n                Err(e) if e.kind() == io::ErrorKind::Interrupted => continue,\n                Err(e) => return Err(e),\n            };\n            self.consume(consume_len);\n            len -= consume_len;\n        }\n        Ok(())\n    }\n    fn discard_exact() {\n        let mut buf = b\"abc\".as_ref();\n        buf.discard_exact(1).unwrap();\n        assert_eq!(buf, b\"bc\");\n        buf.discard_exact(2).unwrap();\n        assert_eq!(buf, b\"\");\n        buf.discard_exact(1).unwrap_err();\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn parse(buf: &mut BytesMut, ctx: ParseContext<'_>) -> ParseResult<RequestLine> {\n        debug_assert!(!buf.is_empty(), \"parse called with empty buf\");\n        let mut keep_alive;\n        let is_http_11;\n        let subject;\n        let version;\n        let len;\n        let headers_len;\n        let mut headers_indices: [HeaderIndices; MAX_HEADERS] = unsafe { mem::uninitialized() };\n        {\n            let mut headers: [httparse::Header<'_>; MAX_HEADERS] = unsafe { mem::uninitialized() };\n            trace!(\n                \"Request.parse([Header; {}], [u8; {}])\",\n                headers.len(),\n                buf.len()\n            );\n            let mut req = httparse::Request::new(&mut headers);\n            let bytes = buf.as_ref();\n            match req.parse(bytes) {\n                Ok(httparse::Status::Complete(parsed_len)) => {\n                    trace!(\"Request.parse Complete({})\", parsed_len);\n                    len = parsed_len;\n                    subject = RequestLine(\n                        Method::from_bytes(req.method.unwrap().as_bytes())?,\n                        req.path.unwrap().parse()?,\n                    );\n                    version = if req.version.unwrap() == 1 {\n                        keep_alive = true;\n                        is_http_11 = true;\n                        Version::HTTP_11\n                    } else {\n                        keep_alive = false;\n                        is_http_11 = false;\n                        Version::HTTP_10\n                    };\n                    trace!(\"headers: {:?}\", &req.headers);\n                    record_header_indices(bytes, &req.headers, &mut headers_indices)?;\n                    headers_len = req.headers.len();\n                }\n                Ok(httparse::Status::Partial) => return Ok(None),\n                Err(err) => {\n                    return Err(match err {\n                        httparse::Error::Token => {\n                            if req.method.is_none() {\n                                Parse::Method\n                            } else {\n                                debug_assert!(req.path.is_none());\n                                Parse::Uri\n                            }\n                        }\n                        other => other.into(),\n                    });\n                }\n            }\n        };\n        let slice = buf.split_to(len).freeze();\n        let mut decoder = DecodedLength::ZERO;\n        let mut expect_continue = false;\n        let mut con_len = None;\n        let mut is_te = false;\n        let mut is_te_chunked = false;\n        let mut wants_upgrade = subject.0 == Method::CONNECT;\n        let mut headers = ctx.cached_headers.take().unwrap_or_else(HeaderMap::new);\n        headers.reserve(headers_len);\n        for header in &headers_indices[..headers_len] {\n            let name = header_name!(&slice[header.name.0..header.name.1]);\n            let value = header_value!(slice.slice(header.value.0..header.value.1));\n            match name {\n                header::TRANSFER_ENCODING => {\n                    if !is_http_11 {\n                        debug!(\"HTTP/1.0 cannot have Transfer-Encoding header\");\n                        return Err(Parse::Header);\n                    }\n                    is_te = true;\n                    if headers::is_chunked_(&value) {\n                        is_te_chunked = true;\n                        decoder = DecodedLength::CHUNKED;\n                    } else {\n                        is_te_chunked = false;\n                    }\n                }\n                header::CONTENT_LENGTH => {\n                    if is_te {\n                        continue;\n                    }\n                    let len = value\n                        .to_str()\n                        .map_err(|_| Parse::Header)\n                        .and_then(|s| s.parse().map_err(|_| Parse::Header))?;\n                    if let Some(prev) = con_len {\n                        if prev != len {\n                            debug!(\n                                \"multiple Content-Length headers with different values: [{}, {}]\",\n                                prev, len,\n                            );\n                            return Err(Parse::Header);\n                        }\n                        continue;\n                    }\n                    decoder = DecodedLength::checked_new(len)?;\n                    con_len = Some(len);\n                }\n                header::CONNECTION => {\n                    if keep_alive {\n                        keep_alive = !headers::connection_close(&value);\n                    } else {\n                        keep_alive = headers::connection_keep_alive(&value);\n                    }\n                }\n                header::EXPECT => {\n                    expect_continue = value.as_bytes() == b\"100-continue\";\n                }\n                header::UPGRADE => {\n                    wants_upgrade = is_http_11;\n                }\n                _ => (),\n            }\n            headers.append(name, value);\n        }\n        if is_te && !is_te_chunked {\n            debug!(\"request with transfer-encoding header, but not chunked, bad request\");\n            return Err(Parse::Header);\n        }\n        *ctx.req_method = Some(subject.0.clone());\n        Ok(Some(ParsedMessage {\n            head: MessageHead {\n                version,\n                subject,\n                headers,\n                extensions: http::Extensions::default(),\n            },\n            decode: decoder,\n            expect_continue,\n            keep_alive,\n            wants_upgrade,\n        }))\n    }\nparse_err(\n            \"\\\n             POST / HTTP/1.1\\r\\n\\\n             transfer-encoding: chunked\\r\\n\\\n             transfer-encoding: afterlol\\r\\n\\\n             \\r\\n\\\n             \",\n            \"transfer-encoding multiple lines doesn't end in chunked\",\n        );\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn decode_aligned(b64ch: u8, decode_table: &[u8; 256]) -> u8 {\n    let mut result: u8 = 0x00;\n    let mut mask: u8;\n    let idx: [u8;2] = [ b64ch % 64, b64ch % 64 + 64];\n    for i in 0..2  {\n        mask = 0xFF ^ (((idx[i] == b64ch) as i8 - 1) as u8);\n        result = result | (decode_table[idx[i] as usize] & mask);\n    }\n    result\n}\nfn decode_chunk(\n    input: &[u8],\n    index_at_start_of_input: usize,\n    decode_table: &[u8; 256],\n    output: &mut [u8],\n) -> Result<(), DecodeError> {\n    let mut accum: u64;\n    #[cfg(not(feature = \"slow_but_safe\"))]\n    let morsel = decode_table[input[0] as usize];\n    #[cfg(feature = \"slow_but_safe\")]\n    let morsel = decode_aligned(input[0], decode_table);\n    if morsel == tables::INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(index_at_start_of_input, input[0]));\n    }\n    accum = (morsel as u64) << 58;\n    #[cfg(not(feature = \"slow_but_safe\"))]\n    let morsel = decode_table[input[1] as usize];\n    #[cfg(feature = \"slow_but_safe\")]\n    let morsel = decode_aligned(input[1], decode_table);\n    if morsel == tables::INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 1,\n            input[1],\n        ));\n    }\n    accum |= (morsel as u64) << 52;\n    #[cfg(not(feature = \"slow_but_safe\"))]\n    let morsel = decode_table[input[2] as usize];\n    #[cfg(feature = \"slow_but_safe\")]\n    let morsel = decode_aligned(input[2], decode_table);\n    if morsel == tables::INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 2,\n            input[2],\n        ));\n    }\n    accum |= (morsel as u64) << 46;\n    #[cfg(not(feature = \"slow_but_safe\"))]\n    let morsel = decode_table[input[3] as usize];\n    #[cfg(feature = \"slow_but_safe\")]\n    let morsel = decode_aligned(input[3], decode_table);\n    if morsel == tables::INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 3,\n            input[3],\n        ));\n    }\n    accum |= (morsel as u64) << 40;\n    #[cfg(not(feature = \"slow_but_safe\"))]\n    let morsel = decode_table[input[4] as usize];\n    #[cfg(feature = \"slow_but_safe\")]\n    let morsel = decode_aligned(input[4], decode_table);\n    if morsel == tables::INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 4,\n            input[4],\n        ));\n    }\n    accum |= (morsel as u64) << 34;\n    #[cfg(not(feature = \"slow_but_safe\"))]\n    let morsel = decode_table[input[5] as usize];\n    #[cfg(feature = \"slow_but_safe\")]\n    let morsel = decode_aligned(input[5], decode_table);\n    if morsel == tables::INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 5,\n            input[5],\n        ));\n    }\n    accum |= (morsel as u64) << 28;\n    #[cfg(not(feature = \"slow_but_safe\"))]\n    let morsel = decode_table[input[6] as usize];\n    #[cfg(feature = \"slow_but_safe\")]\n    let morsel = decode_aligned(input[6], decode_table);\n    if morsel == tables::INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 6,\n            input[6],\n        ));\n    }\n    accum |= (morsel as u64) << 22;\n    #[cfg(not(feature = \"slow_but_safe\"))]\n    let morsel = decode_table[input[7] as usize];\n    #[cfg(feature = \"slow_but_safe\")]\n    let morsel = decode_aligned(input[7], decode_table);\n    if morsel == tables::INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 7,\n            input[7],\n        ));\n    }\n    accum |= (morsel as u64) << 16;\n    write_u64(output, accum);\n    Ok(())\n}\n    fn encode_table(self) -> &'static [u8; 64] {\n        match self {\n            CharacterSet::Standard => tables::STANDARD_ENCODE,\n            CharacterSet::UrlSafe => tables::URL_SAFE_ENCODE,\n            CharacterSet::Crypt => tables::CRYPT_ENCODE,\n            CharacterSet::Bcrypt => tables::BCRYPT_ENCODE,\n            CharacterSet::ImapMutf7 => tables::IMAP_MUTF7_ENCODE,\n            CharacterSet::BinHex => tables::BINHEX_ENCODE,\n        }\n    }\n    fn decode_table(self) -> &'static [u8; 256] {\n        match self {\n            CharacterSet::Standard => &tables::STANDARD_DECODE_HOLDER.data,\n            CharacterSet::UrlSafe => &tables::URL_SAFE_DECODE_HOLDER.data,\n            CharacterSet::Crypt => &tables::CRYPT_DECODE_HOLDER.data,\n            CharacterSet::Bcrypt => &tables::BCRYPT_DECODE_HOLDER.data,\n            CharacterSet::ImapMutf7 => &tables::IMAP_MUTF7_DECODE_HOLDER.data,\n            CharacterSet::BinHex => &tables::BINHEX_DECODE_HOLDER.data,\n        }\n    }\nfn alignment_check() {\n    let p: *const u8 = STANDARD_DECODE_HOLDER.data.as_ptr();\n    assert_eq!((p as u64) % 64, 0);\n    let p: *const u8 = URL_SAFE_DECODE_HOLDER.data.as_ptr();\n    assert_eq!((p as u64) % 64, 0);\n    let p: *const u8 = CRYPT_DECODE_HOLDER.data.as_ptr();\n    assert_eq!((p as u64) % 64, 0);\n    let p: *const u8 = BCRYPT_DECODE_HOLDER.data.as_ptr();\n    assert_eq!((p as u64) % 64, 0);\n    let p: *const u8 = IMAP_MUTF7_DECODE_HOLDER.data.as_ptr();\n    assert_eq!((p as u64) % 64, 0);\n    let p: *const u8 = BINHEX_DECODE_HOLDER.data.as_ptr();\n    assert_eq!((p as u64) % 64, 0);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn insert_many<I: IntoIterator<Item = A::Item>>(&mut self, index: usize, iterable: I) {\n        let mut iter = iterable.into_iter();\n        if index == self.len() {\n            return self.extend(iter);\n        }\n        let (lower_size_bound, _) = iter.size_hint();\n        assert!(lower_size_bound <= core::isize::MAX as usize); \n        assert!(index + lower_size_bound >= index); \n        let mut num_added = 0;\n        let old_len = self.len();\n        assert!(index <= old_len);\n        unsafe {\n            self.reserve(lower_size_bound);\n            let start = self.as_mut_ptr();\n            let ptr = start.add(index);\n            ptr::copy(ptr, ptr.add(lower_size_bound), old_len - index);\n            self.set_len(0);\n            let mut guard = DropOnPanic {\n                start,\n                skip: index..(index + lower_size_bound),\n                len: old_len + lower_size_bound,\n            };\n            while num_added < lower_size_bound {\n                let element = match iter.next() {\n                    Some(x) => x,\n                    None => break,\n                };\n                let cur = ptr.add(num_added);\n                ptr::write(cur, element);\n                guard.skip.start += 1;\n                num_added += 1;\n            }\n            if num_added < lower_size_bound {\n                ptr::copy(\n                    ptr.add(lower_size_bound),\n                    ptr.add(num_added),\n                    old_len - index,\n                );\n            }\n            self.set_len(old_len + num_added);\n            mem::forget(guard);\n        }\n        for element in iter {\n            self.insert(index + num_added, element);\n            num_added += 1;\n        }\n        struct DropOnPanic<T> {\n            start: *mut T,\n            skip: Range<usize>, \n            len: usize,\n        }\n        impl<T> Drop for DropOnPanic<T> {\n            fn drop(&mut self) {\n                for i in 0..self.len {\n                    if !self.skip.contains(&i) {\n                        unsafe {\n                            ptr::drop_in_place(self.start.add(i));\n                        }\n                    }\n                }\n            }\n        }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn map_array(values: [T; $size], mut f: F) -> Self {\n                use std::{\n                    mem::{ManuallyDrop, MaybeUninit},\n                    ptr::{read, write},\n                };\n                let mut values = ManuallyDrop::new(values);\n                unsafe {\n                    let mut result: MaybeUninit<[U; $size]> = MaybeUninit::zeroed();\n                    for i in 0..$size {\n                        write(\n                            result.as_mut_ptr().cast::<U>().add(i),\n                            f(read(&mut values[i])),\n                        );\n                    }\n                    result.assume_init()\n                }\n            }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn read_to_end_with_reservation<R, F>(\n    r: &mut R,\n    buf: &mut Vec<u8>,\n    mut reservation_size: F,\n) -> Result<usize>\nwhere\n    R: Read + ?Sized,\n    F: FnMut(&R) -> usize,\n{\n    let start_len = buf.len();\n    let mut g = Guard { len: buf.len(), buf };\n    let ret;\n    loop {\n        if g.len == g.buf.len() {\n            unsafe {\n                g.buf.reserve(reservation_size(r));\n                let capacity = g.buf.capacity();\n                g.buf.set_len(capacity);\n                r.initializer().initialize(&mut g.buf[g.len..]);\n            }\n        }\n        match r.read(&mut g.buf[g.len..]) {\n            Ok(0) => {\n                ret = Ok(g.len - start_len);\n                break;\n            }\n            Ok(n) => {\n                assert!(n <= g.buf.len() - g.len);\n                                g.len += n;\n            }\n            Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n            Err(e) => {\n                ret = Err(e);\n                break;\n            }\n        }\n    }\n    ret\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn next(&mut self) -> Option<(A::Item, B::Item)> {\n        if self.index < self.len {\n            let i = self.index;\n            self.index += 1;\n            unsafe {\n                Some((self.a.__iterator_get_unchecked(i), self.b.__iterator_get_unchecked(i)))\n            }\n        } else if A::may_have_side_effect() && self.index < self.a.size() {\n            let i = self.index;\n            self.index += 1;\n            unsafe {\n                self.a.__iterator_get_unchecked(i);\n            }\n            None\n        } else {\n            None\n        }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "unsafe fn get_unchecked(&mut self, idx: usize) -> <Self as Iterator>::Item {\n        let idx = self.index + idx;\n        unsafe { (self.a.__iterator_get_unchecked(idx), self.b.__iterator_get_unchecked(idx)) }\n}\nfn test_zip_trusted_random_access_composition() {\n    let a = [0, 1, 2, 3, 4];\n    let b = a;\n    let c = a;\n    let a = a.iter().copied();\n    let b = b.iter().copied();\n    let mut c = c.iter().copied();\n    c.next();\n    let mut z1 = a.zip(b);\n    assert_eq!(z1.next().unwrap(), (0, 0));\n    let mut z2 = z1.zip(c);\n    fn assert_trusted_random_access<T: TrustedRandomAccess>(_a: &T) {}\n    assert_trusted_random_access(&z2);\n    assert_eq!(z2.next().unwrap(), ((1, 1), 1));\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn new(a: A, b: B) -> Self {\n        let a_len = a.size();\n        let len = cmp::min(a_len, b.size());\n        Zip { a, b, index: 0, len, a_len }\n    }\nfn next(&mut self) -> Option<(A::Item, B::Item)> {\n        if self.index < self.len {\n            let i = self.index;\n            self.index += 1;\n            unsafe {\n                Some((self.a.__iterator_get_unchecked(i), self.b.__iterator_get_unchecked(i)))\n            }\n        } else if A::MAY_HAVE_SIDE_EFFECT && self.index < self.a_len {\n            let i = self.index;\n            self.index += 1;\n            self.len += 1;\n            unsafe {\n                self.a.__iterator_get_unchecked(i);\n            }\n            None\n        } else {\n            None\n        }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn next(&mut self) -> Option<(A::Item, B::Item)> {\n        if self.index < self.len {\n            let i = self.index;\n            self.index += 1;\n            unsafe {\n                Some((self.a.__iterator_get_unchecked(i), self.b.__iterator_get_unchecked(i)))\n            }\n        } else if A::MAY_HAVE_SIDE_EFFECT && self.index < self.a.size() {\n            let i = self.index;\n            self.index += 1;\n            self.len += 1;\n            unsafe {\n                self.a.__iterator_get_unchecked(i);\n            }\n            None\n        } else {\n            None\n        }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "\tpub fn set(\n\t\t&mut self,\n\t\toffset: usize,\n\t\tvalue: &[u8],\n\t\ttarget_size: Option<usize>\n\t) -> Result<(), ExitFatal> {\n\t\tif value.is_empty() {\n\t\t\treturn Ok(())\n\t\t}\n\t\tlet target_size = target_size.unwrap_or(value.len());\n\t\tif offset.checked_add(target_size)\n\t\t\t.map(|pos| pos > self.limit).unwrap_or(true)\n\t\t{\n\t\t\treturn Err(ExitFatal::NotSupported)\n\t\t}\n\t\tif self.data.len() < offset + target_size {\n\t\t\tself.data.resize(offset + target_size, 0);\n\t\t}\n\t\tfor index in 0..target_size {\n\t\t\tif self.data.len() > offset + index && value.len() > index {\n\t\t\t\tself.data[offset + index] = value[index];\n\t\t\t} else {\n\t\t\t\tself.data[offset + index] = 0;\n\t\t\t}\n\t\t}\n\t\tOk(())\n\t}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "void Compute(OpKernelContext* context) override {\n    const Tensor& x = context->input(0);\n    const Tensor& y = context->input(1);\n    const float min_x = context->input(2).flat<float>()(0);\n    const float max_x = context->input(3).flat<float>()(0);\n    const float min_y = context->input(4).flat<float>()(0);\n    const float max_y = context->input(5).flat<float>()(0);\n    BCast bcast(BCast::FromShape(x.shape()), BCast::FromShape(y.shape()));\n    if (!bcast.IsValid()) {\n      context->SetStatus(errors::InvalidArgument(\n          \"Incompatible shapes: \", x.shape().DebugString(), \" vs. \",\n          y.shape().DebugString()));\n      return;\n    }\n    Tensor* z;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                0, BCast::ToShape(bcast.output_shape()), &z));\n    OP_REQUIRES(context, (max_x > min_x),\n                errors::InvalidArgument(\"max_x must be larger than min_x.\"));\n    OP_REQUIRES(context, (max_y > min_y),\n                errors::InvalidArgument(\"max_y must be larger than min_y.\"));\n    const T* x_data = x.flat<T>().data();\n    const T* y_data = y.flat<T>().data();\n    Toutput* z_data = z->flat<Toutput>().data();\n    const float smallest_min = std::min(min_x, min_y);\n    const float largest_max = std::max(max_x, max_y);\n    const float biggest_range =\n        std::max(std::abs(smallest_min), std::abs(largest_max));\n    const float output_range = (biggest_range * (1 << 14));\n    const float min_z_value = -output_range;\n    const float max_z_value = output_range;\n    const int ndims = bcast.x_reshape().size();\n    if (ndims <= 1) {\n      if (x.NumElements() == 1) {\n        ScalarAddition<T, Toutput>(context, y_data, min_y, max_y,\n                                   y.NumElements(), x_data[0], min_x, max_x,\n                                   min_z_value, max_z_value, z_data);\n      } else if (y.NumElements() == 1) {\n        ScalarAddition<T, Toutput>(context, x_data, min_x, max_x,\n                                   x.NumElements(), y_data[0], min_y, max_y,\n                                   min_z_value, max_z_value, z_data);\n      } else {\n        VectorAddition<T, Toutput>(context, x_data, min_x, max_x, y_data, min_y,\n                                   max_y, x.NumElements(), min_z_value,\n                                   max_z_value, z_data);\n      }\n    } else if (ndims == 2) {\n      const T* vector_data;\n      int64 vector_num_elements;\n      float vector_min;\n      float vector_max;\n      const T* tensor_data;\n      int64 tensor_num_elements;\n      float tensor_min;\n      float tensor_max;\n      if (x.NumElements() < y.NumElements()) {\n        vector_data = x_data;\n        vector_num_elements = x.NumElements();\n        vector_min = min_x;\n        vector_max = max_x;\n        tensor_data = y_data;\n        tensor_num_elements = y.NumElements();\n        tensor_min = min_y;\n        tensor_max = max_y;\n      } else {\n        vector_data = y_data;\n        vector_num_elements = y.NumElements();\n        vector_min = min_y;\n        vector_max = max_y;\n        tensor_data = x_data;\n        tensor_num_elements = x.NumElements();\n        tensor_min = min_x;\n        tensor_max = max_x;\n      }\n      OP_REQUIRES(context, vector_num_elements > 0,\n                  errors::InvalidArgument(\"Must have some elements to add\"));\n      VectorTensorAddition<T, Toutput>(\n          vector_data, vector_min, vector_max, vector_num_elements, tensor_data,\n          tensor_min, tensor_max, tensor_num_elements, min_z_value, max_z_value,\n          z_data);\n    } else {\n      LOG(INFO) << \"ndims=\" << ndims;\n      LOG(INFO) << \"bcast.x_reshape()=\"\n                << TensorShape(bcast.x_reshape()).DebugString();\n      LOG(INFO) << \"bcast.y_reshape()=\"\n                << TensorShape(bcast.y_reshape()).DebugString();\n      LOG(INFO) << \"bcast.x_bcast()=\"\n                << TensorShape(bcast.x_bcast()).DebugString();\n      LOG(INFO) << \"bcast.y_bcast()=\"\n                << TensorShape(bcast.y_bcast()).DebugString();\n      context->SetStatus(errors::Unimplemented(\n          \"Broadcast between \", context->input(0).shape().DebugString(),\n          \" and \", context->input(1).shape().DebugString(),\n          \" is not supported yet.\"));\n      return;\n    }\n    Tensor* z_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &z_min));\n    z_min->flat<float>()(0) = min_z_value;\n    Tensor* z_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &z_max));\n    z_max->flat<float>()(0) = max_z_value;\n  }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n  int num_inputs = node->inputs->size;\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, num_inputs);\n  Subgraph* this_subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto* subgraphs = this_subgraph->GetSubgraphs();\n  TF_LITE_ENSURE(context, op_data->cond_subgraph_index < subgraphs->size());\n  TF_LITE_ENSURE(context, op_data->body_subgraph_index < subgraphs->size());\n  Subgraph* cond_subgraph = (*subgraphs)[op_data->cond_subgraph_index].get();\n  Subgraph* body_subgraph = (*subgraphs)[op_data->body_subgraph_index].get();\n  TF_LITE_ENSURE_EQ(context, cond_subgraph->inputs().size(), num_inputs);\n  TF_LITE_ENSURE_EQ(context, cond_subgraph->outputs().size(), 1);\n  TF_LITE_ENSURE_EQ(context, body_subgraph->inputs().size(), num_inputs);\n  TF_LITE_ENSURE_EQ(context, body_subgraph->outputs().size(), num_inputs);\n  TF_LITE_ENSURE_OK(\n      context, CopyTensorsShapeAndType(\n                   context, this_subgraph, TfLiteIntArrayView(node->inputs),\n                   cond_subgraph, cond_subgraph->inputs(), true));\n  TF_LITE_ENSURE_OK(context, cond_subgraph->AllocateTensors());\n  TfLiteTensor* cond_output =\n      cond_subgraph->tensor(cond_subgraph->outputs()[0]);\n  if (IsDynamicTensor(cond_output)) {\n    op_data->cond_has_dynamic_output_tensors = true;\n  } else {\n    TF_LITE_ENSURE_STATUS(CheckCondOutput(context, cond_output));\n  }\n  TF_LITE_ENSURE_OK(\n      context, CopyTensorsShapeAndType(\n                   context, this_subgraph, TfLiteIntArrayView(node->inputs),\n                   body_subgraph, body_subgraph->inputs(), true));\n  TF_LITE_ENSURE_OK(context, body_subgraph->AllocateTensors());\n  if (body_subgraph->HasDynamicTensors()) {\n    op_data->body_has_dynamic_output_tensors = true;\n  } else {\n    for (int i = 0; i < num_inputs; ++i) {\n      TfLiteTensor* body_input =\n          body_subgraph->tensor(body_subgraph->inputs()[i]);\n      TfLiteTensor* body_output =\n          body_subgraph->tensor(body_subgraph->outputs()[i]);\n      TF_LITE_ENSURE_TYPES_EQ(context, body_input->type, body_output->type);\n      TF_LITE_ENSURE(context, !IsDynamicTensor(body_output));\n      if (!TfLiteIntArrayEqual(body_input->dims, body_output->dims)) {\n        op_data->body_has_dynamic_output_tensors = true;\n        break;\n      }\n    }\n  }\n  for (int i = 0; i < num_inputs; ++i) {\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));\n    if (op_data->body_has_dynamic_output_tensors) {\n      SetTensorToDynamic(output);\n    } else {\n      TfLiteTensor* body_output =\n          body_subgraph->tensor(body_subgraph->outputs()[i]);\n      TfLiteIntArray* output_size = TfLiteIntArrayCopy(body_output->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, output, output_size));\n    }\n  }\n  return kTfLiteOk;\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n  int num_inputs = node->inputs->size;\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, num_inputs);\n  Subgraph* this_subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto* subgraphs = this_subgraph->GetSubgraphs();\n  TF_LITE_ENSURE(context, op_data->cond_subgraph_index < subgraphs->size());\n  TF_LITE_ENSURE(context, op_data->body_subgraph_index < subgraphs->size());\n  Subgraph* cond_subgraph = (*subgraphs)[op_data->cond_subgraph_index].get();\n  Subgraph* body_subgraph = (*subgraphs)[op_data->body_subgraph_index].get();\n  TF_LITE_ENSURE_EQ(context, cond_subgraph->inputs().size(), num_inputs);\n  TF_LITE_ENSURE_EQ(context, cond_subgraph->outputs().size(), 1);\n  TF_LITE_ENSURE_EQ(context, body_subgraph->inputs().size(), num_inputs);\n  TF_LITE_ENSURE_EQ(context, body_subgraph->outputs().size(), num_inputs);\n  TF_LITE_ENSURE_OK(\n      context, CopyTensorsShapeAndType(\n                   context, this_subgraph, TfLiteIntArrayView(node->inputs),\n                   cond_subgraph, cond_subgraph->inputs(), true));\n  TF_LITE_ENSURE_OK(context, cond_subgraph->AllocateTensors());\n  TfLiteTensor* cond_output =\n      cond_subgraph->tensor(cond_subgraph->outputs()[0]);\n  if (IsDynamicTensor(cond_output)) {\n    op_data->cond_has_dynamic_output_tensors = true;\n  } else {\n    TF_LITE_ENSURE_STATUS(CheckCondOutput(context, cond_output));\n  }\n  TF_LITE_ENSURE_OK(\n      context, CopyTensorsShapeAndType(\n                   context, this_subgraph, TfLiteIntArrayView(node->inputs),\n                   body_subgraph, body_subgraph->inputs(), true));\n  TF_LITE_ENSURE_OK(context, body_subgraph->AllocateTensors());\n  if (body_subgraph->HasDynamicTensors()) {\n    op_data->body_has_dynamic_output_tensors = true;\n  } else {\n    for (int i = 0; i < num_inputs; ++i) {\n      TfLiteTensor* body_input =\n          body_subgraph->tensor(body_subgraph->inputs()[i]);\n      TfLiteTensor* body_output =\n          body_subgraph->tensor(body_subgraph->outputs()[i]);\n      TF_LITE_ENSURE_TYPES_EQ(context, body_input->type, body_output->type);\n      TF_LITE_ENSURE(context, !IsDynamicTensor(body_output));\n      if (!TfLiteIntArrayEqual(body_input->dims, body_output->dims)) {\n        op_data->body_has_dynamic_output_tensors = true;\n        break;\n      }\n    }\n  }\n  for (int i = 0; i < num_inputs; ++i) {\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));\n    if (op_data->body_has_dynamic_output_tensors) {\n      SetTensorToDynamic(output);\n    } else {\n      TfLiteTensor* body_output =\n          body_subgraph->tensor(body_subgraph->outputs()[i]);\n      TfLiteIntArray* output_size = TfLiteIntArrayCopy(body_output->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, output, output_size));\n    }\n  }\n  return kTfLiteOk;\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "    fn peek_char(&self) -> Option<char> {\n        self.state.first().map(|&b| char::from(b))\n    }\nfn read_ipv4_addr(&mut self) -> Option<Ipv4Addr> {\n        self.read_atomically(|p| {\n            let mut groups = [0; 4];\n            for (i, slot) in groups.iter_mut().enumerate() {\n                *slot = p.read_separator('.', i, |p| {\n                    match (p.peek_char(), p.read_number(10, None)) {\n                        (Some('0'), Some(number)) if number != 0 => None,\n                        (_, number) => number,\n                    }\n                })?;\n            }\n            Some(groups.into())\n        })\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub(super) fn forget_allocation_drop_remaining(&mut self) {\n        let remaining = self.as_raw_mut_slice();\n        self.cap = 0;\n        self.buf = unsafe { NonNull::new_unchecked(RawVec::NEW.ptr()) };\n        self.ptr = self.buf.as_ptr();\n        self.end = self.buf.as_ptr();\n        unsafe {\n            ptr::drop_in_place(remaining);\n        }\n    }\ndefault fn from_iter(mut iterator: I) -> Self {\n        if mem::size_of::<T>() == 0\n            || mem::size_of::<T>()\n                != mem::size_of::<<<I as SourceIter>::Source as AsIntoIter>::Item>()\n            || mem::align_of::<T>()\n                != mem::align_of::<<<I as SourceIter>::Source as AsIntoIter>::Item>()\n        {\n            return SpecFromIterNested::from_iter(iterator);\n        }\n        let (src_buf, src_ptr, dst_buf, dst_end, cap) = unsafe {\n            let inner = iterator.as_inner().as_into_iter();\n            (\n                inner.buf.as_ptr(),\n                inner.ptr,\n                inner.buf.as_ptr() as *mut T,\n                inner.end as *const T,\n                inner.cap,\n            )\n        };\n        let len = SpecInPlaceCollect::collect_in_place(&mut iterator, dst_buf, dst_end);\n        let src = unsafe { iterator.as_inner().as_into_iter() };\n        debug_assert_eq!(src_buf, src.buf.as_ptr());\n        if src.ptr != src_ptr {\n            debug_assert!(\n                unsafe { dst_buf.add(len) as *const _ } <= src.ptr,\n                \"InPlaceIterable contract violation, write pointer advanced beyond read pointer\"\n            );\n        }\n        src.forget_allocation_drop_remaining();\n        let vec = unsafe { Vec::from_raw_parts(dst_buf, len, cap) };\n        vec\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32)\n                                         -> Result<T, ParseIntError> {\n    use self::IntErrorKind::*;\n    use self::ParseIntError as PIE;\n    assert!(radix >= 2 && radix <= 36,\n           \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n           radix);\n    if src.is_empty() {\n        return Err(PIE { kind: Empty });\n    }\n    let is_signed_ty = T::from_u32(0) > T::min_value();\n    let src = src.as_bytes();\n    let (is_positive, digits) = match src[0] {\n        b'+' => (true, &src[1..]),\n        b'-' if is_signed_ty => (false, &src[1..]),\n        _ => (true, src)\n    };\n    if digits.is_empty() {\n        return Err(PIE { kind: Empty });\n    }\n    let mut result = T::from_u32(0);\n    if is_positive {\n        for &c in digits {\n            let x = match (c as char).to_digit(radix) {\n                Some(x) => x,\n                None => return Err(PIE { kind: InvalidDigit }),\n            };\n            result = match result.checked_mul(radix) {\n                Some(result) => result,\n                None => return Err(PIE { kind: Overflow }),\n            };\n            result = match result.checked_add(x) {\n                Some(result) => result,\n                None => return Err(PIE { kind: Overflow }),\n            };\n        }\n    } else {\n        for &c in digits {\n            let x = match (c as char).to_digit(radix) {\n                Some(x) => x,\n                None => return Err(PIE { kind: InvalidDigit }),\n            };\n            result = match result.checked_mul(radix) {\n                Some(result) => result,\n                None => return Err(PIE { kind: Underflow }),\n            };\n            result = match result.checked_sub(x) {\n                Some(result) => result,\n                None => return Err(PIE { kind: Underflow }),\n            };\n        }\n    }\n    Ok(result)\n}\n    fn test_leading_plus() {\n        assert_eq!(\"+127\".parse::<u8>().ok(), Some(127u8));\n        assert_eq!(\"+9223372036854775807\".parse::<i64>().ok(), Some(9223372036854775807i64));\n    }\n    fn test_invalid() {\n        assert_eq!(\"--129\".parse::<i8>().ok(), None);\n        assert_eq!(\"++129\".parse::<i8>().ok(), None);\n        assert_eq!(\"\".parse::<u8>().ok(), None);\n    }\n    fn test_empty() {\n        assert_eq!(\"-\".parse::<i8>().ok(), None);\n        assert_eq!(\"+\".parse::<i8>().ok(), None);\n        assert_eq!(\"\".parse::<u8>().ok(), None);\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub async fn mksnap(handle: &CoreDB, con: &mut Connection, act: ActionGroup) -> TResult<()> {\n    let howmany = act.howmany();\n    if howmany == 0 {\n        if !handle.is_snapshot_enabled() {\n            let error = \"err-snapshot-disabled\";\n            con.write_response(GroupBegin(1)).await?;\n            let error = RespCodes::OtherError(Some(error.to_string()));\n            return con.write_response(error).await;\n        }\n        let mut was_engine_error = false;\n        let mut snap_result = None;\n        let mut engine_was_busy = false;\n        {\n            let snaphandle = handle.snapcfg.clone();\n            let snapstatus = (*snaphandle)\n                .as_ref()\n                .unwrap_or_else(|| unsafe { unreachable_unchecked() });\n            let snapengine = SnapshotEngine::new(snapstatus.max, &handle, None);\n            if snapengine.is_err() {\n                was_engine_error = true;\n            } else {\n                if snapstatus.is_busy() {\n                    engine_was_busy = true;\n                } else {\n                    let mut snapengine =\n                        snapengine.unwrap_or_else(|_| unsafe { unreachable_unchecked() });\n                    snap_result = snapengine.mksnap();\n                }\n            }\n        }\n        if was_engine_error {\n            return con\n                .write_response(responses::fresp::R_SERVER_ERR.to_owned())\n                .await;\n        }\n        if engine_was_busy {\n            con.write_response(GroupBegin(1)).await?;\n            let error = RespCodes::OtherError(Some(\"err-snapshot-busy\".to_owned()));\n            return con.write_response(error).await;\n        }\n        if let Some(succeeded) = snap_result {\n            if succeeded {\n                return con\n                    .write_response(responses::fresp::R_OKAY.to_owned())\n                    .await;\n            } else {\n                return con\n                    .write_response(responses::fresp::R_SERVER_ERR.to_owned())\n                    .await;\n            }\n        } else {\n            con.write_response(GroupBegin(1)).await?;\n            let error = RespCodes::OtherError(Some(\"err-access-after-termsig\".to_owned()));\n            return con.write_response(error).await;\n        }\n    } else {\n        if howmany == 1 {\n            let snapname = act\n                .get_ref()\n                .get(1)\n                .unwrap_or_else(|| unsafe { unreachable_unchecked() });\n            let mut path = PathBuf::from(DIR_SNAPSHOT);\n            path.push(\"remote\");\n            path.push(snapname.to_owned() + \".snapshot\");\n            let illegal_snapshot = path\n                .components()\n                .filter(|dir| {\n                    dir == &Component::RootDir || dir == &Component::ParentDir\n                })\n                .count()\n                != 0;\n            if illegal_snapshot {\n                con.write_response(GroupBegin(1)).await?;\n                return con\n                    .write_response(RespCodes::OtherError(Some(\n                        \"err-invalid-snapshot-name\".to_owned(),\n                    )))\n                    .await;\n            }\n            let failed;\n            {\n                match diskstore::flush_data(&path, &handle.acquire_read().get_ref()) {\n                    Ok(_) => failed = false,\n                    Err(e) => {\n                        log::error!(\"Error while creating snapshot: {}\", e);\n                        failed = true;\n                    }\n                }\n            }\n            if failed {\n                return con\n                    .write_response(responses::fresp::R_SERVER_ERR.to_owned())\n                    .await;\n            } else {\n                return con\n                    .write_response(responses::fresp::R_OKAY.to_owned())\n                    .await;\n            }\n        } else {\n            return con\n                .write_response(responses::fresp::R_ACTION_ERR.to_owned())\n                .await;\n        }\n    }\n}\n    pub async fn run(&mut self) -> TResult<()> {\n        loop {\n            self.climit.acquire().await.unwrap().forget();\n            let stream = self.accept().await?;\n            let mut chandle = CHandler {\n                db: self.db.clone(),\n                con: Connection::new(stream),\n                climit: self.climit.clone(),\n                terminator: Terminator::new(self.signal.subscribe()),\n                _term_sig_tx: self.terminate_tx.clone(),\n            };\n            tokio::spawn(async move {\n                if let Err(e) = chandle.run().await {\n                    eprintln!(\"Error: {}\", e);\n                }\n            });\n        }\n    }\n    async fn test_mksnap_sanitization() {\n        let res_should_be = \"#2\\n*1\\n#2\\n&1\\n!25\\nerr-invalid-snapshot-name\\n\"\n            .to_owned()\n            .into_bytes();\n        let query = terrapipe::proc_query(\"MKSNAP ../../badsnappy\");\n        stream.write_all(&query).await.unwrap();\n        let mut response = vec![0; res_should_be.len()];\n        stream.read_exact(&mut response).await.unwrap();\n        assert_eq!(res_should_be, response);\n        let query = terrapipe::proc_query(\"MKSNAP /var/omgcrazysnappy\");\n        stream.write_all(&query).await.unwrap();\n        let mut response = vec![0; res_should_be.len()];\n        stream.read_exact(&mut response).await.unwrap();\n        assert_eq!(res_should_be, response);\n    }\nfn main() {\n    benchtool::runner();\n}\n    fn ran_string(len: usize, rand: impl rand::Rng) -> String {\n        let rand_string: String = rand\n            .sample_iter(&Alphanumeric)\n            .take(len)\n            .map(char::from)\n            .collect();\n        rand_string\n    }\nfn parse_dbtest(mut input: syn::ItemFn, rand: u16) -> Result<TokenStream, syn::Error> {\n    let sig = &mut input.sig;\n    let fname = sig.ident.to_string();\n    let body = &input.block;\n    let attrs = &input.attrs;\n    let vis = &input.vis;\n    let header = quote! {\n        #[::core::prelude::v1::test]\n    };\n    if sig.asyncness.is_none() {\n        let msg = \"`dbtest` functions need to be async\";\n        return Err(syn::Error::new_spanned(sig.fn_token, msg));\n    }\n    sig.asyncness = None;\n    let body = quote! {\n        let asyncdb = crate::coredb::CoreDB::new(\n            crate::config::BGSave::Disabled,\n            crate::config::SnapshotConfig::default(),\n            None\n        ).unwrap();\n        let addr = crate::tests::start_test_server(#rand, Some(asyncdb.clone())).await;\n        let mut stream = tokio::net::TcpStream::connect(&addr).await.unwrap();\n        #body\n        stream.shutdown().await.unwrap();\n        asyncdb.finish_db();\n        drop(asyncdb);\n    };\n    let result = quote! {\n        #header\n        #(#attrs)*\n        #vis #sig {\n            tokio::runtime::Builder::new_multi_thread()\n            .worker_threads(4)\n            .thread_name(#fname)\n            .thread_stack_size(3 * 1024 * 1024)\n            .enable_all()\n            .build()\n            .unwrap()\n            .block_on(async { #body });\n        }\n    };\n    Ok(result.into())\n}\nfn parse_test_module(args: TokenStream, item: TokenStream) -> TokenStream {\n    let input = syn::parse_macro_input!(item as syn::ItemMod);\n    let content = match input.content {\n        Some((_, c)) => c,\n        None => {\n            return syn::Error::new_spanned(&input, \"Couldn't get the module content\")\n                .to_compile_error()\n                .into()\n        }\n    };\n    let args = syn::parse_macro_input!(args as syn::AttributeArgs);\n    let mut skips = Vec::new();\n    for arg in args {\n        match arg {\n            syn::NestedMeta::Meta(syn::Meta::NameValue(namevalue)) => {\n                let ident = namevalue.path.get_ident();\n                if ident.is_none() {\n                    let msg = \"Must have specified ident\";\n                    return syn::Error::new_spanned(namevalue, msg)\n                        .to_compile_error()\n                        .into();\n                }\n                match ident.unwrap().to_string().to_lowercase().as_str() {\n                    \"skip\" => {\n                        let skip_lit = namevalue.lit.clone();\n                        let span = skip_lit.span();\n                        skips = match parse_string(skip_lit, span, \"skip\") {\n                            Ok(s) => s,\n                            Err(_) => {\n                                return syn::Error::new_spanned(\n                                    namevalue,\n                                    \"Expected a value for argument `skip`\",\n                                )\n                                .to_compile_error()\n                                .into();\n                            }\n                        }\n                        .split_whitespace()\n                        .map(|val| val.to_string())\n                        .collect();\n                    }\n                    x => {\n                        let msg = format!(\"Unknown attribute {} is specified; expected `skip`\", x);\n                        return syn::Error::new_spanned(namevalue, msg)\n                            .to_compile_error()\n                            .into();\n                    }\n                }\n            }\n            _ => (),\n        }\n    }\n    let modname = &input.ident;\n    if modname.to_string() != \"__private\" {\n        return syn::Error::new_spanned(\n            modname,\n            \"By convention, all the modules using the `dbtest` macro have to be called `__private`\",\n        )\n        .to_compile_error()\n        .into();\n    }\n    let mut rng = thread_rng();\n    let mut in_set = HashSet::<u16>::new();\n    let mut result = quote! {};\n    for item in content {\n        let mut rand: u16 = rng.gen_range(1025..=65535);\n        #[cfg(not(target_os = \"windows\"))]\n        {\n            while in_set.contains(&rand) {\n                rand = rng.gen_range(1025..=65535);\n            }\n        }\n        #[cfg(target_os = \"windows\")]\n        {\n            in_set.insert(5357);\n            in_set.insert(7680);\n            while in_set.contains(&rand) || (rand >= 49670 && rand <= 50293) {\n                rand = rng.gen_range(1025..=65535);\n            }\n        }\n        in_set.insert(rand);\n        match item {\n            syn::Item::Fn(function) => {\n                if skips.contains(&function.sig.ident.to_string()) {\n                    result = quote! {\n                        #result\n                        #function\n                    };\n                    continue;\n                }\n                let inp = parse_test_sig(function, rand);\n                let __tok: syn::ItemFn = syn::parse_macro_input!(inp as syn::ItemFn);\n                let tok = quote! {\n                    #__tok\n                };\n                result = quote! {\n                    #result\n                    #tok\n                };\n            }\n            token => {\n                result = quote! {\n                    #result\n                    #token\n                };\n            }\n        }\n    }\n    result.into()\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn retrieve_less_version() -> Option<usize> {\n    if let Ok(less_path) = grep_cli::resolve_binary(\"less\") {\n        let cmd = Command::new(less_path).arg(\"--version\").output().ok()?;\n        parse_less_version(&cmd.stdout)\n    } else {\n        None\n    }\n}\nfn _make_process_from_less_path(\n    less_path: PathBuf,\n    args: &[String],\n    replace_arguments_to_less: bool,\n    quit_if_one_screen: bool,\n    config: &config::Config,\n) -> Option<Command> {\n    if let Ok(less_path) = grep_cli::resolve_binary(less_path) {\n        let mut p = Command::new(&less_path);\n        if args.is_empty() || replace_arguments_to_less {\n            p.args(vec![\"--RAW-CONTROL-CHARS\"]);\n            match retrieve_less_version() {\n                None => {\n                    p.arg(\"--no-init\");\n                }\n                Some(version) if (version < 530 || (cfg!(windows) && version < 558)) => {\n                    p.arg(\"--no-init\");\n                }\n                _ => {}\n            }\n            if quit_if_one_screen {\n                p.arg(\"--quit-if-one-screen\");\n            }\n        } else {\n            p.args(args);\n        }\n        p.env(\"LESSCHARSET\", \"UTF-8\");\n        p.env(\"LESSANSIENDCHARS\", \"mK\");\n        if config.navigate {\n            if let Ok(hist_file) = navigate::copy_less_hist_file_and_append_navigate_regexp(config)\n            {\n                p.env(\"LESSHISTFILE\", hist_file);\n                if config.show_themes {\n                    p.arg(\"+n\");\n                }\n            }\n        }\n        Some(p)\n    } else {\n        None\n    }\n}\nfn _make_process_from_pager_path(pager_path: PathBuf, args: &[String]) -> Option<Command> {\n    if pager_path.file_stem() == Some(&OsString::from(\"delta\")) {\n        eprintln!(\n            \"\\\nIt looks like you have set delta as the value of $PAGER. \\\nThis would result in a non-terminating recursion. \\\ndelta is not an appropriate value for $PAGER \\\n(but it is an appropriate value for $GIT_PAGER).\"\n        );\n        std::process::exit(1);\n    }\n    if let Ok(pager_path) = grep_cli::resolve_binary(pager_path) {\n        let mut p = Command::new(&pager_path);\n        p.args(args);\n        Some(p)\n    } else {\n        None\n    }\n}\n    fn try_pager(\n        quit_if_one_screen: bool,\n        pager_from_config: Option<String>,\n        config: &config::Config,\n    ) -> Result<Self> {\n        let mut replace_arguments_to_less = false;\n        let pager_from_env = match (\n            env::var(\"DELTA_PAGER\"),\n            env::var(\"BAT_PAGER\"),\n            env::var(\"PAGER\"),\n        ) {\n            (Ok(delta_pager), _, _) => Some(delta_pager),\n            (_, Ok(bat_pager), _) => Some(bat_pager),\n            (_, _, Ok(pager)) => {\n                replace_arguments_to_less = true;\n                Some(pager)\n            }\n            _ => None,\n        };\n        if pager_from_config.is_some() {\n            replace_arguments_to_less = false;\n        }\n        let pager = pager_from_config\n            .or(pager_from_env)\n            .unwrap_or_else(|| String::from(\"less\"));\n        let pagerflags =\n            shell_words::split(&pager).chain_err(|| \"Could not parse pager command.\")?;\n        Ok(match pagerflags.split_first() {\n            Some((pager_name, args)) => {\n                let pager_path = PathBuf::from(pager_name);\n                let is_less = pager_path.file_stem() == Some(&OsString::from(\"less\"));\n                let process = if is_less {\n                    _make_process_from_less_path(\n                        pager_path,\n                        args,\n                        replace_arguments_to_less,\n                        quit_if_one_screen,\n                        config,\n                    )\n                } else {\n                    _make_process_from_pager_path(pager_path, args)\n                };\n                if let Some(mut process) = process {\n                    process\n                        .stdin(Stdio::piped())\n                        .spawn()\n                        .map(OutputType::Pager)\n                        .unwrap_or_else(|_| OutputType::stdout())\n                } else {\n                    OutputType::stdout()\n                }\n            }\n            None => OutputType::stdout(),\n        })\n    }\nfn diff(\n    minus_file: Option<&PathBuf>,\n    plus_file: Option<&PathBuf>,\n    config: &config::Config,\n    writer: &mut dyn Write,\n) -> i32 {\n    use std::io::BufReader;\n    let die = || {\n        eprintln!(\n            \"\\\nThe main way to use delta is to configure it as the pager for git: \\\nsee https://github.com/dandavison/delta#configuration. \\\nYou can also use delta to diff two files: `delta file_A file_B`.\"\n        );\n        process::exit(config.error_exit_code);\n    };\n    let diff_command = \"git\";\n    let minus_file = minus_file.unwrap_or_else(die);\n    let plus_file = plus_file.unwrap_or_else(die);\n    let diff_command_path = match grep_cli::resolve_binary(PathBuf::from(diff_command)) {\n        Ok(path) => path,\n        Err(_) => return config.error_exit_code,\n    };\n    let mut diff_process = process::Command::new(diff_command_path)\n        .args(&[\"diff\", \"--no-index\"])\n        .args(&[minus_file, plus_file])\n        .stdout(process::Stdio::piped())\n        .spawn()\n        .unwrap_or_else(|err| {\n            eprintln!(\"Failed to execute the command '{}': {}\", diff_command, err);\n            process::exit(config.error_exit_code);\n        });\n    let exit_code = diff_process\n        .wait()\n        .unwrap_or_else(|_| {\n            delta_unreachable(&format!(\"'{}' process not running.\", diff_command));\n        })\n        .code()\n        .unwrap_or_else(|| {\n            eprintln!(\"'{}' process terminated without exit status.\", diff_command);\n            process::exit(config.error_exit_code);\n        });\n    if let Err(error) = delta(\n        BufReader::new(diff_process.stdout.unwrap()).byte_lines(),\n        writer,\n        &config,\n    ) {\n        match error.kind() {\n            ErrorKind::BrokenPipe => process::exit(0),\n            _ => {\n                eprintln!(\"{}\", error);\n                process::exit(config.error_exit_code);\n            }\n        }\n    };\n    exit_code\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn retrieve_less_version(less_path: &dyn AsRef<OsStr>) -> Option<usize> {\n    let resolved_path = grep_cli::resolve_binary(less_path.as_ref()).ok()?;\n    let cmd = Command::new(resolved_path).arg(\"--version\").output().ok()?;\n    parse_less_version(&cmd.stdout)\n}\n    fn try_pager(\n        single_screen_action: SingleScreenAction,\n        wrapping_mode: WrappingMode,\n        pager_from_config: Option<&str>,\n    ) -> Result<Self> {\n        use crate::pager::{self, PagerKind, PagerSource};\n        use std::process::{Command, Stdio};\n        let pager_opt =\n            pager::get_pager(pager_from_config).chain_err(|| \"Could not parse pager command.\")?;\n        let pager = match pager_opt {\n            Some(pager) => pager,\n            None => return Ok(OutputType::stdout()),\n        };\n        if pager.kind == PagerKind::Bat {\n            return Err(ErrorKind::InvalidPagerValueBat.into());\n        }\n        let resolved_path = match grep_cli::resolve_binary(&pager.bin) {\n            Ok(path) => path,\n            Err(_) => {\n                return Ok(OutputType::stdout());\n            }\n        };\n        let mut p = Command::new(resolved_path);\n        let args = pager.args;\n        if pager.kind == PagerKind::Less {\n            let replace_arguments_to_less = pager.source == PagerSource::EnvVarPager;\n            if args.is_empty() || replace_arguments_to_less {\n                p.arg(\"--RAW-CONTROL-CHARS\");\n                if single_screen_action == SingleScreenAction::Quit {\n                    p.arg(\"--quit-if-one-screen\");\n                }\n                if wrapping_mode == WrappingMode::NoWrapping(true) {\n                    p.arg(\"--chop-long-lines\");\n                }\n                match retrieve_less_version(&pager.bin) {\n                    None => {\n                        p.arg(\"--no-init\");\n                    }\n                    Some(version) if (version < 530 || (cfg!(windows) && version < 558)) => {\n                        p.arg(\"--no-init\");\n                    }\n                    _ => {}\n                }\n            } else {\n                p.args(args);\n            }\n            p.env(\"LESSCHARSET\", \"UTF-8\");\n        } else {\n            p.args(args);\n        };\n        Ok(p.stdin(Stdio::piped())\n            .spawn()\n            .map(OutputType::Pager)\n            .unwrap_or_else(|_| OutputType::stdout()))\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "    pub async fn run(&mut self) -> TResult<()> {\n        loop {\n            self.base.climit.acquire().await.unwrap().forget();\n            let stream = skip_loop_err!(self.accept().await);\n            let mut chandle = ConnectionHandler::new(\n                self.base.db.clone(),\n                Connection::new(stream),\n                self.base.climit.clone(),\n                Terminator::new(self.base.signal.subscribe()),\n                self.base.terminate_tx.clone(),\n            );\n            tokio::spawn(async move {\n                if let Err(e) = chandle.run().await {\n                    log::error!(\"Error: {}\", e);\n                }\n            });\n        }\n    }\n    pub async fn run(&mut self) -> TResult<()> {\n        loop {\n            self.base.climit.acquire().await.unwrap().forget();\n            let stream = skip_loop_err!(self.accept().await);\n            let mut sslhandle = ConnectionHandler::new(\n                self.base.db.clone(),\n                Connection::new(stream),\n                self.base.climit.clone(),\n                Terminator::new(self.base.signal.subscribe()),\n                self.base.terminate_tx.clone(),\n            );\n            tokio::spawn(async move {\n                log::debug!(\"Spawned listener task\");\n                if let Err(e) = sslhandle.run().await {\n                    log::error!(\"Error: {}\", e);\n                }\n            });\n        }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn write_ignition(\n    mountpoint: &Path,\n    digest_in: &Option<IgnitionHash>,\n    mut config_in: &File,\n) -> Result<()> {\n    eprintln!(\"Writing Ignition config\");\n    if let Some(ref digest) = digest_in {\n        digest\n            .validate(&mut config_in)\n            .context(\"failed to validate Ignition configuration digest\")?;\n        config_in\n            .seek(SeekFrom::Start(0))\n            .context(\"rewinding Ignition configuration file\")?;\n    };\n    let mut config_dest = mountpoint.to_path_buf();\n    config_dest.push(\"ignition\");\n    if !config_dest.is_dir() {\n        create_dir_all(&config_dest).with_context(|| {\n            format!(\n                \"creating Ignition config directory {}\",\n                config_dest.display()\n            )\n        })?;\n        set_permissions(&config_dest, Permissions::from_mode(0o700)).with_context(|| {\n            format!(\n                \"setting file mode for Ignition directory {}\",\n                config_dest.display()\n            )\n        })?;\n    }\n    config_dest.push(\"config.ign\");\n    let mut config_out = OpenOptions::new()\n        .write(true)\n        .create_new(true)\n        .open(&config_dest)\n        .with_context(|| {\n            format!(\n                \"opening destination Ignition config {}\",\n                config_dest.display()\n            )\n        })?;\n    set_permissions(&config_dest, Permissions::from_mode(0o600)).with_context(|| {\n        format!(\n            \"setting file mode for destination Ignition config {}\",\n            config_dest.display()\n        )\n    })?;\n    copy(&mut config_in, &mut config_out).context(\"writing Ignition config\")?;\n    Ok(())\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "\t\tfn validate_unsigned(_source: TransactionSource, call: &Self::Call) -> TransactionValidity {\n\t\t\tif let Call::transact(transaction) = call {\n\t\t\t\tlet mut gasometer = evm::gasometer::Gasometer::new(\n\t\t\t\t\ttransaction.gas_limit.low_u64(),\n\t\t\t\t\t<T as pallet_evm::Config>::config(),\n\t\t\t\t);\n\t\t\t\tlet transaction_cost = match transaction.action {\n\t\t\t\t\tTransactionAction::Call(_) => {\n\t\t\t\t\t\tevm::gasometer::call_transaction_cost(&transaction.input)\n\t\t\t\t\t}\n\t\t\t\t\tTransactionAction::Create => {\n\t\t\t\t\t\tevm::gasometer::create_transaction_cost(&transaction.input)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tif gasometer.record_transaction(transaction_cost).is_err() {\n\t\t\t\t\treturn InvalidTransaction::Custom(\n\t\t\t\t\t\tTransactionValidationError::InvalidGasLimit as u8,\n\t\t\t\t\t)\n\t\t\t\t\t.into();\n\t\t\t\t}\n\t\t\t\tif let Some(chain_id) = transaction.signature.chain_id() {\n\t\t\t\t\tif chain_id != T::ChainId::get() {\n\t\t\t\t\t\treturn InvalidTransaction::Custom(\n\t\t\t\t\t\t\tTransactionValidationError::InvalidChainId as u8,\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.into();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet origin = Self::recover_signer(&transaction).ok_or_else(|| {\n\t\t\t\t\tInvalidTransaction::Custom(TransactionValidationError::InvalidSignature as u8)\n\t\t\t\t})?;\n\t\t\t\tif transaction.gas_limit >= T::BlockGasLimit::get() {\n\t\t\t\t\treturn InvalidTransaction::Custom(\n\t\t\t\t\t\tTransactionValidationError::InvalidGasLimit as u8,\n\t\t\t\t\t)\n\t\t\t\t\t.into();\n\t\t\t\t}\n\t\t\t\tlet account_data = pallet_evm::Pallet::<T>::account_basic(&origin);\n\t\t\t\tif transaction.nonce < account_data.nonce {\n\t\t\t\t\treturn InvalidTransaction::Stale.into();\n\t\t\t\t}\n\t\t\t\tlet fee = transaction.gas_price.saturating_mul(transaction.gas_limit);\n\t\t\t\tlet total_payment = transaction.value.saturating_add(fee);\n\t\t\t\tif account_data.balance < total_payment {\n\t\t\t\t\treturn InvalidTransaction::Payment.into();\n\t\t\t\t}\n\t\t\t\tlet min_gas_price = T::FeeCalculator::min_gas_price();\n\t\t\t\tif transaction.gas_price < min_gas_price {\n\t\t\t\t\treturn InvalidTransaction::Payment.into();\n\t\t\t\t}\n\t\t\t\tlet mut builder = ValidTransactionBuilder::default()\n\t\t\t\t\t.and_provides((origin, transaction.nonce))\n\t\t\t\t\t.priority(transaction.gas_price.unique_saturated_into());\n\t\t\t\tif transaction.nonce > account_data.nonce {\n\t\t\t\t\tif let Some(prev_nonce) = transaction.nonce.checked_sub(1.into()) {\n\t\t\t\t\t\tbuilder = builder.and_requires((origin, prev_nonce))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuilder.build()\n\t\t\t} else {\n\t\t\t\tErr(InvalidTransaction::Call.into())\n\t\t\t}\n\t\t}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "\tfn apply_validated_transaction(\n\t\tsource: H160,\n\t\ttransaction: Transaction,\n\t) -> DispatchResultWithPostInfo {\n\t\tlet transaction_hash =\n\t\t\tH256::from_slice(Keccak256::digest(&rlp::encode(&transaction)).as_slice());\n\t\tlet transaction_index = Pending::<T>::get().len() as u32;\n\t\tlet (to, _, info) = Self::execute(\n\t\t\tsource,\n\t\t\ttransaction.input.clone(),\n\t\t\ttransaction.value,\n\t\t\ttransaction.gas_limit,\n\t\t\tSome(transaction.gas_price),\n\t\t\tSome(transaction.nonce),\n\t\t\ttransaction.action,\n\t\t\tNone,\n\t\t)?;\n\t\tlet (reason, status, used_gas, dest) = match info {\n\t\t\tCallOrCreateInfo::Call(info) => (\n\t\t\t\tinfo.exit_reason,\n\t\t\t\tTransactionStatus {\n\t\t\t\t\ttransaction_hash,\n\t\t\t\t\ttransaction_index,\n\t\t\t\t\tfrom: source,\n\t\t\t\t\tto,\n\t\t\t\t\tcontract_address: None,\n\t\t\t\t\tlogs: info.logs.clone(),\n\t\t\t\t\tlogs_bloom: {\n\t\t\t\t\t\tlet mut bloom: Bloom = Bloom::default();\n\t\t\t\t\t\tSelf::logs_bloom(info.logs, &mut bloom);\n\t\t\t\t\t\tbloom\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tinfo.used_gas,\n\t\t\t\tto,\n\t\t\t),\n\t\t\tCallOrCreateInfo::Create(info) => (\n\t\t\t\tinfo.exit_reason,\n\t\t\t\tTransactionStatus {\n\t\t\t\t\ttransaction_hash,\n\t\t\t\t\ttransaction_index,\n\t\t\t\t\tfrom: source,\n\t\t\t\t\tto,\n\t\t\t\t\tcontract_address: Some(info.value),\n\t\t\t\t\tlogs: info.logs.clone(),\n\t\t\t\t\tlogs_bloom: {\n\t\t\t\t\t\tlet mut bloom: Bloom = Bloom::default();\n\t\t\t\t\t\tSelf::logs_bloom(info.logs, &mut bloom);\n\t\t\t\t\t\tbloom\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tinfo.used_gas,\n\t\t\t\tSome(info.value),\n\t\t\t),\n\t\t};\n\t\tlet receipt = ethereum::Receipt {\n\t\t\tstate_root: match reason {\n\t\t\t\tExitReason::Succeed(_) => H256::from_low_u64_be(1),\n\t\t\t\tExitReason::Error(_) => H256::from_low_u64_le(0),\n\t\t\t\tExitReason::Revert(_) => H256::from_low_u64_le(0),\n\t\t\t\tExitReason::Fatal(_) => H256::from_low_u64_le(0),\n\t\t\t},\n\t\t\tused_gas,\n\t\t\tlogs_bloom: status.clone().logs_bloom,\n\t\t\tlogs: status.clone().logs,\n\t\t};\n\t\tPending::<T>::append((transaction, status, receipt));\n\t\tSelf::deposit_event(Event::Executed(\n\t\t\tsource,\n\t\t\tdest.unwrap_or_default(),\n\t\t\ttransaction_hash,\n\t\t\treason,\n\t\t));\n\t\tOk(PostDispatchInfo {\n\t\t\tactual_weight: Some(T::GasWeightMapping::gas_to_weight(\n\t\t\t\tused_gas.unique_saturated_into(),\n\t\t\t)),\n\t\t\tpays_fee: Pays::No,\n\t\t})\n\t\t.into()\n\t}\npub fn ensure_ethereum_transaction<OuterOrigin>(o: OuterOrigin) -> Result<H160, &'static str>\nwhere\n\tOuterOrigin: Into<Result<RawOrigin, OuterOrigin>>,\n{\n\tmatch o.into() {\n\t\tOk(RawOrigin::EthereumTransaction(n)) => Ok(n),\n\t\t_ => Err(\"bad origin: expected to be an Ethereum transaction\"),\n\t}\n}\npub struct EnsureEthereumTransaction;\nimpl<O: Into<Result<RawOrigin, O>> + From<RawOrigin>> EnsureOrigin<O>\n\tfor EnsureEthereumTransaction\n{\n\ttype Success = H160;\n\tfn try_origin(o: O) -> Result<Self::Success, O> {\n\t\to.into().and_then(|o| match o {\n\t\t\tRawOrigin::EthereumTransaction(id) => Ok(id),\n\t\t})\n\t}\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\tfn successful_origin() -> O {\n\t\tO::from(RawOrigin::EthereumTransaction(Default::default()))\n\t}\n}\nimpl<T: Config> Call<T>\nwhere\n\tOriginFor<T>: Into<Result<RawOrigin, OriginFor<T>>>,\n{\n\tpub fn is_self_contained(&self) -> bool {\n\t\tmatch self {\n\t\t\tCall::transact(_) => true,\n\t\t\t_ => false,\n\t\t}\n\t}\n\tpub fn check_self_contained(&self) -> Option<Result<H160, TransactionValidityError>> {\n\t\tif let Call::transact(transaction) = self {\n\t\t\tlet check = || {\n\t\t\t\tlet origin = Pallet::<T>::recover_signer(&transaction).ok_or_else(|| {\n\t\t\t\t\tInvalidTransaction::Custom(TransactionValidationError::InvalidSignature as u8)\n\t\t\t\t})?;\n\t\t\t\tOk(origin)\n\t\t\t};\n\t\t\tSome(check())\n\t\t} else {\n\t\t\tNone\n\t\t}\n\t}\n\tpub fn pre_dispatch_self_contained(\n\t\t&self,\n\t\torigin: &H160,\n\t) -> Option<Result<(), TransactionValidityError>> {\n\t\tif let Call::transact(transaction) = self {\n\t\t\tSome(Pallet::<T>::validate_transaction_in_block(\n\t\t\t\t*origin,\n\t\t\t\t&transaction,\n\t\t\t))\n\t\t} else {\n\t\t\tNone\n\t\t}\n\t}\n\tpub fn validate_self_contained(&self, origin: &H160) -> Option<TransactionValidity> {\n\t\tif let Call::transact(transaction) = self {\n\t\t\tSome(Pallet::<T>::validate_transaction_in_pool(\n\t\t\t\t*origin,\n\t\t\t\ttransaction,\n\t\t\t))\n\t\t} else {\n\t\t\tNone\n\t\t}\n\t}\n}\npub use pallet::*;\n#[frame_support::pallet]\npub mod pallet {\n\tuse super::*;\n\tuse frame_support::pallet_prelude::*;\n\tuse frame_system::pallet_prelude::*;\n\t#[pallet::config]\n\tpub trait Config:\n\t\tframe_system::Config\n\t\t+ pallet_balances::Config\n\t\t+ pallet_timestamp::Config\n\t\t+ pallet_evm::Config\n\t{\n\t\ttype Event: From<Event> + IsType<<Self as frame_system::Config>::Event>;\n\t\ttype StateRoot: Get<H256>;\n\t}\n\t#[pallet::pallet]\n\t#[pallet::generate_store(pub(super) trait Store)]\n\tpub struct Pallet<T>(PhantomData<T>);\n\t#[pallet::origin]\n\tpub type Origin = RawOrigin;\n\t#[pallet::hooks]\n\timpl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {\n\t\tfn on_finalize(n: T::BlockNumber) {\n\t\t\t<Pallet<T>>::store_block(\n\t\t\t\tfp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()).is_err(),\n\t\t\t\tU256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(\n\t\t\t\t\tframe_system::Pallet::<T>::block_number(),\n\t\t\t\t)),\n\t\t\t);\n\t\t\tlet block_hash_count = T::BlockHashCount::get();\n\t\t\tlet to_remove = n\n\t\t\t\t.saturating_sub(block_hash_count)\n\t\t\t\t.saturating_sub(One::one());\n\t\t\tif !to_remove.is_zero() {\n\t\t\t\t<BlockHash<T>>::remove(U256::from(\n\t\t\t\t\tUniqueSaturatedInto::<u32>::unique_saturated_into(to_remove),\n\t\t\t\t));\n\t\t\t}\n\t\t}\n\t\tfn on_initialize(_: T::BlockNumber) -> Weight {\n\t\t\tPending::<T>::kill();\n\t\t\tif let Ok(log) = fp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()) {\n\t\t\t\tlet PreLog::Block(block) = log;\n\t\t\t\tfor transaction in block.transactions {\n\t\t\t\t\tlet source = Self::recover_signer(&transaction).expect(\n\t\t\t\t\t\t\"pre-block transaction signature invalid; the block cannot be built\",\n\t\t\t\t\t);\n\t\t\t\t\tSelf::validate_transaction_in_block(source, &transaction).expect(\n\t\t\t\t\t\t\"pre-block transaction verification failed; the block cannot be built\",\n\t\t\t\t\t);\n\t\t\t\t\tSelf::apply_validated_transaction(source, transaction).expect(\n\t\t\t\t\t\t\"pre-block transaction execution failed; the block cannot be built\",\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\t0\n\t\t}\n\t}\n\t#[pallet::call]\n\timpl<T: Config> Pallet<T>\n\twhere\n\t\tOriginFor<T>: Into<Result<RawOrigin, OriginFor<T>>>,\n\t{\n\t\t#[pallet::weight(<T as pallet_evm::Config>::GasWeightMapping::gas_to_weight(transaction.gas_limit.unique_saturated_into()))]\n\t\tpub fn transact(\n\t\t\torigin: OriginFor<T>,\n\t\t\ttransaction: Transaction,\n\t\t) -> DispatchResultWithPostInfo {\n\t\t\tlet source = ensure_ethereum_transaction(origin)?;\n\t\t\tensure!(\n\t\t\t\tfp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()).is_err(),\n\t\t\t\tError::<T>::PreLogExists,\n\t\t\t);\n\t\t\tSelf::apply_validated_transaction(source, transaction)\n\t\t}\n\t}\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(super) fn deposit_event)]\n\tpub enum Event {\n\t\tExecuted(H160, H160, H256, ExitReason),\n\t}\n\t#[pallet::error]\n\tpub enum Error<T> {\n\t\tInvalidSignature,\n\t\tPreLogExists,\n\t}\n\t#[pallet::storage]\n\tpub(super) type Pending<T: Config> =\n\t\tStorageValue<_, Vec<(Transaction, TransactionStatus, ethereum::Receipt)>, ValueQuery>;\n\t#[pallet::storage]\n\tpub(super) type CurrentBlock<T: Config> = StorageValue<_, ethereum::BlockV0>;\n\t#[pallet::storage]\n\tpub(super) type CurrentReceipts<T: Config> = StorageValue<_, Vec<ethereum::Receipt>>;\n\t#[pallet::storage]\n\tpub(super) type CurrentTransactionStatuses<T: Config> = StorageValue<_, Vec<TransactionStatus>>;\n\t#[pallet::storage]\n\tpub(super) type BlockHash<T: Config> = StorageMap<_, Twox64Concat, U256, H256, ValueQuery>;\n\t#[pallet::genesis_config]\n\t#[derive(Default)]\n\tpub struct GenesisConfig {}\n\tfn validate_transaction_common(\n\t\torigin: H160,\n\t\ttransaction: &Transaction,\n\t) -> Result<U256, TransactionValidityError> {\n\t\tlet mut gasometer = evm::gasometer::Gasometer::new(\n\t\t\ttransaction.gas_limit.low_u64(),\n\t\t\t<T as pallet_evm::Config>::config(),\n\t\t);\n\t\tlet transaction_cost = match transaction.action {\n\t\t\tTransactionAction::Call(_) => evm::gasometer::call_transaction_cost(&transaction.input),\n\t\t\tTransactionAction::Create => {\n\t\t\t\tevm::gasometer::create_transaction_cost(&transaction.input)\n\t\t\t}\n\t\t};\n\t\tif gasometer.record_transaction(transaction_cost).is_err() {\n\t\t\treturn Err(InvalidTransaction::Custom(\n\t\t\t\tTransactionValidationError::InvalidGasLimit as u8,\n\t\t\t)\n\t\t\t.into());\n\t\t}\n\t\tif let Some(chain_id) = transaction.signature.chain_id() {\n\t\t\tif chain_id != T::ChainId::get() {\n\t\t\t\treturn Err(InvalidTransaction::Custom(\n\t\t\t\t\tTransactionValidationError::InvalidChainId as u8,\n\t\t\t\t)\n\t\t\t\t.into());\n\t\t\t}\n\t\t}\n\t\tif transaction.gas_limit >= T::BlockGasLimit::get() {\n\t\t\treturn Err(InvalidTransaction::Custom(\n\t\t\t\tTransactionValidationError::InvalidGasLimit as u8,\n\t\t\t)\n\t\t\t.into());\n\t\t}\n\t\tlet account_data = pallet_evm::Pallet::<T>::account_basic(&origin);\n\t\tlet fee = transaction.gas_price.saturating_mul(transaction.gas_limit);\n\t\tlet total_payment = transaction.value.saturating_add(fee);\n\t\tif account_data.balance < total_payment {\n\t\t\treturn Err(InvalidTransaction::Payment.into());\n\t\t}\n\t\tlet min_gas_price = T::FeeCalculator::min_gas_price();\n\t\tif transaction.gas_price < min_gas_price {\n\t\t\treturn Err(InvalidTransaction::Payment.into());\n\t\t}\n\t\tOk(account_data.nonce)\n\t}\n\tpub fn validate_transaction_in_block(\n\t\torigin: H160,\n\t\ttransaction: &ethereum::TransactionV0,\n\t) -> Result<(), TransactionValidityError> {\n\t\tlet account_nonce = Self::validate_transaction_common(origin, transaction)?;\n\t\tif transaction.nonce > account_nonce {\n\t\t\tErr(TransactionValidityError::Invalid(\n\t\t\t\tInvalidTransaction::Future,\n\t\t\t))\n\t\t} else if transaction.nonce < account_nonce {\n\t\t\tErr(TransactionValidityError::Invalid(InvalidTransaction::Stale))\n\t\t} else {\n\t\t\tOk(())\n\t\t}\n\t}\n\tfn validate_transaction_in_pool(\n\t\torigin: H160,\n\t\ttransaction: &Transaction,\n\t) -> TransactionValidity {\n\t\tlet account_nonce = Self::validate_transaction_common(origin, transaction)?;\n\t\tif transaction.nonce < account_nonce {\n\t\t\treturn Err(InvalidTransaction::Stale.into());\n\t\t}\n\t\tlet mut builder = ValidTransactionBuilder::default()\n\t\t\t.and_provides((origin, transaction.nonce))\n\t\t\t.priority(transaction.gas_price.unique_saturated_into());\n\t\tif transaction.nonce > account_nonce {\n\t\t\tif let Some(prev_nonce) = transaction.nonce.checked_sub(1.into()) {\n\t\t\t\tbuilder = builder.and_requires((origin, prev_nonce))\n\t\t\t}\n\t\t}\n\t\tbuilder.build()\n\t}\nfn transaction_with_invalid_chain_id_should_fail_in_block() {\n\tlet (pairs, mut ext) = new_test_ext(1);\n\tlet alice = &pairs[0];\n\text.execute_with(|| {\n\t\tlet transaction =\n\t\t\tdefault_erc20_creation_unsigned_transaction().sign_with_chain_id(&alice.private_key, 1);\n\t\tlet call = crate::Call::<Test>::transact(transaction);\n\t\tlet source = call.check_self_contained().unwrap().unwrap();\n\t\tlet extrinsic = fp_self_contained::CheckedExtrinsic::<_, _, SignedExtra, _> {\n\t\t\tsigned: fp_self_contained::CheckedSignature::SelfContained(source),\n\t\t\tfunction: Call::Ethereum(call),\n\t\t};\n\t\tuse frame_support::weights::GetDispatchInfo as _;\n\t\tlet dispatch_info = extrinsic.get_dispatch_info();\n\t\tassert_err!(\n\t\t\textrinsic.apply::<Test>(&dispatch_info, 0),\n\t\t\tTransactionValidityError::Invalid(InvalidTransaction::Custom(\n\t\t\t\tcrate::TransactionValidationError::InvalidChainId as u8,\n\t\t\t))\n\t\t);\n\t});\n}\nfn transaction_with_to_hight_nonce_should_fail_in_block() {\n\tlet (pairs, mut ext) = new_test_ext(1);\n\tlet alice = &pairs[0];\n\text.execute_with(|| {\n\t\tlet mut transaction = default_erc20_creation_unsigned_transaction();\n\t\ttransaction.nonce = U256::one();\n\t\tlet signed = transaction.sign(&alice.private_key);\n\t\tlet call = crate::Call::<Test>::transact(signed);\n\t\tlet source = call.check_self_contained().unwrap().unwrap();\n\t\tlet extrinsic = fp_self_contained::CheckedExtrinsic::<_, _, SignedExtra, _> {\n\t\t\tsigned: fp_self_contained::CheckedSignature::SelfContained(source),\n\t\t\tfunction: Call::Ethereum(call),\n\t\t};\n\t\tuse frame_support::weights::GetDispatchInfo as _;\n\t\tlet dispatch_info = extrinsic.get_dispatch_info();\n\t\tassert_err!(\n\t\t\textrinsic.apply::<Test>(&dispatch_info, 0),\n\t\t\tTransactionValidityError::Invalid(InvalidTransaction::Future)\n\t\t);\n\t});\n}\nfn transaction_with_to_low_nonce_should_not_work() {\n\tlet (pairs, mut ext) = new_test_ext(1);\n\tlet alice = &pairs[0];\n\text.execute_with(|| {\n\t\tlet mut transaction = default_erc20_creation_unsigned_transaction();\n\t\ttransaction.nonce = U256::from(1);\n\t\tlet signed = transaction.sign(&alice.private_key);\n\t\tlet call = crate::Call::<Test>::transact(signed);\n\t\tlet source = call.check_self_contained().unwrap().unwrap();\n\t\tassert_eq!(\n\t\t\tcall.validate_self_contained(&source).unwrap(),\n\t\t\tValidTransactionBuilder::default()\n\t\t\t\t.and_provides((alice.address, U256::from(1)))\n\t\t\t\t.priority(1u64)\n\t\t\t\t.and_requires((alice.address, U256::from(0)))\n\t\t\t\t.build()\n\t\t);\n\t\tlet t = default_erc20_creation_transaction(alice);\n\t\tassert_ok!(Ethereum::execute(\n\t\t\talice.address,\n\t\t\tt.input,\n\t\t\tt.value,\n\t\t\tt.gas_limit,\n\t\t\tSome(t.gas_price),\n\t\t\tSome(t.nonce),\n\t\t\tt.action,\n\t\t\tNone,\n\t\t));\n\t\ttransaction.nonce = U256::from(0);\n\t\tlet signed2 = transaction.sign(&alice.private_key);\n\t\tlet call2 = crate::Call::<Test>::transact(signed2);\n\t\tlet source2 = call2.check_self_contained().unwrap().unwrap();\n\t\tassert_err!(\n\t\t\tcall2.validate_self_contained(&source2).unwrap(),\n\t\t\tInvalidTransaction::Stale\n\t\t);\n\t});\n}\n\tfn apply<U: ValidateUnsigned<Call = Self::Call>>(\n\t\tself,\n\t\tinfo: &DispatchInfoOf<Self::Call>,\n\t\tlen: usize,\n\t) -> sp_runtime::ApplyExtrinsicResultWithInfo<PostDispatchInfoOf<Self::Call>> {\n\t\tmatch self.signed {\n\t\t\tCheckedSignature::Signed(id, extra) => {\n\t\t\t\tlet pre = Extra::pre_dispatch(extra, &id, &self.function, info, len)?;\n\t\t\t\tlet maybe_who = Some(id);\n\t\t\t\tlet res = self.function.dispatch(Origin::from(maybe_who));\n\t\t\t\tlet post_info = match res {\n\t\t\t\t\tOk(info) => info,\n\t\t\t\t\tErr(err) => err.post_info,\n\t\t\t\t};\n\t\t\t\tExtra::post_dispatch(\n\t\t\t\t\tpre,\n\t\t\t\t\tinfo,\n\t\t\t\t\t&post_info,\n\t\t\t\t\tlen,\n\t\t\t\t\t&res.map(|_| ()).map_err(|e| e.error),\n\t\t\t\t)?;\n\t\t\t\tOk(res)\n\t\t\t}\n\t\t\tCheckedSignature::Unsigned => {\n\t\t\t\tlet pre = Extra::pre_dispatch_unsigned(&self.function, info, len)?;\n\t\t\t\tU::pre_dispatch(&self.function)?;\n\t\t\t\tlet maybe_who = None;\n\t\t\t\tlet res = self.function.dispatch(Origin::from(maybe_who));\n\t\t\t\tlet post_info = match res {\n\t\t\t\t\tOk(info) => info,\n\t\t\t\t\tErr(err) => err.post_info,\n\t\t\t\t};\n\t\t\t\tExtra::post_dispatch(\n\t\t\t\t\tpre,\n\t\t\t\t\tinfo,\n\t\t\t\t\t&post_info,\n\t\t\t\t\tlen,\n\t\t\t\t\t&res.map(|_| ()).map_err(|e| e.error),\n\t\t\t\t)?;\n\t\t\t\tOk(res)\n\t\t\t}\n\t\t\tCheckedSignature::SelfContained(signed_info) => {\n\t\t\t\tself.function\n\t\t\t\t\t.pre_dispatch_self_contained(&signed_info)\n\t\t\t\t\t.ok_or(TransactionValidityError::Invalid(\n\t\t\t\t\t\tInvalidTransaction::BadProof,\n\t\t\t\t\t))??;\n\t\t\t\tOk(self.function.apply_self_contained(signed_info).ok_or(\n\t\t\t\t\tTransactionValidityError::Invalid(InvalidTransaction::BadProof),\n\t\t\t\t)?)\n\t\t\t}\n\t\t}\n\t}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn jumpi(state: &mut Machine) -> Control {\n\tpop_u256!(state, dest);\n\tpop!(state, value);\n\tif value != H256::zero() {\n\t\tlet dest = as_usize_or_fail!(dest, ExitError::InvalidJump);\n\t\tif state.valids.is_valid(dest) {\n\t\t\tControl::Jump(dest)\n\t\t} else {\n\t\t\tControl::Exit(ExitError::InvalidJump.into())\n\t\t}\n\t} else {\n\t\tControl::Continue(1)\n\t}\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "Status SparseCountSparseOutputShapeFn(InferenceContext *c) {\n  ShapeHandle unused;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));\n  auto rank = c->Dim(c->input(0), 1);\n  auto nvals = c->UnknownDim();\n  c->set_output(0, c->Matrix(nvals, rank));  \n  c->set_output(1, c->Vector(nvals));        \n  c->set_output(2, c->Vector(rank));         \n  return Status::OK();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "    fn drop(&mut self) {\n        if self.needs_inst_drop {\n            unsafe {\n                let inst = self.inst.as_mut();\n                let alloc: Alloc = ManuallyDrop::take(&mut inst.alloc);\n                std::ptr::drop_in_place(inst);\n                drop(alloc);\n            }\n        }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "    pub fn clone_cstring_safely(out_ptr: *const c_char) -> Result<CString> {\n        if out_ptr.is_null() {\n            return_errno!(EINVAL, \"NULL address is invalid\");\n        }\n        check_ptr(out_ptr)?;\n        let cstr = unsafe { CStr::from_ptr(out_ptr) };\n        let cstring = CString::from(cstr);\n        if !is_inside_user_space(out_ptr as *const u8, cstring.as_bytes_with_nul().len()) {\n            return_errno!(EFAULT, \"the whole buffer is not in the user space\");\n        }\n        Ok(cstring)\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "export const marked = (markdownStr: string, blockParsers = blockElementParserList, inlineParsers = inlineElementParserList): string => {\n  for (const parser of blockParsers) {\n    const matchResult = parser.matcher(markdownStr);\n    if (!matchResult) {\n      continue;\n    }\n    const matchedStr = matchResult[0];\n    const retainContent = markdownStr.slice(matchedStr.length);\n    if (parser.name === \"br\") {\n      return parser.renderer(matchedStr) + marked(retainContent, blockParsers, inlineParsers);\n    } else {\n      if (retainContent === \"\") {\n        return parser.renderer(matchedStr);\n      } else if (retainContent.startsWith(\"\\n\")) {\n        return parser.renderer(matchedStr) + marked(retainContent.slice(1), blockParsers, inlineParsers);\n      }\n    }\n  }\n  let matchedInlineParser = undefined;\n  let matchedIndex = -1;\n  for (const parser of inlineParsers) {\n    const matchResult = parser.matcher(markdownStr);\n    if (!matchResult) {\n      continue;\n    }\n    if (parser.name === \"plain text\" && matchedInlineParser !== undefined) {\n      continue;\n    }\n    const startIndex = matchResult.index as number;\n    if (matchedInlineParser === undefined || matchedIndex > startIndex) {\n      matchedInlineParser = parser;\n      matchedIndex = startIndex;\n    }\n  }\n  if (matchedInlineParser) {\n    const matchResult = matchedInlineParser.matcher(markdownStr);\n    if (matchResult) {\n      const matchedStr = matchResult[0];\n      const matchedLength = matchedStr.length;\n      const prefixStr = markdownStr.slice(0, matchedIndex);\n      const suffixStr = markdownStr.slice(matchedIndex + matchedLength);\n      return marked(prefixStr, [], inlineParsers) + matchedInlineParser.renderer(matchedStr) + marked(suffixStr, [], inlineParsers);\n    }\n  }\n  return markdownStr;\n};\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "export const marked = (markdownStr: string, blockParsers = blockElementParserList, inlineParsers = inlineElementParserList): string => {\n  for (const parser of blockParsers) {\n    const matchResult = parser.matcher(markdownStr);\n    if (!matchResult) {\n      continue;\n    }\n    const matchedStr = matchResult[0];\n    const retainContent = markdownStr.slice(matchedStr.length);\n    if (parser.name === \"br\") {\n      return parser.renderer(matchedStr) + marked(retainContent, blockParsers, inlineParsers);\n    } else {\n      if (retainContent === \"\") {\n        return parser.renderer(matchedStr);\n      } else if (retainContent.startsWith(\"\\n\")) {\n        return parser.renderer(matchedStr) + marked(retainContent.slice(1), blockParsers, inlineParsers);\n      }\n    }\n  }\n  let matchedInlineParser = undefined;\n  let matchedIndex = -1;\n  for (const parser of inlineParsers) {\n    const matchResult = parser.matcher(markdownStr);\n    if (!matchResult) {\n      continue;\n    }\n    if (parser.name === \"plain text\" && matchedInlineParser !== undefined) {\n      continue;\n    }\n    const startIndex = matchResult.index as number;\n    if (matchedInlineParser === undefined || matchedIndex > startIndex) {\n      matchedInlineParser = parser;\n      matchedIndex = startIndex;\n    }\n  }\n  if (matchedInlineParser) {\n    const matchResult = matchedInlineParser.matcher(markdownStr);\n    if (matchResult) {\n      const matchedStr = matchResult[0];\n      const matchedLength = matchedStr.length;\n      const prefixStr = markdownStr.slice(0, matchedIndex);\n      const suffixStr = markdownStr.slice(matchedIndex + matchedLength);\n      return marked(prefixStr, [], inlineParsers) + matchedInlineParser.renderer(matchedStr) + marked(suffixStr, [], inlineParsers);\n    }\n  }\n  return markdownStr;\n};\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "export const marked = (markdownStr: string, blockParsers = blockElementParserList, inlineParsers = inlineElementParserList): string => {\n  for (const parser of blockParsers) {\n    const matchResult = parser.matcher(markdownStr);\n    if (!matchResult) {\n      continue;\n    }\n    const matchedStr = matchResult[0];\n    const retainContent = markdownStr.slice(matchedStr.length);\n    if (parser.name === \"br\") {\n      return parser.renderer(matchedStr) + marked(retainContent, blockParsers, inlineParsers);\n    } else {\n      if (retainContent === \"\") {\n        return parser.renderer(matchedStr);\n      } else if (retainContent.startsWith(\"\\n\")) {\n        return parser.renderer(matchedStr) + marked(retainContent.slice(1), blockParsers, inlineParsers);\n      }\n    }\n  }\n  let matchedInlineParser = undefined;\n  let matchedIndex = -1;\n  for (const parser of inlineParsers) {\n    const matchResult = parser.matcher(markdownStr);\n    if (!matchResult) {\n      continue;\n    }\n    if (parser.name === \"plain text\" && matchedInlineParser !== undefined) {\n      continue;\n    }\n    const startIndex = matchResult.index as number;\n    if (matchedInlineParser === undefined || matchedIndex > startIndex) {\n      matchedInlineParser = parser;\n      matchedIndex = startIndex;\n    }\n  }\n  if (matchedInlineParser) {\n    const matchResult = matchedInlineParser.matcher(markdownStr);\n    if (matchResult) {\n      const matchedStr = matchResult[0];\n      const matchedLength = matchedStr.length;\n      const prefixStr = markdownStr.slice(0, matchedIndex);\n      const suffixStr = markdownStr.slice(matchedIndex + matchedLength);\n      return marked(prefixStr, [], inlineParsers) + matchedInlineParser.renderer(matchedStr) + marked(suffixStr, [], inlineParsers);\n    }\n  }\n  return markdownStr;\n};\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn calculate_gas_cost(\n\tbase_length: u64,\n\texp_length: u64,\n\tmod_length: u64,\n\texponent: &BigUint,\n) -> u64 {\n\tfn calculate_multiplication_complexity(base_length: u64, mod_length: u64) -> u64 {\n\t\tlet max_length = max(base_length, mod_length);\n\t\tlet mut words = max_length / 8;\n\t\tif max_length % 8 > 0 {\n\t\t\twords += 1;\n\t\t}\n\t\twords * words\n\t}\n\tfn calculate_iteration_count(exp_length: u64, exponent: &BigUint) -> u64 {\n\t\tlet mut iteration_count: u64 = 0;\n\t\tif exp_length <= 32 && exponent.is_zero() {\n\t\t\titeration_count = 0;\n\t\t} else if exp_length <= 32 {\n\t\t\titeration_count = exponent.bits() - 1;\n\t\t} else if exp_length > 32 {\n\t\t\tlet bytes: [u8; 32] = [0xFF; 32];\n\t\t\tlet max_256_bit_uint = BigUint::from_bytes_be(&bytes);\n\t\t\titeration_count =\n\t\t\t\t(8 * (exp_length - 32)) + exponent.bitand(max_256_bit_uint).bits() - 1;\n\t\t}\n\t\tmax(iteration_count, 1)\n\t}\n\tlet multiplication_complexity = calculate_multiplication_complexity(base_length, mod_length);\n\tlet iteration_count = calculate_iteration_count(exp_length, exponent);\n\tlet gas = max(\n\t\tMIN_GAS_COST,\n\t\tmultiplication_complexity * iteration_count / 3,\n\t);\n\tgas\n}\n\tfn calculate_iteration_count(exp_length: u64, exponent: &BigUint) -> u64 {\n\t\tlet mut iteration_count: u64 = 0;\n\t\tif exp_length <= 32 && exponent.is_zero() {\n\t\t\titeration_count = 0;\n\t\t} else if exp_length <= 32 {\n\t\t\titeration_count = exponent.bits() - 1;\n\t\t} else if exp_length > 32 {\n\t\t\tlet bytes: [u8; 32] = [0xFF; 32];\n\t\t\tlet max_256_bit_uint = BigUint::from_bytes_be(&bytes);\n\t\t\titeration_count =\n\t\t\t\t(8 * (exp_length - 32)) + exponent.bitand(max_256_bit_uint).bits() - 1;\n\t\t}\n\t\tmax(iteration_count, 1)\n\t}\n\tfn calculate_multiplication_complexity(base_length: u64, mod_length: u64) -> u64 {\n\t\tlet max_length = max(base_length, mod_length);\n\t\tlet mut words = max_length / 8;\n\t\tif max_length % 8 > 0 {\n\t\t\twords += 1;\n\t\t}\n\t\twords * words\n\t}\n\tfn execute(\n\t\tinput: &[u8],\n\t\ttarget_gas: Option<u64>,\n\t\t_context: &Context,\n\t\t_is_static: bool,\n\t) -> PrecompileResult {\n\t\tif input.len() < 96 {\n\t\t\treturn Err(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"input must contain at least 96 bytes\".into()),\n\t\t\t});\n\t\t};\n\t\tlet max_size_big = BigUint::from_u32(1024).expect(\"can't create BigUint\");\n\t\tlet mut buf = [0; 32];\n\t\tbuf.copy_from_slice(&input[0..32]);\n\t\tlet base_len_big = BigUint::from_bytes_be(&buf);\n\t\tif base_len_big > max_size_big {\n\t\t\treturn Err(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"unreasonably large base length\".into()),\n\t\t\t});\n\t\t}\n\t\tbuf.copy_from_slice(&input[32..64]);\n\t\tlet exp_len_big = BigUint::from_bytes_be(&buf);\n\t\tif exp_len_big > max_size_big {\n\t\t\treturn Err(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"unreasonably large exponent length\".into()),\n\t\t\t});\n\t\t}\n\t\tbuf.copy_from_slice(&input[64..96]);\n\t\tlet mod_len_big = BigUint::from_bytes_be(&buf);\n\t\tif mod_len_big > max_size_big {\n\t\t\treturn Err(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"unreasonably large modulus length\".into()),\n\t\t\t});\n\t\t}\n\t\tlet base_len = base_len_big.to_usize().expect(\"base_len out of bounds\");\n\t\tlet exp_len = exp_len_big.to_usize().expect(\"exp_len out of bounds\");\n\t\tlet mod_len = mod_len_big.to_usize().expect(\"mod_len out of bounds\");\n\t\tlet total_len = base_len + exp_len + mod_len + 96;\n\t\tif input.len() < total_len {\n\t\t\treturn Err(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"insufficient input size\".into()),\n\t\t\t});\n\t\t}\n\t\tlet (r, gas_cost) = if base_len == 0 && mod_len == 0 {\n\t\t\t(BigUint::zero(), MIN_GAS_COST)\n\t\t} else {\n\t\t\tlet base_start = 96; \n\t\t\tlet base = BigUint::from_bytes_be(&input[base_start..base_start + base_len]);\n\t\t\tlet exp_start = base_start + base_len;\n\t\t\tlet exponent = BigUint::from_bytes_be(&input[exp_start..exp_start + exp_len]);\n\t\t\tlet gas_cost =\n\t\t\t\tcalculate_gas_cost(base_len as u64, exp_len as u64, mod_len as u64, &exponent);\n\t\t\tif let Some(gas_left) = target_gas {\n\t\t\t\tif gas_left < gas_cost {\n\t\t\t\t\treturn Err(PrecompileFailure::Error {\n\t\t\t\t\t\texit_status: ExitError::OutOfGas,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t\tlet mod_start = exp_start + exp_len;\n\t\t\tlet modulus = BigUint::from_bytes_be(&input[mod_start..mod_start + mod_len]);\n\t\t\tif modulus.is_zero() || modulus.is_one() {\n\t\t\t\t(BigUint::zero(), gas_cost)\n\t\t\t} else {\n\t\t\t\t(base.modpow(&exponent, &modulus), gas_cost)\n\t\t\t}\n\t\t};\n\t\tlet bytes = r.to_bytes_be();\n\t\tif bytes.len() == mod_len {\n\t\t\tOk(PrecompileOutput {\n\t\t\t\texit_status: ExitSucceed::Returned,\n\t\t\t\tcost: gas_cost,\n\t\t\t\toutput: bytes.to_vec(),\n\t\t\t\tlogs: Default::default(),\n\t\t\t})\n\t\t} else if bytes.len() < mod_len {\n\t\t\tlet mut ret = Vec::with_capacity(mod_len);\n\t\t\tret.extend(core::iter::repeat(0).take(mod_len - bytes.len()));\n\t\t\tret.extend_from_slice(&bytes[..]);\n\t\t\tOk(PrecompileOutput {\n\t\t\t\texit_status: ExitSucceed::Returned,\n\t\t\t\tcost: gas_cost,\n\t\t\t\toutput: ret.to_vec(),\n\t\t\t\tlogs: Default::default(),\n\t\t\t})\n\t\t} else {\n\t\t\tErr(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"failed\".into()),\n\t\t\t})\n\t\t}\n\t}\n\tfn test_zero_exp_with_33_length() {\n\t\tlet input = vec![\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,\n\t\t];\n\t\tlet cost: u64 = 100000;\n\t\tlet context: Context = Context {\n\t\t\taddress: Default::default(),\n\t\t\tcaller: Default::default(),\n\t\t\tapparent_value: From::from(0),\n\t\t};\n\t\tlet precompile_result = Modexp::execute(&input, Some(cost), &context, false)\n\t\t\t.expect(\"Modexp::execute() returned error\");\n\t\tassert_eq!(precompile_result.output.len(), 1); \n\t\tlet result = BigUint::from_bytes_be(&precompile_result.output[..]);\n\t\tlet expected = BigUint::parse_bytes(b\"0\", 10).unwrap();\n\t\tassert_eq!(result, expected);\n\t}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn emit_muldivmod<E: UserDefinedError>(jit: &mut JitCompiler, opc: u8, src: u8, dst: u8, imm: Option<i64>) -> Result<(), EbpfError<E>> {\n    let mul = (opc & ebpf::BPF_ALU_OP_MASK) == (ebpf::MUL32_IMM & ebpf::BPF_ALU_OP_MASK);\n    let div = (opc & ebpf::BPF_ALU_OP_MASK) == (ebpf::DIV32_IMM & ebpf::BPF_ALU_OP_MASK);\n    let sdiv = (opc & ebpf::BPF_ALU_OP_MASK) == (ebpf::SDIV32_IMM & ebpf::BPF_ALU_OP_MASK);\n    let modrm = (opc & ebpf::BPF_ALU_OP_MASK) == (ebpf::MOD32_IMM & ebpf::BPF_ALU_OP_MASK);\n    let size = if (opc & ebpf::BPF_CLS_MASK) == ebpf::BPF_ALU64 { OperandSize::S64 } else { OperandSize::S32 };\n    let sdiv_anchor =  if sdiv { TARGET_PC_LOCAL_ANCHOR - jit.offset_in_text_section } else { 0 };\n    if (div || sdiv || modrm) && imm.is_none() {\n        X86Instruction::load_immediate(OperandSize::S64, R11, jit.pc as i64).emit(jit)?;\n        X86Instruction::test(size, src, src, None).emit(jit)?; \n        emit_jcc(jit, 0x84, TARGET_PC_DIV_BY_ZERO)?;\n    }\n    if sdiv && imm.unwrap_or(-1) == -1 {\n        if imm.is_none() {\n            X86Instruction::cmp_immediate(size, src, -1, None).emit(jit)?;\n            emit_jcc(jit, 0x85, sdiv_anchor)?;\n        }\n        X86Instruction::load_immediate(size, R11, if size == OperandSize::S64 { i64::MIN } else { i32::MIN as i64 }).emit(jit)?;\n        X86Instruction::cmp(size, dst, R11, None).emit(jit)?;\n        emit_jcc(jit, 0x85, sdiv_anchor)?;\n        X86Instruction::load_immediate(OperandSize::S64, R11, jit.pc as i64).emit(jit)?;\n        emit_jmp(jit, TARGET_PC_DIV_OVERFLOW)?;\n    }\n    if sdiv {\n        set_anchor(jit, sdiv_anchor);\n    }\n    if dst != RAX {\n        X86Instruction::push(RAX, None).emit(jit)?;\n    }\n    if dst != RDX {\n        X86Instruction::push(RDX, None).emit(jit)?;\n    }\n    if let Some(imm) = imm {\n        if should_sanitize_constant(jit, imm) {\n            emit_sanitized_load_immediate(jit, OperandSize::S64, R11, imm)?;\n        } else {\n            X86Instruction::load_immediate(OperandSize::S64, R11, imm).emit(jit)?;\n        }\n    } else {\n        X86Instruction::mov(OperandSize::S64, src, R11).emit(jit)?;\n    }\n    if dst != RAX {\n        X86Instruction::mov(OperandSize::S64, dst, RAX).emit(jit)?;\n    }\n    if div || modrm {\n        emit_alu(jit, size, 0x31, RDX, RDX, 0, None)?;\n    } else if sdiv {\n        X86Instruction {\n            size,\n            opcode: 0x99,\n            modrm: false,\n            ..X86Instruction::default()\n        }.emit(jit)?;\n    }\n    emit_alu(jit, size, 0xf7, if mul { 4 } else if sdiv { 7 } else { 6 }, R11, 0, None)?;\n    if dst != RDX {\n        if modrm {\n            X86Instruction::mov(OperandSize::S64, RDX, dst).emit(jit)?;\n        }\n        X86Instruction::pop(RDX).emit(jit)?;\n    }\n    if dst != RAX {\n        if div || sdiv || mul {\n            X86Instruction::mov(OperandSize::S64, RAX, dst).emit(jit)?;\n        }\n        X86Instruction::pop(RAX).emit(jit)?;\n    }\n    if size == OperandSize::S32 && (mul || sdiv)  {\n        X86Instruction::sign_extend_i32_to_i64(dst, dst).emit(jit)?;\n    }\n    Ok(())\n}\nfn test_sdiv32_neg_imm() {\n    test_interpreter_and_jit_asm!(\n        \"\n        lddw r0, 0x10000000c\n        sdiv32 r0, -4\n        exit\",\n        [],\n        (),\n        0,\n        { |_vm, res: Result| { res.unwrap() as i64 == -3 } },\n        3\n    );\n}\nfn test_sdiv32_neg_reg() {\n    test_interpreter_and_jit_asm!(\n        \"\n        lddw r0, 0x10000000c\n        mov r1, -4\n        sdiv32 r0, r1\n        exit\",\n        [],\n        (),\n        0,\n        { |_vm, res: Result| { res.unwrap() as i64 == -0x3 } },\n        4\n    );\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "  void Compute(OpKernelContext* context) override {\n    const Tensor& rhs = context->input(1);\n    context->forward_ref_input_to_ref_output(0, 0);\n    OP_REQUIRES(\n        context, rhs.IsInitialized(),\n        errors::Internal(\"Right hand side of AssignOp is not initialized\"));\n    AllocatorAttributes attr;\n    if (!relax_constraints_) {\n      attr.set_gpu_compatible(true);\n      attr.set_nic_compatible(true);\n    }\n    {\n      mutex_lock l(*context->input_ref_mutex(0));\n      const Tensor& old_lhs = context->mutable_input(0,  true);\n      const bool same_shape = old_lhs.shape().IsSameSize(rhs.shape());\n      if (validate_shape_) {\n        OP_REQUIRES(context, same_shape,\n                    errors::InvalidArgument(\n                        \"Assign requires shapes of both tensors to match. \"\n                        \"lhs shape= \",\n                        old_lhs.shape().DebugString(),\n                        \" rhs shape= \", rhs.shape().DebugString()));\n      }\n      if (old_lhs.IsInitialized() &&\n          old_lhs.shape().num_elements() == rhs.shape().num_elements()) {\n        Tensor reshaped_old_lhs;\n        if (same_shape) {\n          reshaped_old_lhs = old_lhs;\n        } else {\n          CHECK(reshaped_old_lhs.CopyFrom(old_lhs, rhs.shape()));\n          context->replace_ref_input(0, reshaped_old_lhs,\n                                      true);\n        }\n        if (use_exclusive_lock_) {\n          Copy(context, &reshaped_old_lhs, rhs);\n          return;\n        }\n      } else {\n        std::unique_ptr<Tensor> input_alias = context->forward_input(\n            1, OpKernelContext::Params::kNoReservation ,\n            rhs.dtype(), rhs.shape(), DEVICE_MEMORY, attr);\n        if (input_alias != nullptr) {\n          context->replace_ref_input(0, *input_alias,  true);\n          return;\n        }\n        Tensor copy_tensor;\n        OP_REQUIRES_OK(context,\n                       context->allocate_temp(old_lhs.dtype(), rhs.shape(),\n                                              &copy_tensor, attr));\n        context->clear_recorded_memory();\n        context->replace_ref_input(0, copy_tensor,  true);\n        if (use_exclusive_lock_) {\n          Copy(context, &copy_tensor, rhs);\n          return;\n        }\n      }\n    }\n    Tensor old_unlocked_lhs = context->mutable_input(0,  false);\n    Copy(context, &old_unlocked_lhs, rhs);\n  }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn fetch_add(&self, val: $t) -> $t {\n                if can_transmute::<$t, $atomic>() {\n                    let a = unsafe { &*(self.value.get() as *const $atomic) };\n                    a.fetch_add(val, Ordering::AcqRel)\n                } else {\n                    #[cfg(crossbeam_loom)]\n                    {\n                        let _ = val;\n                        unimplemented!(\"loom does not support non-atomic atomic ops\");\n                    }\n                    #[cfg(not(crossbeam_loom))]\n                    {\n                        let _guard = lock(self.value.get() as usize).write();\n                        let value = unsafe { &mut *(self.value.get()) };\n                        let old = *value;\n                        *value = value.wrapping_add(val);\n                        old\n                    }\n                }\n            }\npub fn fetch_sub(&self, val: $t) -> $t {\n                if can_transmute::<$t, $atomic>() {\n                    let a = unsafe { &*(self.value.get() as *const $atomic) };\n                    a.fetch_sub(val, Ordering::AcqRel)\n                } else {\n                    #[cfg(crossbeam_loom)]\n                    {\n                        let _ = val;\n                        unimplemented!(\"loom does not support non-atomic atomic ops\");\n                    }\n                    #[cfg(not(crossbeam_loom))]\n                    {\n                        let _guard = lock(self.value.get() as usize).write();\n                        let value = unsafe { &mut *(self.value.get()) };\n                        let old = *value;\n                        *value = value.wrapping_sub(val);\n                        old\n                    }\n                }\n            }\npub fn fetch_and(&self, val: $t) -> $t {\n                if can_transmute::<$t, $atomic>() {\n                    let a = unsafe { &*(self.value.get() as *const $atomic) };\n                    a.fetch_and(val, Ordering::AcqRel)\n                } else {\n                    #[cfg(crossbeam_loom)]\n                    {\n                        let _ = val;\n                        unimplemented!(\"loom does not support non-atomic atomic ops\");\n                    }\n                    #[cfg(not(crossbeam_loom))]\n                    {\n                        let _guard = lock(self.value.get() as usize).write();\n                        let value = unsafe { &mut *(self.value.get()) };\n                        let old = *value;\n                        *value &= val;\n                        old\n                    }\n                }\n            }\npub fn fetch_or(&self, val: $t) -> $t {\n                if can_transmute::<$t, $atomic>() {\n                    let a = unsafe { &*(self.value.get() as *const $atomic) };\n                    a.fetch_or(val, Ordering::AcqRel)\n                } else {\n                    #[cfg(crossbeam_loom)]\n                    {\n                        let _ = val;\n                        unimplemented!(\"loom does not support non-atomic atomic ops\");\n                    }\n                    #[cfg(not(crossbeam_loom))]\n                    {\n                        let _guard = lock(self.value.get() as usize).write();\n                        let value = unsafe { &mut *(self.value.get()) };\n                        let old = *value;\n                        *value |= val;\n                        old\n                    }\n                }\n            }\npub fn fetch_xor(&self, val: $t) -> $t {\n                if can_transmute::<$t, $atomic>() {\n                    let a = unsafe { &*(self.value.get() as *const $atomic) };\n                    a.fetch_xor(val, Ordering::AcqRel)\n                } else {\n                    #[cfg(crossbeam_loom)]\n                    {\n                        let _ = val;\n                        unimplemented!(\"loom does not support non-atomic atomic ops\");\n                    }\n                    #[cfg(not(crossbeam_loom))]\n                    {\n                        let _guard = lock(self.value.get() as usize).write();\n                        let value = unsafe { &mut *(self.value.get()) };\n                        let old = *value;\n                        *value ^= val;\n                        old\n                    }\n                }\n            }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "    fn c(&mut self, expr: &Hir) -> ResultOrEmpty {\n        use crate::prog;\n        use regex_syntax::hir::HirKind::*;\n        self.check_size()?;\n        match *expr.kind() {\n            Empty => self.c_empty(),\n            Literal(hir::Literal::Unicode(c)) => self.c_char(c),\n            Literal(hir::Literal::Byte(b)) => {\n                assert!(self.compiled.uses_bytes());\n                self.c_byte(b)\n            }\n            Class(hir::Class::Unicode(ref cls)) => self.c_class(cls.ranges()),\n            Class(hir::Class::Bytes(ref cls)) => {\n                if self.compiled.uses_bytes() {\n                    self.c_class_bytes(cls.ranges())\n                } else {\n                    assert!(cls.is_all_ascii());\n                    let mut char_ranges = vec![];\n                    for r in cls.iter() {\n                        let (s, e) = (r.start() as char, r.end() as char);\n                        char_ranges.push(hir::ClassUnicodeRange::new(s, e));\n                    }\n                    self.c_class(&char_ranges)\n                }\n            }\n            Anchor(hir::Anchor::StartLine) if self.compiled.is_reverse => {\n                self.byte_classes.set_range(b'\\n', b'\\n');\n                self.c_empty_look(prog::EmptyLook::EndLine)\n            }\n            Anchor(hir::Anchor::StartLine) => {\n                self.byte_classes.set_range(b'\\n', b'\\n');\n                self.c_empty_look(prog::EmptyLook::StartLine)\n            }\n            Anchor(hir::Anchor::EndLine) if self.compiled.is_reverse => {\n                self.byte_classes.set_range(b'\\n', b'\\n');\n                self.c_empty_look(prog::EmptyLook::StartLine)\n            }\n            Anchor(hir::Anchor::EndLine) => {\n                self.byte_classes.set_range(b'\\n', b'\\n');\n                self.c_empty_look(prog::EmptyLook::EndLine)\n            }\n            Anchor(hir::Anchor::StartText) if self.compiled.is_reverse => {\n                self.c_empty_look(prog::EmptyLook::EndText)\n            }\n            Anchor(hir::Anchor::StartText) => {\n                self.c_empty_look(prog::EmptyLook::StartText)\n            }\n            Anchor(hir::Anchor::EndText) if self.compiled.is_reverse => {\n                self.c_empty_look(prog::EmptyLook::StartText)\n            }\n            Anchor(hir::Anchor::EndText) => {\n                self.c_empty_look(prog::EmptyLook::EndText)\n            }\n            WordBoundary(hir::WordBoundary::Unicode) => {\n                if !cfg!(feature = \"unicode-perl\") {\n                    return Err(Error::Syntax(\n                        \"Unicode word boundaries are unavailable when \\\n                         the unicode-perl feature is disabled\"\n                            .to_string(),\n                    ));\n                }\n                self.compiled.has_unicode_word_boundary = true;\n                self.byte_classes.set_word_boundary();\n                self.byte_classes.set_range(0, 0x7F);\n                self.c_empty_look(prog::EmptyLook::WordBoundary)\n            }\n            WordBoundary(hir::WordBoundary::UnicodeNegate) => {\n                if !cfg!(feature = \"unicode-perl\") {\n                    return Err(Error::Syntax(\n                        \"Unicode word boundaries are unavailable when \\\n                         the unicode-perl feature is disabled\"\n                            .to_string(),\n                    ));\n                }\n                self.compiled.has_unicode_word_boundary = true;\n                self.byte_classes.set_word_boundary();\n                self.byte_classes.set_range(0, 0x7F);\n                self.c_empty_look(prog::EmptyLook::NotWordBoundary)\n            }\n            WordBoundary(hir::WordBoundary::Ascii) => {\n                self.byte_classes.set_word_boundary();\n                self.c_empty_look(prog::EmptyLook::WordBoundaryAscii)\n            }\n            WordBoundary(hir::WordBoundary::AsciiNegate) => {\n                self.byte_classes.set_word_boundary();\n                self.c_empty_look(prog::EmptyLook::NotWordBoundaryAscii)\n            }\n            Group(ref g) => match g.kind {\n                hir::GroupKind::NonCapturing => self.c(&g.hir),\n                hir::GroupKind::CaptureIndex(index) => {\n                    if index as usize >= self.compiled.captures.len() {\n                        self.compiled.captures.push(None);\n                    }\n                    self.c_capture(2 * index as usize, &g.hir)\n                }\n                hir::GroupKind::CaptureName { index, ref name } => {\n                    if index as usize >= self.compiled.captures.len() {\n                        let n = name.to_string();\n                        self.compiled.captures.push(Some(n.clone()));\n                        self.capture_name_idx.insert(n, index as usize);\n                    }\n                    self.c_capture(2 * index as usize, &g.hir)\n                }\n            },\n            Concat(ref es) => {\n                if self.compiled.is_reverse {\n                    self.c_concat(es.iter().rev())\n                } else {\n                    self.c_concat(es)\n                }\n            }\n            Alternation(ref es) => self.c_alternate(&**es),\n            Repetition(ref rep) => self.c_repeat(rep),\n        }\n    }\n    fn c_empty(&mut self) -> ResultOrEmpty {\n        self.extra_inst_bytes += std::mem::size_of::<Inst>();\n        Ok(None)\n    }\nfn big_empty_regex_fails() {\n    use regex::Regex;\n    let result = Regex::new(\"(?:){4294967295}\");\n    assert!(result.is_err());\n}\nfn big_empty_reps_chain_regex_fails() {\n    use regex::Regex;\n    let result = Regex::new(\"(?:){64}{64}{64}{64}{64}{64}\");\n    assert!(result.is_err());\n}\nfn big_zero_reps_regex_fails() {\n    use regex::Regex;\n    let result = Regex::new(r\"x{0}{4294967295}\");\n    assert!(result.is_err());\n}\nfn empty_alt_regex_fails() {\n    use regex::Regex;\n    let result = Regex::new(r\"(?:|){4294967295}\");\n    assert!(result.is_err());\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "    pub fn emit(\n        &self,\n    ) -> (\n        MachBuffer<I>,\n        Vec<CodeOffset>,\n        Vec<(CodeOffset, CodeOffset)>,\n    )\n    where\n        I: MachInstEmit,\n    {\n        let _tt = timing::vcode_emit();\n        let mut buffer = MachBuffer::new();\n        let mut state = I::State::new(&*self.abi);\n        let cfg_metadata = self.flags().machine_code_cfg_info();\n        let mut bb_starts: Vec<Option<CodeOffset>> = vec![];\n        buffer.reserve_labels_for_blocks(self.num_blocks() as BlockIndex);\n        buffer.reserve_labels_for_constants(&self.constants);\n        let mut inst_end_offsets = vec![0; self.insts.len()];\n        let mut label_inst_indices = vec![0; self.num_blocks()];\n        let mut safepoint_indices: FxHashMap<u32, usize> = FxHashMap::default();\n        for (safepoint_idx, iix) in self.safepoint_insns.iter().enumerate() {\n            if self.safepoint_slots[safepoint_idx].len() > 0 {\n                safepoint_indices.insert(*iix, safepoint_idx);\n            }\n        }\n        let mut final_order: SmallVec<[BlockIndex; 16]> = smallvec![];\n        let mut cold_blocks: SmallVec<[BlockIndex; 16]> = smallvec![];\n        for block in 0..self.num_blocks() {\n            let block = block as BlockIndex;\n            if self.block_order.is_cold(block) {\n                cold_blocks.push(block);\n            } else {\n                final_order.push(block);\n            }\n        }\n        let first_cold_block = cold_blocks.first().cloned();\n        final_order.extend(cold_blocks.clone());\n        let mut cur_srcloc = None;\n        let mut last_offset = None;\n        let mut start_of_cold_code = None;\n        for block in final_order {\n            let new_offset = I::align_basic_block(buffer.cur_offset());\n            while new_offset > buffer.cur_offset() {\n                let nop = I::gen_nop((new_offset - buffer.cur_offset()) as usize);\n                nop.emit(&mut buffer, &self.emit_info, &mut Default::default());\n            }\n            assert_eq!(buffer.cur_offset(), new_offset);\n            if Some(block) == first_cold_block {\n                start_of_cold_code = Some(buffer.cur_offset());\n            }\n            let (start, end) = self.block_ranges[block as usize];\n            buffer.bind_label(MachLabel::from_block(block));\n            label_inst_indices[block as usize] = start;\n            if cfg_metadata {\n                let cur_offset = buffer.cur_offset();\n                if last_offset.is_some() && cur_offset <= last_offset.unwrap() {\n                    for i in (0..bb_starts.len()).rev() {\n                        if bb_starts[i].is_some() && cur_offset > bb_starts[i].unwrap() {\n                            break;\n                        }\n                        bb_starts[i] = None;\n                    }\n                }\n                bb_starts.push(Some(cur_offset));\n                last_offset = Some(cur_offset);\n            }\n            for iix in start..end {\n                let srcloc = self.srclocs[iix as usize];\n                if cur_srcloc != Some(srcloc) {\n                    if cur_srcloc.is_some() {\n                        buffer.end_srcloc();\n                    }\n                    buffer.start_srcloc(srcloc);\n                    cur_srcloc = Some(srcloc);\n                }\n                state.pre_sourceloc(cur_srcloc.unwrap_or(SourceLoc::default()));\n                if let Some(safepoint_idx) = safepoint_indices.get(&iix) {\n                    let stack_map = self\n                        .abi\n                        .spillslots_to_stack_map(&self.safepoint_slots[*safepoint_idx][..], &state);\n                    state.pre_safepoint(stack_map);\n                }\n                self.insts[iix as usize].emit(&mut buffer, &self.emit_info, &mut state);\n                if self.generate_debug_info {\n                    let l = &mut inst_end_offsets[0..iix as usize];\n                    for end in l.iter_mut().rev() {\n                        if *end > buffer.cur_offset() {\n                            *end = buffer.cur_offset();\n                        } else {\n                            break;\n                        }\n                    }\n                    inst_end_offsets[iix as usize] = buffer.cur_offset();\n                }\n            }\n            if cur_srcloc.is_some() {\n                buffer.end_srcloc();\n                cur_srcloc = None;\n            }\n            if block < (self.num_blocks() - 1) as BlockIndex {\n                let next_block = block + 1;\n                let next_block_range = self.block_ranges[next_block as usize];\n                let next_block_size = next_block_range.1 - next_block_range.0;\n                let worst_case_next_bb = I::worst_case_size() * next_block_size;\n                if buffer.island_needed(worst_case_next_bb) {\n                    buffer.emit_island(worst_case_next_bb);\n                }\n            }\n        }\n        for (constant, data) in self.constants.iter() {\n            let label = buffer.get_label_for_constant(constant);\n            buffer.defer_constant(label, data.alignment(), data.as_slice(), u32::max_value());\n        }\n        if self.generate_debug_info {\n            for end in inst_end_offsets.iter_mut().rev() {\n                if *end > buffer.cur_offset() {\n                    *end = buffer.cur_offset();\n                } else {\n                    break;\n                }\n            }\n            *self.insts_layout.borrow_mut() = InstsLayoutInfo {\n                inst_end_offsets,\n                label_inst_indices,\n                start_of_cold_code,\n            };\n        }\n        let mut final_bb_starts = vec![];\n        let mut bb_edges = vec![];\n        if cfg_metadata {\n            for block in 0..self.num_blocks() {\n                if bb_starts[block].is_none() {\n                    continue;\n                }\n                let from = bb_starts[block].unwrap();\n                final_bb_starts.push(from);\n                let succs = self.block_succs(BlockIx::new(block as u32));\n                for succ in succs.iter() {\n                    let to = buffer.resolve_label_offset(MachLabel::from_block(succ.get()));\n                    bb_edges.push((from, to));\n                }\n            }\n        }\n        (buffer, final_bb_starts, bb_edges)\n    }\nfn pass_funcref_in_and_out_of_wasm() -> anyhow::Result<()> {\n    let (mut store, module) = ref_types_module(\n        false,\n        r#\"\n            (module\n                (func (export \"func\") (param funcref) (result funcref)\n                    local.get 0\n                )\n            )\n        \"#,\n    )?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let func = instance.get_func(&mut store, \"func\").unwrap();\n    {\n        let mut results = [Val::I32(0)];\n        func.call(\n            &mut store,\n            &[Val::FuncRef(Some(func.clone()))],\n            &mut results,\n        )?;\n        let result_func = results[0].unwrap_funcref().unwrap();\n        assert_eq!(func.ty(&store), result_func.ty(&store));\n    }\n    {\n        let mut results = [Val::I32(0)];\n        func.call(&mut store, &[Val::FuncRef(None)], &mut results)?;\n        let result_func = results[0].unwrap_funcref();\n        assert!(result_func.is_none());\n    }\n    {\n        let other_instance = Instance::new(&mut store, &module, &[])?;\n        let other_instance_func = other_instance.get_func(&mut store, \"func\").unwrap();\n        let mut results = [Val::I32(0)];\n        func.call(\n            &mut store,\n            &[Val::FuncRef(Some(other_instance_func.clone()))],\n            &mut results,\n        )?;\n        assert_eq!(results.len(), 1);\n        let result_func = results[0].unwrap_funcref().unwrap();\n        assert_eq!(other_instance_func.ty(&store), result_func.ty(&store));\n    }\n    {\n        let (mut other_store, other_module) =\n            ref_types_module(false, r#\"(module (func (export \"f\")))\"#)?;\n        let other_store_instance = Instance::new(&mut other_store, &other_module, &[])?;\n        let f = other_store_instance\n            .get_func(&mut other_store, \"f\")\n            .unwrap();\n        assert!(func\n            .call(&mut store, &[Val::FuncRef(Some(f))], &mut [Val::I32(0)])\n            .is_err());\n    }\n    Ok(())\n}\nfn receive_null_funcref_from_wasm() -> anyhow::Result<()> {\n    let (mut store, module) = ref_types_module(\n        false,\n        r#\"\n            (module\n                (func (export \"get-null\") (result funcref)\n                    ref.null func\n                )\n            )\n        \"#,\n    )?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let get_null = instance.get_func(&mut store, \"get-null\").unwrap();\n    let mut results = [Val::I32(0)];\n    get_null.call(&mut store, &[], &mut results)?;\n    let result_func = results[0].unwrap_funcref();\n    assert!(result_func.is_none());\n    Ok(())\n}\nfn drop_externref_via_table_set() -> anyhow::Result<()> {\n    let (mut store, module) = ref_types_module(\n        false,\n        r#\"\n            (module\n                (table $t 1 externref)\n                (func (export \"table-set\") (param externref)\n                  (table.set $t (i32.const 0) (local.get 0))\n                )\n            )\n        \"#,\n    )?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let table_set = instance.get_func(&mut store, \"table-set\").unwrap();\n    let foo_is_dropped = Arc::new(AtomicBool::new(false));\n    let bar_is_dropped = Arc::new(AtomicBool::new(false));\n    let foo = ExternRef::new(SetFlagOnDrop(foo_is_dropped.clone()));\n    let bar = ExternRef::new(SetFlagOnDrop(bar_is_dropped.clone()));\n    {\n        let args = vec![Val::ExternRef(Some(foo))];\n        table_set.call(&mut store, &args, &mut [])?;\n    }\n    store.gc();\n    assert!(!foo_is_dropped.load(SeqCst));\n    assert!(!bar_is_dropped.load(SeqCst));\n    {\n        let args = vec![Val::ExternRef(Some(bar))];\n        table_set.call(&mut store, &args, &mut [])?;\n    }\n    store.gc();\n    assert!(foo_is_dropped.load(SeqCst));\n    assert!(!bar_is_dropped.load(SeqCst));\n    table_set.call(&mut store, &[Val::ExternRef(None)], &mut [])?;\n    assert!(foo_is_dropped.load(SeqCst));\n    assert!(bar_is_dropped.load(SeqCst));\n    Ok(())\n}\nfn global_init_no_leak() -> anyhow::Result<()> {\n    let (mut store, module) = ref_types_module(\n        false,\n        r#\"\n            (module\n                (import \"\" \"\" (global externref))\n                (global externref (global.get 0))\n            )\n        \"#,\n    )?;\n    let externref = ExternRef::new(());\n    let global = Global::new(\n        &mut store,\n        GlobalType::new(ValType::ExternRef, Mutability::Const),\n        externref.clone().into(),\n    )?;\n    Instance::new(&mut store, &module, &[global.into()])?;\n    drop(store);\n    assert_eq!(externref.strong_count(), 1);\n    Ok(())\n}\nfn many_live_refs() -> anyhow::Result<()> {\n    let mut wat = r#\"\n        (module\n            ;; Make new `externref`s.\n            (import \"\" \"make_ref\" (func $make_ref (result externref)))\n            ;; Observe an `externref` so it is kept live.\n            (import \"\" \"observe_ref\" (func $observe_ref (param externref)))\n            (func (export \"many_live_refs\")\n    \"#\n    .to_string();\n    const NUM_LIVE_REFS: usize = 1024;\n    for _ in 0..NUM_LIVE_REFS {\n        wat.push_str(\"(call $make_ref)\\n\");\n    }\n    for _ in 0..NUM_LIVE_REFS {\n        wat.push_str(\"(call $observe_ref)\\n\");\n    }\n    wat.push_str(\n        \"\n            ) ;; func\n        ) ;; module\n        \",\n    );\n    let (mut store, module) = ref_types_module(false, &wat)?;\n    let live_refs = Arc::new(AtomicUsize::new(0));\n    let make_ref = Func::wrap(&mut store, {\n        let live_refs = live_refs.clone();\n        move || Some(ExternRef::new(CountLiveRefs::new(live_refs.clone())))\n    });\n    let observe_ref = Func::wrap(&mut store, |r: Option<ExternRef>| {\n        let r = r.unwrap();\n        let r = r.data().downcast_ref::<CountLiveRefs>().unwrap();\n        assert!(r.live_refs.load(SeqCst) > 0);\n    });\n    let instance = Instance::new(&mut store, &module, &[make_ref.into(), observe_ref.into()])?;\n    let many_live_refs = instance.get_func(&mut store, \"many_live_refs\").unwrap();\n    many_live_refs.call(&mut store, &[], &mut [])?;\n    store.gc();\n    assert_eq!(live_refs.load(SeqCst), 0);\n    return Ok(());\n    struct CountLiveRefs {\n        live_refs: Arc<AtomicUsize>,\n    }\n    impl CountLiveRefs {\n        fn new(live_refs: Arc<AtomicUsize>) -> Self {\n            live_refs.fetch_add(1, SeqCst);\n            Self { live_refs }\n        }\n    }\n    impl Drop for CountLiveRefs {\n        fn drop(&mut self) {\n            self.live_refs.fetch_sub(1, SeqCst);\n        }\n    }\n}\nfn no_gc_middle_of_args() -> anyhow::Result<()> {\n    let (mut store, module) = ref_types_module(\n        false,\n        r#\"\n            (module\n                (import \"\" \"return_some\" (func $return (result externref externref externref)))\n                (import \"\" \"take_some\" (func $take (param externref externref externref)))\n                (func (export \"run\")\n                    (local i32)\n                    i32.const 1000\n                    local.set 0\n                    loop\n                        call $return\n                        call $take\n                        local.get 0\n                        i32.const -1\n                        i32.add\n                        local.tee 0\n                        br_if 0\n                    end\n                )\n            )\n        \"#,\n    )?;\n    let mut linker = Linker::new(store.engine());\n    linker.func_wrap(\"\", \"return_some\", || {\n        (\n            Some(ExternRef::new(\"a\".to_string())),\n            Some(ExternRef::new(\"b\".to_string())),\n            Some(ExternRef::new(\"c\".to_string())),\n        )\n    })?;\n    linker.func_wrap(\n        \"\",\n        \"take_some\",\n        |a: Option<ExternRef>, b: Option<ExternRef>, c: Option<ExternRef>| {\n            let a = a.unwrap();\n            let b = b.unwrap();\n            let c = c.unwrap();\n            assert_eq!(a.data().downcast_ref::<String>().unwrap(), \"a\");\n            assert_eq!(b.data().downcast_ref::<String>().unwrap(), \"b\");\n            assert_eq!(c.data().downcast_ref::<String>().unwrap(), \"c\");\n        },\n    )?;\n    let instance = linker.instantiate(&mut store, &module)?;\n    let func = instance.get_typed_func::<(), (), _>(&mut store, \"run\")?;\n    func.call(&mut store, ())?;\n    Ok(())\n}\nfn smoke_test_gc() -> anyhow::Result<()> {\n    smoke_test_gc_impl(false)\n}\nfn smoke_test_gc_epochs() -> anyhow::Result<()> {\n    smoke_test_gc_impl(true)\n}\nfn smoke_test_gc_impl(use_epochs: bool) -> anyhow::Result<()> {\n    let (mut store, module) = ref_types_module(\n        use_epochs,\n        r#\"\n            (module\n                (import \"\" \"\" (func $do_gc))\n                (func $recursive (export \"func\") (param i32 externref) (result externref)\n                    local.get 0\n                    i32.eqz\n                    if (result externref)\n                        call $do_gc\n                        local.get 1\n                    else\n                        local.get 0\n                        i32.const 1\n                        i32.sub\n                        local.get 1\n                        call $recursive\n                    end\n                )\n            )\n        \"#,\n    )?;\n    let do_gc = Func::wrap(&mut store, |mut caller: Caller<'_, _>| {\n        caller.gc();\n    });\n    let instance = Instance::new(&mut store, &module, &[do_gc.into()])?;\n    let func = instance.get_func(&mut store, \"func\").unwrap();\n    let inner_dropped = Arc::new(AtomicBool::new(false));\n    let r = ExternRef::new(SetFlagOnDrop(inner_dropped.clone()));\n    {\n        let args = [Val::I32(5), Val::ExternRef(Some(r.clone()))];\n        func.call(&mut store, &args, &mut [Val::I32(0)])?;\n    }\n    assert!(r.strong_count() >= 2);\n    store.gc();\n    assert_eq!(r.strong_count(), 1);\n    drop(r);\n    assert!(inner_dropped.load(SeqCst));\n    Ok(())\n}\nfn wasm_dropping_refs() -> anyhow::Result<()> {\n    let (mut store, module) = ref_types_module(\n        false,\n        r#\"\n            (module\n                (func (export \"drop_ref\") (param externref)\n                    nop\n                )\n            )\n        \"#,\n    )?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let drop_ref = instance.get_func(&mut store, \"drop_ref\").unwrap();\n    let num_refs_dropped = Arc::new(AtomicUsize::new(0));\n    for _ in 0..4096 {\n        let r = ExternRef::new(CountDrops(num_refs_dropped.clone()));\n        let args = [Val::ExternRef(Some(r))];\n        drop_ref.call(&mut store, &args, &mut [])?;\n    }\n    assert!(num_refs_dropped.load(SeqCst) > 0);\n    store.gc();\n    assert_eq!(num_refs_dropped.load(SeqCst), 4096);\n    return Ok(());\n    struct CountDrops(Arc<AtomicUsize>);\n    impl Drop for CountDrops {\n        fn drop(&mut self) {\n            self.0.fetch_add(1, SeqCst);\n        }\n    }\n}\npub(crate) fn ref_types_module(\n    use_epochs: bool,\n    source: &str,\n) -> anyhow::Result<(wasmtime::Store<()>, wasmtime::Module)> {\n    use wasmtime::*;\n    let _ = env_logger::try_init();\n    let mut config = Config::new();\n    config.wasm_reference_types(true);\n    if use_epochs {\n        config.epoch_interruption(true);\n    }\n    let engine = Engine::new(&config)?;\n    let mut store = Store::new(&engine, ());\n    if use_epochs {\n        store.set_epoch_deadline(1);\n    }\n    let module = Module::new(&engine, source)?;\n    Ok((store, module))\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "static int somfy_iohc_decode(r_device *decoder, bitbuffer_t *bitbuffer)\n{\n    uint8_t const preamble_pattern[] = {0x57, 0xfd, 0x99};\n    uint8_t b[19 + 15]; \n    if (bitbuffer->num_rows != 1)\n        return DECODE_ABORT_EARLY;\n    unsigned offset = bitbuffer_search(bitbuffer, 0, 0, preamble_pattern, 24) + 24;\n    if (offset + 19 * 10 >= bitbuffer->bits_per_row[0])\n        return DECODE_ABORT_EARLY;\n    unsigned num_bits = bitbuffer->bits_per_row[0] - offset;\n    num_bits = MIN(num_bits, sizeof (b) * 8);\n    int len = extract_bytes_uart(bitbuffer->bb[0], offset, num_bits, b);\n    if (len < 19)\n        return DECODE_ABORT_LENGTH;\n    if ((b[0] & 0xf0) != 0xf0)\n        return DECODE_ABORT_EARLY;\n    int msg_len = b[0] & 0xf; \n    if (len < 19 + msg_len)\n        return DECODE_ABORT_LENGTH;\n    if (crc16lsb(b, len, 0x8408, 0x0000) != 0) \n        return DECODE_FAIL_MIC;\n    bitrow_printf(b, len * 8, \"%s: offset %u, num_bits %u, len %d, msg_len %d\\n\", __func__, offset, num_bits, len, msg_len);\n    int msg_type = (b[0]);\n    int dst_id   = ((unsigned)b[4] << 24) | (b[3] << 16) | (b[2] << 8) | (b[1]); \n    int src_id   = ((unsigned)b[8] << 24) | (b[7] << 16) | (b[6] << 8) | (b[5]); \n    int counter  = (b[len - 10] << 8) | (b[len - 9]);\n    char msg_str[15 * 2 + 1];\n    bitrow_snprint(&b[9], msg_len * 8, msg_str, 15 * 2 + 1);\n    char mac_str[13];\n    bitrow_snprint(&b[len - 8], 6 * 8, mac_str, 13);\n    data_t *data = data_make(\n            \"model\",            \"\",                 DATA_STRING, \"Somfy-IOHC\",\n            \"id\",               \"\",                 DATA_FORMAT, \"%08x\", DATA_INT, src_id,\n            \"dst_id\",           \"Dest ID\",          DATA_FORMAT, \"%08x\", DATA_INT, dst_id,\n            \"msg_type\",         \"Msg type\",         DATA_FORMAT, \"%02x\", DATA_INT, msg_type,\n            \"msg\",              \"Message\",          DATA_STRING, msg_str,\n            \"counter\",          \"Counter\",          DATA_INT,    counter,\n            \"mac\",              \"MAC\",              DATA_STRING, mac_str,\n            \"mic\",              \"Integrity\",        DATA_STRING, \"CRC\",\n            NULL);\n    decoder_output_data(decoder, data);\n    return 1;\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "static int somfy_iohc_decode(r_device *decoder, bitbuffer_t *bitbuffer)\n{\n    uint8_t const preamble_pattern[] = {0x57, 0xfd, 0x99};\n    uint8_t b[19 + 15]; \n    if (bitbuffer->num_rows != 1)\n        return DECODE_ABORT_EARLY;\n    unsigned offset = bitbuffer_search(bitbuffer, 0, 0, preamble_pattern, 24) + 24;\n    if (offset + 19 * 10 >= bitbuffer->bits_per_row[0])\n        return DECODE_ABORT_EARLY;\n    unsigned num_bits = bitbuffer->bits_per_row[0] - offset;\n    num_bits = MIN(num_bits, sizeof (b) * 8);\n    int len = extract_bytes_uart(bitbuffer->bb[0], offset, num_bits, b);\n    if (len < 19)\n        return DECODE_ABORT_LENGTH;\n    if ((b[0] & 0xf0) != 0xf0)\n        return DECODE_ABORT_EARLY;\n    int msg_len = b[0] & 0xf; \n    if (len < 19 + msg_len)\n        return DECODE_ABORT_LENGTH;\n    if (crc16lsb(b, len, 0x8408, 0x0000) != 0) \n        return DECODE_FAIL_MIC;\n    bitrow_printf(b, len * 8, \"%s: offset %u, num_bits %u, len %d, msg_len %d\\n\", __func__, offset, num_bits, len, msg_len);\n    int msg_type = (b[0]);\n    int dst_id   = ((unsigned)b[4] << 24) | (b[3] << 16) | (b[2] << 8) | (b[1]); \n    int src_id   = ((unsigned)b[8] << 24) | (b[7] << 16) | (b[6] << 8) | (b[5]); \n    int counter  = (b[len - 10] << 8) | (b[len - 9]);\n    char msg_str[15 * 2 + 1];\n    bitrow_snprint(&b[9], msg_len * 8, msg_str, 15 * 2 + 1);\n    char mac_str[13];\n    bitrow_snprint(&b[len - 8], 6 * 8, mac_str, 13);\n    data_t *data = data_make(\n            \"model\",            \"\",                 DATA_STRING, \"Somfy-IOHC\",\n            \"id\",               \"\",                 DATA_FORMAT, \"%08x\", DATA_INT, src_id,\n            \"dst_id\",           \"Dest ID\",          DATA_FORMAT, \"%08x\", DATA_INT, dst_id,\n            \"msg_type\",         \"Msg type\",         DATA_FORMAT, \"%02x\", DATA_INT, msg_type,\n            \"msg\",              \"Message\",          DATA_STRING, msg_str,\n            \"counter\",          \"Counter\",          DATA_INT,    counter,\n            \"mac\",              \"MAC\",              DATA_STRING, mac_str,\n            \"mic\",              \"Integrity\",        DATA_STRING, \"CRC\",\n            NULL);\n    decoder_output_data(decoder, data);\n    return 1;\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "async fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let args = set_command_line_args().get_matches();\n    let invoking_uid = env::var(\"PKEXEC_UID\").unwrap().parse::<u32>().unwrap();\n    env::set_var(\"RUST_LOG\", \"swhkd=warn\");\n    if args.is_present(\"debug\") {\n        env::set_var(\"RUST_LOG\", \"swhkd=trace\");\n    }\n    env_logger::init();\n    log::trace!(\"Logger initialized.\");\n    let pidfile: String = String::from(format!(\"/etc/swhkd/runtime/swhkd_{}.pid\", invoking_uid));\n    if Path::new(&pidfile).exists() {\n        log::trace!(\"Reading {} file and checking for running instances.\", pidfile);\n        let swhkd_pid = match fs::read_to_string(&pidfile) {\n            Ok(swhkd_pid) => swhkd_pid,\n            Err(e) => {\n                log::error!(\"Unable to read {} to check all running instances\", e);\n                exit(1);\n            }\n        };\n        log::debug!(\"Previous PID: {}\", swhkd_pid);\n        let mut sys = System::new_all();\n        sys.refresh_all();\n        for (pid, process) in sys.processes() {\n            if pid.to_string() == swhkd_pid && process.exe() == env::current_exe().unwrap() {\n                log::error!(\"Swhkd is already running!\");\n                log::error!(\"pid of existing swhkd process: {}\", pid.to_string());\n                log::error!(\"To close the existing swhkd process, run `sudo killall swhkd`\");\n                exit(1);\n            }\n        }\n    }\n    match fs::write(&pidfile, id().to_string()) {\n        Ok(_) => {}\n        Err(e) => {\n            log::error!(\"Unable to write to {}: {}\", pidfile, e);\n            exit(1);\n        }\n    }\n    if check_user_permissions().is_err() {\n        exit(1);\n    }\n    let load_config = || {\n        seteuid(invoking_uid); \n        let config_file_path: std::path::PathBuf = if args.is_present(\"config\") {\n            Path::new(args.value_of(\"config\").unwrap()).to_path_buf()\n        } else {\n            fetch_xdg_config_path()\n        };\n        log::debug!(\"Using config file path: {:#?}\", config_file_path);\n        let hotkeys = match config::load(&config_file_path) {\n            Err(e) => {\n                log::error!(\"Config Error: {}\", e);\n                exit(1);\n            }\n            Ok(out) => out,\n        };\n        for hotkey in &hotkeys {\n            log::debug!(\"hotkey: {:#?}\", hotkey);\n        }\n        hotkeys\n    };\n    let mut hotkeys = load_config();\n    seteuid(0); \n    log::trace!(\"Attempting to find all keyboard file descriptors.\");\n    let keyboard_devices: Vec<Device> =\n        evdev::enumerate().filter(check_device_is_keyboard).collect();\n    let mut uinput_device = match uinput::create_uinput_device() {\n        Ok(dev) => dev,\n        Err(e) => {\n            log::error!(\"Err: {:#?}\", e);\n            exit(1);\n        }\n    };\n    if keyboard_devices.is_empty() {\n        log::error!(\"No valid keyboard device was detected!\");\n        exit(1);\n    }\n    log::debug!(\"{} Keyboard device(s) detected.\", keyboard_devices.len());\n    let modifiers_map: HashMap<Key, config::Modifier> = HashMap::from([\n        (Key::KEY_LEFTMETA, config::Modifier::Super),\n        (Key::KEY_RIGHTMETA, config::Modifier::Super),\n        (Key::KEY_LEFTMETA, config::Modifier::Super),\n        (Key::KEY_RIGHTMETA, config::Modifier::Super),\n        (Key::KEY_LEFTALT, config::Modifier::Alt),\n        (Key::KEY_RIGHTALT, config::Modifier::Alt),\n        (Key::KEY_LEFTCTRL, config::Modifier::Control),\n        (Key::KEY_RIGHTCTRL, config::Modifier::Control),\n        (Key::KEY_LEFTSHIFT, config::Modifier::Shift),\n        (Key::KEY_RIGHTSHIFT, config::Modifier::Shift),\n    ]);\n    let repeat_cooldown_duration: u64 = if args.is_present(\"cooldown\") {\n        args.value_of(\"cooldown\").unwrap().parse::<u64>().unwrap()\n    } else {\n        250\n    };\n    let mut signals = Signals::new(&[\n        SIGUSR1, SIGUSR2, SIGHUP, SIGABRT, SIGBUS, SIGCHLD, SIGCONT, SIGINT, SIGPIPE, SIGQUIT,\n        SIGSYS, SIGTERM, SIGTRAP, SIGTSTP, SIGVTALRM, SIGXCPU, SIGXFSZ,\n    ])?;\n    let mut execution_is_paused = false;\n    let mut last_hotkey: Option<config::Hotkey> = None;\n    let mut pending_release: bool = false;\n    let mut keyboard_states: Vec<KeyboardState> = Vec::new();\n    let mut keyboard_stream_map = StreamMap::new();\n    for (i, mut device) in keyboard_devices.into_iter().enumerate() {\n        let _ = device.grab();\n        keyboard_stream_map.insert(i, device.into_event_stream()?);\n        keyboard_states.push(KeyboardState::new());\n    }\n    let hotkey_repeat_timer = sleep(Duration::from_millis(0));\n    tokio::pin!(hotkey_repeat_timer);\n    loop {\n        select! {\n            _ = &mut hotkey_repeat_timer, if &last_hotkey.is_some() => {\n                let hotkey = last_hotkey.clone().unwrap();\n                if hotkey.keybinding.on_release {\n                    continue;\n                }\n                send_command(hotkey.clone());\n                hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));\n            }\n            Some(signal) = signals.next() => {\n                match signal {\n                    SIGUSR1 => {\n                        execution_is_paused = true;\n                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {\n                            let _ = device.ungrab();\n                        }\n                    }\n                    SIGUSR2 => {\n                        execution_is_paused = false;\n                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {\n                            let _ = device.grab();\n                        }\n                    }\n                    SIGHUP => {\n                        hotkeys = load_config();\n                    }\n                    SIGINT => {\n                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {\n                            let _ = device.ungrab();\n                        }\n                        log::warn!(\"Received SIGINT signal, exiting...\");\n                        exit(1);\n                    }\n                    _ => {\n                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {\n                            let _ = device.ungrab();\n                        }\n                        log::warn!(\"Received signal: {:#?}\", signal);\n                        log::warn!(\"Exiting...\");\n                        exit(1);\n                    }\n                }\n            }\n            Some((i, Ok(event))) = keyboard_stream_map.next() => {\n                let keyboard_state = &mut keyboard_states[i];\n                let key = match event.kind() {\n                    InputEventKind::Key(keycode) => keycode,\n                    _ => continue\n                };\n                match event.value() {\n                    1 => {\n                        if let Some(modifier) = modifiers_map.get(&key) {\n                            keyboard_state.state_modifiers.insert(*modifier);\n                        } else {\n                            keyboard_state.state_keysyms.insert(key);\n                        }\n                    }\n                    0 => {\n                        if last_hotkey.is_some() && pending_release {\n                            pending_release = false;\n                            send_command(last_hotkey.clone().unwrap());\n                            last_hotkey = None;\n                        }\n                        if let Some(modifier) = modifiers_map.get(&key) {\n                            if let Some(hotkey) = &last_hotkey {\n                                if hotkey.modifiers().contains(modifier) {\n                                    last_hotkey = None;\n                                }\n                            }\n                            keyboard_state.state_modifiers.remove(modifier);\n                        } else if keyboard_state.state_keysyms.contains(key) {\n                            if let Some(hotkey) = &last_hotkey {\n                                if key == hotkey.keysym() {\n                                    last_hotkey = None;\n                                }\n                            }\n                            keyboard_state.state_keysyms.remove(key);\n                        }\n                    }\n                    _ => {}\n                }\n                let possible_hotkeys: Vec<&config::Hotkey> = hotkeys.iter()\n                    .filter(|hotkey| hotkey.modifiers().len() == keyboard_state.state_modifiers.len())\n                    .collect();\n                let event_in_hotkeys = hotkeys.iter().any(|hotkey| {\n                    hotkey.keysym().code() == event.code() &&\n                    keyboard_state.state_modifiers\n                        .iter()\n                        .all(|x| hotkey.modifiers().contains(x)) &&\n                    keyboard_state.state_modifiers.len() == hotkey.modifiers().len()\n                    && !hotkey.is_send()\n                        });\n                if !event_in_hotkeys {\n                    uinput_device.emit(&[event]).unwrap();\n                }\n                if execution_is_paused || possible_hotkeys.is_empty() || last_hotkey.is_some() {\n                    continue;\n                }\n                log::debug!(\"state_modifiers: {:#?}\", keyboard_state.state_modifiers);\n                log::debug!(\"state_keysyms: {:#?}\", keyboard_state.state_keysyms);\n                log::debug!(\"hotkey: {:#?}\", possible_hotkeys);\n                for hotkey in possible_hotkeys {\n                    if keyboard_state.state_modifiers.iter().all(|x| hotkey.modifiers().contains(x))\n                        && keyboard_state.state_modifiers.len() == hotkey.modifiers().len()\n                        && keyboard_state.state_keysyms.contains(hotkey.keysym())\n                    {\n                        last_hotkey = Some(hotkey.clone());\n                        if pending_release { break; }\n                        if hotkey.is_on_release() {\n                            pending_release = true;\n                            break;\n                        }\n                        send_command(hotkey.clone());\n                        hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn main() -> std::io::Result<()> {\n    env::set_var(\"RUST_LOG\", \"swhks=trace\");\n    env_logger::init();\n    let pid_file_path = String::from(format!(\"/run/user/{}/swhks.pid\", unistd::Uid::current()));\n    let sock_file_path = String::from(format!(\"/run/user/{}/swhkd.sock\", unistd::Uid::current()));\n    if Path::new(&pid_file_path).exists() {\n        log::trace!(\"Reading {} file and checking for running instances.\", pid_file_path);\n        let swhkd_pid = match fs::read_to_string(&pid_file_path) {\n            Ok(swhkd_pid) => swhkd_pid,\n            Err(e) => {\n                log::error!(\"Unable to read {} to check all running instances\", e);\n                exit(1);\n            }\n        };\n        log::debug!(\"Previous PID: {}\", swhkd_pid);\n        let mut sys = System::new_all();\n        sys.refresh_all();\n        for (pid, process) in sys.processes() {\n            if pid.to_string() == swhkd_pid && process.exe() == env::current_exe().unwrap() {\n                log::error!(\"Server is already running!\");\n                exit(1);\n            }\n        }\n    }\n    if Path::new(&sock_file_path).exists() {\n        log::trace!(\"Sockfile exists, attempting to remove it.\");\n        match fs::remove_file(&sock_file_path) {\n            Ok(_) => {\n                log::debug!(\"Removed old socket file\");\n            }\n            Err(e) => {\n                log::error!(\"Error removing the socket file!: {}\", e);\n                log::error!(\"You can manually remove the socket file: {}\", sock_file_path);\n                exit(1);\n            }\n        };\n    }\n    match fs::write(&pid_file_path, id().to_string()) {\n        Ok(_) => {}\n        Err(e) => {\n            log::error!(\"Unable to write to {}: {}\", pid_file_path, e);\n            exit(1);\n        }\n    }\n    let listener = UnixListener::bind(sock_file_path)?;\n    loop {\n        match listener.accept() {\n            Ok((mut socket, address)) => {\n                let mut response = String::new();\n                socket.read_to_string(&mut response)?;\n                run_system_command(&response);\n                log::debug!(\"Socket: {:?} Address: {:?} Response: {}\", socket, address, response);\n            }\n            Err(e) => log::error!(\"accept function failed: {:?}\", e),\n        }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn seteuid(uid: u32) {\n    let uid = Uid::from_raw(uid);\n    match nix::unistd::seteuid(uid) {\n        Ok(_) => log::debug!(\"Dropping privileges...\"),\n        Err(e) => {\n            log::error!(\"Failed to set EUID: {:#?}\", e);\n            exit(1);\n        }\n    }\n}\nfn sock_send(command: &str) -> std::io::Result<()> {\n    let sock_file_path =\n        String::from(format!(\"/run/user/{}/swhkd.sock\", env::var(\"PKEXEC_UID\").unwrap()));\n    let mut stream = UnixStream::connect(sock_file_path)?;\n    stream.write_all(command.as_bytes())?;\n    Ok(())\n}\nfn main() -> std::io::Result<()> {\n    env::set_var(\"RUST_LOG\", \"swhks=trace\");\n    env_logger::init();\n    let pid_file_path = String::from(\"/tmp/swhks.pid\");\n    let sock_file_path = String::from(format!(\"/run/user/{}/swhkd.sock\", unistd::Uid::current()));\n    if Path::new(&pid_file_path).exists() {\n        log::trace!(\"Reading {} file and checking for running instances.\", pid_file_path);\n        let swhkd_pid = match fs::read_to_string(&pid_file_path) {\n            Ok(swhkd_pid) => swhkd_pid,\n            Err(e) => {\n                log::error!(\"Unable to read {} to check all running instances\", e);\n                exit(1);\n            }\n        };\n        log::debug!(\"Previous PID: {}\", swhkd_pid);\n        let mut sys = System::new_all();\n        sys.refresh_all();\n        for (pid, process) in sys.processes() {\n            if pid.to_string() == swhkd_pid && process.exe() == env::current_exe().unwrap() {\n                log::error!(\"Server is already running!\");\n                exit(1);\n            }\n        }\n    }\n    if Path::new(&sock_file_path).exists() {\n        log::trace!(\"Sockfile exists, attempting to remove it.\");\n        match fs::remove_file(&sock_file_path) {\n            Ok(_) => {\n                log::debug!(\"Removed old socket file\");\n            }\n            Err(e) => {\n                log::error!(\"Error removing the socket file!: {}\", e);\n                log::error!(\"You can manually remove the socket file: {}\", sock_file_path);\n                exit(1);\n            }\n        };\n    }\n    match fs::write(&pid_file_path, id().to_string()) {\n        Ok(_) => {}\n        Err(e) => {\n            log::error!(\"Unable to write to {}: {}\", pid_file_path, e);\n            exit(1);\n        }\n    }\n    let listener = UnixListener::bind(sock_file_path)?;\n    loop {\n        match listener.accept() {\n            Ok((mut socket, address)) => {\n                let mut response = String::new();\n                socket.read_to_string(&mut response)?;\n                run_system_command(&response);\n                log::debug!(\"Socket: {:?} Address: {:?} Response: {}\", socket, address, response);\n            }\n            Err(e) => log::error!(\"accept function failed: {:?}\", e),\n        }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "async fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let args = set_command_line_args().get_matches();\n    env::set_var(\"RUST_LOG\", \"swhkd=warn\");\n    if args.is_present(\"debug\") {\n        env::set_var(\"RUST_LOG\", \"swhkd=trace\");\n    }\n    env_logger::init();\n    log::trace!(\"Logger initialized.\");\n    let pidfile: String = String::from(\"/tmp/swhkd.pid\");\n    if Path::new(&pidfile).exists() {\n        log::trace!(\"Reading {} file and checking for running instances.\", pidfile);\n        let swhkd_pid = match fs::read_to_string(&pidfile) {\n            Ok(swhkd_pid) => swhkd_pid,\n            Err(e) => {\n                log::error!(\"Unable to read {} to check all running instances\", e);\n                exit(1);\n            }\n        };\n        log::debug!(\"Previous PID: {}\", swhkd_pid);\n        let mut sys = System::new_all();\n        sys.refresh_all();\n        for (pid, process) in sys.processes() {\n            if pid.to_string() == swhkd_pid && process.exe() == env::current_exe().unwrap() {\n                log::error!(\"Swhkd is already running!\");\n                log::error!(\"pid of existing swhkd process: {}\", pid.to_string());\n                log::error!(\"To close the existing swhkd process, run `sudo killall swhkd`\");\n                exit(1);\n            }\n        }\n    }\n    match fs::write(&pidfile, id().to_string()) {\n        Ok(_) => {}\n        Err(e) => {\n            log::error!(\"Unable to write to {}: {}\", pidfile, e);\n            exit(1);\n        }\n    }\n    if check_user_permissions().is_err() {\n        exit(1);\n    }\n    let load_config = || {\n        seteuid(env::var(\"PKEXEC_UID\").unwrap().parse::<u32>().unwrap()); \n        let config_file_path: std::path::PathBuf = if args.is_present(\"config\") {\n            Path::new(args.value_of(\"config\").unwrap()).to_path_buf()\n        } else {\n            fetch_xdg_config_path()\n        };\n        log::debug!(\"Using config file path: {:#?}\", config_file_path);\n        if !config_file_path.exists() {\n            log::error!(\"{:#?} doesn't exist\", config_file_path);\n            exit(1);\n        }\n        let hotkeys = match config::load(&config_file_path) {\n            Err(e) => {\n                log::error!(\"Config Error: {}\", e);\n                exit(1);\n            }\n            Ok(out) => out,\n        };\n        for hotkey in &hotkeys {\n            log::debug!(\"hotkey: {:#?}\", hotkey);\n        }\n        hotkeys\n    };\n    let mut hotkeys = load_config();\n    seteuid(0); \n    log::trace!(\"Attempting to find all keyboard file descriptors.\");\n    let keyboard_devices: Vec<Device> =\n        evdev::enumerate().filter(check_device_is_keyboard).collect();\n    let mut uinput_device = match uinput::create_uinput_device() {\n        Ok(dev) => dev,\n        Err(e) => {\n            log::error!(\"Err: {:#?}\", e);\n            exit(1);\n        }\n    };\n    if keyboard_devices.is_empty() {\n        log::error!(\"No valid keyboard device was detected!\");\n        exit(1);\n    }\n    log::debug!(\"{} Keyboard device(s) detected.\", keyboard_devices.len());\n    let modifiers_map: HashMap<Key, config::Modifier> = HashMap::from([\n        (Key::KEY_LEFTMETA, config::Modifier::Super),\n        (Key::KEY_RIGHTMETA, config::Modifier::Super),\n        (Key::KEY_LEFTMETA, config::Modifier::Super),\n        (Key::KEY_RIGHTMETA, config::Modifier::Super),\n        (Key::KEY_LEFTALT, config::Modifier::Alt),\n        (Key::KEY_RIGHTALT, config::Modifier::Alt),\n        (Key::KEY_LEFTCTRL, config::Modifier::Control),\n        (Key::KEY_RIGHTCTRL, config::Modifier::Control),\n        (Key::KEY_LEFTSHIFT, config::Modifier::Shift),\n        (Key::KEY_RIGHTSHIFT, config::Modifier::Shift),\n    ]);\n    let repeat_cooldown_duration: u64 = if args.is_present(\"cooldown\") {\n        args.value_of(\"cooldown\").unwrap().parse::<u64>().unwrap()\n    } else {\n        250\n    };\n    let mut signals = Signals::new(&[\n        SIGUSR1, SIGUSR2, SIGHUP, SIGABRT, SIGBUS, SIGCHLD, SIGCONT, SIGINT, SIGPIPE, SIGQUIT,\n        SIGSYS, SIGTERM, SIGTRAP, SIGTSTP, SIGVTALRM, SIGXCPU, SIGXFSZ,\n    ])?;\n    let mut execution_is_paused = false;\n    let mut last_hotkey: Option<config::Hotkey> = None;\n    let mut pending_release: bool = false;\n    let mut keyboard_states: Vec<KeyboardState> = Vec::new();\n    let mut keyboard_stream_map = StreamMap::new();\n    for (i, mut device) in keyboard_devices.into_iter().enumerate() {\n        let _ = device.grab();\n        keyboard_stream_map.insert(i, device.into_event_stream()?);\n        keyboard_states.push(KeyboardState::new());\n    }\n    let hotkey_repeat_timer = sleep(Duration::from_millis(0));\n    tokio::pin!(hotkey_repeat_timer);\n    loop {\n        select! {\n            _ = &mut hotkey_repeat_timer, if &last_hotkey.is_some() => {\n                let hotkey = last_hotkey.clone().unwrap();\n                if hotkey.keybinding.on_release {\n                    continue;\n                }\n                send_command(hotkey.clone());\n                hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));\n            }\n            Some(signal) = signals.next() => {\n                match signal {\n                    SIGUSR1 => {\n                        execution_is_paused = true;\n                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {\n                            let _ = device.ungrab();\n                        }\n                    }\n                    SIGUSR2 => {\n                        execution_is_paused = false;\n                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {\n                            let _ = device.grab();\n                        }\n                    }\n                    SIGHUP => {\n                        hotkeys = load_config();\n                    }\n                    SIGINT => {\n                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {\n                            let _ = device.ungrab();\n                        }\n                        log::warn!(\"Received SIGINT signal, exiting...\");\n                        exit(1);\n                    }\n                    _ => {\n                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {\n                            let _ = device.ungrab();\n                        }\n                        log::warn!(\"Received signal: {:#?}\", signal);\n                        log::warn!(\"Exiting...\");\n                        exit(1);\n                    }\n                }\n            }\n            Some((i, Ok(event))) = keyboard_stream_map.next() => {\n                let keyboard_state = &mut keyboard_states[i];\n                let key = match event.kind() {\n                    InputEventKind::Key(keycode) => keycode,\n                    _ => continue\n                };\n                match event.value() {\n                    1 => {\n                        if let Some(modifier) = modifiers_map.get(&key) {\n                            keyboard_state.state_modifiers.insert(*modifier);\n                        } else {\n                            keyboard_state.state_keysyms.insert(key);\n                        }\n                    }\n                    0 => {\n                        if last_hotkey.is_some() && pending_release {\n                            pending_release = false;\n                            send_command(last_hotkey.clone().unwrap());\n                            last_hotkey = None;\n                        }\n                        if let Some(modifier) = modifiers_map.get(&key) {\n                            if let Some(hotkey) = &last_hotkey {\n                                if hotkey.modifiers().contains(modifier) {\n                                    last_hotkey = None;\n                                }\n                            }\n                            keyboard_state.state_modifiers.remove(modifier);\n                        } else if keyboard_state.state_keysyms.contains(key) {\n                            if let Some(hotkey) = &last_hotkey {\n                                if key == hotkey.keysym() {\n                                    last_hotkey = None;\n                                }\n                            }\n                            keyboard_state.state_keysyms.remove(key);\n                        }\n                    }\n                    _ => {}\n                }\n                let possible_hotkeys: Vec<&config::Hotkey> = hotkeys.iter()\n                    .filter(|hotkey| hotkey.modifiers().len() == keyboard_state.state_modifiers.len())\n                    .collect();\n                let event_in_hotkeys = hotkeys.iter().any(|hotkey| {\n                    hotkey.keysym().code() == event.code() &&\n                    keyboard_state.state_modifiers\n                        .iter()\n                        .all(|x| hotkey.modifiers().contains(x)) &&\n                    keyboard_state.state_modifiers.len() == hotkey.modifiers().len()\n                    && !hotkey.is_send()\n                        });\n                if !event_in_hotkeys {\n                    uinput_device.emit(&[event]).unwrap();\n                }\n                if execution_is_paused || possible_hotkeys.is_empty() || last_hotkey.is_some() {\n                    continue;\n                }\n                log::debug!(\"state_modifiers: {:#?}\", keyboard_state.state_modifiers);\n                log::debug!(\"state_keysyms: {:#?}\", keyboard_state.state_keysyms);\n                log::debug!(\"hotkey: {:#?}\", possible_hotkeys);\n                for hotkey in possible_hotkeys {\n                    if keyboard_state.state_modifiers.iter().all(|x| hotkey.modifiers().contains(x))\n                        && keyboard_state.state_modifiers.len() == hotkey.modifiers().len()\n                        && keyboard_state.state_keysyms.contains(hotkey.keysym())\n                    {\n                        last_hotkey = Some(hotkey.clone());\n                        if pending_release { break; }\n                        if hotkey.is_on_release() {\n                            pending_release = true;\n                            break;\n                        }\n                        send_command(hotkey.clone());\n                        hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\npub fn seteuid(uid: u32) {\n    let uid = nix::unistd::Uid::from_raw(uid);\n    match nix::unistd::seteuid(uid) {\n        Ok(_) => log::debug!(\"Dropping privileges...\"),\n        Err(e) => {\n            log::error!(\"Failed to set UID: {:#?}\", e);\n            exit(1);\n        }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        if let Some(span) = self.span {\n            write!(f, \"{}\\n  at {}\", self.kind, span)\n        } else {\n            self.kind.fmt(f)\n        }\n    }\n}\nimpl From<nom::Err<ParseError>> for ParseError {\n    fn from(e: nom::Err<ParseError>) -> Self {\n        match e {\n            nom::Err::Incomplete(_) => ParseErrorKind::Incomplete.unknown_index(),\n            nom::Err::Error(e) | nom::Err::Failure(e) => e,\n        }\n    }\n}\nimpl<'i, 'b> nom::error::ParseError<Input<'i, 'b>> for ParseError {\n    fn from_error_kind(i: Input<'i, 'b>, kind: nom::error::ErrorKind) -> Self {\n        ParseErrorKind::Nom(kind).at(i.span())\n    }\n    fn append(_: Input<'i, 'b>, _: nom::error::ErrorKind, other: Self) -> Self {\n        other\n    }\n}\n#[derive(Debug, Clone, PartialEq, Eq, thiserror::Error)]\n#[non_exhaustive]\npub(crate) enum ParseErrorKind {\n    #[error(\"Unknown token\")]\n    UnknownToken,\n    #[error(transparent)]\n    LexErrorWithMessage(ParseErrorMsg),\n    #[error(\"Unexpected dot. Use `[.]` instead\")]\n    Dot,\n    #[error(\"Expected {}\", .0)]\n    Expected(&'static str),\n    #[error(\"There are leftover tokens that couldn't be parsed\")]\n    LeftoverTokens,\n    #[error(\"Expected {}\", .0)]\n    ExpectedToken(Token),\n    #[error(\"Expected code point or character\")]\n    ExpectedCodePointOrChar,\n    #[error(\"The first number in a range must be smaller than the second\")]\n    RangeIsNotIncreasing,\n    #[error(\"This expression can't be negated\")]\n    UnallowedNot,\n    #[error(\"An expression can't be negated twice\")]\n    UnallowedDoubleNot,\n    #[error(\"Range is too big, it isn't allowed to contain more than {} digits\", .0)]\n    RangeIsTooBig(u8),\n    #[error(\"A variable with the same name already exists in this scope\")]\n    LetBindingExists,\n    #[error(\"Unsupported escape sequence in string\")]\n    InvalidEscapeInStringAt(usize),\n    #[error(transparent)]\n    CharString(CharStringError),\n    #[error(transparent)]\n    CharClass(CharClassError),\n    #[error(transparent)]\n    CodePoint(CodePointError),\n    #[error(transparent)]\n    Number(#[from] NumberError),\n    #[error(transparent)]\n    Repetition(RepetitionError),\n    #[error(transparent)]\n    Unsupported(UnsupportedError),\n    #[error(\"Recursion limit reached. Try a less nested expression\")]\n    RecursionLimit,\n    #[error(\"Unknown error: {:?}\", .0)]\n    Nom(nom::error::ErrorKind),\n    #[error(\"Incomplete parse\")]\n    Incomplete,\n}\nimpl ParseErrorKind {\n    pub(crate) fn at(self, span: Span) -> ParseError {\n        ParseError { kind: self, span: Some(span) }\n    }\n    pub(crate) fn unknown_index(self) -> ParseError {\n        ParseError { kind: self, span: None }\n    }\n}\n    pub fn parse(input: &'i str, options: ParseOptions) -> Result<Self, ParseError> {\n        let rule = parse::parse(input, 256)?;\n        rule.validate(&options)?;\n        Ok(Rulex(rule))\n    }\n    pub fn compile(&self, options: CompileOptions) -> Result<String, CompileError> {\n        let mut used_names = HashMap::new();\n        let mut groups_count = 0;\n        self.0.get_capturing_groups(&mut groups_count, &mut used_names, false)?;\n        let empty_span = Span::new(0, 0);\n        let start = Rule::Boundary(Boundary::new(BoundaryKind::Start, empty_span));\n        let end = Rule::Boundary(Boundary::new(BoundaryKind::End, empty_span));\n        let grapheme = Rule::Grapheme(Grapheme { span: empty_span });\n        let codepoint = Rule::CharClass(CharClass::new(CharGroup::CodePoint, empty_span));\n        let builtins = vec![\n            (\"Start\", &start),\n            (\"End\", &end),\n            (\"Grapheme\", &grapheme),\n            (\"G\", &grapheme),\n            (\"Codepoint\", &codepoint),\n            (\"C\", &codepoint),\n        ];\n        let mut state = CompileState {\n            next_idx: 1,\n            used_names,\n            groups_count,\n            default_quantifier: RegexQuantifier::Greedy,\n            variables: builtins,\n            current_vars: Default::default(),\n        };\n        let compiled = self.0.comp(options, &mut state)?;\n        let mut buf = String::new();\n        compiled.codegen(&mut buf, options.flavor);\n        Ok(buf)\n    }\n    pub fn parse_and_compile(\n        input: &'i str,\n        parse_options: ParseOptions,\n        compile_options: CompileOptions,\n    ) -> Result<String, CompileError> {\n        let parsed = Self::parse(input, parse_options)?;\n        parsed.compile(compile_options)\n    }\n    pub(super) fn from(\n        source: &'i str,\n        tokens: &'b [(Token, Span)],\n        recursion: u16,\n    ) -> Result<Self, ParseError> {\n        let error = tokens.iter().find_map(|&(t, span)| match t {\n            Token::Error => Some((span, None)),\n            Token::ErrorMsg(m) => Some((span, Some(m))),\n            _ => None,\n        });\n        if let Some((span, msg)) = error {\n            return match msg {\n                Some(msg) => Err(ParseErrorKind::LexErrorWithMessage(msg).at(span)),\n                None => Err(ParseErrorKind::UnknownToken.at(span)),\n            };\n        }\n        Ok(Input { source, tokens, recursion })\n    }\n    fn iter_elements(&self) -> Self::IterElem {\n        Input { ..*self }\n    }\n    pub(super) fn recursion_end(&mut self) {\n        self.recursion += 1;\n    }\n    pub(super) fn recursion_start(&mut self) -> Result<(), ParseError> {\n        self.recursion = self\n            .recursion\n            .checked_sub(1)\n            .ok_or_else(|| ParseErrorKind::RecursionLimit.at(self.span()))?;\n        Ok(())\n    }\n    fn take(&self, count: usize) -> Self {\n        let tokens = &self.tokens[..count];\n        Input { tokens, ..*self }\n    }\n    fn take_split(&self, count: usize) -> (Self, Self) {\n        let (left, right) = self.tokens.split_at(count);\n        (Input { tokens: left, ..*self }, Input { tokens: right, ..*self })\n    }\npub(crate) fn parse(source: &str, recursion: u16) -> Result<Rule<'_>, ParseError> {\n    let tokens = super::tokenize::tokenize(source);\n    let input = Input::from(source, &tokens, recursion)?;\n    let (rest, rules) = parse_modified(input)?;\n    if rest.is_empty() {\n        Ok(rules)\n    } else {\n        Err(ParseErrorKind::LeftoverTokens.at(rest.span()))\n    }\n}\nfn recurse<'i, 'b, O>(\n    mut parser: impl Parser<Input<'i, 'b>, O, ParseError>,\n) -> impl FnMut(Input<'i, 'b>) -> PResult<'i, 'b, O> {\n    move |mut input| {\n        input.recursion_start().map_err(nom::Err::Failure)?;\n        match parser.parse(input) {\n            Ok((mut input, output)) => {\n                input.recursion_end();\n                Ok((input, output))\n            }\n            Err(e) => Err(e),\n        }\n    }\n}\npub(super) fn parse_modified<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    enum ModifierKind {\n        Enable,\n        Disable,\n    }\n    try_map2(\n        pair(\n            many0(alt((\n                map(\n                    tuple((\n                        alt((\n                            map(\"enable\", |(_, span)| (ModifierKind::Enable, span)),\n                            map(\"disable\", |(_, span)| (ModifierKind::Disable, span)),\n                        )),\n                        value(BooleanSetting::Lazy, \"lazy\"),\n                        Token::Semicolon,\n                    )),\n                    |((kind, span_start), value, (_, span_end))| {\n                        let stmt = match kind {\n                            ModifierKind::Enable => Stmt::Enable(value),\n                            ModifierKind::Disable => Stmt::Disable(value),\n                        };\n                        (stmt, span_start.join(span_end))\n                    },\n                ),\n                map(\n                    tuple((\n                        \"let\",\n                        cut(Token::Identifier),\n                        cut(Token::Equals),\n                        cut(recurse(parse_or)),\n                        cut(Token::Semicolon),\n                    )),\n                    |((_, span_start), (name, name_span), _, rule, (_, span_end))| {\n                        (Stmt::Let(Let::new(name, rule, name_span)), span_start.join(span_end))\n                    },\n                ),\n            ))),\n            recurse(parse_or),\n        ),\n        |(stmts, mut rule): (Vec<(Stmt, Span)>, _)| {\n            if stmts.len() > 1 {\n                let mut set = HashSet::new();\n                for (stmt, _) in &stmts {\n                    if let Stmt::Let(l) = stmt {\n                        if set.contains(l.name()) {\n                            return Err(ParseErrorKind::LetBindingExists.at(l.name_span));\n                        }\n                        set.insert(l.name());\n                    }\n                }\n            }\n            let span_end = rule.span();\n            for (stmt, span) in stmts.into_iter().rev() {\n                rule = Rule::StmtExpr(Box::new(StmtExpr::new(stmt, rule, span.join(span_end))));\n            }\n            Ok(rule)\n        },\n        nom::Err::Failure,\n    )(input)\n}\npub(super) fn parse_fixes<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    alt((\n        try_map(\n            pair(Token::Not, opt(recurse(parse_fixes))),\n            |(_, rule)| {\n                if let Some(mut rule) = rule {\n                    rule.negate()?;\n                    Ok(rule)\n                } else {\n                    Err(ParseErrorKind::Expected(\"expression\"))\n                }\n            },\n            nom::Err::Failure,\n        ),\n        map(pair(parse_lookaround, recurse(parse_modified)), |((kind, span), rule)| {\n            let span = span.join(rule.span());\n            Rule::Lookaround(Box::new(Lookaround::new(rule, kind, span)))\n        }),\n        try_map2(\n            pair(parse_atom, many0(parse_repetition)),\n            |(mut rule, repetitions)| {\n                let mut prev_syntax = RepSyntax::ExplicitQuantifier;\n                for (kind, quantifier, span, syntax) in repetitions {\n                    if matches!(\n                        (&prev_syntax, &syntax),\n                        (RepSyntax::Other | RepSyntax::QuestionMark, RepSyntax::QuestionMark)\n                    ) {\n                        return Err(ParseErrorKind::Repetition(\n                            RepetitionError::QuestionMarkAfterRepetition,\n                        )\n                        .at(span));\n                    }\n                    prev_syntax = syntax;\n                    let span = rule.span().join(span);\n                    rule =\n                        Rule::Repetition(Box::new(Repetition::new(rule, kind, quantifier, span)));\n                }\n                Ok(rule)\n            },\n            nom::Err::Failure,\n        ),\n    ))(input)\n}\npub(super) fn parse_lookaround<'i, 'b>(\n    input: Input<'i, 'b>,\n) -> PResult<'i, 'b, (LookaroundKind, Span)> {\n    alt((\n        map(Token::LookAhead, |(_, span)| (LookaroundKind::Ahead, span)),\n        map(Token::LookBehind, |(_, span)| (LookaroundKind::Behind, span)),\n    ))(input)\n}\npub(super) enum RepSyntax {\n    ExplicitQuantifier,\n    QuestionMark,\n    Other,\n}\npub(super) fn parse_repetition<'i, 'b>(\n    input: Input<'i, 'b>,\n) -> PResult<'i, 'b, (RepetitionKind, Quantifier, Span, RepSyntax)> {\n    map(\n        pair(\n            alt((\n                map(Token::QuestionMark, |(_, span)| {\n                    (RepetitionKind::zero_one(), span, RepSyntax::QuestionMark)\n                }),\n                map(Token::Star, |(_, span)| (RepetitionKind::zero_inf(), span, RepSyntax::Other)),\n                map(Token::Plus, |(_, span)| (RepetitionKind::one_inf(), span, RepSyntax::Other)),\n                parse_braced_repetition,\n            )),\n            map(\n                opt(alt((\n                    map(\"greedy\", |(_, span)| (Quantifier::Greedy, span)),\n                    map(\"lazy\", |(_, span)| (Quantifier::Lazy, span)),\n                ))),\n                |a| match a {\n                    Some((q, span)) => (q, span, RepSyntax::ExplicitQuantifier),\n                    None => (Quantifier::Default, Span::default(), RepSyntax::Other),\n                },\n            ),\n        ),\n        |((kind, span1, rs1), (quantifier, span2, rs2))| {\n            (\n                kind,\n                quantifier,\n                span1.join(span2),\n                match (rs1, rs2) {\n                    (_, RepSyntax::ExplicitQuantifier) => RepSyntax::ExplicitQuantifier,\n                    (RepSyntax::QuestionMark, _) => RepSyntax::QuestionMark,\n                    _ => RepSyntax::Other,\n                },\n            )\n        },\n    )(input)\n}\npub(super) fn parse_braced_repetition<'i, 'b>(\n    input: Input<'i, 'b>,\n) -> PResult<'i, 'b, (RepetitionKind, Span, RepSyntax)> {\n    fn parse_u32<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, u32> {\n        try_map(Token::Number, |(s, _)| from_str(s), nom::Err::Failure)(input)\n    }\n    map(\n        tuple((\n            Token::OpenBrace,\n            cut(alt((\n                try_map(\n                    separated_pair(opt(parse_u32), Token::Comma, opt(parse_u32)),\n                    |(lower, upper)| Ok(RepetitionKind::try_from((lower.unwrap_or(0), upper))?),\n                    nom::Err::Failure,\n                ),\n                map(parse_u32, RepetitionKind::fixed),\n            ))),\n            cut(Token::CloseBrace),\n        )),\n        |((_, start), rep, (_, end))| (rep, start.join(end), RepSyntax::Other),\n    )(input)\n}\npub(super) fn parse_atom<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    alt((\n        parse_group,\n        parse_string,\n        parse_char_class,\n        parse_boundary,\n        parse_reference,\n        map(parse_code_point, |(c, span)| {\n            Rule::CharClass(CharClass::new(CharGroup::from_char(c), span))\n        }),\n        parse_range,\n        parse_variable,\n        try_map(Token::Dot, |_| Err(ParseErrorKind::Dot), nom::Err::Failure),\n        err(|| ParseErrorKind::Expected(\"expression\")),\n    ))(input)\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn parse_quoted_text(input: &str) -> Result<Cow<'_, str>, ParseErrorKind> {\n    Ok(match input.as_bytes()[0] {\n        b'\"' => {\n            let mut s = strip_first_last(input);\n            let mut buf = String::new();\n            loop {\n                let mut chars = s.chars();\n                let char_len;\n                match chars.next() {\n                    Some('\\\\') => {\n                        char_len = 1;\n                        match chars.next() {\n                            Some('\\\\') => {\n                                buf.push('\\\\');\n                                s = &s[1..];\n                            }\n                            Some('\"') => {\n                                buf.push('\"');\n                                s = &s[1..];\n                            }\n                            _ => {\n                                return Err(ParseErrorKind::InvalidEscapeInStringAt(\n                                    input.len() - s.len(),\n                                ));\n                            }\n                        }\n                    }\n                    Some(c) => {\n                        char_len = c.len_utf8();\n                        buf.push(c)\n                    }\n                    None => break,\n                }\n                s = &s[char_len..];\n            }\n            Cow::Owned(buf)\n        }\n        _ => Cow::Borrowed(strip_first_last(input)),\n    })\n}\nfn try_map<'i, 'b, O1, O2, P, M, EM>(\n    mut parser: P,\n    mut map: M,\n    err_kind: EM,\n) -> impl FnMut(Input<'i, 'b>) -> IResult<Input<'i, 'b>, O2, ParseError>\nwhere\n    P: Parser<Input<'i, 'b>, O1, ParseError>,\n    M: FnMut(O1) -> Result<O2, ParseErrorKind>,\n    EM: Copy + FnOnce(ParseError) -> nom::Err<ParseError>,\n{\n    move |input| {\n        let span = input.span();\n        let (rest, o1) = parser.parse(input)?;\n        let o2 = map(o1).map_err(|e| err_kind(e.at(span)))?;\n        Ok((rest, o2))\n    }\n}\nfn try_map2<'i, 'b, O1, O2, P, M, EM>(\n    mut parser: P,\n    mut map: M,\n    err_kind: EM,\n) -> impl FnMut(Input<'i, 'b>) -> IResult<Input<'i, 'b>, O2, ParseError>\nwhere\n    P: Parser<Input<'i, 'b>, O1, ParseError>,\n    M: FnMut(O1) -> Result<O2, ParseError>,\n    EM: Copy + FnOnce(ParseError) -> nom::Err<ParseError>,\n{\n    move |input| {\n        let (rest, o1) = parser.parse(input)?;\n        let o2 = map(o1).map_err(err_kind)?;\n        Ok((rest, o2))\n    }\n}\nfn err<'i, 'b, T>(\n    mut error_fn: impl FnMut() -> ParseErrorKind,\n) -> impl FnMut(Input<'i, 'b>) -> IResult<Input<'i, 'b>, T, ParseError> {\n    move |input| Err(nom::Err::Error(error_fn().at(input.span())))\n}\npub(crate) fn tokenize(mut input: &str) -> Vec<(Token, Span)> {\n    let mut result = vec![];\n    let mut offset = 0;\n    loop {\n        let input_len = input.len();\n        input = input.trim_start();\n        while input.starts_with('#') {\n            input = input.trim_start_matches(|c| c != '\\n').trim_start();\n        }\n        offset += input_len - input.len();\n        match input.chars().next() {\n            None => break,\n            Some(c) => {\n                let (len, token) = consume_chain! {\n                    input, c;\n                    if input.starts_with(\"<%\") => (2, Token::BStart);\n                    if input.starts_with(\"%>\") => (2, Token::BEnd);\n                    if input.starts_with(\">>\") => (2, Token::LookAhead);\n                    if input.starts_with(\"<<\") => (2, Token::LookBehind);\n                    if input.starts_with(\"::\") => (2, Token::Backref);\n                    if c == '%' => (1, Token::BWord);\n                    if c == '*' => (1, Token::Star);\n                    if c == '+' => (1, Token::Plus);\n                    if c == '?' => (1, Token::QuestionMark);\n                    if c == '|' => (1, Token::Pipe);\n                    if c == ':' => (1, Token::Colon);\n                    if c == ')' => (1, Token::CloseParen);\n                    if c == '{' => (1, Token::OpenBrace);\n                    if c == '}' => (1, Token::CloseBrace);\n                    if c == ',' => (1, Token::Comma);\n                    if c == '!' => (1, Token::Not);\n                    if c == '[' => (1, Token::OpenBracket);\n                    if c == '-' => (1, Token::Dash);\n                    if c == ']' => (1, Token::CloseBracket);\n                    if c == '.' => (1, Token::Dot);\n                    if c == ';' => (1, Token::Semicolon);\n                    if c == '=' => (1, Token::Equals);\n                    if c == '\\'' => match input[1..].find('\\'') {\n                        Some(len_inner) => (len_inner + 2, Token::String),\n                        None => (input.len(), Token::ErrorMsg(ParseErrorMsg::UnclosedString)),\n                    };\n                    if c == '\"' => match find_unescaped_quote(&input[1..]) {\n                        Some(len_inner) => (len_inner + 2, Token::String),\n                        None => (input.len(), Token::ErrorMsg(ParseErrorMsg::UnclosedString)),\n                    };\n                    if let Some(rest) = input.strip_prefix(\"U+\") => {\n                        match rest.find(|c: char| !c.is_ascii_hexdigit()) {\n                            Some(0) => (1, Token::Error),\n                            Some(len_inner) => (len_inner + 2, Token::CodePoint),\n                            None => (input.len(), Token::CodePoint),\n                        }\n                    };\n                    if matches!(c, '0'..='9') => (\n                        input.find(|c: char| !matches!(c, '0'..='9')).unwrap_or(input.len()),\n                        Token::Number,\n                    );\n                    if c.is_alphabetic() || c == '_' => (\n                        input.find(|c: char| !c.is_alphanumeric() && c != '_').unwrap_or(input.len()),\n                        Token::Identifier,\n                    );\n                    if c == '^' => (1, Token::ErrorMsg(ParseErrorMsg::Caret));\n                    if c == '$' => (1, Token::ErrorMsg(ParseErrorMsg::Dollar));\n                    if let Some(rest) = input.strip_prefix(\"(?\") => (\n                        match rest.chars().next() {\n                            Some('<') => {\n                                let name_len = rest.chars()\n                                    .skip(1)\n                                    .take_while(char::is_ascii_alphanumeric)\n                                    .count();\n                                if name_len > 0 && matches!(rest.chars().nth(1 + name_len), Some('>')) {\n                                    4 + name_len\n                                } else if let Some('=' | '!') = rest.chars().nth(1) {\n                                    4\n                                } else {\n                                    3\n                                }\n                            }\n                            Some('P') if matches!(rest.chars().nth(1), Some('<')) => {\n                                let name_len = rest.chars()\n                                    .skip(2)\n                                    .take_while(char::is_ascii_alphanumeric)\n                                    .count();\n                                if name_len > 0 && matches!(rest.chars().nth(2 + name_len), Some('>')) {\n                                    5 + name_len\n                                } else {\n                                    4\n                                }\n                            },\n                            Some('>' | '!' | ':' | '=' | '(' | '|') => 3,\n                            _ => 2,\n                        },\n                        Token::ErrorMsg(ParseErrorMsg::SpecialGroup),\n                    );\n                    if c == '(' => (1, Token::OpenParen);\n                    if c == '\\\\' => {\n                        if input.starts_with(\"\\\\u{\") || input.starts_with(\"\\\\x{\") {\n                            match input[3..].find('}') {\n                                Some(len) => (len + 4, Token::ErrorMsg(ParseErrorMsg::BackslashUnicode)),\n                                None => (2, Token::ErrorMsg(ParseErrorMsg::Backslash)),\n                            }\n                        } else if let Some(rest) = input.strip_prefix(\"\\\\u\") {\n                            match rest.find(|c: char| !c.is_ascii_hexdigit()).unwrap_or(rest.len()) {\n                                4.. => (6, Token::ErrorMsg(ParseErrorMsg::BackslashU4)),\n                                _ => (2, Token::ErrorMsg(ParseErrorMsg::Backslash)),\n                            }\n                        } else if let Some(rest) = input.strip_prefix(\"\\\\x\") {\n                            match rest.find(|c: char| !c.is_ascii_hexdigit()).unwrap_or(rest.len()) {\n                                2.. => (4, Token::ErrorMsg(ParseErrorMsg::BackslashX2)),\n                                _ => (2, Token::ErrorMsg(ParseErrorMsg::Backslash)),\n                            }\n                        } else if let Some(rest) = input.strip_prefix(\"\\\\k<\") {\n                            match rest.find('>') {\n                                Some(len) => (len + 4, Token::ErrorMsg(ParseErrorMsg::BackslashK)),\n                                _ => (2, Token::ErrorMsg(ParseErrorMsg::Backslash)),\n                            }\n                        } else if let Some(next) = input.chars().nth(1) {\n                            (1 + next.len_utf8(), Token::ErrorMsg(ParseErrorMsg::Backslash))\n                        } else {\n                            (1, Token::Error)\n                        }\n                    };\n                };\n                let start = offset;\n                offset += len;\n                input = &input[len..];\n                result.push((token, Span::new(start, offset)));\n            }\n        }\n    }\n    result\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "\tpub fn execute(\n\t\tfrom: H160,\n\t\ttransaction: &Transaction,\n\t\tconfig: Option<evm::Config>,\n\t) -> Result<\n\t\t(Option<H160>, Option<H160>, CallOrCreateInfo),\n\t\tDispatchErrorWithPostInfo<PostDispatchInfo>,\n\t> {\n\t\tlet (\n\t\t\tinput,\n\t\t\tvalue,\n\t\t\tgas_limit,\n\t\t\tmax_fee_per_gas,\n\t\t\tmax_priority_fee_per_gas,\n\t\t\tnonce,\n\t\t\taction,\n\t\t\taccess_list,\n\t\t) = {\n\t\t\tmatch transaction {\n\t\t\t\tTransaction::Legacy(t) => (\n\t\t\t\t\tt.input.clone(),\n\t\t\t\t\tt.value,\n\t\t\t\t\tt.gas_limit,\n\t\t\t\t\tSome(t.gas_price),\n\t\t\t\t\tSome(t.gas_price),\n\t\t\t\t\tSome(t.nonce),\n\t\t\t\t\tt.action,\n\t\t\t\t\tVec::new(),\n\t\t\t\t),\n\t\t\t\tTransaction::EIP2930(t) => {\n\t\t\t\t\tlet access_list: Vec<(H160, Vec<H256>)> = t\n\t\t\t\t\t\t.access_list\n\t\t\t\t\t\t.iter()\n\t\t\t\t\t\t.map(|item| (item.address, item.storage_keys.clone()))\n\t\t\t\t\t\t.collect();\n\t\t\t\t\t(\n\t\t\t\t\t\tt.input.clone(),\n\t\t\t\t\t\tt.value,\n\t\t\t\t\t\tt.gas_limit,\n\t\t\t\t\t\tSome(t.gas_price),\n\t\t\t\t\t\tSome(t.gas_price),\n\t\t\t\t\t\tSome(t.nonce),\n\t\t\t\t\t\tt.action,\n\t\t\t\t\t\taccess_list,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tTransaction::EIP1559(t) => {\n\t\t\t\t\tlet access_list: Vec<(H160, Vec<H256>)> = t\n\t\t\t\t\t\t.access_list\n\t\t\t\t\t\t.iter()\n\t\t\t\t\t\t.map(|item| (item.address, item.storage_keys.clone()))\n\t\t\t\t\t\t.collect();\n\t\t\t\t\t(\n\t\t\t\t\t\tt.input.clone(),\n\t\t\t\t\t\tt.value,\n\t\t\t\t\t\tt.gas_limit,\n\t\t\t\t\t\tSome(t.max_fee_per_gas),\n\t\t\t\t\t\tSome(t.max_priority_fee_per_gas),\n\t\t\t\t\t\tSome(t.nonce),\n\t\t\t\t\t\tt.action,\n\t\t\t\t\t\taccess_list,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tlet is_transactional = true;\n\t\tlet validate = false;\n\t\tmatch action {\n\t\t\tethereum::TransactionAction::Call(target) => {\n\t\t\t\tlet res = match T::Runner::call(\n\t\t\t\t\tfrom,\n\t\t\t\t\ttarget,\n\t\t\t\t\tinput,\n\t\t\t\t\tvalue,\n\t\t\t\t\tgas_limit.unique_saturated_into(),\n\t\t\t\t\tmax_fee_per_gas,\n\t\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\t\tnonce,\n\t\t\t\t\taccess_list,\n\t\t\t\t\tis_transactional,\n\t\t\t\t\tvalidate,\n\t\t\t\t\tconfig.as_ref().unwrap_or_else(|| T::config()),\n\t\t\t\t) {\n\t\t\t\t\tOk(res) => res,\n\t\t\t\t\tErr(e) => {\n\t\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tOk((Some(target), None, CallOrCreateInfo::Call(res)))\n\t\t\t}\n\t\t\tethereum::TransactionAction::Create => {\n\t\t\t\tlet res = match T::Runner::create(\n\t\t\t\t\tfrom,\n\t\t\t\t\tinput,\n\t\t\t\t\tvalue,\n\t\t\t\t\tgas_limit.unique_saturated_into(),\n\t\t\t\t\tmax_fee_per_gas,\n\t\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\t\tnonce,\n\t\t\t\t\taccess_list,\n\t\t\t\t\tis_transactional,\n\t\t\t\t\tvalidate,\n\t\t\t\t\tconfig.as_ref().unwrap_or_else(|| T::config()),\n\t\t\t\t) {\n\t\t\t\t\tOk(res) => res,\n\t\t\t\t\tErr(e) => {\n\t\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tOk((None, Some(res.value), CallOrCreateInfo::Create(res)))\n\t\t\t}\n\t\t}\n\t}\n\t\tfn config() -> &'static EvmConfig {\n\t\t\t&LONDON_CONFIG\n\t\t}\n\t}\n\t#[pallet::call]\n\timpl<T: Config> Pallet<T> {\n\t\t#[pallet::weight(0)]\n\t\tpub fn withdraw(\n\t\t\torigin: OriginFor<T>,\n\t\t\taddress: H160,\n\t\t\tvalue: BalanceOf<T>,\n\t\t) -> DispatchResult {\n\t\t\tlet destination = T::WithdrawOrigin::ensure_address_origin(&address, origin)?;\n\t\t\tlet address_account_id = T::AddressMapping::into_account_id(address);\n\t\t\tT::Currency::transfer(\n\t\t\t\t&address_account_id,\n\t\t\t\t&destination,\n\t\t\t\tvalue,\n\t\t\t\tExistenceRequirement::AllowDeath,\n\t\t\t)?;\n\t\t\tOk(())\n\t\t}\n\t\t#[pallet::weight(T::GasWeightMapping::gas_to_weight(*gas_limit))]\n\t\tpub fn call(\n\t\t\torigin: OriginFor<T>,\n\t\t\tsource: H160,\n\t\t\ttarget: H160,\n\t\t\tinput: Vec<u8>,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: u64,\n\t\t\tmax_fee_per_gas: U256,\n\t\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t\t) -> DispatchResultWithPostInfo {\n\t\t\tT::CallOrigin::ensure_address_origin(&source, origin)?;\n\t\t\tlet is_transactional = true;\n\t\t\tlet validate = true;\n\t\t\tlet info = match T::Runner::call(\n\t\t\t\tsource,\n\t\t\t\ttarget,\n\t\t\t\tinput,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tSome(max_fee_per_gas),\n\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\tnonce,\n\t\t\t\taccess_list,\n\t\t\t\tis_transactional,\n\t\t\t\tvalidate,\n\t\t\t\tT::config(),\n\t\t\t) {\n\t\t\t\tOk(info) => info,\n\t\t\t\tErr(e) => {\n\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t};\n\t\t\tmatch info.exit_reason {\n\t\t\t\tExitReason::Succeed(_) => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::Executed(target));\n\t\t\t\t}\n\t\t\t\t_ => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::ExecutedFailed(target));\n\t\t\t\t}\n\t\t\t};\n\t\t\tOk(PostDispatchInfo {\n\t\t\t\tactual_weight: Some(T::GasWeightMapping::gas_to_weight(\n\t\t\t\t\tinfo.used_gas.unique_saturated_into(),\n\t\t\t\t)),\n\t\t\t\tpays_fee: Pays::No,\n\t\t\t})\n\t\t}\n\t\t#[pallet::weight(T::GasWeightMapping::gas_to_weight(*gas_limit))]\n\t\tpub fn create(\n\t\t\torigin: OriginFor<T>,\n\t\t\tsource: H160,\n\t\t\tinit: Vec<u8>,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: u64,\n\t\t\tmax_fee_per_gas: U256,\n\t\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t\t) -> DispatchResultWithPostInfo {\n\t\t\tT::CallOrigin::ensure_address_origin(&source, origin)?;\n\t\t\tlet is_transactional = true;\n\t\t\tlet validate = true;\n\t\t\tlet info = match T::Runner::create(\n\t\t\t\tsource,\n\t\t\t\tinit,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tSome(max_fee_per_gas),\n\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\tnonce,\n\t\t\t\taccess_list,\n\t\t\t\tis_transactional,\n\t\t\t\tvalidate,\n\t\t\t\tT::config(),\n\t\t\t) {\n\t\t\t\tOk(info) => info,\n\t\t\t\tErr(e) => {\n\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t};\n\t\t\tmatch info {\n\t\t\t\tCreateInfo {\n\t\t\t\t\texit_reason: ExitReason::Succeed(_),\n\t\t\t\t\tvalue: create_address,\n\t\t\t\t\t..\n\t\t\t\t} => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::Created(create_address));\n\t\t\t\t}\n\t\t\t\tCreateInfo {\n\t\t\t\t\texit_reason: _,\n\t\t\t\t\tvalue: create_address,\n\t\t\t\t\t..\n\t\t\t\t} => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::CreatedFailed(create_address));\n\t\t\t\t}\n\t\t\t}\n\t\t\tOk(PostDispatchInfo {\n\t\t\t\tactual_weight: Some(T::GasWeightMapping::gas_to_weight(\n\t\t\t\t\tinfo.used_gas.unique_saturated_into(),\n\t\t\t\t)),\n\t\t\t\tpays_fee: Pays::No,\n\t\t\t})\n\t\t}\n\t\t#[pallet::weight(T::GasWeightMapping::gas_to_weight(*gas_limit))]\n\t\tpub fn create2(\n\t\t\torigin: OriginFor<T>,\n\t\t\tsource: H160,\n\t\t\tinit: Vec<u8>,\n\t\t\tsalt: H256,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: u64,\n\t\t\tmax_fee_per_gas: U256,\n\t\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t\t) -> DispatchResultWithPostInfo {\n\t\t\tT::CallOrigin::ensure_address_origin(&source, origin)?;\n\t\t\tlet is_transactional = true;\n\t\t\tlet validate = true;\n\t\t\tlet info = match T::Runner::create2(\n\t\t\t\tsource,\n\t\t\t\tinit,\n\t\t\t\tsalt,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tSome(max_fee_per_gas),\n\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\tnonce,\n\t\t\t\taccess_list,\n\t\t\t\tis_transactional,\n\t\t\t\tvalidate,\n\t\t\t\tT::config(),\n\t\t\t) {\n\t\t\t\tOk(info) => info,\n\t\t\t\tErr(e) => {\n\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t};\n\t\t\tmatch info {\n\t\t\t\tCreateInfo {\n\t\t\t\t\texit_reason: ExitReason::Succeed(_),\n\t\t\t\t\tvalue: create_address,\n\t\t\t\t\t..\n\t\t\t\t} => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::Created(create_address));\n\t\t\t\t}\n\t\t\t\tCreateInfo {\n\t\t\t\t\texit_reason: _,\n\t\t\t\t\tvalue: create_address,\n\t\t\t\t\t..\n\t\t\t\t} => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::CreatedFailed(create_address));\n\t\t\t\t}\n\t\t\t}\n\t\t\tOk(PostDispatchInfo {\n\t\t\t\tactual_weight: Some(T::GasWeightMapping::gas_to_weight(\n\t\t\t\t\tinfo.used_gas.unique_saturated_into(),\n\t\t\t\t)),\n\t\t\t\tpays_fee: Pays::No,\n\t\t\t})\n\t\t}\n\t}\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(super) fn deposit_event)]\n\tpub enum Event<T: Config> {\n\t\tLog(Log),\n\t\tCreated(H160),\n\t\tCreatedFailed(H160),\n\t\tExecuted(H160),\n\t\tExecutedFailed(H160),\n\t\tBalanceDeposit(T::AccountId, H160, U256),\n\t\tBalanceWithdraw(T::AccountId, H160, U256),\n\t}\n\t#[pallet::error]\n\tpub enum Error<T> {\n\t\tBalanceLow,\n\t\tFeeOverflow,\n\t\tPaymentOverflow,\n\t\tWithdrawFailed,\n\t\tGasPriceTooLow,\n\t\tInvalidNonce,\n\t\tGasLimitTooLow,\n\t\tGasLimitTooHigh,\n\t\tUndefined,\n\t}\n\timpl<T> From<InvalidEvmTransactionError> for Error<T> {\n\t\tfn from(validation_error: InvalidEvmTransactionError) -> Self {\n\t\t\tmatch validation_error {\n\t\t\t\tInvalidEvmTransactionError::GasLimitTooLow => Error::<T>::GasLimitTooLow,\n\t\t\t\tInvalidEvmTransactionError::GasLimitTooHigh => Error::<T>::GasLimitTooHigh,\n\t\t\t\tInvalidEvmTransactionError::GasPriceTooLow => Error::<T>::GasLimitTooLow,\n\t\t\t\tInvalidEvmTransactionError::PriorityFeeTooHigh => Error::<T>::GasPriceTooLow,\n\t\t\t\tInvalidEvmTransactionError::BalanceTooLow => Error::<T>::BalanceLow,\n\t\t\t\tInvalidEvmTransactionError::TxNonceTooLow => Error::<T>::InvalidNonce,\n\t\t\t\tInvalidEvmTransactionError::TxNonceTooHigh => Error::<T>::InvalidNonce,\n\t\t\t\tInvalidEvmTransactionError::InvalidPaymentInput => Error::<T>::GasPriceTooLow,\n\t\t\t\t_ => Error::<T>::Undefined,\n\t\t\t}\n\t\t}\n\t}\n\t#[pallet::genesis_config]\n\t#[cfg_attr(feature = \"std\", derive(Default))]\n\tpub struct GenesisConfig {\n\t\tpub accounts: std::collections::BTreeMap<H160, GenesisAccount>,\n\t}\n\t#[pallet::genesis_build]\n\timpl<T: Config> GenesisBuild<T> for GenesisConfig\n\twhere\n\t\tU256: UniqueSaturatedInto<BalanceOf<T>>,\n\t{\n\t\tfn build(&self) {\n\t\t\tconst MAX_ACCOUNT_NONCE: usize = 100;\n\t\t\tfor (address, account) in &self.accounts {\n\t\t\t\tlet account_id = T::AddressMapping::into_account_id(*address);\n\t\t\t\tfor _ in 0..min(\n\t\t\t\t\tMAX_ACCOUNT_NONCE,\n\t\t\t\t\tUniqueSaturatedInto::<usize>::unique_saturated_into(account.nonce),\n\t\t\t\t) {\n\t\t\t\t\tframe_system::Pallet::<T>::inc_account_nonce(&account_id);\n\t\t\t\t}\n\t\t\t\tT::Currency::deposit_creating(&account_id, account.balance.unique_saturated_into());\n\t\t\t\tPallet::<T>::create_account(*address, account.code.clone());\n\t\t\t\tfor (index, value) in &account.storage {\n\t\t\t\t\t<AccountStorages<T>>::insert(address, index, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t#[pallet::storage]\n\t#[pallet::getter(fn account_codes)]\n\tpub type AccountCodes<T: Config> = StorageMap<_, Blake2_128Concat, H160, Vec<u8>, ValueQuery>;\n\t#[pallet::storage]\n\t#[pallet::getter(fn account_storages)]\n\tpub type AccountStorages<T: Config> =\n\t\tStorageDoubleMap<_, Blake2_128Concat, H160, Blake2_128Concat, H256, H256, ValueQuery>;\n}\npub type BalanceOf<T> =\n\t<<T as Config>::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance;\ntype NegativeImbalanceOf<C, T> =\n\t<C as Currency<<T as frame_system::Config>::AccountId>>::NegativeImbalance;\npub trait EnsureAddressOrigin<OuterOrigin> {\n\ttype Success;\n\tfn ensure_address_origin(\n\t\taddress: &H160,\n\t\torigin: OuterOrigin,\n\t) -> Result<Self::Success, BadOrigin> {\n\t\tSelf::try_address_origin(address, origin).map_err(|_| BadOrigin)\n\t}\n\tfn try_address_origin(\n\t\taddress: &H160,\n\t\torigin: OuterOrigin,\n\t) -> Result<Self::Success, OuterOrigin>;\n}\npub struct EnsureAddressSame;\nimpl<OuterOrigin> EnsureAddressOrigin<OuterOrigin> for EnsureAddressSame\nwhere\n\tOuterOrigin: Into<Result<RawOrigin<H160>, OuterOrigin>> + From<RawOrigin<H160>>,\n{\n\ttype Success = H160;\n\tfn try_address_origin(address: &H160, origin: OuterOrigin) -> Result<H160, OuterOrigin> {\n\t\torigin.into().and_then(|o| match o {\n\t\t\tRawOrigin::Signed(who) if &who == address => Ok(who),\n\t\t\tr => Err(OuterOrigin::from(r)),\n\t\t})\n\t}\n}\npub struct EnsureAddressRoot<AccountId>(sp_std::marker::PhantomData<AccountId>);\nimpl<OuterOrigin, AccountId> EnsureAddressOrigin<OuterOrigin> for EnsureAddressRoot<AccountId>\nwhere\n\tOuterOrigin: Into<Result<RawOrigin<AccountId>, OuterOrigin>> + From<RawOrigin<AccountId>>,\n{\n\ttype Success = ();\n\tfn try_address_origin(_address: &H160, origin: OuterOrigin) -> Result<(), OuterOrigin> {\n\t\torigin.into().and_then(|o| match o {\n\t\t\tRawOrigin::Root => Ok(()),\n\t\t\tr => Err(OuterOrigin::from(r)),\n\t\t})\n\t}\n}\npub struct EnsureAddressNever<AccountId>(sp_std::marker::PhantomData<AccountId>);\nimpl<OuterOrigin, AccountId> EnsureAddressOrigin<OuterOrigin> for EnsureAddressNever<AccountId> {\n\ttype Success = AccountId;\n\tfn try_address_origin(_address: &H160, origin: OuterOrigin) -> Result<AccountId, OuterOrigin> {\n\t\tErr(origin)\n\t}\n}\npub struct EnsureAddressTruncated;\nimpl<OuterOrigin> EnsureAddressOrigin<OuterOrigin> for EnsureAddressTruncated\nwhere\n\tOuterOrigin: Into<Result<RawOrigin<AccountId32>, OuterOrigin>> + From<RawOrigin<AccountId32>>,\n{\n\ttype Success = AccountId32;\n\tfn try_address_origin(address: &H160, origin: OuterOrigin) -> Result<AccountId32, OuterOrigin> {\n\t\torigin.into().and_then(|o| match o {\n\t\t\tRawOrigin::Signed(who) if AsRef::<[u8; 32]>::as_ref(&who)[0..20] == address[0..20] => {\n\t\t\t\tOk(who)\n\t\t\t}\n\t\t\tr => Err(OuterOrigin::from(r)),\n\t\t})\n\t}\n}\npub trait AddressMapping<A> {\n\tfn into_account_id(address: H160) -> A;\n}\npub struct IdentityAddressMapping;\nimpl AddressMapping<H160> for IdentityAddressMapping {\n\tfn into_account_id(address: H160) -> H160 {\n\t\taddress\n\t}\n}\npub struct HashedAddressMapping<H>(sp_std::marker::PhantomData<H>);\nimpl<H: Hasher<Out = H256>> AddressMapping<AccountId32> for HashedAddressMapping<H> {\n\tfn into_account_id(address: H160) -> AccountId32 {\n\t\tlet mut data = [0u8; 24];\n\t\tdata[0..4].copy_from_slice(b\"evm:\");\n\t\tdata[4..24].copy_from_slice(&address[..]);\n\t\tlet hash = H::hash(&data);\n\t\tAccountId32::from(Into::<[u8; 32]>::into(hash))\n\t}\n}\npub trait BlockHashMapping {\n\tfn block_hash(number: u32) -> H256;\n}\npub struct SubstrateBlockHashMapping<T>(sp_std::marker::PhantomData<T>);\nimpl<T: Config> BlockHashMapping for SubstrateBlockHashMapping<T> {\n\tfn block_hash(number: u32) -> H256 {\n\t\tlet number = T::BlockNumber::from(number);\n\t\tH256::from_slice(frame_system::Pallet::<T>::block_hash(number).as_ref())\n\t}\n}\npub trait GasWeightMapping {\n\tfn gas_to_weight(gas: u64) -> Weight;\n\tfn weight_to_gas(weight: Weight) -> u64;\n}\nimpl GasWeightMapping for () {\n\tfn gas_to_weight(gas: u64) -> Weight {\n\t\tgas as Weight\n\t}\n\tfn weight_to_gas(weight: Weight) -> u64 {\n\t\tweight as u64\n\t}\n}\nstatic LONDON_CONFIG: EvmConfig = EvmConfig::london();\nimpl<T: Config> Pallet<T> {\n\tpub fn is_account_empty(address: &H160) -> bool {\n\t\tlet (account, _) = Self::account_basic(address);\n\t\tlet code_len = <AccountCodes<T>>::decode_len(address).unwrap_or(0);\n\t\taccount.nonce == U256::zero() && account.balance == U256::zero() && code_len == 0\n\t}\n\tpub fn remove_account_if_empty(address: &H160) {\n\t\tif Self::is_account_empty(address) {\n\t\t\tSelf::remove_account(address);\n\t\t}\n\t}\n\tpub fn remove_account(address: &H160) {\n\t\tif <AccountCodes<T>>::contains_key(address) {\n\t\t\tlet account_id = T::AddressMapping::into_account_id(*address);\n\t\t\tlet _ = frame_system::Pallet::<T>::dec_sufficients(&account_id);\n\t\t}\n\t\t<AccountCodes<T>>::remove(address);\n\t\tlet _ = <AccountStorages<T>>::remove_prefix(address, None);\n\t}\n\tpub fn create_account(address: H160, code: Vec<u8>) {\n\t\tif code.is_empty() {\n\t\t\treturn;\n\t\t}\n\t\tif !<AccountCodes<T>>::contains_key(&address) {\n\t\t\tlet account_id = T::AddressMapping::into_account_id(address);\n\t\t\tlet _ = frame_system::Pallet::<T>::inc_sufficients(&account_id);\n\t\t}\n\t\t<AccountCodes<T>>::insert(address, code);\n\t}\n\tpub fn account_basic(address: &H160) -> (Account, frame_support::weights::Weight) {\n\t\tlet account_id = T::AddressMapping::into_account_id(*address);\n\t\tlet nonce = frame_system::Pallet::<T>::account_nonce(&account_id);\n\t\tlet balance = T::Currency::reducible_balance(&account_id, true);\n\t\t(\n\t\t\tAccount {\n\t\t\t\tnonce: U256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(nonce)),\n\t\t\t\tbalance: U256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(balance)),\n\t\t\t},\n\tfn correct_and_deposit_fee(\n\t\twho: &H160,\n\t\tcorrected_fee: U256,\n\t\tbase_fee: U256,\n\t\talready_withdrawn: Self::LiquidityInfo,\n\t) -> Self::LiquidityInfo {\n\t\tif let Some(paid) = already_withdrawn {\n\t\t\tlet account_id = T::AddressMapping::into_account_id(*who);\n\t\t\tlet refund_amount = paid\n\t\t\t\t.peek()\n\t\t\t\t.saturating_sub(corrected_fee.unique_saturated_into());\n\t\t\tlet refund_imbalance = C::deposit_into_existing(&account_id, refund_amount)\n\t\t\t\t.unwrap_or_else(|_| C::PositiveImbalance::zero());\n\t\t\tlet refund_imbalance = if C::minimum_balance().is_zero()\n\t\t\t\t&& refund_amount > C::Balance::zero()\n\t\t\t\t&& C::total_balance(&account_id).is_zero()\n\t\t\t{\n\t\t\t\tmatch C::make_free_balance_be(&account_id, refund_amount) {\n\t\t\t\t\tSignedImbalance::Positive(p) => p,\n\t\t\t\t\t_ => C::PositiveImbalance::zero(),\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trefund_imbalance\n\t\t\t};\n\t\t\tlet adjusted_paid = paid\n\t\t\t\t.offset(refund_imbalance)\n\t\t\t\t.same()\n\t\t\t\t.unwrap_or_else(|_| C::NegativeImbalance::zero());\n\t\t\tlet (base_fee, tip) = adjusted_paid.split(base_fee.unique_saturated_into());\n\t\t\tOU::on_unbalanced(base_fee);\n\t\t\treturn Some(tip);\n\t\t}\n\t\tNone\n\t}\n\tfn withdraw_fee(who: &H160, fee: U256) -> Result<Self::LiquidityInfo, Error<T>>;\n\tfn correct_and_deposit_fee(\n\t\twho: &H160,\n\t\tcorrected_fee: U256,\n\t\tbase_fee: U256,\n\t\talready_withdrawn: Self::LiquidityInfo,\n\t) -> Self::LiquidityInfo;\n\tfn pay_priority_fee(tip: Self::LiquidityInfo);\n}\npub struct EVMCurrencyAdapter<C, OU>(sp_std::marker::PhantomData<(C, OU)>);\nimpl<T, C, OU> OnChargeEVMTransaction<T> for EVMCurrencyAdapter<C, OU>\nwhere\n\tT: Config,\n\tC: Currency<<T as frame_system::Config>::AccountId>,\n\tC::PositiveImbalance: Imbalance<\n\t\t<C as Currency<<T as frame_system::Config>::AccountId>>::Balance,\n\t\tOpposite = C::NegativeImbalance,\n\t>,\n\tC::NegativeImbalance: Imbalance<\n\t\t<C as Currency<<T as frame_system::Config>::AccountId>>::Balance,\n\t\tOpposite = C::PositiveImbalance,\n\t>,\n\tOU: OnUnbalanced<NegativeImbalanceOf<C, T>>,\n\tU256: UniqueSaturatedInto<<C as Currency<<T as frame_system::Config>::AccountId>>::Balance>,\n{\n\ttype LiquidityInfo = Option<NegativeImbalanceOf<C, T>>;\n\tfn withdraw_fee(who: &H160, fee: U256) -> Result<Self::LiquidityInfo, Error<T>> {\n\t\tif fee.is_zero() {\n\t\t\treturn Ok(None);\n\t\t}\n\t\tlet account_id = T::AddressMapping::into_account_id(*who);\n\t\tlet imbalance = C::withdraw(\n\t\t\t&account_id,\n\t\t\tfee.unique_saturated_into(),\n\t\t\tWithdrawReasons::FEE,\n\t\t\tExistenceRequirement::AllowDeath,\n\t\t)\n\t\t.map_err(|_| Error::<T>::BalanceLow)?;\n\t\tOk(Some(imbalance))\n\t}\n\tfn correct_and_deposit_fee(\n\t\twho: &H160,\n\t\tcorrected_fee: U256,\n\t\tbase_fee: U256,\n\t\talready_withdrawn: Self::LiquidityInfo,\n\t) -> Self::LiquidityInfo {\n\t\tif let Some(paid) = already_withdrawn {\n\t\t\tlet account_id = T::AddressMapping::into_account_id(*who);\n\t\t\tlet refund_amount = paid\n\t\t\t\t.peek()\n\t\t\t\t.saturating_sub(corrected_fee.unique_saturated_into());\n\t\t\tlet refund_imbalance = C::deposit_into_existing(&account_id, refund_amount)\n\t\t\t\t.unwrap_or_else(|_| C::PositiveImbalance::zero());\n\t\t\tlet refund_imbalance = if C::minimum_balance().is_zero()\n\t\t\t\t&& refund_amount > C::Balance::zero()\n\t\t\t\t&& C::total_balance(&account_id).is_zero()\n\t\t\t{\n\t\t\t\tmatch C::make_free_balance_be(&account_id, refund_amount) {\n\t\t\t\t\tSignedImbalance::Positive(p) => p,\n\t\t\t\t\t_ => C::PositiveImbalance::zero(),\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trefund_imbalance\n\t\t\t};\n\t\t\tlet adjusted_paid = paid\n\t\t\t\t.offset(refund_imbalance)\n\t\t\t\t.same()\n\t\t\t\t.unwrap_or_else(|_| C::NegativeImbalance::zero());\n\t\t\tlet (base_fee, tip) = adjusted_paid.split(base_fee.unique_saturated_into());\n\t\t\tOU::on_unbalanced(base_fee);\n\t\t\treturn Some(tip);\n\t\t}\n\t\tNone\n\t}\n\tfn pay_priority_fee(tip: Self::LiquidityInfo) {\n\t\tif let Some(tip) = tip {\n\t\t\tlet account_id = T::AddressMapping::into_account_id(<Pallet<T>>::find_author());\n\t\t\tlet _ = C::deposit_into_existing(&account_id, tip.peek());\n\t\t}\n\t}\n}\n\tpub fn metadata_mut(&mut self) -> &mut StackSubstateMetadata<'config> {\n\t\t&mut self.metadata\n\t}\n\tpub fn enter(&mut self, gas_limit: u64, is_static: bool) {\n\t\tlet mut entering = Self {\n\t\t\tmetadata: self.metadata.spit_child(gas_limit, is_static),\n\t\t\tparent: None,\n\t\t\tdeletes: BTreeSet::new(),\n\t\t\tlogs: Vec::new(),\n\t\t};\n\t\tmem::swap(&mut entering, self);\n\t\tself.parent = Some(Box::new(entering));\n\t\tsp_io::storage::start_transaction();\n\t}\n\tpub fn exit_commit(&mut self) -> Result<(), ExitError> {\n\t\tlet mut exited = *self.parent.take().expect(\"Cannot commit on root substate\");\n\t\tmem::swap(&mut exited, self);\n\t\tself.metadata.swallow_commit(exited.metadata)?;\n\t\tself.logs.append(&mut exited.logs);\n\t\tself.deletes.append(&mut exited.deletes);\n\t\tsp_io::storage::commit_transaction();\n\t\tOk(())\n\t}\n\tpub fn exit_revert(&mut self) -> Result<(), ExitError> {\n\t\tlet mut exited = *self.parent.take().expect(\"Cannot discard on root substate\");\n\t\tmem::swap(&mut exited, self);\n\t\tself.metadata.swallow_revert(exited.metadata)?;\n\t\tsp_io::storage::rollback_transaction();\n\t\tOk(())\n\t}\n\tpub fn exit_discard(&mut self) -> Result<(), ExitError> {\n\t\tlet mut exited = *self.parent.take().expect(\"Cannot discard on root substate\");\n\t\tmem::swap(&mut exited, self);\n\t\tself.metadata.swallow_discard(exited.metadata)?;\n\t\tsp_io::storage::rollback_transaction();\n\t\tOk(())\n\t}\n\tpub fn deleted(&self, address: H160) -> bool {\n\t\tif self.deletes.contains(&address) {\n\t\t\treturn true;\n\t\t}\n\t\tif let Some(parent) = self.parent.as_ref() {\n\t\t\treturn parent.deleted(address);\n\t\t}\n\t\tfalse\n\t}\n\tpub fn set_deleted(&mut self, address: H160) {\n\t\tself.deletes.insert(address);\n\t}\n\tpub fn log(&mut self, address: H160, topics: Vec<H256>, data: Vec<u8>) {\n\t\tself.logs.push(Log {\n\t\t\taddress,\n\t\t\ttopics,\n\t\t\tdata,\n\t\t});\n\t}\n\tfn recursive_is_cold<F: Fn(&Accessed) -> bool>(&self, f: &F) -> bool {\n\t\tlet local_is_accessed = self.metadata.accessed().as_ref().map(f).unwrap_or(false);\n\t\tif local_is_accessed {\n\t\t\tfalse\n\t\t} else {\n\t\t\tself.parent\n\t\t\t\t.as_ref()\n\t\t\t\t.map(|p| p.recursive_is_cold(f))\n\t\t\t\t.unwrap_or(true)\n\t\t}\n\t}\n}\npub struct SubstrateStackState<'vicinity, 'config, T> {\n\tvicinity: &'vicinity Vicinity,\n\tsubstate: SubstrateStackSubstate<'config>,\n\t_marker: PhantomData<T>,\n}\nimpl<'vicinity, 'config, T: Config> SubstrateStackState<'vicinity, 'config, T> {\n\tpub fn new(vicinity: &'vicinity Vicinity, metadata: StackSubstateMetadata<'config>) -> Self {\n\t\tSelf {\n\t\t\tvicinity,\n\t\t\tsubstate: SubstrateStackSubstate {\n\t\t\t\tmetadata,\n\t\t\t\tdeletes: BTreeSet::new(),\n\t\t\t\tlogs: Vec::new(),\n\t\t\t\tparent: None,\n\t\t\t},\n\t\t\t_marker: PhantomData,\n\t\t}\n\t}\n}\nimpl<'vicinity, 'config, T: Config> BackendT for SubstrateStackState<'vicinity, 'config, T> {\n\tfn gas_price(&self) -> U256 {\n\t\tself.vicinity.gas_price\n\t}\n\tfn origin(&self) -> H160 {\n\t\tself.vicinity.origin\n\t}\n\tfn block_hash(&self, number: U256) -> H256 {\n\t\tif number > U256::from(u32::max_value()) {\n\t\t\tH256::default()\n\t\t} else {\n\t\t\tT::BlockHashMapping::block_hash(number.as_u32())\n\t\t}\n\t}\n\tfn block_number(&self) -> U256 {\n\t\tlet number: u128 = frame_system::Pallet::<T>::block_number().unique_saturated_into();\n\t\tU256::from(number)\n\t}\n\tfn block_coinbase(&self) -> H160 {\n\t\tPallet::<T>::find_author()\n\t}\n\tfn block_timestamp(&self) -> U256 {\n\t\tlet now: u128 = pallet_timestamp::Pallet::<T>::get().unique_saturated_into();\n\t\tU256::from(now / 1000)\n\t}\n\tfn block_difficulty(&self) -> U256 {\n\t\tU256::zero()\n\t}\n\tfn block_gas_limit(&self) -> U256 {\n\t\tT::BlockGasLimit::get()\n\t}\n\tfn chain_id(&self) -> U256 {\n\t\tU256::from(T::ChainId::get())\n\t}\n\tfn exists(&self, _address: H160) -> bool {\n\t\ttrue\n\t}\n\tfn basic(&self, address: H160) -> evm::backend::Basic {\n\t\tlet (account, _) = Pallet::<T>::account_basic(&address);\n\t\tevm::backend::Basic {\n\t\t\tbalance: account.balance,\n\t\t\tnonce: account.nonce,\n\t\t}\n\t}\n\tfn code(&self, address: H160) -> Vec<u8> {\n\t\t<AccountCodes<T>>::get(&address)\n\t}\n\tfn storage(&self, address: H160, index: H256) -> H256 {\n\t\t<AccountStorages<T>>::get(address, index)\n\t}\n\tfn original_storage(&self, _address: H160, _index: H256) -> Option<H256> {\n\t\tNone\n\t}\n\tfn block_base_fee_per_gas(&self) -> sp_core::U256 {\n\t\tlet (base_fee, _) = T::FeeCalculator::min_gas_price();\n\t\tbase_fee\n\t}\n}\nimpl<'vicinity, 'config, T: Config> StackStateT<'config>\n\tfor SubstrateStackState<'vicinity, 'config, T>\nwhere\n\tBalanceOf<T>: TryFrom<U256> + Into<U256>,\n{\n\tfn metadata(&self) -> &StackSubstateMetadata<'config> {\n\t\tself.substate.metadata()\n\t}\n\tfn metadata_mut(&mut self) -> &mut StackSubstateMetadata<'config> {\n\t\tself.substate.metadata_mut()\n\t}\n\tfn enter(&mut self, gas_limit: u64, is_static: bool) {\n\t\tself.substate.enter(gas_limit, is_static)\n\t}\n\tfn exit_commit(&mut self) -> Result<(), ExitError> {\n\t\tself.substate.exit_commit()\n\t}\n\tfn exit_revert(&mut self) -> Result<(), ExitError> {\n\t\tself.substate.exit_revert()\n\t}\n\tfn exit_discard(&mut self) -> Result<(), ExitError> {\n\t\tself.substate.exit_discard()\n\t}\n\tfn is_empty(&self, address: H160) -> bool {\n\t\tPallet::<T>::is_account_empty(&address)\n\t}\n\tfn deleted(&self, address: H160) -> bool {\n\t\tself.substate.deleted(address)\n\t}\n\tfn inc_nonce(&mut self, address: H160) {\n\t\tlet account_id = T::AddressMapping::into_account_id(address);\n\t\tframe_system::Pallet::<T>::inc_account_nonce(&account_id);\n\t}\n\tfn set_storage(&mut self, address: H160, index: H256, value: H256) {\n\t\tif value == H256::default() {\n\t\t\tlog::debug!(\n\t\t\t\ttarget: \"evm\",\n\t\t\t\t\"Removing storage for {:?} [index: {:?}]\",\n\t\t\t\taddress,\n\t\t\t\tindex,\n\t\t\t);\n\t\t\t<AccountStorages<T>>::remove(address, index);\n\t\t} else {\n\t\t\tlog::debug!(\n\t\t\t\ttarget: \"evm\",\n\t\t\t\t\"Updating storage for {:?} [index: {:?}, value: {:?}]\",\n\t\t\t\taddress,\n\t\t\t\tindex,\n\t\t\t\tvalue,\n\t\t\t);\n\t\t\t<AccountStorages<T>>::insert(address, index, value);\n\t\t}\n\t}\n\tfn reset_storage(&mut self, address: H160) {\n\t\tlet _ = <AccountStorages<T>>::remove_prefix(address, None);\n\t}\n\tfn log(&mut self, address: H160, topics: Vec<H256>, data: Vec<u8>) {\n\t\tself.substate.log(address, topics, data)\n\t}\n\tfn set_deleted(&mut self, address: H160) {\n\t\tself.substate.set_deleted(address)\n\t}\n\tfn set_code(&mut self, address: H160, code: Vec<u8>) {\n\t\tlog::debug!(\n\t\t\ttarget: \"evm\",\n\t\t\t\"Inserting code ({} bytes) at {:?}\",\n\t\t\tcode.len(),\n\t\t\taddress\n\t\t);\n\t\tPallet::<T>::create_account(address, code);\n\t}\n\tfn transfer(&mut self, transfer: Transfer) -> Result<(), ExitError> {\n\t\tlet source = T::AddressMapping::into_account_id(transfer.source);\n\t\tlet target = T::AddressMapping::into_account_id(transfer.target);\n\t\tT::Currency::transfer(\n\t\t\t&source,\n\t\t\t&target,\n\t\t\ttransfer\n\t\t\t\t.value\n\t\t\t\t.try_into()\n\t\t\t\t.map_err(|_| ExitError::OutOfFund)?,\n\t\t\tExistenceRequirement::AllowDeath,\n\t\t)\n\t\t.map_err(|_| ExitError::OutOfFund)\n\t}\n\tfn reset_balance(&mut self, _address: H160) {\n\t}\n\tfn touch(&mut self, _address: H160) {\n\t}\n\tfn is_cold(&self, address: H160) -> bool {\n\t\tself.substate\n\t\t\t.recursive_is_cold(&|a| a.accessed_addresses.contains(&address))\n\t}\n\tfn is_storage_cold(&self, address: H160, key: H256) -> bool {\n\t\tself.substate\n\t\t\t.recursive_is_cold(&|a: &Accessed| a.accessed_storage.contains(&(address, key)))\n\t}\n}\n\tfn transfer(&mut self, transfer: Transfer) -> Result<(), ExitError> {\n\t\tlet source = T::AddressMapping::into_account_id(transfer.source);\n\t\tlet target = T::AddressMapping::into_account_id(transfer.target);\n\t\tT::Currency::transfer(\n\t\t\t&source,\n\t\t\t&target,\n\t\t\ttransfer\n\t\t\t\t.value\n\t\t\t\t.try_into()\n\t\t\t\t.map_err(|_| ExitError::OutOfFund)?,\n\t\t\tExistenceRequirement::AllowDeath,\n\t\t)\n\t\t.map_err(|_| ExitError::OutOfFund)\n\t}\nfn issuance_after_tip() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet before_tip = <Test as Config>::Currency::total_issuance();\n\t\tlet result = EVM::call(\n\t\t\tOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tU256::from(2_000_000_000),\n\t\t\tSome(U256::from(1)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tresult.expect(\"EVM can be called\");\n\t\tlet after_tip = <Test as Config>::Currency::total_issuance();\n\t\tlet base_fee: u64 = <Test as Config>::FeeCalculator::min_gas_price()\n\t\t\t.0\n\t\t\t.unique_saturated_into();\n\t\tassert_eq!(after_tip, (before_tip - (base_fee * 21_000)));\n\t});\n}\nfn refunds_and_priority_should_work() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet author = EVM::find_author();\n\t\tlet before_tip = EVM::account_basic(&author).0.balance;\n\t\tlet before_call = EVM::account_basic(&H160::default()).0.balance;\n\t\tlet tip = U256::from(1_500_000_000);\n\t\tlet max_fee_per_gas = U256::from(2_000_000_000);\n\t\tlet used_gas = U256::from(21_000);\n\t\tlet _ = EVM::call(\n\t\t\tOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tmax_fee_per_gas,\n\t\t\tSome(tip),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tlet (base_fee, _) = <Test as Config>::FeeCalculator::min_gas_price();\n\t\tlet actual_tip = (max_fee_per_gas - base_fee).min(tip) * used_gas;\n\t\tlet total_cost = (used_gas * base_fee) + U256::from(actual_tip) + U256::from(1);\n\t\tlet after_call = EVM::account_basic(&H160::default()).0.balance;\n\t\tassert_eq!(after_call, before_call - total_cost);\n\t\tlet after_tip = EVM::account_basic(&author).0.balance;\n\t\tassert_eq!(after_tip, (before_tip + actual_tip));\n\t});\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "    pub fn zero() -> MoveWideConst {\n        MoveWideConst { bits: 0, shift: 0 }\n    }\n    fn load_constant64_full(\n        &mut self,\n        ty: Type,\n        extend: &generated_code::ImmExtend,\n        value: u64,\n    ) -> Reg {\n        let bits = ty.bits();\n        let value = if bits < 64 {\n            if *extend == generated_code::ImmExtend::Sign {\n                let shift = 64 - bits;\n                let value = value as i64;\n                ((value << shift) >> shift) as u64\n            } else {\n                value & !(u64::MAX << bits)\n            }\n        } else {\n            value\n        };\n        let rd = self.temp_writable_reg(I64);\n        if value == 0 {\n            self.emit(&MInst::MovWide {\n                op: MoveWideOp::MovZ,\n                rd,\n                imm: MoveWideConst::zero(),\n                size: OperandSize::Size64,\n            });\n            return rd.to_reg();\n        } else if value == u64::MAX {\n            self.emit(&MInst::MovWide {\n                op: MoveWideOp::MovN,\n                rd,\n                imm: MoveWideConst::zero(),\n                size: OperandSize::Size64,\n            });\n            return rd.to_reg();\n        };\n        let (num_half_words, size, negated) = if value >> 32 == 0 {\n            (2, OperandSize::Size32, (!value << 32) >> 32)\n        } else {\n            (4, OperandSize::Size64, !value)\n        };\n        let first_is_inverted = count_zero_half_words(negated, num_half_words)\n            > count_zero_half_words(value, num_half_words);\n        let ignored_halfword = if first_is_inverted { 0xffff } else { 0 };\n        let mut first_mov_emitted = false;\n        for i in 0..num_half_words {\n            let imm16 = (value >> (16 * i)) & 0xffff;\n            if imm16 != ignored_halfword {\n                if !first_mov_emitted {\n                    first_mov_emitted = true;\n                    if first_is_inverted {\n                        let imm =\n                            MoveWideConst::maybe_with_shift(((!imm16) & 0xffff) as u16, i * 16)\n                                .unwrap();\n                        self.emit(&MInst::MovWide {\n                            op: MoveWideOp::MovN,\n                            rd,\n                            imm,\n                            size,\n                        });\n                    } else {\n                        let imm = MoveWideConst::maybe_with_shift(imm16 as u16, i * 16).unwrap();\n                        self.emit(&MInst::MovWide {\n                            op: MoveWideOp::MovZ,\n                            rd,\n                            imm,\n                            size,\n                        });\n                    }\n                } else {\n                    let imm = MoveWideConst::maybe_with_shift(imm16 as u16, i * 16).unwrap();\n                    self.emit(&MInst::MovWide {\n                        op: MoveWideOp::MovK,\n                        rd,\n                        imm,\n                        size,\n                    });\n                }\n            }\n        }\n        assert!(first_mov_emitted);\n        return self.writable_reg_to_reg(rd);\n        fn count_zero_half_words(mut value: u64, num_half_words: u8) -> usize {\n            let mut count = 0;\n            for _ in 0..num_half_words {\n                if value & 0xffff == 0 {\n                    count += 1;\n                }\n                value >>= 16;\n            }\n            count\n        }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "    fn exit_document(&mut self, ctx: &mut ValidatorContext<'a, S>, _: &'a Document<S>) {\n        assert!(self.current_fragment.is_none());\n        let mut detector = CycleDetector {\n            visited: HashSet::new(),\n            spreads: &self.spreads,\n            errors: Vec::new(),\n        };\n        for frag in &self.fragment_order {\n            if !detector.visited.contains(frag) {\n                detector.detect_from(frag);\n            }\n        }\n        ctx.append_errors(detector.errors);\n    }\n    fn find_undef_vars_inner(\n        &'a self,\n        scope: &Scope<'a>,\n        defined: &HashSet<&'a str>,\n        unused: &mut Vec<&'a Spanning<&'a str>>,\n        visited: &mut HashSet<Scope<'a>>,\n    ) -> Option<&'a Vec<&'a str>> {\n        if visited.contains(scope) {\n            return None;\n        }\n        visited.insert(scope.clone());\n        if let Some(used_vars) = self.used_variables.get(scope) {\n            for var in used_vars {\n                if !defined.contains(&var.item) {\n                    unused.push(var);\n                }\n            }\n        }\n        self.spreads.get(scope)\n    }\n    fn collect_conflicts_between_fragments(\n        &self,\n        conflicts: &mut Vec<Conflict>,\n        fragment_name1: &'a str,\n        fragment_name2: &'a str,\n        mutually_exclusive: bool,\n        ctx: &ValidatorContext<'a, S>,\n    ) where\n        S: ScalarValue,\n    {\n        if fragment_name1 == fragment_name2 {\n            return;\n        }\n        let fragment1 = match self.named_fragments.get(fragment_name1) {\n            Some(f) => f,\n            None => return,\n        };\n        let fragment2 = match self.named_fragments.get(fragment_name2) {\n            Some(f) => f,\n            None => return,\n        };\n        {\n            if self.compared_fragments.borrow().contains(\n                fragment_name1,\n                fragment_name2,\n                mutually_exclusive,\n            ) {\n                return;\n            }\n        }\n        {\n            self.compared_fragments.borrow_mut().insert(\n                fragment_name1,\n                fragment_name2,\n                mutually_exclusive,\n            );\n        }\n        let (field_map1, fragment_names1) =\n            self.get_referenced_fields_and_fragment_names(fragment1, ctx);\n        let (field_map2, fragment_names2) =\n            self.get_referenced_fields_and_fragment_names(fragment2, ctx);\n        self.collect_conflicts_between(\n            conflicts,\n            mutually_exclusive,\n            &field_map1,\n            &field_map2,\n            ctx,\n        );\n        for fragment_name2 in &fragment_names2 {\n            self.collect_conflicts_between_fragments(\n                conflicts,\n                fragment_name1,\n                fragment_name2,\n                mutually_exclusive,\n                ctx,\n            );\n        }\n        for fragment_name1 in &fragment_names1 {\n            self.collect_conflicts_between_fragments(\n                conflicts,\n                fragment_name1,\n                fragment_name2,\n                mutually_exclusive,\n                ctx,\n            );\n        }\n    }\n    fn collect_conflicts_between_fields_and_fragment(\n        &self,\n        conflicts: &mut Vec<Conflict>,\n        field_map: &AstAndDefCollection<'a, S>,\n        fragment_name: &str,\n        mutually_exclusive: bool,\n        ctx: &ValidatorContext<'a, S>,\n    ) where\n        S: ScalarValue,\n    {\n        let mut to_check = Vec::new();\n        if let Some(fragments) = self.collect_conflicts_between_fields_and_fragment_inner(\n            conflicts,\n            field_map,\n            fragment_name,\n            mutually_exclusive,\n            ctx,\n        ) {\n            to_check.push((fragment_name, fragments))\n        }\n        while let Some((fragment_name, fragment_names2)) = to_check.pop() {\n            for fragment_name2 in fragment_names2 {\n                if fragment_name == fragment_name2 {\n                    return;\n                }\n                if let Some(fragments) = self.collect_conflicts_between_fields_and_fragment_inner(\n                    conflicts,\n                    field_map,\n                    fragment_name2,\n                    mutually_exclusive,\n                    ctx,\n                ) {\n                    to_check.push((fragment_name2, fragments));\n                };\n            }\n        }\n    }\n    fn collect_conflicts_between_fields_and_fragment_inner(\n        &self,\n        conflicts: &mut Vec<Conflict>,\n        field_map: &AstAndDefCollection<'a, S>,\n        fragment_name: &str,\n        mutually_exclusive: bool,\n        ctx: &ValidatorContext<'a, S>,\n    ) -> Option<Vec<&'a str>>\n    where\n        S: ScalarValue,\n    {\n        let fragment = self.named_fragments.get(fragment_name)?;\n        let (field_map2, fragment_names2) =\n            self.get_referenced_fields_and_fragment_names(fragment, ctx);\n        self.collect_conflicts_between(conflicts, mutually_exclusive, field_map, &field_map2, ctx);\n        Some(fragment_names2)\n    }\n    fn collect_conflicts_between(\n        &self,\n        conflicts: &mut Vec<Conflict>,\n        mutually_exclusive: bool,\n        field_map1: &AstAndDefCollection<'a, S>,\n        field_map2: &AstAndDefCollection<'a, S>,\n        ctx: &ValidatorContext<'a, S>,\n    ) where\n        S: ScalarValue,\n    {\n        for (response_name, fields1) in field_map1.iter() {\n            if let Some(fields2) = field_map2.get(response_name) {\n                for field1 in fields1 {\n                    for field2 in fields2 {\n                        if let Some(conflict) = self.find_conflict(\n                            response_name,\n                            field1,\n                            field2,\n                            mutually_exclusive,\n                            ctx,\n                        ) {\n                            conflicts.push(conflict);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    fn dummy() -> bool {\n        false\n    }\nasync fn test() {\n    const PERM: &str = \"abcefghijk\";\n    const CIRCLE_SIZE: usize = 7500;\n    let query = iter::once(format!(\"query {{ ...{PERM} }} \"))\n        .chain(\n            PERM.chars()\n                .permutations(PERM.len())\n                .map(|vec| vec.into_iter().collect::<String>())\n                .take(CIRCLE_SIZE)\n                .collect::<Vec<_>>()\n                .into_iter()\n                .circular_tuple_windows::<(_, _)>()\n                .map(|(cur, next)| format!(\"fragment {cur} on Query {{ ...{next} }} \")),\n        )\n        .collect::<String>();\n    let schema = Schema::new(Query, EmptyMutation::new(), EmptySubscription::new());\n    let _ = juniper::execute(&query, None, &schema, &graphql_vars! {}, &())\n        .await\n        .unwrap_err();\n}\n    fn dummy() -> bool {\n        false\n    }\nasync fn test() {\n    const PERM: &str = \"abcefghijk\";\n    const CIRCLE_SIZE: usize = 7500;\n    let query = iter::once(format!(\"query {{ ...{PERM} }} \"))\n        .chain(\n            PERM.chars()\n                .permutations(PERM.len())\n                .map(|vec| vec.into_iter().collect::<String>())\n                .take(CIRCLE_SIZE)\n                .collect::<Vec<_>>()\n                .into_iter()\n                .circular_tuple_windows::<(_, _)>()\n                .map(|(cur, next)| format!(\"fragment {cur} on Query {{ ...{next} }} \")),\n        )\n        .collect::<String>();\n    let schema = Schema::new(Query, EmptyMutation::new(), EmptySubscription::new());\n    let _ = juniper::execute(&query, None, &schema, &Variables::new(), &())\n        .await\n        .unwrap_err();\n}\n    fn exit_document(&mut self, ctx: &mut ValidatorContext<'a, S>, _: &'a Document<S>) {\n        assert!(self.current_fragment.is_none());\n        let mut detector = CycleDetector {\n            visited: HashSet::new(),\n            spreads: &self.spreads,\n            errors: Vec::new(),\n        };\n        for frag in &self.fragment_order {\n            if !detector.visited.contains(frag) {\n                detector.detect_from(frag);\n            }\n        }\n        ctx.append_errors(detector.errors);\n    }\n    fn find_undef_vars_inner(\n        &'a self,\n        scope: &Scope<'a>,\n        defined: &HashSet<&'a str>,\n        unused: &mut Vec<&'a Spanning<&'a str>>,\n        visited: &mut HashSet<Scope<'a>>,\n    ) -> Option<&'a Vec<&'a str>> {\n        if visited.contains(scope) {\n            return None;\n        }\n        visited.insert(scope.clone());\n        if let Some(used_vars) = self.used_variables.get(scope) {\n            for var in used_vars {\n                if !defined.contains(&var.item) {\n                    unused.push(var);\n                }\n            }\n        }\n        self.spreads.get(scope)\n    }\n    fn collect_conflicts_between_fragments(\n        &self,\n        conflicts: &mut Vec<Conflict>,\n        fragment_name1: &'a str,\n        fragment_name2: &'a str,\n        mutually_exclusive: bool,\n        ctx: &ValidatorContext<'a, S>,\n    ) where\n        S: ScalarValue,\n    {\n        if fragment_name1 == fragment_name2 {\n            return;\n        }\n        let fragment1 = match self.named_fragments.get(fragment_name1) {\n            Some(f) => f,\n            None => return,\n        };\n        let fragment2 = match self.named_fragments.get(fragment_name2) {\n            Some(f) => f,\n            None => return,\n        };\n        {\n            if self.compared_fragments.borrow().contains(\n                fragment_name1,\n                fragment_name2,\n                mutually_exclusive,\n            ) {\n                return;\n            }\n        }\n        {\n            self.compared_fragments.borrow_mut().insert(\n                fragment_name1,\n                fragment_name2,\n                mutually_exclusive,\n            );\n        }\n        let (field_map1, fragment_names1) =\n            self.get_referenced_fields_and_fragment_names(fragment1, ctx);\n        let (field_map2, fragment_names2) =\n            self.get_referenced_fields_and_fragment_names(fragment2, ctx);\n        self.collect_conflicts_between(\n            conflicts,\n            mutually_exclusive,\n            &field_map1,\n            &field_map2,\n            ctx,\n        );\n        for fragment_name2 in &fragment_names2 {\n            self.collect_conflicts_between_fragments(\n                conflicts,\n                fragment_name1,\n                fragment_name2,\n                mutually_exclusive,\n                ctx,\n            );\n        }\n        for fragment_name1 in &fragment_names1 {\n            self.collect_conflicts_between_fragments(\n                conflicts,\n                fragment_name1,\n                fragment_name2,\n                mutually_exclusive,\n                ctx,\n            );\n        }\n    }\n    fn collect_conflicts_between_fields_and_fragment(\n        &self,\n        conflicts: &mut Vec<Conflict>,\n        field_map: &AstAndDefCollection<'a, S>,\n        fragment_name: &str,\n        mutually_exclusive: bool,\n        ctx: &ValidatorContext<'a, S>,\n    ) where\n        S: ScalarValue,\n    {\n        let mut to_check = Vec::new();\n        if let Some(fragments) = self.collect_conflicts_between_fields_and_fragment_inner(\n            conflicts,\n            field_map,\n            fragment_name,\n            mutually_exclusive,\n            ctx,\n        ) {\n            to_check.push((fragment_name, fragments))\n        }\n        while let Some((fragment_name, fragment_names2)) = to_check.pop() {\n            for fragment_name2 in fragment_names2 {\n                if fragment_name == fragment_name2 {\n                    return;\n                }\n                if let Some(fragments) = self.collect_conflicts_between_fields_and_fragment_inner(\n                    conflicts,\n                    field_map,\n                    fragment_name2,\n                    mutually_exclusive,\n                    ctx,\n                ) {\n                    to_check.push((fragment_name2, fragments));\n                };\n            }\n        }\n    }\n    fn collect_conflicts_between_fields_and_fragment_inner(\n        &self,\n        conflicts: &mut Vec<Conflict>,\n        field_map: &AstAndDefCollection<'a, S>,\n        fragment_name: &str,\n        mutually_exclusive: bool,\n        ctx: &ValidatorContext<'a, S>,\n    ) -> Option<Vec<&'a str>>\n    where\n        S: ScalarValue,\n    {\n        let fragment = self.named_fragments.get(fragment_name)?;\n        let (field_map2, fragment_names2) =\n            self.get_referenced_fields_and_fragment_names(fragment, ctx);\n        self.collect_conflicts_between(conflicts, mutually_exclusive, field_map, &field_map2, ctx);\n        Some(fragment_names2)\n    }\n    fn collect_conflicts_between(\n        &self,\n        conflicts: &mut Vec<Conflict>,\n        mutually_exclusive: bool,\n        field_map1: &AstAndDefCollection<'a, S>,\n        field_map2: &AstAndDefCollection<'a, S>,\n        ctx: &ValidatorContext<'a, S>,\n    ) where\n        S: ScalarValue,\n    {\n        for (response_name, fields1) in field_map1.iter() {\n            if let Some(fields2) = field_map2.get(response_name) {\n                for field1 in fields1 {\n                    for field2 in fields2 {\n                        if let Some(conflict) = self.find_conflict(\n                            response_name,\n                            field1,\n                            field2,\n                            mutually_exclusive,\n                            ctx,\n                        ) {\n                            conflicts.push(conflict);\n                        }\n                    }\n                }\n            }\n        }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "\tpub fn new(mask: bool) -> Receiver {\n    \t\tReceiver::new_with_limits(mask, DEFAULT_MAX_DATAFRAME_SIZE, DEFAULT_MAX_MESSAGE_SIZE)\n    \t}\n    \tpub fn new_with_limits(mask: bool, max_dataframe_size: usize, max_message_size: usize) -> Receiver {\n    \t\tlet max_dataframe_size: u32 = max_dataframe_size.min(u32::MAX as usize) as u32;\n    \t\tlet max_message_size: u32 = max_message_size.min(u32::MAX as usize) as u32;\n    \t\tReceiver {\n    \t\t\tbuffer: Vec::new(),\n    \t\t\tmask,\n    \t\t\tmax_dataframe_size,\n    \t\t\tmax_message_size,\n    \t\t}\n    \t}\n    fn recv_dataframe<R>(&mut self, reader: &mut R) -> WebSocketResult<DataFrame>\n    \twhere\n    \t\tR: Read,\n    \t{\n    \t\tDataFrame::read_dataframe_with_limit(reader, self.mask, self.max_dataframe_size as usize)\n    \t}\n    \tfn recv_message_dataframes<R>(&mut self, reader: &mut R) -> WebSocketResult<Vec<DataFrame>>\n    \twhere\n    \t\tR: Read,\n    \t{\n    \t\tlet mut current_message_length : usize = self.buffer.iter().map(|x|x.data.len()).sum();\n    \t\tlet mut finished = if self.buffer.is_empty() {\n    \t\t\tlet first = self.recv_dataframe(reader)?;\n    \t\t\tif first.opcode == Opcode::Continuation {\n    \t\t\t\treturn Err(WebSocketError::ProtocolError(\n    \t\t\t\t\t\"Unexpected continuation data frame opcode\",\n    \t\t\t\t));\n    \t\t\t}\n    \t\t\tlet finished = first.finished;\n    \t\t\tcurrent_message_length += first.data.len();\n    \t\t\tself.buffer.push(first);\n    \t\t\tfinished\n    \t\t} else {\n    \t\t\tfalse\n    \t\t};\n    \t\twhile !finished {\n    \t\t\tlet next = self.recv_dataframe(reader)?;\n    \t\t\tfinished = next.finished;\n    \t\t\tmatch next.opcode as u8 {\n    \t\t\t\t0 => {\n    \t\t\t\t\tcurrent_message_length += next.data.len();\n    \t\t\t\t\tself.buffer.push(next)\n    \t\t\t\t}\n    \t\t\t\t8..=15 => {\n    \t\t\t\t\treturn Ok(vec![next]);\n    \t\t\t\t}\n    \t\t\t\t_ => {\n    \t\t\t\t\treturn Err(WebSocketError::ProtocolError(\n    \t\t\t\t\t\t\"Unexpected data frame opcode\",\n    \t\t\t\t\t));\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tif !finished {\n    \t\t\t\tif self.buffer.len() >= MAX_DATAFRAMES_IN_ONE_MESSAGE {\n    \t\t\t\t\treturn Err(WebSocketError::ProtocolError(\n    \t\t\t\t\t\t\"Exceeded count of data frames in one WebSocket message\",\n    \t\t\t\t\t));\n    \t\t\t\t}\n    \t\t\t\tif current_message_length >= self.max_message_size as usize {\n    \t\t\t\t\treturn Err(WebSocketError::ProtocolError(\n    \t\t\t\t\t\t\"Exceeded maximum WebSocket message size\",\n    \t\t\t\t\t));\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tOk(::std::mem::replace(&mut self.buffer, Vec::new()))\n    \t}\n\tpub fn read_dataframe_with_limit<R>(reader: &mut R, should_be_masked: bool, limit: usize) -> WebSocketResult<Self>\n\twhere\n\t\tR: Read,\n\t{\n\t\tlet header = dfh::read_header(reader)?;\n\t\tif header.len > limit as u64 {\n\t\t\treturn Err(io::Error::new(io::ErrorKind::InvalidData, \"exceeded DataFrame length limit\").into());\n\t\t}\n\t\tlet mut data: Vec<u8> = Vec::with_capacity(header.len as usize);\n\t\tlet read = reader.take(header.len).read_to_end(&mut data)?;\n\t\tif (read as u64) < header.len {\n\t\t\treturn Err(io::Error::new(io::ErrorKind::UnexpectedEof, \"incomplete payload\").into());\n\t\t}\n\t\tDataFrame::read_dataframe_body(header, data, should_be_masked)\n\t}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn error_on_execution_failure(reason: &ExitReason, data: &[u8]) -> Result<()> {\n\tmatch reason {\n\t\tExitReason::Succeed(_) => Ok(()),\n\t\tExitReason::Error(e) => {\n\t\t\tif *e == ExitError::OutOfGas {\n\t\t\t\treturn Err(internal_err(\"out of gas\"));\n\t\t\t}\n\t\t\tErr(crate::internal_err_with_data(\n\t\t\t\tformat!(\"evm error: {:?}\", e),\n\t\t\t\t&[],\n\t\t\t))\n\t\t}\n\t\tExitReason::Revert(_) => {\n\t\t\tconst LEN_START: usize = 36;\n\t\t\tconst MESSAGE_START: usize = 68;\n\t\t\tlet mut message = \"VM Exception while processing transaction: revert\".to_string();\n\t\t\tif data.len() > MESSAGE_START {\n\t\t\t\tlet message_len =\n\t\t\t\t\tU256::from(&data[LEN_START..MESSAGE_START]).saturated_into::<usize>();\n\t\t\t\tlet message_end = MESSAGE_START.saturating_add(message_len);\n\t\t\t\tif data.len() >= message_end {\n\t\t\t\t\tlet body: &[u8] = &data[MESSAGE_START..message_end];\n\t\t\t\t\tif let Ok(reason) = std::str::from_utf8(body) {\n\t\t\t\t\t\tmessage = format!(\"{} {}\", message, reason);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tErr(crate::internal_err_with_data(message, data))\n\t\t}\n\t\tExitReason::Fatal(e) => Err(crate::internal_err_with_data(\n\t\t\tformat!(\"evm fatal: {:?}\", e),\n\t\t\t&[],\n\t\t)),\n\t}\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "Status RangeSize(const Tensor* start_t, const Tensor* limit_t,\n                 const Tensor* delta_t, InferenceContext* const c) {\n  T start = start_t->scalar<T>()();\n  T limit = limit_t->scalar<T>()();\n  T delta = delta_t->scalar<T>()();\n  if (start > limit && delta > T(0)) {\n    return errors::InvalidArgument(\n        \"Requires start <= limit when delta > 0: \", start, \"/\", limit);\n  }\n  if (start < limit && delta < T(0)) {\n    return errors::InvalidArgument(\n        \"Requires start >= limit when delta < 0: \", start, \"/\", limit);\n  }\n  if (delta == T(0)) {\n    return errors::InvalidArgument(\"Requires delta != 0\");\n  }\n  int64_t size;\n  if (std::is_integral<T>::value) {\n    size = Eigen::divup(static_cast<int64_t>(Eigen::numext::abs(limit - start)),\n                        static_cast<int64_t>(Eigen::numext::abs(delta)));\n  } else {\n    auto size_auto =\n        Eigen::numext::ceil(Eigen::numext::abs((limit - start) / delta));\n    if (size_auto > std::numeric_limits<int64_t>::max()) {\n      return errors::InvalidArgument(\"Requires ((limit - start) / delta) <= \",\n                                     std::numeric_limits<int64_t>::max());\n    }\n    size = static_cast<int64_t>(size_auto);\n  }\n  c->set_output(0, c->Vector(static_cast<int64_t>(size)));\n  return Status::OK();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn unpack_package(&self, pkg: PackageId, tarball: &File) -> CargoResult<PathBuf> {\n        let package_dir = format!(\"{}-{}\", pkg.name(), pkg.version());\n        let dst = self.src_path.join(&package_dir);\n        dst.create_dir()?;\n        let path = dst.join(PACKAGE_SOURCE_LOCK);\n        let path = self.config.assert_package_cache_locked(&path);\n        let unpack_dir = path.parent().unwrap();\n        if let Ok(meta) = path.metadata() {\n            if meta.len() > 0 {\n                return Ok(unpack_dir.to_path_buf());\n            }\n        }\n        let gz = GzDecoder::new(tarball);\n        let mut tar = Archive::new(gz);\n        let prefix = unpack_dir.file_name().unwrap();\n        let parent = unpack_dir.parent().unwrap();\n        for entry in tar.entries()? {\n            let mut entry = entry.with_context(|| \"failed to iterate over archive\")?;\n            let entry_path = entry\n                .path()\n                .with_context(|| \"failed to read entry path\")?\n                .into_owned();\n            if !entry_path.starts_with(prefix) {\n                anyhow::bail!(\n                    \"invalid tarball downloaded, contains \\\n                     a file at {:?} which isn't under {:?}\",\n                    entry_path,\n                    prefix\n                )\n            }\n            if entry_path\n                .file_name()\n                .map_or(false, |p| p == PACKAGE_SOURCE_LOCK)\n            {\n                continue;\n            }\n            let mut result = entry.unpack_in(parent).map_err(anyhow::Error::from);\n            if cfg!(windows) && restricted_names::is_windows_reserved_path(&entry_path) {\n                result = result.with_context(|| {\n                    format!(\n                        \"`{}` appears to contain a reserved Windows path, \\\n                        it cannot be extracted on Windows\",\n                        entry_path.display()\n                    )\n                });\n            }\n            result\n                .with_context(|| format!(\"failed to unpack entry at `{}`\", entry_path.display()))?;\n        }\n        let mut ok = OpenOptions::new()\n            .create_new(true)\n            .read(true)\n            .write(true)\n            .open(&path)\n            .with_context(|| format!(\"failed to open `{}`\", path.display()))?;\n        write!(ok, \"ok\")?;\n        Ok(unpack_dir.to_path_buf())\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn check_perms() {\n        super::message::info(\"Obtaining root permissions...\\n\");\n        let mut cmd = self::run_as_normal_user(\"/usr/bin/sudo\");\n        cmd.arg(\"true\");\n        if !cmd.spawn().unwrap().wait().unwrap().success() {\n            super::message::error(\"Couldn't obtain root permissions.\\n\");\n            quit::with_code(exitcode::USAGE);\n        }\n    }\npub fn run_as_normal_user<P: AsRef<super::OsStr>>(program: P) -> super::ProcCommand {\n        let mut cmd = super::ProcCommand::new(\"/usr/bin/sudo\");\n        cmd.args([\"-E\", \"-n\"]);\n        cmd.arg(format!(\"-u#{}\", *self::NORMAL_UID));\n        cmd.arg(\"--\");\n        cmd.arg(program);\n        cmd\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "async fn should_accept_forward(\n        &self,\n        info: &GossipRequest,\n        sender_key: Curve25519PublicKey,\n    ) -> Result<bool, CryptoStoreError> {\n        let device =\n            self.store.get_device_from_curve_key(&info.request_recipient, sender_key).await?;\n        if let Some(device) = device {\n            Ok(device.user_id() == self.user_id() && device.is_verified())\n        } else {\n            Ok(false)\n        }\n    }\nasync fn receive_supported_keys(\n        &self,\n        sender_key: Curve25519PublicKey,\n        event: &DecryptedForwardedRoomKeyEvent,\n        content: &ForwardedMegolmV1AesSha2Content,\n    ) -> Result<Option<InboundGroupSession>, CryptoStoreError> {\n        let algorithm = event.content.algorithm();\n        if let Some(info) = self.get_key_info(event).await? {\n            if self.should_accept_forward(&info, sender_key).await? {\n                self.accept_forwarded_room_key(&info, &event.sender, sender_key, algorithm, content)\n                    .await\n            } else {\n                warn!(\n                    sender = %event.sender,\n                    %sender_key,\n                    room_id = %content.room_id,\n                    session_id = content.session_id.as_str(),\n                    claimed_sender_key = %content.claimed_sender_key,\n                    \"Received a forwarded room key from an unknown device, or \\\n                     from a device that the key request recipient doesn't own\",\n                );\n                Ok(None)\n            }\n        } else {\n            warn!(\n                sender = %event.sender,\n                sender_key = %sender_key,\n                room_id = %content.room_id,\n                session_id = content.session_id.as_str(),\n                claimed_sender_key = %content.claimed_sender_key,\n                algorithm = %algorithm,\n                \"Received a forwarded room key that we didn't request\",\n            );\n            Ok(None)\n        }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub(crate) fn build(self) -> Auth {\n        self.auth\n    }\nfn canonicalized_resource(&self) -> Cow<'_, CanonicalizedResource> {\n        Cow::Borrowed(&self.canonicalized_resource)\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "function assert(cond, msg) {\n        if (!cond) {\n            throw Error(\"assertion failed: \" + msg)\n        }\n    }\n    function ecsign(d, z) {\n        assert(d != 0, \"d must not be 0\")\n        assert(z != 0, \"z must not be 0\")\n        while (true) {\n            const k = rnd(P)\n            const R = mulG(k)\n            if (R[0] == 0) continue\n            const s = mulmod(invmod(k, N), addmod(z, mulmod(R[0], d, N), N), N)\n            if (s == 0) continue\n            if (s.testn(255)) continue\n            return {r: toHex(R[0]), s: toHex(s), v: R[1].testn(0) ? 1 : 0}\n        }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "Status FractionalPoolShapeFn(InferenceContext* c) {\n  ShapeHandle input;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 4, &input));\n  std::vector<float> pooling_ratio;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"pooling_ratio\", &pooling_ratio));\n  if (pooling_ratio.size() != 4) {\n    return errors::InvalidArgument(\n        \"pooling_ratio field must specify 4 dimensions\");\n  }\n  std::vector<DimensionHandle> output_dims;\n  for (int i = 0; i < 4; ++i) {\n    DimensionHandle d = c->Dim(input, i);\n    if (c->ValueKnown(d)) {\n      auto val =\n          static_cast<int64_t>(std::floor(c->Value(d) / pooling_ratio[i]));\n      if (val < 0) {\n        return errors::InvalidArgument(\"Size computed for dim \", i,\n                                       \" is negative: \", val);\n      }\n      output_dims.push_back(c->MakeDim(val));\n    } else {\n      output_dims.push_back(c->UnknownDim());\n    }\n  }\n  for (std::size_t i = 0; i < pooling_ratio.size(); ++i) {\n    if (pooling_ratio[i] < 1) {\n      return errors::InvalidArgument(\n          \"pooling_ratio cannot be smaller than 1, got: \", pooling_ratio[i]);\n    }\n  }\n  c->set_output(0, c->MakeShape(output_dims));\n  c->set_output(1, c->Vector(output_dims[1]));\n  c->set_output(2, c->Vector(output_dims[2]));\n  return OkStatus();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "Status FractionalPoolShapeFn(InferenceContext* c) {\n  ShapeHandle input;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 4, &input));\n  std::vector<float> pooling_ratio;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"pooling_ratio\", &pooling_ratio));\n  if (pooling_ratio.size() != 4) {\n    return errors::InvalidArgument(\n        \"pooling_ratio field must specify 4 dimensions\");\n  }\n  std::vector<DimensionHandle> output_dims;\n  for (int i = 0; i < 4; ++i) {\n    DimensionHandle d = c->Dim(input, i);\n    if (c->ValueKnown(d)) {\n      auto val =\n          static_cast<int64_t>(std::floor(c->Value(d) / pooling_ratio[i]));\n      if (val < 0) {\n        return errors::InvalidArgument(\"Size computed for dim \", i,\n                                       \" is negative: \", val);\n      }\n      output_dims.push_back(c->MakeDim(val));\n    } else {\n      output_dims.push_back(c->UnknownDim());\n    }\n  }\n  for (std::size_t i = 0; i < pooling_ratio.size(); ++i) {\n    if (pooling_ratio[i] < 1) {\n      return errors::InvalidArgument(\n          \"pooling_ratio cannot be smaller than 1, got: \", pooling_ratio[i]);\n    }\n  }\n  c->set_output(0, c->MakeShape(output_dims));\n  c->set_output(1, c->Vector(output_dims[1]));\n  c->set_output(2, c->Vector(output_dims[2]));\n  return OkStatus();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn get_apk_signature(apk: &str) -> Result<(u32, String)> {\n    let mut buffer = [0u8; 0x10];\n    let mut size4 = [0u8; 4];\n    let mut size8 = [0u8; 8];\n    let mut size_of_block = [0u8; 8];\n    let mut f = std::fs::File::open(apk)?;\n    let mut i = 0;\n    loop {\n        let mut n = [0u8; 2];\n        f.seek(SeekFrom::End(-i - 2))?;\n        f.read_exact(&mut n)?;\n        let n = u16::from_le_bytes(n);\n        if i64::from(n) == i {\n            f.seek(SeekFrom::Current(-22))?;\n            f.read_exact(&mut size4)?;\n            if u32::from_le_bytes(size4) ^ 0xcafe_babe_u32 == 0xccfb_f1ee_u32 {\n                if i > 0 {\n                    println!(\"warning: comment length is {i}\");\n                }\n                break;\n            }\n        }\n        ensure!(n != 0xffff, \"not a zip file\");\n        i += 1;\n    }\n    f.seek(SeekFrom::Current(12))?;\n    f.read_exact(&mut size4)?;\n    f.seek(SeekFrom::Start(u64::from(u32::from_le_bytes(size4)) - 0x18))?;\n    f.read_exact(&mut size8)?;\n    f.read_exact(&mut buffer)?;\n    ensure!(&buffer == b\"APK Sig Block 42\", \"Can not found sig block\");\n    let pos = u64::from(u32::from_le_bytes(size4)) - (u64::from_le_bytes(size8) + 0x8);\n    f.seek(SeekFrom::Start(pos))?;\n    f.read_exact(&mut size_of_block)?;\n    ensure!(size_of_block == size8, \"not a signed apk\");\n    let mut v2_signing: Option<(u32, String)> = None;\n    let mut v3_signing: Option<(u32, String)> = None;\n    loop {\n        let mut id = [0u8; 4];\n        let mut offset = 4u32;\n        f.read_exact(&mut size8)?; \n        if size8 == size_of_block {\n            break;\n        }\n        f.read_exact(&mut id)?; \n        let id = u32::from_le_bytes(id);\n        if id == 0x7109_871a_u32 {\n            v2_signing = Some(calc_cert_sha256(&mut f, &mut size4, &mut offset)?);\n        } else if id == 0xf053_68c0_u32 {\n            v3_signing = Some(calc_cert_sha256(&mut f, &mut size4, &mut offset)?);\n        }\n        f.seek(SeekFrom::Current(\n            i64::from_le_bytes(size8) - i64::from(offset),\n        ))?;\n    }\n    match (v2_signing, v3_signing) {\n        (None, Some(s)) => Ok(s),\n        (Some(s), None) => Ok(s),\n        (Some(s1), Some(s2)) => {\n            if s1 == s2 {\n                Ok(s1)\n            } else {\n                Err(anyhow::anyhow!(\n                    \"Inconsisent signature, v2: {}, v3: {}!\",\n                    s1.1,\n                    s2.1\n                ))\n            }\n        }\n        _ => Err(anyhow::anyhow!(\"Unknown signature!\")),\n    }\n}\nfn calc_cert_sha256(\n    f: &mut std::fs::File,\n    size4: &mut [u8; 4],\n    offset: &mut u32,\n) -> Result<(u32, String)> {\n    f.read_exact(size4)?; \n    f.read_exact(size4)?; \n    f.read_exact(size4)?; \n    *offset += 0x4 * 3;\n    f.read_exact(size4)?; \n    let pos = u32::from_le_bytes(*size4); \n    f.seek(SeekFrom::Current(i64::from(pos)))?;\n    *offset += 0x4 + pos;\n    f.read_exact(size4)?; \n    f.read_exact(size4)?; \n    *offset += 0x4 * 2;\n    let cert_len = u32::from_le_bytes(*size4);\n    let mut cert: Vec<u8> = vec![0; cert_len as usize];\n    f.read_exact(&mut cert)?;\n    *offset += cert_len;\n    Ok((cert_len, sha256::digest(&cert)))\n}\npub fn get_apk_signature(apk: &str) -> Result<(u32, String)> {\n    let mut buffer = [0u8; 0x10];\n    let mut size4 = [0u8; 4];\n    let mut size8 = [0u8; 8];\n    let mut size_of_block = [0u8; 8];\n    let mut f = std::fs::File::open(apk)?;\n    let mut i = 0;\n    loop {\n        let mut n = [0u8; 2];\n        f.seek(SeekFrom::End(-i - 2))?;\n        f.read_exact(&mut n)?;\n        let n = u16::from_le_bytes(n);\n        if i64::from(n) == i {\n            f.seek(SeekFrom::Current(-22))?;\n            f.read_exact(&mut size4)?;\n            if u32::from_le_bytes(size4) ^ 0xcafe_babe_u32 == 0xccfb_f1ee_u32 {\n                if i > 0 {\n                    println!(\"warning: comment length is {i}\");\n                }\n                break;\n            }\n        }\n        ensure!(n != 0xffff, \"not a zip file\");\n        i += 1;\n    }\n    f.seek(SeekFrom::Current(12))?;\n    f.read_exact(&mut size4)?;\n    f.seek(SeekFrom::Start(u64::from(u32::from_le_bytes(size4)) - 0x18))?;\n    f.read_exact(&mut size8)?;\n    f.read_exact(&mut buffer)?;\n    ensure!(&buffer == b\"APK Sig Block 42\", \"Can not found sig block\");\n    let pos = u64::from(u32::from_le_bytes(size4)) - (u64::from_le_bytes(size8) + 0x8);\n    f.seek(SeekFrom::Start(pos))?;\n    f.read_exact(&mut size_of_block)?;\n    ensure!(size_of_block == size8, \"not a signed apk\");\n    let mut v2_signing: Option<(u32, String)> = None;\n    let mut v3_signing: Option<(u32, String)> = None;\n    loop {\n        let mut id = [0u8; 4];\n        let mut offset = 4u32;\n        f.read_exact(&mut size8)?; \n        if size8 == size_of_block {\n            break;\n        }\n        f.read_exact(&mut id)?; \n        let id = u32::from_le_bytes(id);\n        if id == 0x7109_871a_u32 {\n            v2_signing = Some(calc_cert_sha256(&mut f, &mut size4, &mut offset)?);\n        } else if id == 0xf053_68c0_u32 {\n            v3_signing = Some(calc_cert_sha256(&mut f, &mut size4, &mut offset)?);\n        }\n        f.seek(SeekFrom::Current(\n            i64::from_le_bytes(size8) - i64::from(offset),\n        ))?;\n    }\n    match (v2_signing, v3_signing) {\n        (None, Some(s)) => Ok(s),\n        (Some(s), None) => Ok(s),\n        (Some(s1), Some(s2)) => {\n            if s1 == s2 {\n                Ok(s1)\n            } else {\n                Err(anyhow::anyhow!(\n                    \"Inconsisent signature, v2: {}, v3: {}!\",\n                    s1.1,\n                    s2.1\n                ))\n            }\n        }\n        _ => Err(anyhow::anyhow!(\"Unknown signature!\")),\n    }\n}\npub fn run() -> Result<()> {\n    #[cfg(target_os = \"android\")]\n    android_logger::init_once(\n        Config::default()\n            .with_max_level(LevelFilter::Trace) \n            .with_tag(\"KernelSU\"), \n    );\n    #[cfg(not(target_os = \"android\"))]\n    env_logger::init();\n    let arg0 = std::env::args().next().unwrap_or_default();\n    if arg0 == \"su\" || arg0 == \"/system/bin/su\" {\n        return crate::ksu::root_shell();\n    }\n    let cli = Args::parse();\n    log::info!(\"command: {:?}\", cli.command);\n    let result = match cli.command {\n        Commands::PostFsData => event::on_post_data_fs(),\n        Commands::BootCompleted => event::on_boot_completed(),\n        Commands::Module { command } => {\n            #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n            {\n                utils::switch_mnt_ns(1)?;\n                utils::unshare_mnt_ns()?;\n            }\n            match command {\n                Module::Install { zip } => module::install_module(&zip),\n                Module::Uninstall { id } => module::uninstall_module(&id),\n                Module::Enable { id } => module::enable_module(&id),\n                Module::Disable { id } => module::disable_module(&id),\n                Module::List => module::list_modules(),\n            }\n        }\n        Commands::Install => event::install(),\n        Commands::Sepolicy { command } => match command {\n            Sepolicy::Patch { sepolicy } => crate::sepolicy::live_patch(&sepolicy),\n            Sepolicy::Apply { file } => crate::sepolicy::apply_file(file),\n            Sepolicy::Check { sepolicy } => crate::sepolicy::check_rule(&sepolicy),\n        },\n        Commands::Services => event::on_services(),\n        Commands::Profile { command } => match command {\n            Profile::GetSepolicy { package } => crate::profile::get_sepolicy(package),\n            Profile::SetSepolicy { package, policy } => {\n                crate::profile::set_sepolicy(package, policy)\n            }\n            Profile::GetTemplate { package } => crate::profile::get_template(package),\n            Profile::SetTemplate { package, template } => {\n                crate::profile::set_template(package, template)\n            }\n            Profile::ListTemplates => crate::profile::list_templates(),\n        },\n        Commands::Debug { command } => match command {\n            Debug::SetManager { apk } => debug::set_manager(&apk),\n            Debug::GetSign { apk } => {\n                let sign = apk_sign::get_apk_signature(&apk)?;\n                println!(\"size: {:#x}, hash: {}\", sign.0, sign.1);\n                Ok(())\n            }\n            Debug::Version => {\n                println!(\"Kernel Version: {}\", crate::ksu::get_version());\n                Ok(())\n            }\n            Debug::Su => crate::ksu::grant_root(),\n            Debug::Mount => event::mount_systemlessly(defs::MODULE_DIR),\n            Debug::Test => todo!(),\n        },\n    };\n    if let Err(e) = &result {\n        log::error!(\"Error: {:?}\", e);\n    }\n    result\n}\nfn set_kernel_param(size: u32, hash: String) -> Result<()> {\n    let kernel_param_path = Path::new(KERNEL_PARAM_PATH).join(\"parameters\");\n    let expeced_size_path = kernel_param_path.join(\"ksu_expected_size\");\n    let expeced_hash_path = kernel_param_path.join(\"ksu_expected_hash\");\n    println!(\n        \"before size: {:#x} hash: {}\",\n        read_u32(&expeced_size_path)?,\n        std::fs::read_to_string(&expeced_hash_path)?\n    );\n    std::fs::write(&expeced_size_path, size.to_string())?;\n    std::fs::write(&expeced_hash_path, hash)?;\n    println!(\n        \"after size: {:#x} hash: {}\",\n        read_u32(&expeced_size_path)?,\n        std::fs::read_to_string(&expeced_hash_path)?\n    );\n    Ok(())\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn pipe_mode(&mut self, pipe_mode: PipeMode) -> &mut Self {\n        let is_msg = matches!(pipe_mode, PipeMode::Message);\n        bool_flag!(self.pipe_mode, is_msg, winbase::PIPE_TYPE_MESSAGE);\n        self\n    }\n#[test]\n    fn opts_default_pipe_mode() {\n        let opts = ServerOptions::new();\n        assert_eq!(opts.pipe_mode, PIPE_TYPE_BYTE | PIPE_REJECT_REMOTE_CLIENTS);\n    }\n    #[test]\n    fn opts_unset_reject_remote() {\n        let mut opts = ServerOptions::new();\n        opts.reject_remote_clients(false);\n        assert_eq!(opts.pipe_mode & PIPE_REJECT_REMOTE_CLIENTS, 0);\n    }\n    #[test]\n    fn opts_set_pipe_mode_maintains_reject_remote_clients() {\n        let mut opts = ServerOptions::new();\n        opts.pipe_mode(PipeMode::Byte);\n        assert_eq!(opts.pipe_mode, PIPE_TYPE_BYTE | PIPE_REJECT_REMOTE_CLIENTS);\n        opts.reject_remote_clients(false);\n        opts.pipe_mode(PipeMode::Byte);\n        assert_eq!(opts.pipe_mode, PIPE_TYPE_BYTE);\n        opts.reject_remote_clients(true);\n        opts.pipe_mode(PipeMode::Byte);\n        assert_eq!(opts.pipe_mode, PIPE_TYPE_BYTE | PIPE_REJECT_REMOTE_CLIENTS);\n        opts.reject_remote_clients(false);\n        opts.pipe_mode(PipeMode::Message);\n        assert_eq!(opts.pipe_mode, PIPE_TYPE_MESSAGE);\n        opts.reject_remote_clients(true);\n        opts.pipe_mode(PipeMode::Message);\n        assert_eq!(\n            opts.pipe_mode,\n            PIPE_TYPE_MESSAGE | PIPE_REJECT_REMOTE_CLIENTS\n        );\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn shuffle_0_31_mask(&mut self, mask: &VecMask) -> VCodeConstant {\n        let mask = mask\n            .iter()\n            .map(|&b| if b > 15 { b.wrapping_sub(16) } else { b })\n            .map(|b| if b > 15 { 0b10000000 } else { b })\n            .collect();\n        self.lower_ctx\n            .use_constant(VCodeConstantData::Generated(mask))\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn generate_private_key(&mut self, is_server: bool) -> BigUint {\n        let q = (&self.prime_num - &BigUint::from(1u8)) / &BigUint::from(2u8);\n        let mut rng = rand::thread_rng();\n        self.private_key = rng.gen_biguint_range(\n            &if is_server {\n                1u8.into()\n            } else {\n                2u8.into()\n            },\n            &q,\n        );\n        self.private_key.clone()\n    }\npub fn validate_shared_secret(&self, shared_secret: &BigUint) -> bool {\n        let one = BigUint::from(1u8);\n        let prime_minus_one = &self.prime_num - &one;\n        shared_secret > &one && shared_secret < &prime_minus_one\n    }\npub fn validate_public_key(&self, public_key: &BigUint) -> bool {\n        let one = BigUint::from(1u8);\n        let prime_minus_one = &self.prime_num - &one;\n        public_key > &one && public_key < &prime_minus_one\n    }\nuse log::debug;\n#[doc(hidden)]\n    fn server_dh(&mut self, exchange: &mut Exchange, payload: &[u8]) -> Result<(), crate::Error> {\n        debug!(\"server_dh\");\n        let client_pubkey = {\n            if payload.first() != Some(&msg::KEX_ECDH_INIT) {\n                return Err(crate::Error::Inconsistent);\n            }\n            #[allow(clippy::indexing_slicing)] \n            let pubkey_len = BigEndian::read_u32(&payload[1..]) as usize;\n            if payload.len() < 5 + pubkey_len {\n                return Err(crate::Error::Inconsistent);\n            }\n            &payload\n                .get(5..(5 + pubkey_len))\n                .ok_or(crate::Error::Inconsistent)?\n        };\n        debug!(\"client_pubkey: {:?}\", client_pubkey);\n        self.dh.generate_private_key(true);\n        let server_pubkey = &self.dh.generate_public_key();\n        if !self.dh.validate_public_key(server_pubkey) {\n            return Err(crate::Error::Inconsistent);\n        }\n        let encoded_server_pubkey = biguint_to_mpint(server_pubkey);\n        exchange.server_ephemeral.clear();\n        exchange.server_ephemeral.extend(&encoded_server_pubkey);\n        let decoded_client_pubkey = DH::decode_public_key(client_pubkey);\n        if !self.dh.validate_public_key(&decoded_client_pubkey) {\n            return Err(crate::Error::Inconsistent);\n        }\n        let shared = self.dh.compute_shared_secret(decoded_client_pubkey);\n        if !self.dh.validate_shared_secret(&shared) {\n            return Err(crate::Error::Inconsistent);\n        }\n        self.shared_secret = Some(biguint_to_mpint(&shared));\n        Ok(())\n    }\n#[doc(hidden)]\n    fn client_dh(\n        &mut self,\n        client_ephemeral: &mut CryptoVec,\n        buf: &mut CryptoVec,\n    ) -> Result<(), crate::Error> {\n        self.dh.generate_private_key(false);\n        let client_pubkey = &self.dh.generate_public_key();\n        if !self.dh.validate_public_key(client_pubkey) {\n            return Err(crate::Error::Inconsistent);\n        }\n        let encoded_pubkey = biguint_to_mpint(client_pubkey);\n        client_ephemeral.clear();\n        client_ephemeral.extend(&encoded_pubkey);\n        buf.push(msg::KEX_ECDH_INIT);\n        buf.extend_ssh_string(&encoded_pubkey);\n        Ok(())\n    }\n    fn compute_shared_secret(&mut self, remote_pubkey_: &[u8]) -> Result<(), crate::Error> {\n        let remote_pubkey = DH::decode_public_key(remote_pubkey_);\n        if !self.dh.validate_public_key(&remote_pubkey) {\n            return Err(crate::Error::Inconsistent);\n        }\n        let shared = self.dh.compute_shared_secret(remote_pubkey);\n        if !self.dh.validate_shared_secret(&shared) {\n            return Err(crate::Error::Inconsistent);\n        }\n        self.shared_secret = Some(biguint_to_mpint(&shared));\n        Ok(())\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn calculate_gas_cost(\n\tbase_length: u64,\n\tmod_length: u64,\n\texponent: &BigUint,\n\texponent_bytes: &[u8],\n\tmod_is_even: bool,\n) -> u64 {\n\tfn calculate_multiplication_complexity(base_length: u64, mod_length: u64) -> u64 {\n\t\tlet max_length = max(base_length, mod_length);\n\t\tlet mut words = max_length / 8;\n\t\tif max_length % 8 > 0 {\n\t\t\twords += 1;\n\t\t}\n\t\twords * words\n\t}\n\tfn calculate_iteration_count(exponent: &BigUint, exponent_bytes: &[u8]) -> u64 {\n\t\tlet mut iteration_count: u64 = 0;\n\t\tlet exp_length = exponent_bytes.len() as u64;\n\t\tif exp_length <= 32 && exponent.is_zero() {\n\t\t\titeration_count = 0;\n\t\t} else if exp_length <= 32 {\n\t\t\titeration_count = exponent.bits() - 1;\n\t\t} else if exp_length > 32 {\n\t\t\tlet exponent_head = BigUint::from_bytes_be(&exponent_bytes[..32]);\n\t\t\titeration_count = (8 * (exp_length - 32)) + exponent_head.bits() - 1;\n\t\t}\n\t\tmax(iteration_count, 1)\n\t}\n\tlet multiplication_complexity = calculate_multiplication_complexity(base_length, mod_length);\n\tlet iteration_count = calculate_iteration_count(exponent, exponent_bytes);\n\tmax(\n\t\tMIN_GAS_COST,\n\t\tmultiplication_complexity * iteration_count / 3,\n\t)\n\t.saturating_mul(if mod_is_even { 20 } else { 1 })\n}\nfn execute(handle: &mut impl PrecompileHandle) -> PrecompileResult {\n\t\tlet input = handle.input();\n\t\tlet mut input_offset = 0;\n\t\tlet mut base_len_buf = [0u8; 32];\n\t\tread_input(input, &mut base_len_buf, &mut input_offset);\n\t\tlet mut exp_len_buf = [0u8; 32];\n\t\tread_input(input, &mut exp_len_buf, &mut input_offset);\n\t\tlet mut mod_len_buf = [0u8; 32];\n\t\tread_input(input, &mut mod_len_buf, &mut input_offset);\n\t\tlet max_size_big = BigUint::from_u32(1024).expect(\"can't create BigUint\");\n\t\tlet base_len_big = BigUint::from_bytes_be(&base_len_buf);\n\t\tif base_len_big > max_size_big {\n\t\t\treturn Err(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"unreasonably large base length\".into()),\n\t\t\t});\n\t\t}\n\t\tlet exp_len_big = BigUint::from_bytes_be(&exp_len_buf);\n\t\tif exp_len_big > max_size_big {\n\t\t\treturn Err(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"unreasonably large exponent length\".into()),\n\t\t\t});\n\t\t}\n\t\tlet mod_len_big = BigUint::from_bytes_be(&mod_len_buf);\n\t\tif mod_len_big > max_size_big {\n\t\t\treturn Err(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"unreasonably large modulus length\".into()),\n\t\t\t});\n\t\t}\n\t\tlet base_len = base_len_big.to_usize().expect(\"base_len out of bounds\");\n\t\tlet exp_len = exp_len_big.to_usize().expect(\"exp_len out of bounds\");\n\t\tlet mod_len = mod_len_big.to_usize().expect(\"mod_len out of bounds\");\n\t\tif mod_len == 0 {\n\t\t\treturn Ok(PrecompileOutput {\n\t\t\t\texit_status: ExitSucceed::Returned,\n\t\t\t\toutput: vec![],\n\t\t\t});\n\t\t}\n\t\tlet r = if base_len == 0 && mod_len == 0 {\n\t\t\thandle.record_cost(MIN_GAS_COST)?;\n\t\t\tBigUint::zero()\n\t\t} else {\n\t\t\tlet mut base_buf = vec![0u8; base_len];\n\t\t\tread_input(input, &mut base_buf, &mut input_offset);\n\t\t\tlet base = BigUint::from_bytes_be(&base_buf);\n\t\t\tlet mut exp_buf = vec![0u8; exp_len];\n\t\t\tread_input(input, &mut exp_buf, &mut input_offset);\n\t\t\tlet exponent = BigUint::from_bytes_be(&exp_buf);\n\t\t\tlet mut mod_buf = vec![0u8; mod_len];\n\t\t\tread_input(input, &mut mod_buf, &mut input_offset);\n\t\t\tlet modulus = BigUint::from_bytes_be(&mod_buf);\n\t\t\tlet gas_cost = calculate_gas_cost(\n\t\t\t\tbase_len as u64,\n\t\t\t\tmod_len as u64,\n\t\t\t\t&exponent,\n\t\t\t\t&exp_buf,\n\t\t\t\tmodulus.is_even(),\n\t\t\t);\n\t\t\thandle.record_cost(gas_cost)?;\n\t\t\tif modulus.is_zero() || modulus.is_one() {\n\t\t\t\tBigUint::zero()\n\t\t\t} else {\n\t\t\t\tbase.modpow(&exponent, &modulus)\n\t\t\t}\n\t\t};\n\t\tlet bytes = r.to_bytes_be();\n\t\tif bytes.len() == mod_len {\n\t\t\tOk(PrecompileOutput {\n\t\t\t\texit_status: ExitSucceed::Returned,\n\t\t\t\toutput: bytes.to_vec(),\n\t\t\t})\n\t\t} else if bytes.len() < mod_len {\n\t\t\tlet mut ret = Vec::with_capacity(mod_len);\n\t\t\tret.extend(core::iter::repeat(0).take(mod_len - bytes.len()));\n\t\t\tret.extend_from_slice(&bytes[..]);\n\t\t\tOk(PrecompileOutput {\n\t\t\t\texit_status: ExitSucceed::Returned,\n\t\t\t\toutput: ret.to_vec(),\n\t\t\t})\n\t\t} else {\n\t\t\tErr(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"failed\".into()),\n\t\t\t})\n\t\t}\n\t}\nfn test_long_exp_gas_cost_matches_specs() {\n\t\tlet input = vec![\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t16, 0, 0, 0, 255, 255, 255, 2, 0, 0, 179, 0, 0, 2, 0, 0, 122, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 255, 251, 0, 0, 0, 0, 4, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 255, 255, 255, 2, 0, 0, 179, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255,\n\t\t\t255, 255, 255, 249,\n\t\t];\n\t\tlet context: Context = Context {\n\t\t\taddress: Default::default(),\n\t\t\tcaller: Default::default(),\n\t\t\tapparent_value: From::from(0),\n\t\t};\n\t\tlet mut handle = MockHandle::new(input, Some(100_000), context);\n\t\tlet _ = Modexp::execute(&mut handle).expect(\"Modexp::execute() returned error\");\n\t\tassert_eq!(handle.gas_used, 7104 * 20); \n\t}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn deserialize<R: std::io::Read>(\n        reader: &mut R,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<Self> {\n        let header = T::deserialize(reader, version_map, app_version)\n            .map_err(|ref err| VersionizeError::Deserialize(format!(\"{:?}\", err)))?;\n        let entries: Vec<<T as FamStruct>::Entry> =\n            Vec::deserialize(reader, version_map, app_version)\n                .map_err(|ref err| VersionizeError::Deserialize(format!(\"{:?}\", err)))?;\n        if header.len() != entries.len() {\n            let msg = format!(\n                \"Mismatch between length of FAM specified in FamStruct header ({}) \\\n                and actual size of FAM ({})\",\n                header.len(),\n                entries.len()\n            );\n            return Err(VersionizeError::Deserialize(msg));\n        }\n        let mut object = FamStructWrapper::from_entries(&entries)\n            .map_err(|ref err| VersionizeError::Deserialize(format!(\"{:?}\", err)))?;\n        *object.as_mut_fam_struct() = header;\n        Ok(object)\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn try_static_init(&mut self, page_size: u64, max_image_size_always_allowed: u64) {\n        if !self.module.memory_initialization.is_segmented() {\n            return;\n        }\n        struct Memory {\n            data_size: u64,\n            min_addr: u64,\n            max_addr: u64,\n            segments: Vec<(usize, StaticMemoryInitializer)>,\n        }\n        let mut info = PrimaryMap::with_capacity(self.module.memory_plans.len());\n        for _ in 0..self.module.memory_plans.len() {\n            info.push(Memory {\n                data_size: 0,\n                min_addr: u64::MAX,\n                max_addr: 0,\n                segments: Vec::new(),\n            });\n        }\n        let mut idx = 0;\n        let ok = self.module.memory_initialization.init_memory(\n            &mut (),\n            InitMemory::CompileTime(&self.module),\n            |(), memory, init| {\n                if self.module.defined_memory_index(memory).is_none() {\n                    return false;\n                };\n                let info = &mut info[memory];\n                let data_len = u64::from(init.data.end - init.data.start);\n                if data_len > 0 {\n                    info.data_size += data_len;\n                    info.min_addr = info.min_addr.min(init.offset);\n                    info.max_addr = info.max_addr.max(init.offset + data_len);\n                    info.segments.push((idx, init.clone()));\n                }\n                idx += 1;\n                true\n            },\n        );\n        if !ok {\n            return;\n        }\n        for info in info.values().filter(|i| i.data_size > 0) {\n            let image_size = info.max_addr - info.min_addr;\n            if image_size < info.data_size.saturating_mul(2) {\n                continue;\n            }\n            if image_size < max_image_size_always_allowed {\n                continue;\n            }\n            return;\n        }\n        let data = mem::replace(&mut self.data, Vec::new());\n        let mut map = PrimaryMap::with_capacity(info.len());\n        let mut module_data_size = 0u32;\n        for (memory, info) in info.iter() {\n            let extent = if info.segments.len() > 0 {\n                (info.max_addr - info.min_addr) as usize\n            } else {\n                0\n            };\n            let mut image = Vec::with_capacity(extent);\n            for (idx, init) in info.segments.iter() {\n                let data = &data[*idx];\n                assert_eq!(data.len(), init.data.len());\n                let offset = usize::try_from(init.offset - info.min_addr).unwrap();\n                if image.len() < offset {\n                    image.resize(offset, 0u8);\n                    image.extend_from_slice(data);\n                } else {\n                    image.splice(\n                        offset..(offset + data.len()).min(image.len()),\n                        data.iter().copied(),\n                    );\n                }\n            }\n            assert_eq!(image.len(), extent);\n            assert_eq!(image.capacity(), extent);\n            let mut offset = if info.segments.len() > 0 {\n                info.min_addr\n            } else {\n                0\n            };\n            if let Some(i) = image.iter().rposition(|i| *i != 0) {\n                image.truncate(i + 1);\n            }\n            if let Some(i) = image.iter().position(|i| *i != 0) {\n                offset += i as u64;\n                image.drain(..i);\n            }\n            let mut len = u64::try_from(image.len()).unwrap();\n            if offset % page_size != 0 {\n                let zero_padding = offset % page_size;\n                self.data.push(vec![0; zero_padding as usize].into());\n                offset -= zero_padding;\n                len += zero_padding;\n            }\n            self.data.push(image.into());\n            if len % page_size != 0 {\n                let zero_padding = page_size - (len % page_size);\n                self.data.push(vec![0; zero_padding as usize].into());\n                len += zero_padding;\n            }\n            assert!(offset % page_size == 0);\n            assert!(len % page_size == 0);\n            let len = u32::try_from(len).unwrap();\n            let init = if len > 0 {\n                Some(StaticMemoryInitializer {\n                    offset,\n                    data: module_data_size..module_data_size + len,\n                })\n            } else {\n                None\n            };\n            let idx = map.push(init);\n            assert_eq!(idx, memory);\n            module_data_size += len;\n        }\n        self.data_align = Some(page_size);\n        self.module.memory_initialization = MemoryInitialization::Static { map };\n    }\npub fn init_memory(\n        &self,\n        state: &mut T,\n        init: InitMemory<'_, T>,\n        mut write: impl FnMut(&mut T, MemoryIndex, &StaticMemoryInitializer) -> bool,\n    ) -> bool {\n        let initializers = match self {\n            MemoryInitialization::Segmented(list) => list,\n            MemoryInitialization::Static { map } => {\n                for (index, init) in map {\n                    if let Some(init) = init {\n                        let result = write(state, index, init);\n                        if !result {\n                            return result;\n                        }\n                    }\n                }\n                return true;\n            }\n        };\n        for initializer in initializers {\n            let MemoryInitializer {\n                memory_index,\n                base,\n                offset,\n                ref data,\n            } = *initializer;\n            let base = match base {\n                Some(index) => match &init {\n                    InitMemory::Runtime {\n                        get_global_as_u64, ..\n                    } => get_global_as_u64(state, index),\n                    InitMemory::CompileTime(_) => return false,\n                },\n                None => 0,\n            };\n            let start = match base.checked_add(offset) {\n                Some(start) => start,\n                None => return false,\n            };\n            let len = u64::try_from(data.len()).unwrap();\n            let end = match start.checked_add(len) {\n                Some(end) => end,\n                None => return false,\n            };\n            let cur_size_in_pages = match &init {\n                InitMemory::CompileTime(module) => module.memory_plans[memory_index].memory.minimum,\n                InitMemory::Runtime {\n                    memory_size_in_pages,\n                    ..\n                } => memory_size_in_pages(state, memory_index),\n            };\n            if let Some(max) = cur_size_in_pages.checked_mul(u64::from(WASM_PAGE_SIZE)) {\n                if end > max {\n                    return false;\n                }\n            }\n            let init = StaticMemoryInitializer {\n                offset: start,\n                data: data.clone(),\n            };\n            let result = write(state, memory_index, &init);\n            if !result {\n                return result;\n            }\n        }\n        return true;\n    }\npub enum InitMemory<'a, T> {\n    CompileTime(&'a Module),\n    Runtime {\n        memory_size_in_pages: &'a dyn Fn(&mut T, MemoryIndex) -> u64,\n        get_global_as_u64: &'a dyn Fn(&mut T, GlobalIndex) -> u64,\n    },\n}\n    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *const T {\n        (std::ptr::addr_of!(self.vmctx).cast::<u8>())\n            .add(usize::try_from(offset).unwrap())\n            .cast()\n    }\n    unsafe fn vmctx_plus_offset_mut<T>(&mut self, offset: u32) -> *mut T {\n        (std::ptr::addr_of_mut!(self.vmctx).cast::<u8>())\n            .add(usize::try_from(offset).unwrap())\n            .cast()\n    }\n    fn table(&mut self, index: DefinedTableIndex) -> VMTableDefinition {\n        unsafe { *self.table_ptr(index) }\n    }\n    fn set_table(&mut self, index: DefinedTableIndex, table: VMTableDefinition) {\n        unsafe {\n            *self.table_ptr(index) = table;\n        }\n    }\n    fn table_ptr(&mut self, index: DefinedTableIndex) -> *mut VMTableDefinition {\n        unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_vmtable_definition(index)) }\n    }\n    fn global(&mut self, index: DefinedGlobalIndex) -> &VMGlobalDefinition {\n        unsafe { &*self.global_ptr(index) }\n    }\n    fn global_ptr(&mut self, index: DefinedGlobalIndex) -> *mut VMGlobalDefinition {\n        unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_vmglobal_definition(index)) }\n    }\n    pub(crate) fn defined_or_imported_global_ptr(\n        &mut self,\n        index: GlobalIndex,\n    ) -> *mut VMGlobalDefinition {\n        if let Some(index) = self.module().defined_global_index(index) {\n            self.global_ptr(index)\n        } else {\n            self.imported_global(index).from\n        }\n    }\n    pub fn runtime_limits(&mut self) -> *mut *const VMRuntimeLimits {\n        unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_runtime_limits()) }\n    }\n    pub fn epoch_ptr(&mut self) -> *mut *const AtomicU64 {\n        unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_epoch_ptr()) }\n    }\n    pub fn externref_activations_table(&mut self) -> *mut *mut VMExternRefActivationsTable {\n        unsafe { self.vmctx_plus_offset_mut(self.offsets().vmctx_externref_activations_table()) }\n    }\npub unsafe fn set_store(&mut self, store: Option<*mut dyn Store>) {\n        if let Some(store) = store {\n            *self.vmctx_plus_offset_mut(self.offsets().vmctx_store()) = store;\n            *self.runtime_limits() = (*store).vmruntime_limits();\n            *self.epoch_ptr() = (*store).epoch_ptr();\n            *self.externref_activations_table() = (*store).externref_activations_table().0;\n        } else {\n            assert_eq!(\n                mem::size_of::<*mut dyn Store>(),\n                mem::size_of::<[*mut (); 2]>()\n            );\n            *self.vmctx_plus_offset_mut::<[*mut (); 2]>(self.offsets().vmctx_store()) =\n                [ptr::null_mut(), ptr::null_mut()];\n            *self.runtime_limits() = ptr::null_mut();\n            *self.epoch_ptr() = ptr::null_mut();\n            *self.externref_activations_table() = ptr::null_mut();\n        }\n    }\n    pub(crate) unsafe fn set_callee(&mut self, callee: Option<NonNull<VMFunctionBody>>) {\n        *self.vmctx_plus_offset_mut(self.offsets().vmctx_callee()) =\n            callee.map_or(ptr::null_mut(), |c| c.as_ptr());\n    }\n    unsafe fn table_index(&mut self, table: &VMTableDefinition) -> DefinedTableIndex {\n        let index = DefinedTableIndex::new(\n            usize::try_from(\n                (table as *const VMTableDefinition)\n                    .offset_from(self.table_ptr(DefinedTableIndex::new(0))),\n            )\n            .unwrap(),\n        );\n        assert!(index.index() < self.tables.len());\n        index\n    }\nfn construct_anyfunc(\n        &mut self,\n        index: FuncIndex,\n        sig: SignatureIndex,\n        into: *mut VMCallerCheckedFuncRef,\n    ) {\n        let type_index = unsafe {\n            let base: *const VMSharedSignatureIndex =\n                *self.vmctx_plus_offset_mut(self.offsets().vmctx_signature_ids_array());\n            *base.add(sig.index())\n        };\n        let (func_ptr, vmctx) = if let Some(def_index) = self.module().defined_func_index(index) {\n            (\n                self.runtime_info.function(def_index),\n                VMOpaqueContext::from_vmcontext(self.vmctx_ptr()),\n            )\n        } else {\n            let import = self.imported_function(index);\n            (import.body.as_ptr(), import.vmctx)\n        };\n        unsafe {\n            *into = VMCallerCheckedFuncRef {\n                vmctx,\n                type_index,\n                func_ptr: NonNull::new(func_ptr).expect(\"Non-null function pointer\"),\n            };\n        }\n    }\npub(crate) fn get_caller_checked_anyfunc(\n        &mut self,\n        index: FuncIndex,\n    ) -> Option<*mut VMCallerCheckedFuncRef> {\n        if index == FuncIndex::reserved_value() {\n            return None;\n        }\n        unsafe {\n            let func = &self.module().functions[index];\n            let sig = func.signature;\n            let anyfunc: *mut VMCallerCheckedFuncRef = self\n                .vmctx_plus_offset_mut::<VMCallerCheckedFuncRef>(\n                    self.offsets().vmctx_anyfunc(func.anyfunc),\n                );\n            self.construct_anyfunc(index, sig, anyfunc);\n            Some(anyfunc)\n        }\n    }\nunsafe fn initialize_vmctx(\n        &mut self,\n        module: &Module,\n        offsets: &VMOffsets<HostPtr>,\n        store: StorePtr,\n        imports: Imports,\n    ) {\n        assert!(std::ptr::eq(module, self.module().as_ref()));\n        *self.vmctx_plus_offset(offsets.vmctx_magic()) = VMCONTEXT_MAGIC;\n        self.set_callee(None);\n        self.set_store(store.as_raw());\n        let signatures = self.runtime_info.signature_ids();\n        *self.vmctx_plus_offset(offsets.vmctx_signature_ids_array()) = signatures.as_ptr();\n        *self.vmctx_plus_offset(offsets.vmctx_builtin_functions()) = &VMBuiltinFunctionsArray::INIT;\n        debug_assert_eq!(imports.functions.len(), module.num_imported_funcs);\n        ptr::copy_nonoverlapping(\n            imports.functions.as_ptr(),\n            self.vmctx_plus_offset(offsets.vmctx_imported_functions_begin()),\n            imports.functions.len(),\n        );\n        debug_assert_eq!(imports.tables.len(), module.num_imported_tables);\n        ptr::copy_nonoverlapping(\n            imports.tables.as_ptr(),\n            self.vmctx_plus_offset(offsets.vmctx_imported_tables_begin()),\n            imports.tables.len(),\n        );\n        debug_assert_eq!(imports.memories.len(), module.num_imported_memories);\n        ptr::copy_nonoverlapping(\n            imports.memories.as_ptr(),\n            self.vmctx_plus_offset(offsets.vmctx_imported_memories_begin()),\n            imports.memories.len(),\n        );\n        debug_assert_eq!(imports.globals.len(), module.num_imported_globals);\n        ptr::copy_nonoverlapping(\n            imports.globals.as_ptr(),\n            self.vmctx_plus_offset(offsets.vmctx_imported_globals_begin()),\n            imports.globals.len(),\n        );\n        let mut ptr = self.vmctx_plus_offset(offsets.vmctx_tables_begin());\n        for i in 0..module.table_plans.len() - module.num_imported_tables {\n            ptr::write(ptr, self.tables[DefinedTableIndex::new(i)].vmtable());\n            ptr = ptr.add(1);\n  }\n        let mut ptr = self.vmctx_plus_offset(offsets.vmctx_memories_begin());\n        let mut owned_ptr = self.vmctx_plus_offset(offsets.vmctx_owned_memories_begin());\n        for i in 0..module.memory_plans.len() - module.num_imported_memories {\n            let defined_memory_index = DefinedMemoryIndex::new(i);\n            let memory_index = module.memory_index(defined_memory_index);\n            if module.memory_plans[memory_index].memory.shared {\n                let def_ptr = self.memories[defined_memory_index]\n                    .as_shared_memory()\n                    .unwrap()\n                    .vmmemory_ptr();\n                ptr::write(ptr, def_ptr.cast_mut());\n            } else {\n                ptr::write(owned_ptr, self.memories[defined_memory_index].vmmemory());\n                ptr::write(ptr, owned_ptr);\n                owned_ptr = owned_ptr.add(1);\n            }\n            ptr = ptr.add(1);\n        }\n        self.initialize_vmctx_globals(module);\n    }\nunsafe fn initialize_vmctx(\n        &mut self,\n        module: &Module,\n        offsets: &VMOffsets<HostPtr>,\n        store: StorePtr,\n        imports: Imports,\n    ) {\n        assert!(std::ptr::eq(module, self.module().as_ref()));\n        *self.vmctx_plus_offset_mut(offsets.vmctx_magic()) = VMCONTEXT_MAGIC;\n        self.set_callee(None);\n        self.set_store(store.as_raw());\n        let signatures = self.runtime_info.signature_ids();\n        *self.vmctx_plus_offset_mut(offsets.vmctx_signature_ids_array()) = signatures.as_ptr();\n        *self.vmctx_plus_offset_mut(offsets.vmctx_builtin_functions()) =\n            &VMBuiltinFunctionsArray::INIT;\n        debug_assert_eq!(imports.functions.len(), module.num_imported_funcs);\n        ptr::copy_nonoverlapping(\n            imports.functions.as_ptr(),\n            self.vmctx_plus_offset_mut(offsets.vmctx_imported_functions_begin()),\n            imports.functions.len(),\n        );\n        debug_assert_eq!(imports.tables.len(), module.num_imported_tables);\n        ptr::copy_nonoverlapping(\n            imports.tables.as_ptr(),\n            self.vmctx_plus_offset_mut(offsets.vmctx_imported_tables_begin()),\n            imports.tables.len(),\n        );\n        debug_assert_eq!(imports.memories.len(), module.num_imported_memories);\n        ptr::copy_nonoverlapping(\n            imports.memories.as_ptr(),\n            self.vmctx_plus_offset_mut(offsets.vmctx_imported_memories_begin()),\n            imports.memories.len(),\n        );\n        debug_assert_eq!(imports.globals.len(), module.num_imported_globals);\n        ptr::copy_nonoverlapping(\n            imports.globals.as_ptr(),\n            self.vmctx_plus_offset_mut(offsets.vmctx_imported_globals_begin()),\n            imports.globals.len(),\n        );\n        let mut ptr = self.vmctx_plus_offset_mut(offsets.vmctx_tables_begin());\n        for i in 0..module.table_plans.len() - module.num_imported_tables {\n            ptr::write(ptr, self.tables[DefinedTableIndex::new(i)].vmtable());\n            ptr = ptr.add(1);\n        }\n        let mut ptr = self.vmctx_plus_offset_mut(offsets.vmctx_memories_begin());\n        let mut owned_ptr = self.vmctx_plus_offset_mut(offsets.vmctx_owned_memories_begin());\n        for i in 0..module.memory_plans.len() - module.num_imported_memories {\n            let defined_memory_index = DefinedMemoryIndex::new(i);\n            let memory_index = module.memory_index(defined_memory_index);\n            if module.memory_plans[memory_index].memory.shared {\n                let def_ptr = self.memories[defined_memory_index]\n                    .as_shared_memory()\n                    .unwrap()\n                    .vmmemory_ptr();\n                ptr::write(ptr, def_ptr.cast_mut());\n            } else {\n                ptr::write(owned_ptr, self.memories[defined_memory_index].vmmemory());\n                ptr::write(ptr, owned_ptr);\n                owned_ptr = owned_ptr.add(1);\n            }\n            ptr = ptr.add(1);\n        }\n        self.initialize_vmctx_globals(module);\n    }\nfn drop(&mut self) {\n        let module = self.module().clone();\n        for (idx, global) in module.globals.iter() {\n            let idx = match module.defined_global_index(idx) {\n                Some(idx) => idx,\n                None => continue,\n            };\n            match global.wasm_ty {\n                WasmType::ExternRef => {}\n                _ => continue,\n            }\n            unsafe {\n                drop((*self.global_ptr(idx)).as_externref_mut().take());\n            }\n        }\n    }\npub unsafe fn table_index(&mut self, table: &VMTableDefinition) -> DefinedTableIndex {\n        self.instance_mut().table_index(table)\n    }\nfn get_table_init_start(init: &TableInitializer, instance: &mut Instance) -> Result<u32> {\n    match init.base {\n        Some(base) => {\n            let val = unsafe { *(*instance.defined_or_imported_global_ptr(base)).as_u32() };\n            init.offset\n                .checked_add(val)\n                .ok_or_else(|| anyhow!(\"element segment global base overflows\"))\n        }\n        None => Ok(init.offset),\n    }\n}\nfn initialize_tables(instance: &mut Instance, module: &Module) -> Result<()> {\n    match &module.table_initialization {\n        TableInitialization::FuncTable { segments, .. }\n        | TableInitialization::Segments { segments } => {\n            for segment in segments {\n                let start = get_table_init_start(segment, instance)?;\n                instance.table_init_segment(\n                    segment.table_index,\n                    &segment.elements,\n                    start,\n                    0,\n                    segment.elements.len() as u32,\n                )?;\n            }\n        }\n    }\n        Ok(())\n}\nfn get_memory_init_start(init: &MemoryInitializer, instance: &mut Instance) -> Result<u64> {\n    match init.base {\n        Some(base) => {\n            let mem64 = instance.module().memory_plans[init.memory_index]\n                .memory\n                .memory64;\n            let val = unsafe {\n                let global = instance.defined_or_imported_global_ptr(base);\n                if mem64 {\n                    *(*global).as_u64()\n                } else {\n                    u64::from(*(*global).as_u32())\n                }\n            };\n            init.offset\n                .checked_add(val)\n                .ok_or_else(|| anyhow!(\"data segment global base overflows\"))\n        }\n        None => Ok(init.offset),\n    }\n}\nfn check_memory_init_bounds(\n    instance: &mut Instance,\n    initializers: &[MemoryInitializer],\n) -> Result<()> {\n    for init in initializers {\n        let memory = instance.get_memory(init.memory_index);\n        let start = get_memory_init_start(init, instance)?;\n        let end = usize::try_from(start)\n            .ok()\n            .and_then(|start| start.checked_add(init.data.len()));\n        match end {\n            Some(end) if end <= memory.current_length() => {\n            }\n            _ => {\n                bail!(\"memory out of bounds: data segment does not fit\")\n            }\n        }\n    }\n    Ok(())\n}\nfn initialize_memories(instance: &mut Instance, module: &Module) -> Result<()> {\n    let memory_size_in_pages = &|instance: &mut Instance, memory| {\n        (instance.get_memory(memory).current_length() as u64) / u64::from(WASM_PAGE_SIZE)\n    };\n    let get_global_as_u64 = &mut |instance: &mut Instance, global| unsafe {\n        let def = instance.defined_or_imported_global_ptr(global);\n        if module.globals[global].wasm_ty == WasmType::I64 {\n            *(*def).as_u64()\n        } else {\n            u64::from(*(*def).as_u32())\n        }\n    };\n    let ok = module.memory_initialization.init_memory(\n        instance,\n        InitMemory::Runtime {\n            memory_size_in_pages,\n            get_global_as_u64,\n        },\n        |instance, memory_index, init| {\n            if let Some(memory_index) = module.defined_memory_index(memory_index) {\n                if !instance.memories[memory_index].needs_init() {\n                    return true;\n                }\n            }\n            let memory = instance.get_memory(memory_index);\n            unsafe {\n                let src = instance.wasm_data(init.data.clone());\n                let dst = memory.base.add(usize::try_from(init.offset).unwrap());\n                ptr::copy_nonoverlapping(src.as_ptr(), dst, src.len())\n            }\n            true\n        },\n    );\n    if !ok {\n        return Err(Trap::MemoryOutOfBounds.into());\n    }\n    Ok(())\n}\nfn check_init_bounds(instance: &mut Instance, module: &Module) -> Result<()> {\n    check_table_init_bounds(instance, module)?;\n    match &module.memory_initialization {\n        MemoryInitialization::Segmented(initializers) => {\n            check_memory_init_bounds(instance, initializers)?;\n        }\n        MemoryInitialization::Static { .. } => {}\n    }\n    Ok(())\n}\nunsafe fn externref_global_get(vmctx: *mut VMContext, index: u32) -> *mut u8 {\n    let index = GlobalIndex::from_u32(index);\n    let instance = (*vmctx).instance_mut();\n    let global = instance.defined_or_imported_global_ptr(index);\n    match (*global).as_externref().clone() {\n        None => ptr::null_mut(),\n        Some(externref) => {\n            let raw = externref.as_raw();\n            let (activations_table, module_info_lookup) =\n                (*instance.store()).externref_activations_table();\n            activations_table.insert_with_gc(externref, module_info_lookup);\n            raw\n        }\n    }\n}\nunsafe fn externref_global_set(vmctx: *mut VMContext, index: u32, externref: *mut u8) {\n    let externref = if externref.is_null() {\n        None\n    } else {\n        Some(VMExternRef::clone_from_raw(externref))\n    };\n    let index = GlobalIndex::from_u32(index);\n    let instance = (*vmctx).instance_mut();\n    let global = instance.defined_or_imported_global_ptr(index);\n    let old = mem::replace((*global).as_externref_mut(), externref);\n    drop(old);\n}\npub unsafe fn catch_traps<'a, F>(\n    signal_handler: Option<*const SignalHandler<'static>>,\n    capture_backtrace: bool,\n    caller: *mut VMContext,\n    mut closure: F,\n) -> Result<(), Box<Trap>>\nwhere\n    F: FnMut(*mut VMContext),\n{\n    let limits = (*caller).instance_mut().runtime_limits();\n    let result = CallThreadState::new(signal_handler, capture_backtrace, *limits).with(|cx| {\n        wasmtime_setjmp(\n            cx.jmp_buf.as_ptr(),\n            call_closure::<F>,\n            &mut closure as *mut F as *mut u8,\n            caller,\n        )\n    });\n    return match result {\n        Ok(x) => Ok(x),\n        Err((UnwindReason::Trap(reason), backtrace)) => Err(Box::new(Trap { reason, backtrace })),\n        Err((UnwindReason::Panic(panic), _)) => std::panic::resume_unwind(panic),\n    };\n    extern \"C\" fn call_closure<F>(payload: *mut u8, caller: *mut VMContext)\n    where\n        F: FnMut(*mut VMContext),\n    {\n        unsafe { (*(payload as *mut F))(caller) }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub(crate) enum Token {\n    ProcessingInstructionStart,\n    ProcessingInstructionEnd,\n    DoctypeStart,\n    OpeningTagStart,\n    ClosingTagStart,\n    TagEnd,\n    EmptyTagEnd,\n    CommentStart,\n    CommentEnd,\n    Chunk(&'static str),\n    Character(char),\n    Whitespace(char),\n    EqualsSign,\n    SingleQuote,\n    DoubleQuote,\n    CDataStart,\n    CDataEnd,\n    ReferenceStart,\n    ReferenceEnd,\n    MarkupDeclarationStart,\n}\nimpl fmt::Display for Token {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            Token::Chunk(s)                            => s.fmt(f),\n            Token::Character(c) | Token::Whitespace(c) => c.fmt(f),\n            other => match other {\n                Token::OpeningTagStart            => \"<\",\n                Token::ProcessingInstructionStart => \"<?\",\n                Token::DoctypeStart               => \"<!DOCTYPE\",\n                Token::ClosingTagStart            => \"</\",\n                Token::CommentStart               => \"<!--\",\n                Token::CDataStart                 => \"<![CDATA[\",\n                Token::TagEnd                     => \">\",\n                Token::EmptyTagEnd                => \"/>\",\n                Token::ProcessingInstructionEnd   => \"?>\",\n                Token::CommentEnd                 => \"-->\",\n                Token::CDataEnd                   => \"]]>\",\n                Token::ReferenceStart             => \"&\",\n                Token::ReferenceEnd               => \";\",\n                Token::EqualsSign                 => \"=\",\n                Token::SingleQuote                => \"'\",\n                Token::DoubleQuote                => \"\\\"\",\n                _                          => unreachable!()\n            }.fmt(f),\n        }\n    }\n}\nimpl Token {\n    pub fn as_static_str(&self) -> Option<&'static str> {\n        match *self {\n            Token::OpeningTagStart            => Some(\"<\"),\n            Token::ProcessingInstructionStart => Some(\"<?\"),\n            Token::DoctypeStart               => Some(\"<!DOCTYPE\"),\n            Token::ClosingTagStart            => Some(\"</\"),\n            Token::CommentStart               => Some(\"<!--\"),\n            Token::CDataStart                 => Some(\"<![CDATA[\"),\n            Token::TagEnd                     => Some(\">\"),\n            Token::EmptyTagEnd                => Some(\"/>\"),\n            Token::ProcessingInstructionEnd   => Some(\"?>\"),\n            Token::CommentEnd                 => Some(\"-->\"),\n            Token::CDataEnd                   => Some(\"]]>\"),\n            Token::ReferenceStart             => Some(\"&\"),\n            Token::ReferenceEnd               => Some(\";\"),\n            Token::EqualsSign                 => Some(\"=\"),\n            Token::SingleQuote                => Some(\"'\"),\n            Token::DoubleQuote                => Some(\"\\\"\"),\n            Token::Chunk(s)                   => Some(s),\n            _                                 => None\n        }\n    }\n    pub fn push_to_string(&self, target: &mut String) {\n        match self.as_static_str() {\n            Some(s) => { target.push_str(s); }\n            None => {\n                match *self {\n                    Token::Character(c) | Token::Whitespace(c) => target.push(c),\n                    _ => unreachable!()\n                }\n            }\n        }\n    }\n    #[inline]\n    pub fn contains_char_data(&self) -> bool {\n        match *self {\n            Token::Whitespace(_) | Token::Chunk(_) | Token::Character(_) | Token::CommentEnd |\n            Token::TagEnd | Token::EqualsSign | Token::DoubleQuote | Token::SingleQuote | Token::CDataEnd | \n            Token::ProcessingInstructionEnd | Token::EmptyTagEnd => true,\n            _ => false\n        }\n    }\n    #[inline]\n    pub fn is_whitespace(&self) -> bool {\n        match *self {\n            Token::Whitespace(_) => true,\n            _ => false,\n        }\n    }\n}\n#[derive(Copy, Clone)]\nenum State {\n    Normal,\n    TagStarted,\n    CommentOrCDataOrDoctypeStarted,\n    CommentStarted,\n    DoctypeStarted(DoctypeStartedSubstate),\n    InsideMarkupDeclaration,\n    InsideDoctype,\n    CDataStarted(CDataStartedSubstate),\n    ProcessingInstructionClosing,\n    EmptyTagClosing,\n    CommentClosing(ClosingSubstate),\n    CDataClosing(ClosingSubstate),\n    InvalidCDataClosing(ClosingSubstate),\n    InsideComment,\n    InsideCdata,\n    InsideProcessingInstruction,\n    InsideMarkupDeclarationQuotedString(QuoteStyle),\n}\n#[derive(Copy, Clone, Eq, PartialEq)]\nenum QuoteStyle {\n    Single, Double\n}\n#[derive(Copy, Clone)]\nenum ClosingSubstate {\n    First, Second\n}\n#[derive(Copy, Clone)]\nenum DoctypeStartedSubstate {\n    D, DO, DOC, DOCT, DOCTY, DOCTYP\n}\n#[derive(Copy, Clone)]\nenum CDataStartedSubstate {\n    E, C, CD, CDA, CDAT, CDATA\n}\npub(crate) type Result<T = Option<Token>, E = Error> = result::Result<T, E>;\nmacro_rules! dispatch_on_enum_state(\n    ($_self:ident, $s:expr, $c:expr, $is:expr,\n     $($st:ident; $stc:expr ; $next_st:ident ; $chunk:expr),+;\n     $end_st:ident ; $end_c:expr ; $end_chunk:expr ; $e:expr) => (\n        match $s {\n            $(\n            $st => match $c {\n                $stc => $_self.move_to($is($next_st)),\n                _  => $_self.handle_error($chunk, $c)\n            },\n            )+\n            $end_st => match $c {\n                $end_c => $e,\n                _      => $_self.handle_error($end_chunk, $c)\n            }\n        }\n    )\n);\npub(crate) struct Lexer {\n    pos: TextPosition,\n    head_pos: TextPosition,\n    char_queue: VecDeque<char>,\n    st: State,\n    normal_state: State,\n    skip_errors: bool,\n    inside_token: bool,\n    eof_handled: bool\n}\nimpl Position for Lexer {\n    #[inline]\n    fn position(&self) -> TextPosition { self.pos }\n}\nimpl Lexer {\n    pub fn new() -> Lexer {\n        Lexer {\n            pos: TextPosition::new(),\n            head_pos: TextPosition::new(),\n            char_queue: VecDeque::with_capacity(4),  \n            st: State::Normal,\n            normal_state: State::Normal,\n            skip_errors: false,\n            inside_token: false,\n            eof_handled: false\n        }\n    }\n    pub(crate) fn disable_errors(&mut self) { self.skip_errors = true; }\n    #[inline]\n    pub fn reset_eof_handled(&mut self) { self.eof_handled = false; }\n    pub fn next_token<B: Read>(&mut self, b: &mut B) -> Result {\n        if self.eof_handled {\n            return Ok(None);\n        }\n        if !self.inside_token {\n            self.pos = self.head_pos;\n            self.inside_token = true;\n        }\n        while let Some(c) = self.char_queue.pop_front() {\n            match self.read_next_token(c)? {\n                Some(t) => {\n                    self.inside_token = false;\n                    return Ok(Some(t));\n                }\n                None => {} \n            }\n        }\n        loop {\n            let c = match util::next_char_from(b)? {\n                Some(c) => c,  \n                None => break, \n            };\n            match self.read_next_token(c)? {\n                Some(t) => {\n                    self.inside_token = false;\n                    return Ok(Some(t));\n                }\n                None => {\n                }\n            }\n        }\n        self.eof_handled = true;\n        self.pos = self.head_pos;\n        match self.st {\n            State::InsideCdata | State::CDataClosing(_) => Err(self.error(\"Unclosed CDATA\")),\n            State::TagStarted | State::CommentOrCDataOrDoctypeStarted |\n            State::CommentStarted | State::CDataStarted(_)| State::DoctypeStarted(_) |\n            State::CommentClosing(ClosingSubstate::Second) |\n            State::InsideComment | State::InsideMarkupDeclaration |\n            State::InsideProcessingInstruction | State::ProcessingInstructionClosing |\n            State::InsideDoctype | State::InsideMarkupDeclarationQuotedString(_) =>\n                Err(self.error(\"Unexpected end of stream\")),\n            State::EmptyTagClosing =>\n                Ok(Some(Token::Character('/'))),\n            State::CommentClosing(ClosingSubstate::First) =>\n                Ok(Some(Token::Character('-'))),\n            State::InvalidCDataClosing(ClosingSubstate::First) =>\n                Ok(Some(Token::Character(']'))),\n            State::InvalidCDataClosing(ClosingSubstate::Second) =>\n                Ok(Some(Token::Chunk(\"]]\"))),\n            State::Normal =>\n                Ok(None),\n        }\n    }\n    #[inline]\n    fn error<M: Into<Cow<'static, str>>>(&self, msg: M) -> Error {\n        (self, msg).into()\n    }\n    #[inline]\n    fn read_next_token(&mut self, c: char) -> Result {\n        let res = self.dispatch_char(c);\n        if self.char_queue.is_empty() {\n            if c == '\\n' {\n                self.head_pos.new_line();\n            } else {\n                self.head_pos.advance(1);\n            }\n        }\n        res\n    }\n    fn dispatch_char(&mut self, c: char) -> Result {\n        match self.st {\n            State::Normal                         => self.normal(c),\n            State::TagStarted                     => self.tag_opened(c),\n            State::CommentOrCDataOrDoctypeStarted => self.comment_or_cdata_or_doctype_started(c),\n            State::CommentStarted                 => self.comment_started(c),\n            State::CDataStarted(s)                => self.cdata_started(c, s),\n            State::DoctypeStarted(s)              => self.doctype_started(c, s),\n            State::InsideDoctype                  => self.inside_doctype(c),\n            State::EmptyTagClosing                => self.empty_element_closing(c),\n            State::CommentClosing(s)              => self.comment_closing(c, s),\n            State::CDataClosing(s)                => self.cdata_closing(c, s),\n            State::InvalidCDataClosing(s)         => self.invalid_cdata_closing(c, s),\n            State::InsideComment                  => self.inside_comment_state(c),\n            State::InsideCdata                    => self.inside_cdata(c),\n            State::InsideProcessingInstruction    => self.inside_processing_instruction(c),\n            State::ProcessingInstructionClosing   => self.processing_instruction_closing(c),\n            State::InsideMarkupDeclaration       => self.markup_declaration(c),\n            State::InsideMarkupDeclarationQuotedString(q) => self.markup_declaration_string(c, q),\n        }\n    }\n    #[inline]\n    fn move_to(&mut self, st: State) -> Result {\n        self.st = st;\n        Ok(None)\n    }\n    #[inline]\n    fn move_to_with(&mut self, st: State, token: Token) -> Result {\n        self.st = st;\n        Ok(Some(token))\n    }\n    #[inline]\n    fn move_to_and_reset_normal(&mut self, st: State, token: Token) -> Result {\n        self.normal_state = st;\n        self.st = st;\n        Ok(Some(token))\n    }\n    #[inline]\n    fn move_to_with_unread(&mut self, st: State, cs: &[char], token: Token) -> Result {\n        self.char_queue.extend(cs.iter().copied());\n        self.move_to_with(st, token)\n    }\n    fn handle_error(&mut self, chunk: &'static str, c: char) -> Result {\n        self.char_queue.push_back(c);\n        if self.skip_errors {\n            self.move_to_with(State::Normal, Token::Chunk(chunk))\n        } else {\n            Err(self.error(format!(\"Unexpected token '{chunk}' before '{c}'\")))\n        }\n    }\n    fn normal(&mut self, c: char) -> Result {\n        match c {\n            '<'                        => self.move_to(State::TagStarted),\n            '>'                        => Ok(Some(Token::TagEnd)),\n            '/'                        => self.move_to(State::EmptyTagClosing),\n            '='                        => Ok(Some(Token::EqualsSign)),\n            '\"'                        => Ok(Some(Token::DoubleQuote)),\n            '\\''                       => Ok(Some(Token::SingleQuote)),\n            ']'                        => self.move_to(State::InvalidCDataClosing(ClosingSubstate::First)),\n            '&'                        => Ok(Some(Token::ReferenceStart)),\n            ';'                        => Ok(Some(Token::ReferenceEnd)),\n            _ if is_whitespace_char(c) => Ok(Some(Token::Whitespace(c))),\n            _                          => Ok(Some(Token::Character(c)))\n        }\n    }\n    fn inside_cdata(&mut self, c: char) -> Result {\n        match c {\n            ']'                        => self.move_to(State::CDataClosing(ClosingSubstate::First)),\n            _ if is_whitespace_char(c) => Ok(Some(Token::Whitespace(c))),\n            _                          => Ok(Some(Token::Character(c)))\n        }\n    }\n    fn inside_processing_instruction(&mut self, c: char) -> Result {\n        match c {\n            '?'                        => self.move_to(State::ProcessingInstructionClosing),\n            '<'                        => Ok(Some(Token::OpeningTagStart)),\n            '>'                        => Ok(Some(Token::TagEnd)),\n            '/'                        => Ok(Some(Token::ClosingTagStart)),\n            '='                        => Ok(Some(Token::EqualsSign)),\n            '\"'                        => Ok(Some(Token::DoubleQuote)),\n            '\\''                       => Ok(Some(Token::SingleQuote)),\n            '&'                        => Ok(Some(Token::ReferenceStart)),\n            ';'                        => Ok(Some(Token::ReferenceEnd)),\n            _ if is_whitespace_char(c) => Ok(Some(Token::Whitespace(c))),\n            _                          => Ok(Some(Token::Character(c)))\n        }\n    }\n    fn inside_comment_state(&mut self, c: char) -> Result {\n        match c {\n            '-'                        => self.move_to(State::CommentClosing(ClosingSubstate::First)),\n            _ if is_whitespace_char(c) => Ok(Some(Token::Whitespace(c))),\n            _                          => Ok(Some(Token::Character(c)))\n        }\n    }\n    fn tag_opened(&mut self, c: char) -> Result {\n        match c {\n            '?'                        => self.move_to_with(State::InsideProcessingInstruction, Token::ProcessingInstructionStart),\n            '/'                        => self.move_to_with(self.normal_state, Token::ClosingTagStart),\n            '!'                        => self.move_to(State::CommentOrCDataOrDoctypeStarted),\n            _ if is_whitespace_char(c) => self.move_to_with_unread(self.normal_state, &[c], Token::OpeningTagStart),\n            _ if is_name_char(c)       => self.move_to_with_unread(self.normal_state, &[c], Token::OpeningTagStart),\n            _                          => self.handle_error(\"<\", c)\n        }\n    }\n    fn comment_or_cdata_or_doctype_started(&mut self, c: char) -> Result {\n        match c {\n            '-' => self.move_to(State::CommentStarted),\n            '[' => self.move_to(State::CDataStarted(CDataStartedSubstate::E)),\n            'D' => self.move_to(State::DoctypeStarted(DoctypeStartedSubstate::D)),\n            'E' | 'A' | 'N' if matches!(self.normal_state, State::InsideDoctype) => self.move_to_with(State::InsideMarkupDeclaration, Token::MarkupDeclarationStart),\n            _ => self.handle_error(\"<!\", c),\n        }\n    }\n    /// Encountered '<!-'\n    fn comment_started(&mut self, c: char) -> Result {\n        match c {\n            '-' => self.move_to_with(State::InsideComment, Token::CommentStart),\n            _ => self.handle_error(\"<!-\", c),\n        }\n    }\n    /// Encountered '<!['\n    fn cdata_started(&mut self, c: char, s: CDataStartedSubstate) -> Result {\n        use self::CDataStartedSubstate::{C, CD, CDA, CDAT, CDATA, E};\n        dispatch_on_enum_state!(self, s, c, State::CDataStarted,\n            E     ; 'C' ; C     ; \"<![\",\n            C     ; 'D' ; CD    ; \"<![C\",\n            CD    ; 'A' ; CDA   ; \"<![CD\",\n            CDA   ; 'T' ; CDAT  ; \"<![CDA\",\n            CDAT  ; 'A' ; CDATA ; \"<![CDAT\";\n            CDATA ; '[' ; \"<![CDATA\" ; self.move_to_with(State::InsideCdata, Token::CDataStart)\n        )\n    }\n    /// Encountered '<!' that isn't DOCTYPE or CDATA\n    fn markup_declaration(&mut self, c: char) -> Result {\n        match c {\n            '<'                        => self.handle_error(\"<!\", c),\n            '>'                        => self.move_to_with(self.normal_state, Token::TagEnd),\n            '&'                        => Ok(Some(Token::ReferenceStart)),\n            ';'                        => Ok(Some(Token::ReferenceEnd)),\n            '\"'                        => self.move_to_with(State::InsideMarkupDeclarationQuotedString(QuoteStyle::Double), Token::DoubleQuote),\n            '\\''                       => self.move_to_with(State::InsideMarkupDeclarationQuotedString(QuoteStyle::Single), Token::SingleQuote),\n            _ => Ok(None),\n        }\n    }\n    fn markup_declaration_string(&mut self, c: char, q: QuoteStyle) -> Result {\n        match c {\n            '\"' if q == QuoteStyle::Double  => self.move_to_with(State::InsideMarkupDeclaration, Token::DoubleQuote),\n            '\\'' if q == QuoteStyle::Single => self.move_to_with(State::InsideMarkupDeclaration, Token::SingleQuote),\n            _ => Ok(None),\n        }\n    }\n    fn doctype_started(&mut self, c: char, s: DoctypeStartedSubstate) -> Result {\n        use self::DoctypeStartedSubstate::{D, DO, DOC, DOCT, DOCTY, DOCTYP};\n        dispatch_on_enum_state!(self, s, c, State::DoctypeStarted,\n            D      ; 'O' ; DO     ; \"<!D\",\n            DO     ; 'C' ; DOC    ; \"<!DO\",\n            DOC    ; 'T' ; DOCT   ; \"<!DOC\",\n            DOCT   ; 'Y' ; DOCTY  ; \"<!DOCT\",\n            DOCTY  ; 'P' ; DOCTYP ; \"<!DOCTY\";\n            DOCTYP ; 'E' ; \"<!DOCTYP\" ; self.move_to_and_reset_normal(State::InsideDoctype, Token::DoctypeStart)\n        )\n    }\n    /// State used while awaiting the closing bracket for the <!DOCTYPE tag\n    fn inside_doctype(&mut self, c: char) -> Result {\n        match c {\n            '>' => self.move_to_and_reset_normal(State::Normal, Token::TagEnd),\n            '<'                        => self.move_to(State::TagStarted),\n            '&'                        => Ok(Some(Token::ReferenceStart)),\n            ';'                        => Ok(Some(Token::ReferenceEnd)),\n            _ => Ok(None),\n        }\n    }\n    /// Encountered '?'\n    fn processing_instruction_closing(&mut self, c: char) -> Result {\n        match c {\n            '>' => self.move_to_with(self.normal_state, Token::ProcessingInstructionEnd),\n            _ => self.move_to_with_unread(State::InsideProcessingInstruction, &[c], Token::Character('?')),\n        }\n    }\n    /// Encountered '/'\n    fn empty_element_closing(&mut self, c: char) -> Result {\n        match c {\n            '>' => self.move_to_with(self.normal_state, Token::EmptyTagEnd),\n            _ => self.move_to_with_unread(self.normal_state, &[c], Token::Character('/')),\n        }\n    }\n    /// Encountered '-'\n    fn comment_closing(&mut self, c: char, s: ClosingSubstate) -> Result {\n        match s {\n            ClosingSubstate::First => match c {\n                '-' => self.move_to(State::CommentClosing(ClosingSubstate::Second)),\n                _ => self.move_to_with_unread(State::InsideComment, &[c], Token::Character('-')),\n            },\n            ClosingSubstate::Second => match c {\n                '>' => self.move_to_with(self.normal_state, Token::CommentEnd),\n                // double dash not followed by a greater-than is a hard error inside comment\n                _ => self.handle_error(\"--\", c),\n            },\n        }\n    }\n    /// Encountered ']'\n    fn cdata_closing(&mut self, c: char, s: ClosingSubstate) -> Result {\n        match s {\n            ClosingSubstate::First => match c {\n                ']' => self.move_to(State::CDataClosing(ClosingSubstate::Second)),\n                _ => self.move_to_with_unread(State::InsideCdata, &[c], Token::Character(']')),\n            },\n            ClosingSubstate::Second => match c {\n                '>' => self.move_to_with(State::Normal, Token::CDataEnd),\n                _ => self.move_to_with_unread(State::InsideCdata, &[']', c], Token::Character(']')),\n            },\n        }\n    }\n    /// Encountered ']'\n    fn invalid_cdata_closing(&mut self, c: char, s: ClosingSubstate) -> Result {\n        match s {\n            ClosingSubstate::First => match c {\n                ']' => self.move_to(State::InvalidCDataClosing(ClosingSubstate::Second)),\n                _ => self.move_to_with_unread(State::Normal, &[c], Token::Character(']')),\n            },\n            ClosingSubstate::Second => match c {\n                '>' => self.move_to_with(self.normal_state, Token::CDataEnd),\n                _ => self.move_to_with_unread(State::Normal, &[']', c], Token::Character(']')),\n            },\n        }\n    }\n}\n#[cfg(test)]\nmod tests {\n    use crate::common::Position;\n    use std::io::{BufReader, Cursor};\n    use super::{Lexer, Token};\n    macro_rules! assert_oks(\n        (for $lex:ident and $buf:ident ; $($e:expr)+) => ({\n            $(\n                assert_eq!(Ok(Some($e)), $lex.next_token(&mut $buf));\n             )+\n        })\n    );\n    macro_rules! assert_err(\n        (for $lex:ident and $buf:ident expect row $r:expr ; $c:expr, $s:expr) => ({\n            let err = $lex.next_token(&mut $buf);\n            assert!(err.is_err());\n            let err = err.unwrap_err();\n            assert_eq!($r as u64, err.position().row);\n            assert_eq!($c as u64, err.position().column);\n            assert_eq!($s, err.msg());\n        })\n    );\n    macro_rules! assert_none(\n        (for $lex:ident and $buf:ident) => (\n            assert_eq!(Ok(None), $lex.next_token(&mut $buf))\n        )\n    );\n    fn make_lex_and_buf(s: &str) -> (Lexer, BufReader<Cursor<Vec<u8>>>) {\n        (Lexer::new(), BufReader::new(Cursor::new(s.to_owned().into_bytes())))\n    }\n    #[test]\n    fn tricky_pi() {\n        let (mut lex, mut buf) = make_lex_and_buf(\n            r#\"<?x<!-- &??><x>\"#\n        );\n        assert_oks!(for lex and buf ;\n            Token::ProcessingInstructionStart\n            Token::Character('x')\n            Token::OpeningTagStart // processing of <?xml?> relies on the extra tokens\n            Token::Character('!')\n            Token::Character('-')\n            Token::Character('-')\n            Token::Whitespace(' ')\n            Token::ReferenceStart\n            Token::Character('?')\n            Token::ProcessingInstructionEnd\n            Token::OpeningTagStart\n            Token::Character('x')\n            Token::TagEnd\n        );\n        assert_none!(for lex and buf);\n    }\n    #[test]\n    fn simple_lexer_test() {\n        let (mut lex, mut buf) = make_lex_and_buf(\n            r#\"<a p='q'> x<b z=\"y\">d\t</b></a><p/> <?nm ?> <!-- a c --> &nbsp;\"#\n        );\n        assert_oks!(for lex and buf ;\n            Token::OpeningTagStart\n            Token::Character('a')\n            Token::Whitespace(' ')\n            Token::Character('p')\n            Token::EqualsSign\n            Token::SingleQuote\n            Token::Character('q')\n            Token::SingleQuote\n            Token::TagEnd\n            Token::Whitespace(' ')\n            Token::Character('x')\n            Token::OpeningTagStart\n            Token::Character('b')\n            Token::Whitespace(' ')\n            Token::Character('z')\n            Token::EqualsSign\n            Token::DoubleQuote\n            Token::Character('y')\n            Token::DoubleQuote\n            Token::TagEnd\n            Token::Character('d')\n            Token::Whitespace('\\t')\n            Token::ClosingTagStart\n            Token::Character('b')\n            Token::TagEnd\n            Token::ClosingTagStart\n            Token::Character('a')\n            Token::TagEnd\n            Token::OpeningTagStart\n            Token::Character('p')\n            Token::EmptyTagEnd\n            Token::Whitespace(' ')\n            Token::ProcessingInstructionStart\n            Token::Character('n')\n            Token::Character('m')\n            Token::Whitespace(' ')\n            Token::ProcessingInstructionEnd\n            Token::Whitespace(' ')\n            Token::CommentStart\n            Token::Whitespace(' ')\n            Token::Character('a')\n            Token::Whitespace(' ')\n            Token::Character('c')\n            Token::Whitespace(' ')\n            Token::CommentEnd\n            Token::Whitespace(' ')\n            Token::ReferenceStart\n            Token::Character('n')\n            Token::Character('b')\n            Token::Character('s')\n            Token::Character('p')\n            Token::ReferenceEnd\n        );\n        assert_none!(for lex and buf);\n    }\n    #[test]\n    fn special_chars_test() {\n        let (mut lex, mut buf) = make_lex_and_buf(\n            r#\"?x!+ // -| ]z]]\"#\n        );\n        assert_oks!(for lex and buf ;\n            Token::Character('?')\n            Token::Character('x')\n            Token::Character('!')\n            Token::Character('+')\n            Token::Whitespace(' ')\n            Token::Character('/')\n            Token::Character('/')\n            Token::Whitespace(' ')\n            Token::Character('-')\n            Token::Character('|')\n            Token::Whitespace(' ')\n            Token::Character(']')\n            Token::Character('z')\n            Token::Chunk(\"]]\")\n        );\n        assert_none!(for lex and buf);\n    }\n    #[test]\n    fn cdata_test() {\n        let (mut lex, mut buf) = make_lex_and_buf(\n            r#\"<a><![CDATA[x y ?]]> </a>\"#\n        );\n        assert_oks!(for lex and buf ;\n            Token::OpeningTagStart\n            Token::Character('a')\n            Token::TagEnd\n            Token::CDataStart\n            Token::Character('x')\n            Token::Whitespace(' ')\n            Token::Character('y')\n            Token::Whitespace(' ')\n            Token::Character('?')\n            Token::CDataEnd\n            Token::Whitespace(' ')\n            Token::ClosingTagStart\n            Token::Character('a')\n            Token::TagEnd\n        );\n        assert_none!(for lex and buf);\n    }\n    #[test]\n    fn cdata_closers_test() {\n        let (mut lex, mut buf) = make_lex_and_buf(\n            r#\"<![CDATA[] > ]> ]]><!---->]]<a>\"#\n        );\n        assert_oks!(for lex and buf ;\n            Token::CDataStart\n            Token::Character(']')\n            Token::Whitespace(' ')\n            Token::Character('>')\n            Token::Whitespace(' ')\n            Token::Character(']')\n            Token::Character('>')\n            Token::Whitespace(' ')\n            Token::CDataEnd\n            Token::CommentStart\n            Token::CommentEnd\n            Token::Character(']')\n            Token::Character(']')\n            Token::OpeningTagStart\n            Token::Character('a')\n            Token::TagEnd\n        );\n        assert_none!(for lex and buf);\n    }\n    #[test]\n    fn doctype_test() {\n        let (mut lex, mut buf) = make_lex_and_buf(\n            r#\"<a><!DOCTYPE ab xx z> \"#\n        );\n        assert_oks!(for lex and buf ;\n            Token::OpeningTagStart\n            Token::Character('a')\n            Token::TagEnd\n            Token::DoctypeStart\n            Token::TagEnd\n            Token::Whitespace(' ')\n        );\n        assert_none!(for lex and buf);\n    }\n    #[test]\n    fn tricky_comments() {\n        let (mut lex, mut buf) = make_lex_and_buf(\n            r#\"<a><!-- C ->--></a>\"#\n        );\n        assert_oks!(for lex and buf ;\n            Token::OpeningTagStart\n            Token::Character('a')\n            Token::TagEnd\n            Token::CommentStart\n            Token::Whitespace(' ')\n            Token::Character('C')\n            Token::Whitespace(' ')\n            Token::Character('-')\n            Token::Character('>')\n            Token::CommentEnd\n            Token::ClosingTagStart\n            Token::Character('a')\n            Token::TagEnd\n        );\n        assert_none!(for lex and buf);\n    }\n    #[test]\n    fn doctype_with_internal_subset_test() {\n        let (mut lex, mut buf) = make_lex_and_buf(\n            r#\"<a><!DOCTYPE ab[<!ELEMENT ba \">>>>>\"> ]> \"#\n        );\n        assert_oks!(for lex and buf ;\n            Token::OpeningTagStart\n            Token::Character('a')\n            Token::TagEnd\n            Token::DoctypeStart\n            Token::MarkupDeclarationStart\n            Token::DoubleQuote\n            Token::DoubleQuote\n            Token::TagEnd\n            Token::TagEnd\n            Token::Whitespace(' ')\n        );\n        assert_none!(for lex and buf);\n    }\n    #[test]\n    fn doctype_internal_pi_comment() {\n        let (mut lex, mut buf) = make_lex_and_buf(\n            \"<!DOCTYPE a [\\n<!ELEMENT leopard ANY> <!-- <?non?>--> <?pi > ?> \\n]>\"\n        );\n        assert_oks!(for lex and buf ;\n            Token::DoctypeStart\n            Token::MarkupDeclarationStart\n            Token::TagEnd\n            Token::CommentStart\n            Token::Whitespace(' ')\n            Token::Character('<')\n            Token::Character('?')\n            Token::Character('n')\n            Token::Character('o')\n            Token::Character('n')\n            Token::Character('?')\n            Token::Character('>')\n            Token::CommentEnd\n            Token::ProcessingInstructionStart\n            Token::Character('p')\n            Token::Character('i')\n            Token::Whitespace(' ')\n            Token::TagEnd // not really\n            Token::Whitespace(' ')\n            Token::ProcessingInstructionEnd\n            Token::TagEnd // DTD\n        );\n        assert_none!(for lex and buf);\n    }\n    #[test]\n    fn end_of_stream_handling_ok() {\n        macro_rules! eof_check(\n            ($data:expr ; $token:expr) => ({\n                let (mut lex, mut buf) = make_lex_and_buf($data);\n                assert_oks!(for lex and buf ; $token);\n                assert_none!(for lex and buf);\n            })\n        );\n        eof_check!(\"?\"  ; Token::Character('?'));\n        eof_check!(\"/\"  ; Token::Character('/'));\n        eof_check!(\"-\"  ; Token::Character('-'));\n        eof_check!(\"]\"  ; Token::Character(']'));\n        eof_check!(\"]]\" ; Token::Chunk(\"]]\"));\n    }\n    #[test]\n    fn end_of_stream_handling_error() {\n        macro_rules! eof_check(\n            ($data:expr; $r:expr, $c:expr) => ({\n                let (mut lex, mut buf) = make_lex_and_buf($data);\n                assert_err!(for lex and buf expect row $r ; $c, \"Unexpected end of stream\");\n                assert_none!(for lex and buf);\n            })\n        );\n        eof_check!(\"<\"        ; 0, 1);\n        eof_check!(\"<!\"       ; 0, 2);\n        eof_check!(\"<!-\"      ; 0, 3);\n        eof_check!(\"<![\"      ; 0, 3);\n        eof_check!(\"<![C\"     ; 0, 4);\n        eof_check!(\"<![CD\"    ; 0, 5);\n        eof_check!(\"<![CDA\"   ; 0, 6);\n        eof_check!(\"<![CDAT\"  ; 0, 7);\n        eof_check!(\"<![CDATA\" ; 0, 8);\n    }\n    #[test]\n    fn error_in_comment_or_cdata_prefix() {\n        let (mut lex, mut buf) = make_lex_and_buf(\"<!x\");\n        assert_err!(for lex and buf expect row 0 ; 0,\n            \"Unexpected token '<!' before 'x'\"\n        );\n        let (mut lex, mut buf) = make_lex_and_buf(\"<!x\");\n        lex.disable_errors();\n        assert_oks!(for lex and buf ;\n            Token::Chunk(\"<!\")\n            Token::Character('x')\n        );\n        assert_none!(for lex and buf);\n    }\n    #[test]\n    fn error_in_comment_started() {\n        let (mut lex, mut buf) = make_lex_and_buf(\"<!-\\t\");\n        assert_err!(for lex and buf expect row 0 ; 0,\n            \"Unexpected token '<!-' before '\\t'\"\n        );\n        let (mut lex, mut buf) = make_lex_and_buf(\"<!-\\t\");\n        lex.disable_errors();\n        assert_oks!(for lex and buf ;\n            Token::Chunk(\"<!-\")\n            Token::Whitespace('\\t')\n        );\n        assert_none!(for lex and buf);\n    }\n    #[test]\n    fn error_in_comment_two_dashes_not_at_end() {\n        let (mut lex, mut buf) = make_lex_and_buf(\"--x\");\n        lex.st = super::State::InsideComment;\n        assert_err!(for lex and buf expect row 0; 0,\n            \"Unexpected token '--' before 'x'\"\n        );\n        let (mut lex, mut buf) = make_lex_and_buf(\"--x\");\n        assert_oks!(for lex and buf ;\n            Token::Character('-')\n            Token::Character('-')\n            Token::Character('x')\n        );\n    }\n    macro_rules! check_case(\n        ($chunk:expr, $app:expr; $data:expr; $r:expr, $c:expr, $s:expr) => ({\n            let (mut lex, mut buf) = make_lex_and_buf($data);\n            assert_err!(for lex and buf expect row $r ; $c, $s);\n            let (mut lex, mut buf) = make_lex_and_buf($data);\n            lex.disable_errors();\n            assert_oks!(for lex and buf ;\n                Token::Chunk($chunk)\n                Token::Character($app)\n            );\n            assert_none!(for lex and buf);\n        })\n    );\n    #[test]\n    fn error_in_cdata_started() {\n        check_case!(\"<![\",      '['; \"<![[\"      ; 0, 0, \"Unexpected token '<![' before '['\");\n        check_case!(\"<![C\",     '['; \"<![C[\"     ; 0, 0, \"Unexpected token '<![C' before '['\");\n        check_case!(\"<![CD\",    '['; \"<![CD[\"    ; 0, 0, \"Unexpected token '<![CD' before '['\");\n        check_case!(\"<![CDA\",   '['; \"<![CDA[\"   ; 0, 0, \"Unexpected token '<![CDA' before '['\");\n        check_case!(\"<![CDAT\",  '['; \"<![CDAT[\"  ; 0, 0, \"Unexpected token '<![CDAT' before '['\");\n        check_case!(\"<![CDATA\", '|'; \"<![CDATA|\" ; 0, 0, \"Unexpected token '<![CDATA' before '|'\");\n    }\n    #[test]\n    fn error_in_doctype_started() {\n        check_case!(\"<!D\",      'a'; \"<!Da\"      ; 0, 0, \"Unexpected token '<!D' before 'a'\");\n        check_case!(\"<!DO\",     'b'; \"<!DOb\"     ; 0, 0, \"Unexpected token '<!DO' before 'b'\");\n        check_case!(\"<!DOC\",    'c'; \"<!DOCc\"    ; 0, 0, \"Unexpected token '<!DOC' before 'c'\");\n        check_case!(\"<!DOCT\",   'd'; \"<!DOCTd\"   ; 0, 0, \"Unexpected token '<!DOCT' before 'd'\");\n        check_case!(\"<!DOCTY\",  'e'; \"<!DOCTYe\"  ; 0, 0, \"Unexpected token '<!DOCTY' before 'e'\");\n        check_case!(\"<!DOCTYP\", 'f'; \"<!DOCTYPf\" ; 0, 0, \"Unexpected token '<!DOCTYP' before 'f'\");\n    }\n    #[test]\n    fn issue_98_cdata_ending_with_right_bracket() {\n        let (mut lex, mut buf) = make_lex_and_buf(\n            r#\"<![CDATA[Foo [Bar]]]>\"#\n        );\n        assert_oks!(for lex and buf ;\n            Token::CDataStart\n            Token::Character('F')\n            Token::Character('o')\n            Token::Character('o')\n            Token::Whitespace(' ')\n            Token::Character('[')\n            Token::Character('B')\n            Token::Character('a')\n            Token::Character('r')\n            Token::Character(']')\n            Token::CDataEnd\n        );\n        assert_none!(for lex and buf);\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn try_invoke(&self) -> Result<ink_primitives::MessageResult<R>, crate::Error> {\n        crate::invoke_contract(self)\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn delegate(\n            &mut self,\n            code_hash: Hash,\n            selector: [u8; 4],\n        ) -> Option<ink::LangError> {\n            let result = build_call::<DefaultEnvironment>()\n                .delegate(code_hash)\n                .exec_input(ExecutionInput::new(Selector::new(selector)))\n                .returns::<bool>()\n                .try_invoke()\n                .expect(\"Error from the Contracts pallet.\");\n            match result {\n                Ok(_) => None,\n                Err(e @ ink::LangError::CouldNotReadInput) => Some(e),\n                Err(_) => {\n                    unimplemented!(\"No other `LangError` variants exist at the moment.\")\n                }\n            }\n        }\nasync fn e2e_call_builder_delegate_returns_correct_value(\n            mut client: ink_e2e::Client<C, E>,\n        ) -> E2EResult<()> {\n            let origin = client\n                .create_and_fund_account(&ink_e2e::alice(), 10_000_000_000_000)\n                .await;\n            let expected_value = 42;\n            let constructor = CallBuilderDelegateTestRef::new(expected_value);\n            let call_builder = client\n                .instantiate(\"call_builder_delegate\", &origin, constructor, 0, None)\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder_call = call_builder.call::<CallBuilderDelegateTest>();\n            let code_hash = client\n                .upload(\"incrementer\", &origin, None)\n                .await\n                .expect(\"upload `incrementer` failed\")\n                .code_hash;\n            let selector = ink::selector_bytes!(\"get\");\n            let call = call_builder_call.invoke(code_hash, selector);\n            let call_result = client\n                .call(&origin, &call, 0, None)\n                .await\n                .expect(\"Client failed to call `call_builder::invoke`.\")\n                .return_value();\n            assert_eq!(\n                call_result, expected_value,\n                \"Decoded an unexpected value from the call.\"\n            );\n            Ok(())\n        }\nasync fn e2e_invalid_message_selector_can_be_handled(\n            mut client: ink_e2e::Client<C, E>,\n        ) -> E2EResult<()> {\n            let origin = client\n                .create_and_fund_account(&ink_e2e::bob(), 10_000_000_000_000)\n                .await;\n            let constructor = CallBuilderDelegateTestRef::new(Default::default());\n            let call_builder_contract = client\n                .instantiate(\"call_builder_delegate\", &origin, constructor, 0, None)\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder_call =\n                call_builder_contract.call::<CallBuilderDelegateTest>();\n            let code_hash = client\n                .upload(\"incrementer\", &origin, None)\n                .await\n                .expect(\"upload `incrementer` failed\")\n                .code_hash;\n            let selector = ink::selector_bytes!(\"invalid_selector\");\n            let call = call_builder_call.delegate(code_hash, selector);\n            let call_result = client\n                .call(&origin, &call, 0, None)\n                .await\n                .expect(\"Calling `call_builder::delegate` failed\");\n            assert!(matches!(\n                call_result.return_value(),\n                Some(ink::LangError::CouldNotReadInput)\n            ));\n            Ok(())\n        }\nasync fn e2e_invalid_message_selector_panics_on_invoke(\n            mut client: ink_e2e::Client<C, E>,\n        ) -> E2EResult<()> {\n            let origin = client\n                .create_and_fund_account(&ink_e2e::charlie(), 10_000_000_000_000)\n                .await;\n            let constructor = CallBuilderDelegateTestRef::new(Default::default());\n            let call_builder_contract = client\n                .instantiate(\"call_builder_delegate\", &origin, constructor, 0, None)\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder_call =\n                call_builder_contract.call::<CallBuilderDelegateTest>();\n            let code_hash = client\n                .upload(\"incrementer\", &origin, None)\n                .await\n                .expect(\"upload `incrementer` failed\")\n                .code_hash;\n            let selector = ink::selector_bytes!(\"invalid_selector\");\n            let call = call_builder_call.invoke(code_hash, selector);\n            let call_result = client.call_dry_run(&origin, &call, 0, None).await;\n            assert!(call_result.is_err());\n            assert!(call_result\n                .debug_message()\n                .contains(\"Cross-contract call failed with CouldNotReadInput\"));\n            Ok(())\n        }\npub fn invoke(&mut self, code_hash: Hash, selector: [u8; 4]) -> i32 {\n            use ink::env::call::build_call;\n            build_call::<DefaultEnvironment>()\n                .delegate(code_hash)\n                .exec_input(ExecutionInput::new(Selector::new(selector)))\n                .returns::<i32>()\n                .invoke()\n        }\npub fn invoke_contract_delegate(&self) -> i32 {\npub fn new(value: i32) -> Self {\n            Self { value }\n        }\npub fn try_invoke(&self) -> Result<ink_primitives::MessageResult<R>, crate::Error> {\n        crate::invoke_contract(self)\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "impl fmt::Debug for Scope {\n  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    f.debug_struct(\"Scope\")\n      .field(\n        \"allowed_patterns\",\n        &self\n          .allowed_patterns\n          .lock()\n          .unwrap()\n          .iter()\n          .map(|p| p.as_str())\n          .collect::<Vec<&str>>(),\n      )\n      .field(\n        \"forbidden_patterns\",\n        &self\n          .forbidden_patterns\n          .lock()\n          .unwrap()\n          .iter()\n          .map(|p| p.as_str())\n          .collect::<Vec<&str>>(),\n      )\n      .finish()\n  }\n}\nfn push_pattern<P: AsRef<Path>, F: Fn(&str) -> Result<Pattern, glob::PatternError>>(\n  list: &mut HashSet<Pattern>,\n  pattern: P,\n  f: F,\n) -> crate::Result<()> {\n  let path: PathBuf = pattern.as_ref().components().collect();\n  list.insert(f(&path.to_string_lossy())?);\n  #[cfg(windows)]\n  {\n    if let Ok(p) = std::fs::canonicalize(&path) {\n      list.insert(f(&p.to_string_lossy())?);\n    } else {\n      list.insert(f(&format!(\"\\\\\\\\?\\\\{}\", path.display()))?);\n    }\n  }\n  Ok(())\n}\nimpl Scope {\n  pub(crate) fn for_fs_api(\n    config: &Config,\n    package_info: &PackageInfo,\n    env: &Env,\n    scope: &FsAllowlistScope,\n  ) -> crate::Result<Self> {\n    let mut allowed_patterns = HashSet::new();\n    for path in scope.allowed_paths() {\n      if let Ok(path) = parse_path(config, package_info, env, path) {\n        push_pattern(&mut allowed_patterns, path, Pattern::new)?;\n      }\n    }\n    let mut forbidden_patterns = HashSet::new();\n    if let Some(forbidden_paths) = scope.forbidden_paths() {\n      for path in forbidden_paths {\n        if let Ok(path) = parse_path(config, package_info, env, path) {\n          push_pattern(&mut forbidden_patterns, path, Pattern::new)?;\n        }\n      }\n    }\n    let require_literal_leading_dot = match scope {\n      FsAllowlistScope::Scope {\n        require_literal_leading_dot: Some(require),\n        ..\n      } => *require,\n      #[cfg(unix)]\n      _ => true,\n      #[cfg(windows)]\n      _ => false,\n    };\n    Ok(Self {\n      allowed_patterns: Arc::new(Mutex::new(allowed_patterns)),\n      forbidden_patterns: Arc::new(Mutex::new(forbidden_patterns)),\n      event_listeners: Default::default(),\n      match_options: glob::MatchOptions {\n        require_literal_separator: true,\n        require_literal_leading_dot,\n        ..Default::default()\n      },\n    })\n  }\n  pub fn allowed_patterns(&self) -> HashSet<Pattern> {\n    self.allowed_patterns.lock().unwrap().clone()\n  }\n  pub fn forbidden_patterns(&self) -> HashSet<Pattern> {\n    self.forbidden_patterns.lock().unwrap().clone()\n  }\n  pub fn listen<F: Fn(&Event) + Send + 'static>(&self, f: F) -> Uuid {\n    let id = Uuid::new_v4();\n    self.event_listeners.lock().unwrap().insert(id, Box::new(f));\n    id\n  }\n  fn trigger(&self, event: Event) {\n    let listeners = self.event_listeners.lock().unwrap();\n    let handlers = listeners.values();\n    for listener in handlers {\n      listener(&event);\n    }\n  }\n  pub fn allow_directory<P: AsRef<Path>>(&self, path: P, recursive: bool) -> crate::Result<()> {\n    let path = path.as_ref();\n    {\n      let mut list = self.allowed_patterns.lock().unwrap();\n      push_pattern(&mut list, path, escaped_pattern)?;\n      push_pattern(&mut list, path, |p| {\n        escaped_pattern_with(p, if recursive { \"**\" } else { \"*\" })\n      })?;\n    }\n    self.trigger(Event::PathAllowed(path.to_path_buf()));\n    Ok(())\n  }\n  pub fn allow_file<P: AsRef<Path>>(&self, path: P) -> crate::Result<()> {\n    let path = path.as_ref();\n    push_pattern(\n      &mut self.allowed_patterns.lock().unwrap(),\n      path,\n      escaped_pattern,\n    )?;\n    self.trigger(Event::PathAllowed(path.to_path_buf()));\n    Ok(())\n  }\n  pub fn forbid_directory<P: AsRef<Path>>(&self, path: P, recursive: bool) -> crate::Result<()> {\n    let path = path.as_ref();\n    {\n      let mut list = self.forbidden_patterns.lock().unwrap();\n      push_pattern(&mut list, path, escaped_pattern)?;\n      push_pattern(&mut list, path, |p| {\n        escaped_pattern_with(p, if recursive { \"**\" } else { \"*\" })\n      })?;\n    }\n    self.trigger(Event::PathForbidden(path.to_path_buf()));\n    Ok(())\n  }\n  pub fn forbid_file<P: AsRef<Path>>(&self, path: P) -> crate::Result<()> {\n    let path = path.as_ref();\n    push_pattern(\n      &mut self.forbidden_patterns.lock().unwrap(),\n      path,\n      escaped_pattern,\n    )?;\n    self.trigger(Event::PathForbidden(path.to_path_buf()));\n    Ok(())\n  }\n  pub fn is_allowed<P: AsRef<Path>>(&self, path: P) -> bool {\n    let path = path.as_ref();\n    let path = if !path.exists() {\n      crate::Result::Ok(path.to_path_buf())\n    } else {\n      std::fs::canonicalize(path).map_err(Into::into)\n    };\n    if let Ok(path) = path {\n      let path: PathBuf = path.components().collect();\n      let forbidden = self\n        .forbidden_patterns\n        .lock()\n        .unwrap()\n        .iter()\n        .any(|p| p.matches_path_with(&path, self.match_options));\n      if forbidden {\n        false\n      } else {\n        let allowed = self\n          .allowed_patterns\n          .lock()\n          .unwrap()\n          .iter()\n          .any(|p| p.matches_path_with(&path, self.match_options));\n        allowed\n      }\n    } else {\n      false\n    }\n  }\n}\nfn escaped_pattern(p: &str) -> Result<Pattern, glob::PatternError> {\n  Pattern::new(&glob::Pattern::escape(p))\n}\nfn escaped_pattern_with(p: &str, append: &str) -> Result<Pattern, glob::PatternError> {\n  Pattern::new(&format!(\n    \"{}{}{append}\",\n    glob::Pattern::escape(p),\n    MAIN_SEPARATOR\n  ))\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn make_type_internal<F>(\n        module: BinaryIndexedView,\n        tok: &SignatureToken,\n        resolver: &F,\n    ) -> PartialVMResult<Type>\n    where\n        F: Fn(&IdentStr, &ModuleId) -> PartialVMResult<CachedStructIndex>,\n    {\n        let res = match tok {\n            SignatureToken::Bool => Type::Bool,\n            SignatureToken::U8 => Type::U8,\n            SignatureToken::U16 => Type::U16,\n            SignatureToken::U32 => Type::U32,\n            SignatureToken::U64 => Type::U64,\n            SignatureToken::U128 => Type::U128,\n            SignatureToken::U256 => Type::U256,\n            SignatureToken::Address => Type::Address,\n            SignatureToken::Signer => Type::Signer,\n            SignatureToken::TypeParameter(idx) => Type::TyParam(*idx),\n            SignatureToken::Vector(inner_tok) => {\n                let inner_type = Self::make_type_internal(module, inner_tok, resolver)?;\n                Type::Vector(Box::new(inner_type))\n            },\n            SignatureToken::Reference(inner_tok) => {\n                let inner_type = Self::make_type_internal(module, inner_tok, resolver)?;\n                Type::Reference(Box::new(inner_type))\n            },\n            SignatureToken::MutableReference(inner_tok) => {\n                let inner_type = Self::make_type_internal(module, inner_tok, resolver)?;\n                Type::MutableReference(Box::new(inner_type))\n            },\n            SignatureToken::Struct(sh_idx) => {\n                let struct_handle = module.struct_handle_at(*sh_idx);\n                let struct_name = module.identifier_at(struct_handle.name);\n                let module_handle = module.module_handle_at(struct_handle.module);\n                let module_id = ModuleId::new(\n                    *module.address_identifier_at(module_handle.address),\n                    module.identifier_at(module_handle.name).to_owned(),\n                );\n                let def_idx = resolver(struct_name, &module_id)?;\n                Type::Struct(def_idx)\n            },\n            SignatureToken::StructInstantiation(sh_idx, tys) => {\n                let type_parameters: Vec<_> = tys\n                    .iter()\n                    .map(|tok| Self::make_type_internal(module, tok, resolver))\n                    .collect::<PartialVMResult<_>>()?;\n                let struct_handle = module.struct_handle_at(*sh_idx);\n                let struct_name = module.identifier_at(struct_handle.name);\n                let module_handle = module.module_handle_at(struct_handle.module);\n                let module_id = ModuleId::new(\n                    *module.address_identifier_at(module_handle.address),\n                    module.identifier_at(module_handle.name).to_owned(),\n                );\n                let def_idx = resolver(struct_name, &module_id)?;\n                Type::StructInstantiation(def_idx, type_parameters)\n            },\n        };\n        Ok(res)\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "async fn api_return_to_sso_get_common(\n        &self,\n        req: &Request,\n        session: &Session,\n        services: Data<&Services>,\n        code: &Option<String>,\n    ) -> poem::Result<Result<String, String>> {\n        let Some(context) = session.get::<SsoContext>(SSO_CONTEXT_SESSION_KEY) else {\n            return Ok(Err(\"Not in an active SSO process\".to_string()));\n        };\n        let Some(ref code) = *code else {\n            return Ok(Err(\"No authorization code in the return URL request\".to_string()));\n        };\n        let response = context\n            .request\n            .verify_code((*code).clone())\n            .await\n            .map_err(poem::error::InternalServerError)?;\n        if !response.email_verified.unwrap_or(true) {\n            return Ok(Err(\"The SSO account's e-mail is not verified\".to_string()));\n        }\n        let Some(email) = response.email else {\n            return Ok(Err(\"No e-mail information in the SSO response\".to_string()));\n        };\n        info!(\"SSO login as {email}\");\n        let cred = AuthCredential::Sso {\n            provider: context.provider,\n            email: email.clone(),\n        };\n        let username = services\n            .config_provider\n            .lock()\n            .await\n            .username_for_sso_credential(&cred)\n            .await?;\n        let Some(username) = username else {\n            return Ok(Err(format!(\"No user matching {email}\")));\n        };\n        let mut auth_state_store = services.auth_state_store.lock().await;\n        let state_arc =\n            get_auth_state_for_request(&username, session, &mut auth_state_store).await?;\n        let mut state = state_arc.lock().await;\n        let mut cp = services.config_provider.lock().await;\n        if state.username() != username {\n            return Ok(Err(format!(\n                \"Incorrect account for SSO authentication ({username})\"\n            )));\n        }\n        if cp.validate_credential(&username, &cred).await? {\n            state.add_valid_credential(cred);\n        }\n        if let AuthResult::Accepted { username } = state.verify() {\n            auth_state_store.complete(state.id()).await;\n            authorize_session(req, username).await?;\n        }\n        Ok(Ok(context\n            .next_url\n            .as_deref()\n            .unwrap_or(\"/@warpgate#/login\")\n            .to_owned()))\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "async fn create_client_stream(config: CompleteConfig) -> Result<(Client, ClientStream), Error> {\n    let irc_config = Config {\n        nickname: Some(config.twitch.username.clone()),\n        server: Some(config.twitch.server.clone()),\n        channels: vec![format!(\"#{}\", config.twitch.channel)],\n        password: config.twitch.token.clone(),\n        port: Some(6697),\n        use_tls: Some(true),\n        ping_timeout: Some(10),\n        ping_time: Some(10),\n        ..Default::default()\n    };\n    let mut client = Client::from_config(irc_config.clone()).await?;\n    client.identify()?;\n    let stream = client.stream()?;\n    Ok((client, stream))\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "validate_feature_name(pkg_id, feature)?;\n        for fv in fvs {\n            let dep_data = {\n                match fv {\n                    Feature(dep_name) | Dep { dep_name, .. } | DepFeature { dep_name, .. } => {\n                        dep_map.get(dep_name)\n                    }\n                }\n            };\n            let is_optional_dep = dep_data\n                .iter()\n                .flat_map(|d| d.iter())\n                .any(|d| d.is_optional());\n            let is_any_dep = dep_data.is_some();\n            match fv {\n                Feature(f) => {\n                    if !features.contains_key(f) {\n                        if !is_any_dep {\n                            bail!(\n                                \"feature `{}` includes `{}` which is neither a dependency \\\n                                 nor another feature\",\n                                feature,\n                                fv\n                            );\n                        }\n                        if is_optional_dep {\n                            if !map.contains_key(f) {\n                                bail!(\n                                    \"feature `{}` includes `{}`, but `{}` is an \\\n                                     optional dependency without an implicit feature\\n\\\n                                     Use `dep:{}` to enable the dependency.\",\n                                    feature,\n                                    fv,\n                                    f,\n                                    f\n                                );\n                            }\n                        } else {\n                            bail!(\"feature `{}` includes `{}`, but `{}` is not an optional dependency\\n\\\n                                A non-optional dependency of the same name is defined; \\\n                                consider adding `optional = true` to its definition.\",\n                                feature, fv, f);\n                        }\n                    }\n                }\n                Dep { dep_name } => {\n                    if !is_any_dep {\n                        bail!(\n                            \"feature `{}` includes `{}`, but `{}` is not listed as a dependency\",\n                            feature,\n                            fv,\n                            dep_name\n                        );\n                    }\n                    if !is_optional_dep {\n                        bail!(\n                            \"feature `{}` includes `{}`, but `{}` is not an optional dependency\\n\\\n                             A non-optional dependency of the same name is defined; \\\n                             consider adding `optional = true` to its definition.\",\n                            feature,\n                            fv,\n                            dep_name\n                        );\n                    }\n                }\n                DepFeature {\n                    dep_name,\n                    dep_feature,\n                    weak,\n                    ..\n                } => {\n                    if dep_feature.contains('/') {\n                        bail!(\n                            \"multiple slashes in feature `{}` (included by feature `{}`) are not allowed\",\n                            fv,\n                            feature\n                        );\n                    }\n                    if let Some(stripped_dep) = dep_name.strip_prefix(\"dep:\") {\n                        let has_other_dep = explicitly_listed.contains(stripped_dep);\n                        let is_optional = dep_map\n                            .get(stripped_dep)\n                            .iter()\n                            .flat_map(|d| d.iter())\n                            .any(|d| d.is_optional());\n                        let extra_help = if *weak || has_other_dep || !is_optional {\n                            String::new()\n                        } else {\n                            format!(\n                                \"\\nIf the intent is to avoid creating an implicit feature \\\n                                 `{stripped_dep}` for an optional dependency, \\\n                                 then consider replacing this with two values:\\n    \\\n                                 \\\"dep:{stripped_dep}\\\", \\\"{stripped_dep}/{dep_feature}\\\"\"\n                            )\n                        };\n                        bail!(\n                            \"feature `{feature}` includes `{fv}` with both `dep:` and `/`\\n\\\n                            To fix this, remove the `dep:` prefix.{extra_help}\"\n                        )\n                    }\n                    if !is_any_dep {\n                        bail!(\n                            \"feature `{}` includes `{}`, but `{}` is not a dependency\",\n                            feature,\n                            fv,\n                            dep_name\n                        );\n                    }\n                    if *weak && !is_optional_dep {\n                        bail!(\"feature `{}` includes `{}` with a `?`, but `{}` is not an optional dependency\\n\\\n                            A non-optional dependency of the same name is defined; \\\n                            consider removing the `?` or changing the dependency to be optional\",\n                            feature, fv, dep_name);\n                    }\n                }\n            }\n        }\n    }\n    let used: HashSet<_> = map\n        .values()\n        .flatten()\n        .filter_map(|fv| match fv {\n            Dep { dep_name } | DepFeature { dep_name, .. } => Some(dep_name),\n            _ => None,\n        })\n        .collect();\n    if let Some(dep) = dependencies\n        .iter()\n        .find(|dep| dep.is_optional() && !used.contains(&dep.name_in_toml()))\n    {\n        bail!(\n            \"optional dependency `{}` is not included in any feature\\n\\\n            Make sure that `dep:{}` is included in one of features in the [features] table.\",\n            dep.name_in_toml(),\n            dep.name_in_toml(),\n        );\n    }\n    Ok(map)\n}\n#[derive(Clone, Debug, Ord, PartialOrd, Eq, PartialEq, Hash)]\npub enum FeatureValue {\n    Feature(InternedString),\n    Dep { dep_name: InternedString },\n    DepFeature {\n        dep_name: InternedString,\n        dep_feature: InternedString,\n        weak: bool,\n    },\n}\nimpl FeatureValue {\n    pub fn new(feature: InternedString) -> FeatureValue {\n        match feature.find('/') {\n            Some(pos) => {\n                let (dep, dep_feat) = feature.split_at(pos);\n                let dep_feat = &dep_feat[1..];\n                let (dep, weak) = if let Some(dep) = dep.strip_suffix('?') {\n                    (dep, true)\n                } else {\n                    (dep, false)\n                };\n                FeatureValue::DepFeature {\n                    dep_name: InternedString::new(dep),\n                    dep_feature: InternedString::new(dep_feat),\n                    weak,\n                }\n            }\n            None => {\n                if let Some(dep_name) = feature.strip_prefix(\"dep:\") {\n                    FeatureValue::Dep {\n                        dep_name: InternedString::new(dep_name),\n                    }\n                } else {\n                    FeatureValue::Feature(feature)\n                }\n            }\n        }\n    }\n    pub fn has_dep_prefix(&self) -> bool {\n        matches!(self, FeatureValue::Dep { .. })\n    }\n}\nimpl fmt::Display for FeatureValue {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        use self::FeatureValue::*;\n        match self {\n            Feature(feat) => write!(f, \"{}\", feat),\n            Dep { dep_name } => write!(f, \"dep:{}\", dep_name),\n            DepFeature {\n                dep_name,\n                dep_feature,\n                weak,\n            } => {\n                let weak = if *weak { \"?\" } else { \"\" };\n                write!(f, \"{}{}/{}\", dep_name, weak, dep_feature)\n            }\n        }\n    }\n}\npub type FeatureMap = BTreeMap<InternedString, Vec<FeatureValue>>;\nfn validate_feature_name(pkg_id: PackageId, name: &str) -> CargoResult<()> {\n    let mut chars = name.chars();\n    if let Some(ch) = chars.next() {\n        if !(unicode_xid::UnicodeXID::is_xid_start(ch) || ch == '_' || ch.is_digit(10)) {\n            bail!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                the first character must be a Unicode XID start character or digit \\\n                (most letters or `_` or `0` to `9`)\",\n                ch,\n                name,\n                pkg_id\n            );\n        }\n    }\n    for ch in chars {\n        if !(unicode_xid::UnicodeXID::is_xid_continue(ch) || ch == '-' || ch == '+' || ch == '.') {\n            bail!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                characters must be Unicode XID characters, `+`, or `.` \\\n                (numbers, `+`, `-`, `_`, `.`, or most letters)\",\n                ch,\n                name,\n                pkg_id\n            );\n        }\n    }\n    Ok(())\n}\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::sources::CRATES_IO_INDEX;\n    use crate::util::into_url::IntoUrl;\n    use crate::core::SourceId;\n    #[test]\n    fn valid_feature_names() {\n        let loc = CRATES_IO_INDEX.into_url().unwrap();\n        let source_id = SourceId::for_registry(&loc).unwrap();\n        let pkg_id = PackageId::new(\"foo\", \"1.0.0\", source_id).unwrap();\n        assert!(validate_feature_name(pkg_id, \"c++17\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"128bit\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"_foo\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"feat-name\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"feat_name\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"foo.bar\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"+foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"-foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \".foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"foo:bar\").is_err());\n        assert!(validate_feature_name(pkg_id, \"foo?\").is_err());\n        assert!(validate_feature_name(pkg_id, \"?foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"\").is_err());\n        assert!(validate_feature_name(pkg_id, \"a\").is_err());\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn get_ref<T: ByteValued>(&self, offset: usize) -> Result<VolatileRef<T, BS<Self::B>>> {\n        let slice = self.get_slice(offset, size_of::<T>())?;\n        assert_eq!(\n            slice.len(),\n            size_of::<T>(),\n            \"VolatileMemory::get_slice(offset, count) returned slice of length != count.\"\n        );\n        unsafe {\n            Ok(VolatileRef::with_bitmap(\n                slice.addr,\n                slice.bitmap,\n                slice.mmap,\n            ))\n        }\n    }\nunsafe fn aligned_as_ref<T: ByteValued>(&self, offset: usize) -> Result<&T> {\n        let slice = self.get_slice(offset, size_of::<T>())?;\n        slice.check_alignment(align_of::<T>())?;\n        assert_eq!(\n            slice.len(),\n            size_of::<T>(),\n            \"VolatileMemory::get_slice(offset, count) returned slice of length != count.\"\n        );\n        unsafe { Ok(&*(slice.addr as *const T)) }\n    }\nunsafe fn aligned_as_mut<T: ByteValued>(&self, offset: usize) -> Result<&mut T> {\n        let slice = self.get_slice(offset, size_of::<T>())?;\n        slice.check_alignment(align_of::<T>())?;\n        assert_eq!(\n            slice.len(),\n            size_of::<T>(),\n            \"VolatileMemory::get_slice(offset, count) returned slice of length != count.\"\n        );\n        unsafe { Ok(&mut *(slice.addr as *mut T)) }\n    }\nfn get_atomic_ref<T: AtomicInteger>(&self, offset: usize) -> Result<&T> {\n        let slice = self.get_slice(offset, size_of::<T>())?;\n        slice.check_alignment(align_of::<T>())?;\n        assert_eq!(\n            slice.len(),\n            size_of::<T>(),\n            \"VolatileMemory::get_slice(offset, count) returned slice of length != count.\"\n        );\n        unsafe { Ok(&*(slice.addr as *const T)) }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub(crate) fn operation_name(&self) -> Option<String> {\n        self.entries\n            .get(OPERATION_NAME)\n            .map(|v| v.value().as_str().unwrap().to_string())\n    }\nasync fn call_websocket(\n    mut notify: Notify<String, graphql::Response>,\n    request: SubgraphRequest,\n    context: Context,\n    service_name: String,\n    subgraph_cfg: &WebSocketConfiguration,\n    subscription_hash: String,\n) -> Result<SubgraphResponse, BoxError> {\n    let SubgraphRequest {\n        subgraph_request,\n        subscription_stream,\n        ..\n    } = request;\n    let mut subscription_stream_tx =\n        subscription_stream.ok_or_else(|| FetchError::SubrequestWsError {\n            service: service_name.clone(),\n            reason: \"cannot get the websocket stream\".to_string(),\n        })?;\n    let (handle, created) = notify\n        .create_or_subscribe(subscription_hash.clone(), false)\n        .await?;\n    tracing::info!(\n        monotonic_counter.apollo.router.operations.subscriptions = 1u64,\n        subscriptions.mode = %\"passthrough\",\n        subscriptions.deduplicated = !created,\n        subgraph.service.name = service_name,\n    );\n    if !created {\n        subscription_stream_tx.send(handle.into_stream()).await?;\n        tracing::info!(\n            monotonic_counter.apollo_router_deduplicated_subscriptions_total = 1u64,\n            mode = %\"passthrough\",\n        );\n        return Ok(SubgraphResponse::builder()\n            .context(context)\n            .extensions(Object::default())\n            .build());\n    }\n    let (parts, body) = subgraph_request.into_parts();\n    let connection_params = match (\n        context.get_json_value(SUBSCRIPTION_WS_CUSTOM_CONNECTION_PARAMS),\n        parts\n            .headers\n            .get(http::header::AUTHORIZATION)\n            .and_then(|auth| auth.to_str().ok()),\n    ) {\n        (Some(connection_params), _) => Some(connection_params),\n        (None, Some(authorization)) => Some(serde_json_bytes::json!({ \"token\": authorization })),\n        _ => None,\n    };\n    let request = get_websocket_request(service_name.clone(), parts, subgraph_cfg)?;\n    let display_headers = context.contains_key(LOGGING_DISPLAY_HEADERS);\n    let display_body = context.contains_key(LOGGING_DISPLAY_BODY);\n    if display_headers {\n        tracing::info!(http.request.headers = ?request.headers(), apollo.subgraph.name = %service_name, \"Websocket request headers to subgraph {service_name:?}\");\n    }\n    if display_body {\n        tracing::info!(http.request.body = ?request.body(), apollo.subgraph.name = %service_name, \"Websocket request body to subgraph {service_name:?}\");\n    }\n    let uri = request.uri();\n    let path = uri.path();\n    let host = uri.host().unwrap_or_default();\n    let port = uri.port_u16().unwrap_or_else(|| {\n        let scheme = uri.scheme_str();\n        if scheme == Some(\"wss\") {\n            443\n        } else if scheme == Some(\"ws\") {\n            80\n        } else {\n            0\n        }\n    });\n    let subgraph_req_span = tracing::info_span!(\"subgraph_request\",\n        \"otel.kind\" = \"CLIENT\",\n        \"net.peer.name\" = %host,\n        \"net.peer.port\" = %port,\n        \"http.route\" = %path,\n        \"http.url\" = %uri,\n        \"net.transport\" = \"ip_tcp\",\n        \"apollo.subgraph.name\" = %service_name,\n        \"graphql.operation.name\" = %operation_name,\n    );\n    let (ws_stream, mut resp) = match request.uri().scheme_str() {\n        Some(\"wss\") => {\n            connect_async_tls_with_config(request, None, None)\n                .instrument(subgraph_req_span)\n                .await\n        }\n        _ => connect_async(request).instrument(subgraph_req_span).await,\n    }\n    .map_err(|err| FetchError::SubrequestWsError {\n        service: service_name.clone(),\n        reason: format!(\"cannot connect websocket to subgraph: {err}\"),\n    })?;\n    if display_body {\n        tracing::info!(\n            response.body = %String::from_utf8_lossy(&resp.body_mut().take().unwrap_or_default()), apollo.subgraph.name = %service_name, \"Raw response body from subgraph {service_name:?} received\"\n        );\n    }\n    let mut gql_stream = GraphqlWebSocket::new(\n        convert_websocket_stream(ws_stream, subscription_hash.clone()),\n        subscription_hash,\n        subgraph_cfg.protocol,\n        connection_params,\n    )\n    .await\n    .map_err(|_| FetchError::SubrequestWsError {\n        service: service_name.clone(),\n        reason: \"cannot get the GraphQL websocket stream\".to_string(),\n    })?;\n    gql_stream\n        .send(body)\n        .await\n        .map_err(|err| FetchError::SubrequestWsError {\n            service: service_name,\n            reason: format!(\"cannot send the subgraph request to websocket stream: {err:?}\"),\n        })?;\n    let (mut gql_sink, gql_stream) = gql_stream.split();\n    let (handle_sink, handle_stream) = handle.split();\n    tokio::task::spawn(async move {\n        let _ = gql_stream\n            .map(Ok::<_, graphql::Error>)\n            .forward(handle_sink)\n            .await;\n        if let Err(err) = gql_sink.close().await {\n            tracing::trace!(\"cannot close the websocket stream: {err:?}\");\n        }\n    });\n    subscription_stream_tx.send(handle_stream).await?;\n    Ok(SubgraphResponse::new_from_response(\n        resp.map(|_| graphql::Response::default()),\n        context,\n    ))\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn create_p2p_network(\n        config: &NodeConfig,\n        state_sync_store: RocksDbStore,\n        chain_identifier: ChainIdentifier,\n        trusted_peer_change_rx: watch::Receiver<TrustedPeerChangeEvent>,\n        archive_readers: ArchiveReaderBalancer,\n        prometheus_registry: &Registry,\n    ) -> Result<(Network, discovery::Handle, state_sync::Handle)> {\n        let (state_sync, state_sync_server) = state_sync::Builder::new()\n            .config(config.p2p_config.state_sync.clone().unwrap_or_default())\n            .store(state_sync_store)\n            .archive_readers(archive_readers)\n            .with_metrics(prometheus_registry)\n            .build();\n        let (discovery, discovery_server) = discovery::Builder::new(trusted_peer_change_rx)\n            .config(config.p2p_config.clone())\n            .build();\n        let p2p_network = {\n            let routes = anemo::Router::new()\n                .add_rpc_service(discovery_server)\n                .add_rpc_service(state_sync_server);\n            let inbound_network_metrics =\n                NetworkMetrics::new(\"sui\", \"inbound\", prometheus_registry);\n            let outbound_network_metrics =\n                NetworkMetrics::new(\"sui\", \"outbound\", prometheus_registry);\n            let service = ServiceBuilder::new()\n                .layer(\n                    TraceLayer::new_for_server_errors()\n                        .make_span_with(DefaultMakeSpan::new().level(tracing::Level::INFO))\n                        .on_failure(DefaultOnFailure::new().level(tracing::Level::WARN)),\n                )\n                .layer(CallbackLayer::new(MetricsMakeCallbackHandler::new(\n                    Arc::new(inbound_network_metrics),\n                    config.p2p_config.excessive_message_size(),\n                )))\n                .service(routes);\n            let outbound_layer = ServiceBuilder::new()\n                .layer(\n                    TraceLayer::new_for_client_and_server_errors()\n                        .make_span_with(DefaultMakeSpan::new().level(tracing::Level::INFO))\n                        .on_failure(DefaultOnFailure::new().level(tracing::Level::WARN)),\n                )\n                .layer(CallbackLayer::new(MetricsMakeCallbackHandler::new(\n                    Arc::new(outbound_network_metrics),\n                    config.p2p_config.excessive_message_size(),\n                )))\n                .into_inner();\n            let mut anemo_config = config.p2p_config.anemo_config.clone().unwrap_or_default();\n            anemo_config.max_frame_size = Some(1 << 30);\n            let mut quic_config = anemo_config.quic.unwrap_or_default();\n            if quic_config.socket_send_buffer_size.is_none() {\n                quic_config.socket_send_buffer_size = Some(20 << 20);\n            }\n            if quic_config.socket_receive_buffer_size.is_none() {\n                quic_config.socket_receive_buffer_size = Some(20 << 20);\n            }\n            quic_config.allow_failed_socket_buffer_size_setting = true;\n            anemo_config.quic = Some(quic_config);\n            let server_name = format!(\"sui-{}\", chain_identifier);\n            let network = Network::bind(config.p2p_config.listen_address)\n                .server_name(&server_name)\n                .private_key(config.network_key_pair().copy().private().0.to_bytes())\n                .config(anemo_config)\n                .outbound_request_layer(outbound_layer)\n                .start(service)?;\n            info!(\n                server_name = server_name,\n                \"P2p network started on {}\",\n                network.local_addr()\n            );\n            network\n        };\n        let discovery_handle = discovery.start(p2p_network.clone());\n        let state_sync_handle = state_sync.start(p2p_network.clone());\n        Ok((p2p_network, discovery_handle, state_sync_handle))\n    }\nfn decode(&mut self, buf: &mut DecodeBuf<'_>) -> Result<Option<Self::Item>, Self::Error> {\n        if !buf.has_remaining() {\n            return Ok(None);\n        }\n        let chunk = buf.chunk();\n        let item: Self::Item =\n            bcs::from_bytes(chunk).map_err(|e| Status::internal(e.to_string()))?;\n        buf.advance(chunk.len());\n        Ok(Some(item))\n    }\npub fn spawn(\n        authority: Authority,\n        keypair: NetworkKeyPair,\n        id: WorkerId,\n        committee: Committee,\n        worker_cache: WorkerCache,\n        protocol_config: ProtocolConfig,\n        parameters: Parameters,\n        validator: impl TransactionValidator,\n        client: NetworkClient,\n        store: DBMap<BatchDigest, Batch>,\n        metrics: Metrics,\n        tx_shutdown: &mut PreSubscribedBroadcastSender,\n    ) -> Vec<JoinHandle<()>> {\n        let worker_name = keypair.public().clone();\n        let worker_peer_id = PeerId(worker_name.0.to_bytes());\n        info!(\"Boot worker node with id {} peer id {}\", id, worker_peer_id,);\n        let worker = Self {\n            authority: authority.clone(),\n            keypair,\n            id,\n            committee: committee.clone(),\n            worker_cache: worker_cache.clone(),\n            protocol_config: protocol_config.clone(),\n            parameters: parameters.clone(),\n            store,\n        };\n        let node_metrics = Arc::new(metrics.worker_metrics.unwrap());\n        let endpoint_metrics = metrics.endpoint_metrics.unwrap();\n        let channel_metrics: Arc<WorkerChannelMetrics> = Arc::new(metrics.channel_metrics.unwrap());\n        let inbound_network_metrics = Arc::new(metrics.inbound_network_metrics.unwrap());\n        let outbound_network_metrics = Arc::new(metrics.outbound_network_metrics.unwrap());\n        let network_connection_metrics = metrics.network_connection_metrics.unwrap();\n        let mut shutdown_receivers = tx_shutdown.subscribe_n(NUM_SHUTDOWN_RECEIVERS);\n        let mut worker_service = WorkerToWorkerServer::new(WorkerReceiverHandler {\n            protocol_config: protocol_config.clone(),\n            id: worker.id,\n            client: client.clone(),\n            store: worker.store.clone(),\n            validator: validator.clone(),\n        });\n        if let Some(limit) = parameters.anemo.report_batch_rate_limit {\n            worker_service = worker_service.add_layer_for_report_batch(InboundRequestLayer::new(\n                rate_limit::RateLimitLayer::new(\n                    governor::Quota::per_second(limit),\n                    rate_limit::WaitMode::Block,\n                ),\n            ));\n        }\n        if let Some(limit) = parameters.anemo.request_batches_rate_limit {\n            worker_service = worker_service.add_layer_for_request_batches(\n                InboundRequestLayer::new(rate_limit::RateLimitLayer::new(\n                    governor::Quota::per_second(limit),\n                    rate_limit::WaitMode::Block,\n                )),\n            );\n        }\n        let primary_service = PrimaryToWorkerServer::new(PrimaryReceiverHandler {\n            authority_id: worker.authority.id(),\n            id: worker.id,\n            committee: worker.committee.clone(),\n            protocol_config: protocol_config.clone(),\n            worker_cache: worker.worker_cache.clone(),\n            store: worker.store.clone(),\n            request_batches_timeout: worker.parameters.sync_retry_delay,\n            request_batches_retry_nodes: worker.parameters.sync_retry_nodes,\n            network: None,\n            batch_fetcher: None,\n            validator: validator.clone(),\n        });\n        let address = worker\n            .worker_cache\n            .worker(authority.protocol_key(), &id)\n            .expect(\"Our public key or worker id is not in the worker cache\")\n            .worker_address;\n        let address = address\n            .replace(0, |_protocol| Some(Protocol::Ip4(Ipv4Addr::UNSPECIFIED)))\n            .unwrap();\n        let addr = address.to_anemo_address().unwrap();\n        let epoch_string: String = committee.epoch().to_string();\n        let our_primary_peer_id = PeerId(authority.network_key().0.to_bytes());\n        let primary_to_worker_router = anemo::Router::new()\n            .add_rpc_service(primary_service)\n            .route_layer(RequireAuthorizationLayer::new(AllowedPeers::new([\n                our_primary_peer_id,\n            ])))\n            .route_layer(RequireAuthorizationLayer::new(AllowedEpoch::new(\n                epoch_string.clone(),\n            )));\n        let worker_peer_ids = worker_cache\n            .all_workers()\n            .into_iter()\n            .map(|(worker_name, _)| PeerId(worker_name.0.to_bytes()));\n        let routes = anemo::Router::new()\n            .add_rpc_service(worker_service)\n            .route_layer(RequireAuthorizationLayer::new(AllowedPeers::new(\n                worker_peer_ids,\n            )))\n            .route_layer(RequireAuthorizationLayer::new(AllowedEpoch::new(\n                epoch_string.clone(),\n            )))\n            .merge(primary_to_worker_router);\n        let service = ServiceBuilder::new()\n            .layer(\n                TraceLayer::new_for_server_errors()\n                    .make_span_with(DefaultMakeSpan::new().level(tracing::Level::INFO))\n                    .on_failure(DefaultOnFailure::new().level(tracing::Level::WARN)),\n            )\n            .layer(CallbackLayer::new(MetricsMakeCallbackHandler::new(\n                inbound_network_metrics,\n                parameters.anemo.excessive_message_size(),\n            )))\n            .layer(CallbackLayer::new(FailpointsMakeCallbackHandler::new()))\n            .layer(SetResponseHeaderLayer::overriding(\n                EPOCH_HEADER_KEY.parse().unwrap(),\n                epoch_string.clone(),\n            ))\n            .service(routes);\n        let outbound_layer = ServiceBuilder::new()\n            .layer(\n                TraceLayer::new_for_client_and_server_errors()\n                    .make_span_with(DefaultMakeSpan::new().level(tracing::Level::INFO))\n                    .on_failure(DefaultOnFailure::new().level(tracing::Level::WARN)),\n            )\n            .layer(CallbackLayer::new(MetricsMakeCallbackHandler::new(\n                outbound_network_metrics,\n                parameters.anemo.excessive_message_size(),\n            )))\n            .layer(CallbackLayer::new(FailpointsMakeCallbackHandler::new()))\n            .layer(SetRequestHeaderLayer::overriding(\n                EPOCH_HEADER_KEY.parse().unwrap(),\n                epoch_string,\n            ))\n            .into_inner();\n        let anemo_config = {\n            let mut quic_config = anemo::QuicConfig::default();\n            quic_config.max_concurrent_bidi_streams = Some(10_000);\n            quic_config.stream_receive_window = Some(100 << 20);\n            quic_config.receive_window = Some(200 << 20);\n            quic_config.send_window = Some(200 << 20);\n            quic_config.crypto_buffer_size = Some(1 << 20);\n            quic_config.socket_receive_buffer_size = Some(20 << 20);\n            quic_config.socket_send_buffer_size = Some(20 << 20);\n            quic_config.allow_failed_socket_buffer_size_setting = true;\n            quic_config.max_idle_timeout_ms = Some(30_000);\n            quic_config.keep_alive_interval_ms = Some(5_000);\n            let mut config = anemo::Config::default();\n            config.quic = Some(quic_config);\n            config.max_frame_size = Some(1 << 30);\n            config.inbound_request_timeout_ms = Some(300_000);\n            config.outbound_request_timeout_ms = Some(300_000);\n            config.shutdown_idle_timeout_ms = Some(1_000);\n            config.connectivity_check_interval_ms = Some(2_000);\n            config.connection_backoff_ms = Some(1_000);\n            config.max_connection_backoff_ms = Some(20_000);\n            config\n        };\n        let network;\n        let mut retries_left = 90;\n        loop {\n            let network_result = anemo::Network::bind(addr.clone())\n                .server_name(\"narwhal\")\n                .private_key(worker.keypair.copy().private().0.to_bytes())\n                .config(anemo_config.clone())\n                .outbound_request_layer(outbound_layer.clone())\n                .start(service.clone());\n            match network_result {\n                Ok(n) => {\n                    network = n;\n                    break;\n                }\n                Err(_) => {\n                    retries_left -= 1;\n                    if retries_left <= 0 {\n                        panic!();\n                    }\n                    error!(\n                        \"Address {} should be available for the primary Narwhal service, retrying in one second\",\n                        addr\n                    );\n                    sleep(Duration::from_secs(1));\n                }\n            }\n        }\n        info!(\"Worker {} listening to worker messages on {}\", id, address);\n        let batch_fetcher = BatchFetcher::new(\n            worker_name,\n            network.clone(),\n            worker.store.clone(),\n            node_metrics.clone(),\n            protocol_config.clone(),\n        );\n        client.set_primary_to_worker_local_handler(\n            worker_peer_id,\n            Arc::new(PrimaryReceiverHandler {\n                authority_id: worker.authority.id(),\n                id: worker.id,\n                committee: worker.committee.clone(),\n                protocol_config,\n                worker_cache: worker.worker_cache.clone(),\n                store: worker.store.clone(),\n                request_batches_timeout: worker.parameters.sync_retry_delay,\n                request_batches_retry_nodes: worker.parameters.sync_retry_nodes,\n                network: Some(network.clone()),\n                batch_fetcher: Some(batch_fetcher),\n                validator: validator.clone(),\n            }),\n        );\n        let mut peer_types = HashMap::new();\n        let other_workers = worker\n            .worker_cache\n            .others_workers_by_id(authority.protocol_key(), &id)\n            .into_iter()\n            .map(|(_, info)| (info.name, info.worker_address));\n        for (public_key, address) in other_workers {\n            let (peer_id, address) = Self::add_peer_in_network(&network, public_key, &address);\n            peer_types.insert(peer_id, \"other_worker\".to_string());\n            info!(\n                \"Adding others workers with peer id {} and address {}\",\n                peer_id, address\n            );\n        }\n        let (peer_id, address) = Self::add_peer_in_network(\n            &network,\n            authority.network_key(),\n            &authority.primary_address(),\n        );\n        peer_types.insert(peer_id, \"our_primary\".to_string());\n        info!(\n            \"Adding our primary with peer id {} and address {}\",\n            peer_id, address\n        );\n        let other_primaries: Vec<(AuthorityIdentifier, Multiaddr, NetworkPublicKey)> =\n            committee.others_primaries_by_id(authority.id());\n        for (_, _, network_key) in other_primaries {\n            peer_types.insert(\n                PeerId(network_key.0.to_bytes()),\n                \"other_primary\".to_string(),\n            );\n        }\n        let (connection_monitor_handle, _) = network::connectivity::ConnectionMonitor::spawn(\n            network.downgrade(),\n            network_connection_metrics,\n            peer_types,\n            Some(shutdown_receivers.pop().unwrap()),\n        );\n        let network_admin_server_base_port = parameters\n            .network_admin_server\n            .worker_network_admin_server_base_port\n            .checked_add(id as u16)\n            .unwrap();\n        info!(\n            \"Worker {} listening to network admin messages on 127.0.0.1:{}\",\n            id, network_admin_server_base_port\n        );\n        let admin_handles = network::admin::start_admin_server(\n            network_admin_server_base_port,\n            network.clone(),\n            shutdown_receivers.pop().unwrap(),\n        );\n        let client_flow_handles = worker.handle_clients_transactions(\n            vec![\n                shutdown_receivers.pop().unwrap(),\n                shutdown_receivers.pop().unwrap(),\n                shutdown_receivers.pop().unwrap(),\n            ],\n            node_metrics,\n            channel_metrics,\n            endpoint_metrics,\n            validator,\n            client,\n            network.clone(),\n        );\n        let network_shutdown_handle =\n            Self::shutdown_network_listener(shutdown_receivers.pop().unwrap(), network);\n        info!(\n            \"Worker {} successfully booted on {}\",\n            id,\n            worker\n                .worker_cache\n                .worker(authority.protocol_key(), &worker.id)\n                .expect(\"Our public key or worker id is not in the worker cache\")\n                .transactions\n        );\n        let mut handles = vec![connection_monitor_handle, network_shutdown_handle];\n        handles.extend(admin_handles);\n        handles.extend(client_flow_handles);\n        handles\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub struct ServerHandler {\n    pub id: SessionId,\n    pub event_tx: UnboundedSender<ServerHandlerEvent>,\n}\n#[derive(thiserror::Error, Debug)]\npub enum ServerHandlerError {\n    #[error(\"channel disconnected\")]\n    ChannelSend,\n}\nimpl ServerHandler {\n    fn send_event(&self, event: ServerHandlerEvent) -> Result<(), ServerHandlerError> {\n        self.event_tx\n            .send(event)\n            .map_err(|_| ServerHandlerError::ChannelSend)\n    }\n}\n#[async_trait]\nimpl russh::server::Handler for ServerHandler {\n    type Error = anyhow::Error;\n    async fn auth_succeeded(self, session: Session) -> Result<(Self, Session), Self::Error> {\n        let handle = session.handle();\n        self.send_event(ServerHandlerEvent::Authenticated(HandleWrapper(handle)))?;\n        Ok((self, session))\n    }\n    async fn channel_open_session(\n        self,\n        channel: Channel<Msg>,\n        session: Session,\n    ) -> Result<(Self, bool, Session), Self::Error> {\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::ChannelOpenSession(\n            ServerChannelId(channel.id()),\n            tx,\n        ))?;\n        let allowed = rx.await.unwrap_or(false);\n        Ok((self, allowed, session))\n    }\n    async fn subsystem_request(\n        self,\n        channel: ChannelId,\n        name: &str,\n        mut session: Session,\n    ) -> Result<(Self, Session), Self::Error> {\n        let name = name.to_string();\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::SubsystemRequest(\n            ServerChannelId(channel),\n            name,\n            tx,\n        ))?;\n        if rx.await.unwrap_or(false) {\n            session.channel_success(channel)\n        } else {\n            session.channel_failure(channel)\n        }\n        Ok((self, session))\n    }\n    async fn pty_request(\n        self,\n        channel: ChannelId,\n        term: &str,\n        col_width: u32,\n        row_height: u32,\n        pix_width: u32,\n        pix_height: u32,\n        modes: &[(Pty, u32)],\n        mut session: Session,\n    ) -> Result<(Self, Session), Self::Error> {\n        let term = term.to_string();\n        let modes = modes\n            .iter()\n            .take_while(|x| (x.0 as u8) > 0 && (x.0 as u8) < 160)\n            .map(Clone::clone)\n            .collect();\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::PtyRequest(\n            ServerChannelId(channel),\n            PtyRequest {\n                term,\n                col_width,\n                row_height,\n                pix_width,\n                pix_height,\n                modes,\n            },\n            tx,\n        ))?;\n        let _ = rx.await;\n        session.channel_success(channel);\n        Ok((self, session))\n    }\n    async fn shell_request(\n        self,\n        channel: ChannelId,\n        mut session: Session,\n    ) -> Result<(Self, Session), Self::Error> {\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::ShellRequest(\n            ServerChannelId(channel),\n            tx,\n        ))?;\n        if rx.await.unwrap_or(false) {\n            session.channel_success(channel)\n        } else {\n            session.channel_failure(channel)\n        }\n        Ok((self, session))\n    }\n    async fn auth_publickey_offered(\n        self,\n        user: &str,\n        key: &russh_keys::key::PublicKey,\n    ) -> Result<(Self, Auth), Self::Error> {\n        let user = Secret::new(user.to_string());\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::AuthPublicKeyOffer(\n            user,\n            key.clone(),\n            tx,\n        ))?;\n        let result = rx.await.unwrap_or(false);\n        Ok((\n            self,\n            if result {\n                Auth::Accept\n            } else {\n                Auth::Reject {\n                    proceed_with_methods: None,\n                }\n            },\n        ))\n    }\n    async fn auth_publickey(\n        self,\n        user: &str,\n        key: &russh_keys::key::PublicKey,\n    ) -> Result<(Self, Auth), Self::Error> {\n        let user = Secret::new(user.to_string());\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::AuthPublicKey(user, key.clone(), tx))?;\n        let result = rx.await.unwrap_or(Auth::UnsupportedMethod);\n        Ok((self, result))\n    }\n    async fn auth_password(self, user: &str, password: &str) -> Result<(Self, Auth), Self::Error> {\n        let user = Secret::new(user.to_string());\n        let password = Secret::new(password.to_string());\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::AuthPassword(user, password, tx))?;\n        let result = rx.await.unwrap_or(Auth::UnsupportedMethod);\n        Ok((self, result))\n    }\n    async fn auth_keyboard_interactive(\n        self,\n        user: &str,\n        _submethods: &str,\n        response: Option<russh::server::Response<'async_trait>>,\n    ) -> Result<(Self, Auth), Self::Error> {\n        let user = Secret::new(user.to_string());\n        let response = response\n            .and_then(|mut r| r.next())\n            .and_then(|b| String::from_utf8(b.to_vec()).ok())\n            .map(Secret::new);\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::AuthKeyboardInteractive(\n            user, response, tx,\n        ))?;\n        let result = rx.await.unwrap_or(Auth::UnsupportedMethod);\n        Ok((self, result))\n    }\n    async fn data(\n        self,\n        channel: ChannelId,\n        data: &[u8],\n        session: Session,\n    ) -> Result<(Self, Session), Self::Error> {\n        let channel = ServerChannelId(channel);\n        let data = Bytes::from(data.to_vec());\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::Data(channel, data, tx))?;\n        let _ = rx.await;\n        Ok((self, session))\n    }\n    async fn extended_data(\n        self,\n        channel: ChannelId,\n        code: u32,\n        data: &[u8],\n        session: Session,\n    ) -> Result<(Self, Session), Self::Error> {\n        let channel = ServerChannelId(channel);\n        let data = Bytes::from(data.to_vec());\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::ExtendedData(channel, data, code, tx))?;\n        let _ = rx.await;\n        Ok((self, session))\n    }\n    async fn channel_close(\n        self,\n        channel: ChannelId,\n        session: Session,\n    ) -> Result<(Self, Session), Self::Error> {\n        let channel = ServerChannelId(channel);\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::ChannelClose(channel, tx))?;\n        let _ = rx.await;\n        Ok((self, session))\n    }\n    async fn window_change_request(\n        self,\n        channel: ChannelId,\n        col_width: u32,\n        row_height: u32,\n        pix_width: u32,\n        pix_height: u32,\n        session: Session,\n    ) -> Result<(Self, Session), Self::Error> {\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::WindowChangeRequest(\n            ServerChannelId(channel),\n            PtyRequest {\n                term: \"\".to_string(),\n                col_width,\n                row_height,\n                pix_width,\n                pix_height,\n                modes: vec![],\n            },\n            tx,\n        ))?;\n        let _ = rx.await;\n        Ok((self, session))\n    }\n    async fn channel_eof(\n        self,\n        channel: ChannelId,\n        session: Session,\n    ) -> Result<(Self, Session), Self::Error> {\n        let channel = ServerChannelId(channel);\n        let (tx, rx) = oneshot::channel();\n        self.event_tx\n            .send(ServerHandlerEvent::ChannelEof(channel, tx))\n            .map_err(|_| ServerHandlerError::ChannelSend)?;\n        let _ = rx.await;\n        Ok((self, session))\n    }\n    async fn signal(\n        self,\n        channel: ChannelId,\n        signal_name: russh::Sig,\n        session: Session,\n    ) -> Result<(Self, Session), Self::Error> {\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::Signal(\n            ServerChannelId(channel),\n            signal_name,\n            tx,\n        ))?;\n        let _ = rx.await;\n        Ok((self, session))\n    }\n    async fn exec_request(\n        self,\n        channel: ChannelId,\n        data: &[u8],\n        mut session: Session,\n    ) -> Result<(Self, Session), Self::Error> {\n        let data = Bytes::from(data.to_vec());\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::ExecRequest(\n            ServerChannelId(channel),\n            data,\n            tx,\n        ))?;\n        if rx.await.unwrap_or(false) {\n            session.channel_success(channel)\n        } else {\n            session.channel_failure(channel)\n        }\n        Ok((self, session))\n    }\n    async fn env_request(\n        self,\n        channel: ChannelId,\n        variable_name: &str,\n        variable_value: &str,\n        session: Session,\n    ) -> Result<(Self, Session), Self::Error> {\n        let variable_name = variable_name.to_string();\n        let variable_value = variable_value.to_string();\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::EnvRequest(\n            ServerChannelId(channel),\n            variable_name,\n            variable_value,\n            tx,\n        ))?;\n        let _ = rx.await;\n        Ok((self, session))\n    }\n    async fn channel_open_direct_tcpip(\n        self,\n        channel: Channel<Msg>,\n        host_to_connect: &str,\n        port_to_connect: u32,\n        originator_address: &str,\n        originator_port: u32,\n        session: Session,\n    ) -> Result<(Self, bool, Session), Self::Error> {\n        let host_to_connect = host_to_connect.to_string();\n        let originator_address = originator_address.to_string();\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::ChannelOpenDirectTcpIp(\n            ServerChannelId(channel.id()),\n            DirectTCPIPParams {\n                host_to_connect,\n                port_to_connect,\n                originator_address,\n                originator_port,\n            },\n            tx,\n        ))?;\n        let allowed = rx.await.unwrap_or(false);\n        Ok((self, allowed, session))\n    }\n    async fn x11_request(\n        self,\n        channel: ChannelId,\n        single_conection: bool,\n        x11_auth_protocol: &str,\n        x11_auth_cookie: &str,\n        x11_screen_number: u32,\n        session: Session,\n    ) -> Result<(Self, Session), Self::Error> {\n        let x11_auth_protocol = x11_auth_protocol.to_string();\n        let x11_auth_cookie = x11_auth_cookie.to_string();\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::X11Request(\n            ServerChannelId(channel),\n            X11Request {\n                single_conection,\n                x11_auth_protocol,\n                x11_auth_cookie,\n                x11_screen_number,\n            },\n            tx,\n        ))?;\n        let _ = rx.await;\n        Ok((self, session))\n    }\n    async fn tcpip_forward(\n        self,\n        address: &str,\n        port: &mut u32,\n        mut session: Session,\n    ) -> Result<(Self, bool, Session), Self::Error> {\n        let address = address.to_string();\n        let port = *port;\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::TcpIpForward(address, port, tx))?;\n        let allowed = rx.await.unwrap_or(false);\n        if allowed {\n            session.request_success()\n        } else {\n            session.request_failure()\n        }\n        Ok((self, allowed, session))\n    }\n    async fn cancel_tcpip_forward(\n        self,\n        address: &str,\n        port: u32,\n        mut session: Session,\n    ) -> Result<(Self, bool, Session), Self::Error> {\n        let address = address.to_string();\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::CancelTcpIpForward(address, port, tx))?;\n        let allowed = rx.await.unwrap_or(false);\n        if allowed {\n            session.request_success()\n        } else {\n            session.request_failure()\n        }\n        Ok((self, allowed, session))\n    }\n}\nimpl Drop for ServerHandler {\n    fn drop(&mut self) {\n        debug!(\"Dropped\");\n        let _ = self.event_tx.send(ServerHandlerEvent::Disconnect);\n    }\n}\nimpl Debug for ServerHandler {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"ServerHandler\")\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn config() -> &'static EvmConfig {\n\t\t\t&SHANGHAI_CONFIG\n\t\t}\nfn handle_sufficient_reference() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet addr = H160::from_str(\"1230000000000000000000000000000000000001\").unwrap();\n\t\tlet addr_2 = H160::from_str(\"1234000000000000000000000000000000000001\").unwrap();\n\t\tlet substrate_addr: <Test as frame_system::Config>::AccountId =\n\t\t\t<Test as Config>::AddressMapping::into_account_id(addr);\n\t\tlet substrate_addr_2: <Test as frame_system::Config>::AccountId =\n\t\t\t<Test as Config>::AddressMapping::into_account_id(addr_2);\n\t\t<crate::AccountCodes<Test>>::insert(addr, vec![0]);\n\t\tlet account = frame_system::Account::<Test>::get(substrate_addr);\n\t\tassert_eq!(account.sufficients, 0);\n\t\tEVM::create_account(addr_2, vec![1, 2, 3]);\n\t\tlet account_2 = frame_system::Account::<Test>::get(substrate_addr_2);\n\t\tassert_eq!(account_2.sufficients, 1);\n\t\tEVM::remove_account(&addr_2);\n\t\tlet account_2 = frame_system::Account::<Test>::get(substrate_addr_2);\n\t\tassert_eq!(account_2.sufficients, 1);\n\t});\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "async fn process_supergraph_response_stage<C>(\n    http_client: C,\n    coprocessor_url: String,\n    sdl: Arc<String>,\n    response: supergraph::Response,\n    response_config: SupergraphResponseConf,\n) -> Result<supergraph::Response, BoxError>\nwhere\n    C: Service<hyper::Request<Body>, Response = hyper::Response<Body>, Error = BoxError>\n        + Clone\n        + Send\n        + Sync\n        + 'static,\n    <C as tower::Service<http::Request<Body>>>::Future: Send + 'static,\n{\n    let (mut parts, body) = response.response.into_parts();\n    let (first, rest): (Option<response::Response>, graphql::ResponseStream) =\n        body.into_future().await;\n    let first = first.ok_or_else(|| {\n        BoxError::from(\"Coprocessor cannot convert body into future due to problem with first part\")\n    })?;\n    let headers_to_send = response_config\n        .headers\n        .then(|| externalize_header_map(&parts.headers))\n        .transpose()?;\n    let body_to_send = response_config\n        .body\n        .then(|| serde_json::to_value(&first).expect(\"serialization will not fail\"));\n    let status_to_send = response_config.status_code.then(|| parts.status.as_u16());\n    let context_to_send = response_config.context.then(|| response.context.clone());\n    let sdl_to_send = response_config.sdl.then(|| sdl.clone().to_string());\n    let payload = Externalizable::supergraph_builder()\n        .stage(PipelineStep::SupergraphResponse)\n        .and_id(TraceId::maybe_new().map(|id| id.to_string()))\n        .and_headers(headers_to_send)\n        .and_body(body_to_send)\n        .and_context(context_to_send)\n        .and_status_code(status_to_send)\n        .and_sdl(sdl_to_send.clone())\n        .build();\n    tracing::debug!(?payload, \"externalized output\");\n    let guard = response.context.enter_active_request();\n    let start = Instant::now();\n    let co_processor_result = payload.call(http_client.clone(), &coprocessor_url).await;\n    let duration = start.elapsed().as_secs_f64();\n    drop(guard);\n    tracing::info!(\n        histogram.apollo.router.operations.coprocessor.duration = duration,\n        coprocessor.stage = %PipelineStep::SupergraphResponse,\n    );\n    tracing::debug!(?co_processor_result, \"co-processor returned\");\n    let co_processor_output = co_processor_result?;\n    validate_coprocessor_output(&co_processor_output, PipelineStep::SupergraphResponse)?;\n    let new_body: crate::response::Response = match co_processor_output.body {\n        Some(value) => serde_json::from_value(value)?,\n        None => first,\n    };\n    if let Some(control) = co_processor_output.control {\n        parts.status = control.get_http_status()?\n    }\n    if let Some(context) = co_processor_output.context {\n        for (key, value) in context.try_into_iter()? {\n            response\n                .context\n                .upsert_json_value(key, move |_current| value);\n        }\n    }\n    if let Some(headers) = co_processor_output.headers {\n        parts.headers = internalize_header_map(headers)?;\n    }\n    let context = response.context.clone();\n    let map_context = response.context.clone();\n    let mapped_stream = rest\n        .then(move |deferred_response| {\n            let generator_client = http_client.clone();\n            let generator_coprocessor_url = coprocessor_url.clone();\n            let generator_map_context = map_context.clone();\n            let generator_sdl_to_send = sdl_to_send.clone();\n            async move {\n                let body_to_send = response_config.body.then(|| {\n                    serde_json::to_value(&deferred_response).expect(\"serialization will not fail\")\n                });\n                let context_to_send = response_config\n                    .context\n                    .then(|| generator_map_context.clone());\n                let payload = Externalizable::supergraph_builder()\n                    .stage(PipelineStep::SupergraphResponse)\n                    .and_id(TraceId::maybe_new().map(|id| id.to_string()))\n                    .and_body(body_to_send)\n                    .and_context(context_to_send)\n                    .and_sdl(generator_sdl_to_send)\n                    .build();\n                tracing::debug!(?payload, \"externalized output\");\n                let guard = generator_map_context.enter_active_request();\n                let co_processor_result = payload\n                    .call(generator_client, &generator_coprocessor_url)\n                    .await;\n                drop(guard);\n                tracing::debug!(?co_processor_result, \"co-processor returned\");\n                let co_processor_output = co_processor_result?;\n                validate_coprocessor_output(\n                    &co_processor_output,\n                    PipelineStep::SupergraphResponse,\n                )?;\n                let new_deferred_response: crate::response::Response =\n                    match co_processor_output.body {\n                        Some(value) => serde_json::from_value(value)?,\n                        None => deferred_response,\n                    };\n                if let Some(context) = co_processor_output.context {\n                    for (key, value) in context.try_into_iter()? {\n                        generator_map_context.upsert_json_value(key, move |_current| value);\n                    }\n                }\n                Ok(new_deferred_response)\n            }\n        })\n        .map(|res: Result<response::Response, BoxError>| match res {\n            Ok(response) => response,\n            Err(e) => {\n                tracing::error!(\"coprocessor error handling deferred supergraph response: {e}\");\n                response::Response::builder()\n                    .error(\n                        Error::builder()\n                            .message(\"Internal error handling deferred response\")\n                            .extension_code(\"INTERNAL_ERROR\")\n                            .build(),\n                    )\n                    .build()\n            }\n        });\n    let stream = once(ready(new_body)).chain(mapped_stream).boxed();\n    Ok(supergraph::Response {\n        context,\n        response: http::Response::from_parts(parts, stream),\n    })\n}\nfn fake_stream_new(\n        responses: Vec<graphql::Response>,\n        status_code: Option<StatusCode>,\n        headers: MultiMap<TryIntoHeaderName, TryIntoHeaderValue>,\n        context: Context,\n    ) -> Result<Self, BoxError> {\n        let mut builder = http::Response::builder().status(status_code.unwrap_or(StatusCode::OK));\n        for (key, values) in headers {\n            let header_name: HeaderName = key.try_into()?;\n            for value in values {\n                let header_value: HeaderValue = value.try_into()?;\n                builder = builder.header(header_name.clone(), header_value);\n            }\n        }\n        let stream = futures::stream::iter(responses);\n        let response = builder.body(stream.boxed())?;\n        Ok(Self { response, context })\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn from_payload(payload: &[u8]) -> Result<Self, DecodeError> {\n        const MIN_LENGTH: usize = 32 + 4 + 4;\n        const MAX_LENGTH: usize = 32 + 4 + 64;\n        let payload_len = payload.len();\n        if !(MIN_LENGTH..=MAX_LENGTH).contains(&payload_len) {\n            return Err(DecodeError::Invalid);\n        }\n        let inner_payload_len = u32::from_be_bytes(\n            (&payload[32..32 + 4])\n                .try_into()\n                .map_err(|_| DecodeError::Invalid)?,\n        );\n        if inner_payload_len > u32::MAX - 3 {\n                return Err(DecodeError::Invalid);\n        }\n        if (inner_payload_len + (4 - inner_payload_len % 4) % 4) as usize != payload_len - 32 - 4 {\n            return Err(DecodeError::Invalid);\n        }\n        let ed25519 = (&payload[0..32])\n            .try_into()\n            .map_err(|_| DecodeError::Invalid)?;\n        let inner_payload = &payload[32 + 4..32 + 4 + inner_payload_len as usize];\n        Ok(Self {\n            ed25519,\n            payload: inner_payload.to_vec(),\n        })\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn build_vyper(\n    source_code: &str,\n    version: semver::Version,\n    message_version: &str,\n) -> anyhow::Result<()> {\n    check_dependencies();\n    let vyper = VyperCompiler::new(VyperCompiler::DEFAULT_EXECUTABLE_NAME.to_owned());\n    if vyper.version.default != version {\n        panic!(\"{}\", message_version);\n    }\n    inkwell::support::enable_llvm_pretty_stack_trace();\n    compiler_llvm_context::initialize_target(compiler_llvm_context::Target::EraVM);\n    let _ = crate::process::EXECUTABLE.set(PathBuf::from(crate::r#const::DEFAULT_EXECUTABLE_NAME));\n    let optimizer_settings = compiler_llvm_context::OptimizerSettings::none();\n    let mut sources = BTreeMap::new();\n    sources.insert(\"test.vy\".to_string(), source_code.to_string());\n    let input = VyperStandardJsonInput::try_from_sources(\n        sources.clone(),\n        VyperStandardJsonInputSettingsEVMVersion::Paris,\n        VyperStandardJsonInputSettingsSelection::generate_default(),\n        true,\n    )?;\n    let output = vyper.standard_json(input)?;\n    let project = output.try_into_project(&vyper.version.default)?;\n    let _build = project.compile(\n        optimizer_settings,\n        false,\n        zkevm_assembly::RunningVmEncodingMode::Production,\n        None,\n    )?;\n    Ok(())\n}\npub fn compile(\n        self,\n        optimizer_settings: compiler_llvm_context::OptimizerSettings,\n        include_metadata_hash: bool,\n        bytecode_encoding: zkevm_assembly::RunningVmEncodingMode,\n        debug_config: Option<compiler_llvm_context::DebugConfig>,\n    ) -> anyhow::Result<Build> {\n        let mut build = Build::default();\n        let source_code_hash = if include_metadata_hash {\n            Some(self.source_code_hash)\n        } else {\n            None\n        };\n        let results: BTreeMap<String, anyhow::Result<ContractBuild>> = self\n            .contracts\n            .into_par_iter()\n            .map(|(full_path, contract)| {\n                let process_output = crate::process::call(ProcessInput::new(\n                    full_path.clone(),\n                    contract,\n                    source_code_hash,\n                    bytecode_encoding == zkevm_assembly::RunningVmEncodingMode::Testing,\n                    optimizer_settings.clone(),\n                    debug_config.clone(),\n                ));\n                (full_path, process_output.map(|output| output.build))\n            })\n            .collect();\n        let is_forwarder_used = results.iter().any(|(_path, result)| {\n            result\n                .as_ref()\n                .map(|contract| {\n                    contract\n                        .build\n                        .factory_dependencies\n                        .contains_key(crate::r#const::FORWARDER_CONTRACT_HASH.as_str())\n                })\n                .unwrap_or_default()\n        });\n        if is_forwarder_used {\n            let forwarder_build = compiler_llvm_context::EraVMBuild::new(\n                crate::r#const::FORWARDER_CONTRACT_ASSEMBLY.to_owned(),\n                None,\n                crate::r#const::FORWARDER_CONTRACT_BYTECODE.clone(),\n                crate::r#const::FORWARDER_CONTRACT_HASH.clone(),\n            );\n            build.contracts.insert(\n                crate::r#const::FORWARDER_CONTRACT_NAME.to_owned(),\n                ContractBuild::new(forwarder_build),\n            );\n        }\n        for (path, result) in results.into_iter() {\n            match result {\n                Ok(contract) => {\n                    build.contracts.insert(path, contract);\n                }\n                Err(error) => {\n                    anyhow::bail!(\"Contract `{}` compiling error: {:?}\", path, error);\n                }\n            }\n        }\n        Ok(build)\n    }\nfn declare(\n        &mut self,\n        context: &mut compiler_llvm_context::EraVMContext<D>,\n    ) -> anyhow::Result<()> {\n        let mut entry = compiler_llvm_context::EraVMEntryFunction::default();\n        entry.declare(context)?;\n        let mut runtime = compiler_llvm_context::EraVMRuntime::new(\n            compiler_llvm_context::EraVMAddressSpace::HeapAuxiliary,\n        );\n        runtime.declare(context)?;\n        compiler_llvm_context::EraVMDeployCodeFunction::new(\n            compiler_llvm_context::EraVMDummyLLVMWritable::default(),\n        )\n        .declare(context)?;\n        compiler_llvm_context::EraVMRuntimeCodeFunction::new(\n            compiler_llvm_context::EraVMDummyLLVMWritable::default(),\n        )\n        .declare(context)?;\n        for name in [\n            compiler_llvm_context::EraVMRuntime::FUNCTION_DEPLOY_CODE,\n            compiler_llvm_context::EraVMRuntime::FUNCTION_RUNTIME_CODE,\n            compiler_llvm_context::EraVMRuntime::FUNCTION_ENTRY,\n        ]\n        .into_iter()\n        {\n            context\n                .get_function(name)\n                .expect(\"Always exists\")\n                .borrow_mut()\n                .set_vyper_data(compiler_llvm_context::EraVMFunctionVyperData::default());\n        }\n        entry.into_llvm(context)?;\n        runtime.into_llvm(context)?;\n        Ok(())\n    }\nfn into_llvm(\n        mut self,\n        context: &mut compiler_llvm_context::EraVMContext<D>,\n    ) -> anyhow::Result<()> {\n        let (mut runtime_code, immutables_size) =\n            self.expression.extract_runtime_code()?.unwrap_or_default();\n        let mut deploy_code = self.expression.try_into_deploy_code()?;\n        match immutables_size {\n            Expression::IntegerLiteral(number) => {\n                let immutables_size = number\n                    .as_u64()\n                    .ok_or_else(|| anyhow::anyhow!(\"Immutable size `{}` parsing error\", number))?;\n                let vyper_data = compiler_llvm_context::EraVMContextVyperData::new(\n                    immutables_size as usize,\n                    false,\n                );\n                context.set_vyper_data(vyper_data);\n            }\n            expression => anyhow::bail!(\"Invalid immutables size format: {:?}\", expression),\n        }\n        let mut function_expressions = deploy_code\n            .extract_functions()?\n            .into_iter()\n            .map(|(label, expression)| {\n                (\n                    label,\n                    expression,\n                    compiler_llvm_context::EraVMCodeType::Deploy,\n                )\n            })\n            .collect::<Vec<(String, Expression, compiler_llvm_context::EraVMCodeType)>>();\n        function_expressions.extend(\n            runtime_code\n                .extract_functions()?\n                .into_iter()\n                .map(|(label, expression)| {\n                    (\n                        label,\n                        expression,\n                        compiler_llvm_context::EraVMCodeType::Runtime,\n                    )\n                })\n                .collect::<Vec<(String, Expression, compiler_llvm_context::EraVMCodeType)>>(),\n        );\n        let mut functions = Vec::with_capacity(function_expressions.capacity());\n        for (label, expression, code_type) in function_expressions.into_iter() {\n            let mut metadata_label = label\n                .strip_suffix(format!(\"_{}\", compiler_llvm_context::EraVMCodeType::Deploy).as_str())\n                .unwrap_or(label.as_str());\n            metadata_label = label\n                .strip_suffix(\n                    format!(\"_{}\", compiler_llvm_context::EraVMCodeType::Runtime).as_str(),\n                )\n                .unwrap_or(metadata_label);\n            metadata_label = label\n                .strip_suffix(format!(\"_{}\", crate::r#const::LABEL_SUFFIX_COMMON).as_str())\n                .unwrap_or(metadata_label);\n            let metadata_name =\n                self.source_metadata\n                    .function_info\n                    .iter()\n                    .find_map(|(name, function)| {\n                        if metadata_label == function.ir_identifier.as_str() {\n                            Some(name.to_owned())\n                        } else {\n                            None\n                        }\n                    });\n            let metadata = match metadata_name {\n                Some(metadata_name) => self\n                    .source_metadata\n                    .function_info\n                    .get(metadata_name.as_str())\n                    .cloned(),\n                None => None,\n            };\n            functions.push((Function::new(label, metadata, expression), code_type));\n        }\n        for (function, _code_type) in functions.iter_mut() {\n            function.declare(context)?;\n        }\n        for (function, code_type) in functions.into_iter() {\n            context.set_code_type(code_type);\n            function.into_llvm(context)?;\n        }\n        compiler_llvm_context::EraVMDeployCodeFunction::new(deploy_code).into_llvm(context)?;\n        compiler_llvm_context::EraVMRuntimeCodeFunction::new(runtime_code).into_llvm(context)?;\n        Ok(())\n    }\npub fn into_llvm_value<D>(\n        self,\n        context: &mut compiler_llvm_context::EraVMContext<D>,\n    ) -> anyhow::Result<()>\n    where\n        D: compiler_llvm_context::EraVMDependency + Clone,\n    {\n        let [identifier, value] = self.0;\n        let identifier = identifier.try_into_identifier()?;\n        let pointer = context\n            .current_function()\n            .borrow()\n            .get_stack_pointer(identifier.as_str())\n            .ok_or_else(|| anyhow::anyhow!(\"Variable `{}` not found\", identifier))?;\n        let value = value\n            .into_llvm_value(context)?\n            .ok_or_else(|| anyhow::anyhow!(\"Expected a value\"))?;\n        context.build_store(pointer, value);\n        Ok(())\n    }\nfn main_inner() -> anyhow::Result<()> {\n    let mut arguments = Arguments::new();\n    arguments.validate()?;\n    rayon::ThreadPoolBuilder::new()\n        .stack_size(RAYON_WORKER_STACK_SIZE)\n        .build_global()\n        .expect(\"Thread pool configuration failure\");\n    inkwell::support::enable_llvm_pretty_stack_trace();\n    compiler_llvm_context::initialize_target(compiler_llvm_context::Target::EraVM); \n    if arguments.version {\n        println!(\n            \"{} v{} (LLVM build {})\",\n            env!(\"CARGO_PKG_DESCRIPTION\"),\n            env!(\"CARGO_PKG_VERSION\"),\n            inkwell::support::get_commit_id().to_string(),\n        );\n        return Ok(());\n    }\n    if arguments.recursive_process {\n        return compiler_vyper::run_process();\n    }\n    let debug_config = match arguments.debug_output_directory {\n        Some(debug_output_directory) => {\n            std::fs::create_dir_all(debug_output_directory.as_path())?;\n            Some(compiler_llvm_context::DebugConfig::new(\n                debug_output_directory,\n            ))\n        }\n        None => None,\n    };\n    for path in arguments.input_files.iter_mut() {\n        *path = path.canonicalize()?;\n    }\n    let vyper = compiler_vyper::VyperCompiler::new(\n        arguments\n            .vyper\n            .unwrap_or_else(|| compiler_vyper::VyperCompiler::DEFAULT_EXECUTABLE_NAME.to_owned()),\n    );\n    let mut optimizer_settings = match arguments.optimization {\n        Some(mode) => compiler_llvm_context::OptimizerSettings::try_from_cli(mode)?,\n        None => compiler_llvm_context::OptimizerSettings::cycles(),\n    };\n    optimizer_settings.is_verify_each_enabled = arguments.llvm_verify_each;\n    optimizer_settings.is_debug_logging_enabled = arguments.llvm_debug_logging;\n    let include_metadata_hash = match arguments.metadata_hash {\n        Some(metadata_hash) => {\n            let metadata =\n                compiler_llvm_context::EraVMMetadataHash::from_str(metadata_hash.as_str())?;\n            metadata != compiler_llvm_context::EraVMMetadataHash::None\n        }\n        None => true,\n    };\n    let build = if arguments.llvm_ir {\n        compiler_vyper::llvm_ir(\n            arguments.input_files,\n            optimizer_settings,\n            include_metadata_hash,\n            debug_config,\n        )\n    } else if arguments.zkasm {\n        compiler_vyper::zkasm(arguments.input_files, include_metadata_hash, debug_config)\n    } else {\n        match arguments.format.as_deref() {\n            Some(\"combined_json\") => {\n                compiler_vyper::combined_json(\n                    arguments.input_files,\n                    &vyper,\n                    !arguments.disable_vyper_optimizer,\n                    optimizer_settings,\n                    include_metadata_hash,\n                    debug_config,\n                    arguments.output_directory,\n                    arguments.overwrite,\n                )?;\n                return Ok(());\n            }\n            Some(format) if format.split(',').any(|format| format == \"combined_json\") => {\n                anyhow::bail!(\"If using combined_json it must be the only output format requested\");\n            }\n            Some(_) | None => compiler_vyper::standard_output(\n                arguments.input_files,\n                &vyper,\n                !arguments.disable_vyper_optimizer,\n                optimizer_settings,\n                include_metadata_hash,\n                debug_config,\n            ),\n        }\n    }?;\n    match arguments.output_directory {\n        Some(output_directory) => {\n            std::fs::create_dir_all(output_directory.as_path())?;\n            build.write_to_directory(output_directory.as_path(), arguments.overwrite)?;\n        }\n        None => {\n            for (path, contract) in build.contracts.into_iter() {\n                eprintln!(\"Contract `{path}`:\");\n                let bytecode_string = hex::encode(contract.build.bytecode);\n                println!(\"0x{bytecode_string}\");\n                if let Some(format) = arguments.format.as_deref() {\n                    let extra_output = vyper.extra_output(PathBuf::from(path).as_path(), format)?;\n                    println!();\n                    println!(\"{extra_output}\");\n                }\n            }\n        }\n    }\n    Ok(())\n}\npub fn new(build: compiler_llvm_context::EraVMBuild) -> Self {\n        Self { build }\n    }\npub fn try_from_llvm_ir_path(path: &Path) -> anyhow::Result<Self> {\n        let source_code = std::fs::read_to_string(path)\n            .map_err(|error| anyhow::anyhow!(\"LLVM IR file {:?} reading error: {}\", path, error))?;\n        let path = path.to_string_lossy().to_string();\n        let source_code_hash = sha3::Keccak256::digest(source_code.as_bytes()).into();\n        let mut project_contracts = BTreeMap::new();\n        project_contracts.insert(\n            path,\n            LLVMIRContract::new(\n                compiler_llvm_context::eravm_const::LLVM_VERSION,\n                source_code,\n            )\n            .into(),\n        );\n        Ok(Self::new(\n            compiler_llvm_context::eravm_const::LLVM_VERSION,\n            source_code_hash,\n            project_contracts,\n        ))\n    }\npub fn try_from_zkasm_path(path: &Path) -> anyhow::Result<Self> {\n        let source_code = std::fs::read_to_string(path).map_err(|error| {\n            anyhow::anyhow!(\"zkEVM assembly file {:?} reading error: {}\", path, error)\n        })?;\n        let path = path.to_string_lossy().to_string();\n        let source_code_hash = sha3::Keccak256::digest(source_code.as_bytes()).into();\n        let mut project_contracts = BTreeMap::new();\n        project_contracts.insert(\n            path,\n            ZKASMContract::new(\n                compiler_llvm_context::eravm_const::ZKEVM_VERSION,\n                source_code,\n            )\n            .into(),\n        );\n        Ok(Self::new(\n            compiler_llvm_context::eravm_const::ZKEVM_VERSION,\n            source_code_hash,\n            project_contracts,\n        ))\n    }\npub fn write_to_directory(\n        self,\n        output_directory: &Path,\n        contract_path: &Path,\n        overwrite: bool,\n    ) -> anyhow::Result<()> {\n        let contract_name = Self::short_path(contract_path.to_str().expect(\"Always valid\"));\n        let assembly_file_name = format!(\n            \"{}.{}\",\n            contract_name,\n            compiler_common::EXTENSION_ERAVM_ASSEMBLY\n        );\n        let mut assembly_file_path = output_directory.to_owned();\n        assembly_file_path.push(assembly_file_name);\n        if assembly_file_path.exists() && !overwrite {\n            eprintln!(\n                \"Refusing to overwrite an existing file {assembly_file_path:?} (use --overwrite to force).\",\n            );\n        } else {\n            File::create(&assembly_file_path)\n                .map_err(|error| {\n                    anyhow::anyhow!(\"File {:?} creating error: {}\", assembly_file_path, error)\n                })?\n                .write_all(self.build.assembly_text.as_bytes())\n                .map_err(|error| {\n                    anyhow::anyhow!(\"File {:?} writing error: {}\", assembly_file_path, error)\n                })?;\n        }\n        let binary_file_name = format!(\n            \"{}.{}\",\n            contract_name,\n            compiler_common::EXTENSION_ERAVM_BINARY\n        );\n        let mut binary_file_path = output_directory.to_owned();\n        binary_file_path.push(binary_file_name);\n        if binary_file_path.exists() && !overwrite {\n            eprintln!(\n                \"Refusing to overwrite an existing file {binary_file_path:?} (use --overwrite to force).\",\n            );\n        } else {\n            File::create(&binary_file_path)\n                .map_err(|error| {\n                    anyhow::anyhow!(\"File {:?} creating error: {}\", binary_file_path, error)\n                })?\n                .write_all(self.build.bytecode.as_slice())\n                .map_err(|error| {\n                    anyhow::anyhow!(\"File {:?} writing error: {}\", binary_file_path, error)\n                })?;\n        }\n        Ok(())\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "async fn api_auth_login(\n        &self,\n        req: &Request,\n        session: &Session,\n        services: Data<&Services>,\n        body: Json<LoginRequest>,\n    ) -> poem::Result<LoginResponse> {\n        let mut auth_state_store = services.auth_state_store.lock().await;\n        let state_arc = match get_auth_state_for_request(\n            &body.username,\n            session,\n            &mut auth_state_store,\n        )\n        .await\n        {\n            Err(WarpgateError::UserNotFound) => {\n                return Ok(LoginResponse::Failure(Json(LoginFailureResponse {\n                    state: ApiAuthState::Failed,\n                })))\n            }\n            x => x,\n        }?;\n        let mut state = state_arc.lock().await;\n        let mut cp = services.config_provider.lock().await;\n        let password_cred = AuthCredential::Password(Secret::new(body.password.clone()));\n        if cp\n            .validate_credential(&state.username(), &password_cred)\n            .await?\n        {\n            state.add_valid_credential(password_cred);\n        }\n        match state.verify() {\n            AuthResult::Accepted { username } => {\n                auth_state_store.complete(state.id()).await;\n                authorize_session(req, username).await?;\n                Ok(LoginResponse::Success)\n            }\n            x => {\n                error!(\"Auth rejected\");\n                Ok(LoginResponse::Failure(Json(LoginFailureResponse {\n                    state: x.into(),\n                })))\n            }\n        }\n    }\npub async fn get_auth_state_for_request(\n    username: &str,\n    session: &Session,\n    store: &mut AuthStateStore,\n) -> Result<Arc<Mutex<AuthState>>, WarpgateError> {\n    if let Some(id) = session.get_auth_state_id() {\n        if !store.contains_key(&id.0) {\n            session.remove(AUTH_STATE_ID_SESSION_KEY)\n        }\n    }\n    if let Some(id) = session.get_auth_state_id() {\n        let state = store.get(&id.0).ok_or(WarpgateError::InconsistentState)?;\n        let existing_matched = state.lock().await.username() == username;\n        if existing_matched {\n            return Ok(state);\n        }\n    }\n    let (id, state) = store\n        .create(None, username, crate::common::PROTOCOL_NAME)\n        .await?;\n    session.set(AUTH_STATE_ID_SESSION_KEY, AuthStateId(id));\n    Ok(state)\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "unsafe fn set_len(&mut self, len: usize);\npub fn new(num_elements: usize) -> Result<FamStructWrapper<T>, Error> {\n        if num_elements > T::max_len() {\n            return Err(Error::SizeLimitExceeded);\n        }\n        let required_mem_allocator_capacity =\n            FamStructWrapper::<T>::mem_allocator_len(num_elements)\n                .ok_or(Error::SizeLimitExceeded)?;\n        let mut mem_allocator = Vec::with_capacity(required_mem_allocator_capacity);\n        mem_allocator.push(T::default());\n        for _ in 1..required_mem_allocator_capacity {\n            mem_allocator.push(unsafe { mem::zeroed() })\n        }\n        unsafe {\n            mem_allocator[0].set_len(num_elements);\n        }\n        Ok(FamStructWrapper { mem_allocator })\n    }\nfn as_mut_fam_struct(&mut self) -> &mut T {\n        &mut self.mem_allocator[0]\n    }\nfn set_len(&mut self, len: usize) -> Result<(), Error> {\n        let additional_elements = isize::try_from(len)\n            .and_then(|len| isize::try_from(self.len()).map(|self_len| len - self_len))\n            .map_err(|_| Error::SizeLimitExceeded)?;\n        if additional_elements == 0 {\n            return Ok(());\n        }\n        if additional_elements > 0 {\n            if len > T::max_len() {\n                return Err(Error::SizeLimitExceeded);\n            }\n            self.reserve(additional_elements as usize)?;\n        }\n        let current_mem_allocator_len = self.mem_allocator.len();\n        let required_mem_allocator_len =\n            FamStructWrapper::<T>::mem_allocator_len(len).ok_or(Error::SizeLimitExceeded)?;\n        unsafe {\n            self.mem_allocator.set_len(required_mem_allocator_len);\n        }\n        for i in current_mem_allocator_len..required_mem_allocator_len {\n            self.mem_allocator[i] = unsafe { mem::zeroed() }\n        }\n        unsafe {\n            self.as_mut_fam_struct().set_len(len);\n        }\n        if additional_elements < 0 {\n            self.mem_allocator.shrink_to_fit();\n        }\n        Ok(())\n    }\nfn visit_seq<V>(self, mut seq: V) -> Result<FamStructWrapper<X>, V::Error>\n            where\n                V: SeqAccess<'de>,\n            {\n                use serde::de::Error;\n                let header: X = seq\n                    .next_element()?\n                    .ok_or_else(|| de::Error::invalid_length(0, &self))?;\n                let entries: Vec<X::Entry> = seq\n                    .next_element()?\n                    .ok_or_else(|| de::Error::invalid_length(1, &self))?;\n                if header.len() != entries.len() {\n                    let msg = format!(\n                        \"Mismatch between length of FAM specified in FamStruct header ({}) \\\n                         and actual size of FAM ({})\",\n                        header.len(),\n                        entries.len()\n                    );\n                    return Err(V::Error::custom(msg));\n                }\n                let mut result: Self::Value = FamStructWrapper::from_entries(entries.as_slice())\n                    .map_err(|e| V::Error::custom(format!(\"{:?}\", e)))?;\n                result.mem_allocator[0] = header;\n                Ok(result)\n            }\nunsafe fn set_len(&mut self, len: usize) {\n                self.$field_name = len as $field_type;\n            }\n#[derive(Default, Debug, PartialEq, Eq)]\n#[cfg(feature = \"with-serde\")]\n    #[test]\n    fn test_bad_deserialize() {\n        #[repr(C)]\n        #[derive(Default, Debug, PartialEq, Serialize, Deserialize)]\n        struct Foo {\n            pub len: u32,\n            pub padding: u32,\n            pub entries: __IncompleteArrayField<u32>,\n        }\n        generate_fam_struct_impl!(Foo, u32, entries, u32, len, 100);\n        let state = FamStructWrapper::<Foo>::new(0).unwrap();\n        let mut bytes = bincode::serialize(&state).unwrap();\n        bytes[0] = 255;\n        assert!(\n            matches!(bincode::deserialize::<FamStructWrapper<Foo>>(&bytes).map_err(|boxed| *boxed), Err(bincode::ErrorKind::Custom(s)) if s == *\"Mismatch between length of FAM specified in FamStruct header (255) and actual size of FAM (0)\")\n        );\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn deserialize_empty<'a, V>(&'a mut self, _visitor: V) -> Result<V::Value>\n    where\n        V: Visitor<'de>,\n    {\n        Err(Error::msg(\"Cannot decode empty type\"))\n    }\nfn visit_byte_buf<E: de::Error>(self, value: Vec<u8>) -> DResult<E> {\n        let (tag, mut bytes) = value.split_at(1);\n        match tag[0] {\n            0u8 => {\n                let v = Int(num_bigint::BigInt::from_signed_bytes_le(bytes));\n                Ok(IDLValue::Int(v))\n            }\n            1u8 => {\n                let v = Nat(num_bigint::BigUint::from_bytes_le(bytes));\n                Ok(IDLValue::Nat(v))\n            }\n            2u8 => {\n                let v = crate::Principal::try_from(bytes).map_err(E::custom)?;\n                Ok(IDLValue::Principal(v))\n            }\n            4u8 => {\n                let v = crate::Principal::try_from(bytes).map_err(E::custom)?;\n                Ok(IDLValue::Service(v))\n            }\n            5u8 => {\n                use std::io::Read;\n                let len = leb128::read::unsigned(&mut bytes).map_err(E::custom)? as usize;\n                let mut buf = vec![0; len];\n                bytes.read_exact(&mut buf).map_err(E::custom)?;\n                let meth = String::from_utf8(buf).map_err(E::custom)?;\n                let id = crate::Principal::try_from(bytes).map_err(E::custom)?;\n                Ok(IDLValue::Func(id, meth))\n            }\n            3u8 => Ok(IDLValue::Reserved),\n            _ => Err(de::Error::custom(\"unknown tag in visit_byte_buf\")),\n        }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub async fn get_full_snapshot_path(\n    toc: &TableOfContent,\n    snapshot_name: &str,\n) -> Result<PathBuf, StorageError> {\n    let snapshots_path = toc.snapshots_path();\n    let absolute_snapshot_dir = Path::new(snapshots_path)\n        .canonicalize()\n        .map_err(|_| StorageError::not_found(format!(\"Snapshot directory: {snapshots_path}\")))?;\n    let absolute_snapshot_path = absolute_snapshot_dir\n        .join(snapshot_name)\n        .canonicalize()\n        .map_err(|_| StorageError::not_found(format!(\"Snapshot {snapshot_name}\")))?;\n    if !absolute_snapshot_path.starts_with(absolute_snapshot_dir) {\n        return Err(StorageError::not_found(format!(\"Snapshot {snapshot_name}\")));\n    }\n    if !absolute_snapshot_path.exists() {\n        return Err(StorageError::not_found(format!(\"Snapshot {snapshot_name}\")));\n    }\n    Ok(absolute_snapshot_path)\n}\npub async fn get_snapshot_path(&self, snapshot_name: &str) -> CollectionResult<PathBuf> {\n        let absolute_snapshot_dir = self.snapshots_path.canonicalize().map_err(|_| {\n            CollectionError::not_found(format!(\n                \"Snapshot directory: {}\",\n                self.snapshots_path.display()\n            ))\n        })?;\n        let absolute_snapshot_path = absolute_snapshot_dir\n            .join(snapshot_name)\n            .canonicalize()\n            .map_err(|_| CollectionError::not_found(format!(\"Snapshot {snapshot_name}\")))?;\n        if !absolute_snapshot_path.starts_with(absolute_snapshot_dir) {\n            return Err(CollectionError::not_found(format!(\n                \"Snapshot {snapshot_name}\"\n            )));\n        }\n        if !absolute_snapshot_path.exists() {\n            return Err(CollectionError::not_found(format!(\n                \"Snapshot {snapshot_name}\"\n            )));\n        }\n        Ok(absolute_snapshot_path)\n    }\npub fn not_found(description: impl Into<String>) -> StorageError {\n        StorageError::NotFound {\n            description: description.into(),\n        }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "#[export_name = \"html_style_block_handler\"]\npub unsafe extern \"C\" fn html_style_block_handler(\n    ctx: *mut cli_ctx,\n    file_bytes: *const c_char,\n) -> cl_error_t {\n    let css_input = if file_bytes.is_null() {\n        warn!(\"html css 'file_bytes' buffer is NULL\");\n        return cl_error_t_CL_ERROR;\n    } else {\n        #[allow(unused_unsafe)]\n        unsafe { CStr::from_ptr(file_bytes) }.to_string_lossy()\n    };\n    let extractor = if let Ok(extractor) = CssImageExtractor::new(&css_input) {\n        extractor\n    } else {\n        return cl_error_t_CL_ERROR;\n    };\n    let mut scan_result = cl_error_t_CL_SUCCESS;\n    extractor.into_iter().all(|image| {\n            debug!(\"Extracted {}-byte image\", image.len());\n            let ret = magic_scan(ctx, &image, None);\n            if ret != cl_error_t_CL_SUCCESS {\n                scan_result = ret;\n                return false;\n            }\n            true\n        });\n    scan_result\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn verify(&self, payload: &[u8], headers: &HeaderMap) -> Result<(), WebhookError> {\n        let msg_id = Self::get_header(headers, SVIX_MSG_ID_KEY, UNBRANDED_MSG_ID_KEY, \"id\")?;\n        let msg_signature = Self::get_header(\n            headers,\n            SVIX_MSG_SIGNATURE_KEY,\n            UNBRANDED_MSG_SIGNATURE_KEY,\n            \"signature\",\n        )?;\n        let msg_ts = Self::get_header(\n            headers,\n            SVIX_MSG_TIMESTAMP_KEY,\n            UNBRANDED_MSG_TIMESTAMP_KEY,\n            \"timestamp\",\n        )\n        .and_then(Self::parse_timestamp)?;\n        Self::verify_timestamp(msg_ts)?;\n        let versioned_signature = self.sign(msg_id, msg_ts, payload)?;\n        let expected_signature = versioned_signature\n            .split_once(',')\n            .map(|x| x.1)\n            .ok_or(WebhookError::InvalidSignature)?;\n        msg_signature\n            .split(' ')\n            .filter_map(|x| x.split_once(','))\n            .filter(|x| x.0 == SIGNATURE_VERSION)\n            .any(|x| {\n                (x.1.len() == expected_signature.len())\n                    && (x\n                        .1\n                        .bytes()\n                        .zip(expected_signature.bytes())\n                        .fold(0, |acc, (a, b)| acc | (a ^ b))\n                        == 0)\n            })\n            .then_some(())\n            .ok_or(WebhookError::InvalidSignature)\n    }\n    #[test]\n    fn test_verify_partial_signature() {\n        let secret = \"whsec_C2FVsBQIhrscChlQIMV+b5sSYspob7oD\".to_owned();\n        let msg_id = \"msg_27UH4WbU6Z5A5EzD8u03UvzRbpk\";\n        let payload = {\"email\":\"test@example.com\",\"username\":\"test_user\"}\"#;\n        let wh = Webhook::new(&secret).unwrap();\n        let signature = wh\n            .sign(msg_id, OffsetDateTime::now_utc().unix_timestamp(), payload)\n            .unwrap();\n        for mut headers in [\n            get_svix_headers(msg_id, &signature),\n            get_unbranded_headers(msg_id, &signature),\n        ] {\n            let partial = format!(\n                \"{},\",\n                signature.split(',').collect::<Vec<&str>>().first().unwrap()\n            );\n            headers.insert(SVIX_MSG_SIGNATURE_KEY, partial.parse().unwrap());\n            headers.insert(UNBRANDED_MSG_SIGNATURE_KEY, partial.parse().unwrap());\n            assert!(wh.verify(payload, &headers).is_err());\n        }\n        for mut headers in [\n            get_svix_headers(msg_id, &signature),\n            get_unbranded_headers(msg_id, &signature),\n        ] {\n            let partial = &signature[0..8];\n            headers.insert(SVIX_MSG_SIGNATURE_KEY, partial.parse().unwrap());\n            headers.insert(UNBRANDED_MSG_SIGNATURE_KEY, partial.parse().unwrap());\n            assert!(wh.verify(payload, &headers).is_err());\n        }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn cleanup_for_create(\n\t\t&mut self,\n\t\tcreated_address: H160,\n\t\treason: ExitReason,\n\t\treturn_data: Vec<u8>,\n\t) -> (ExitReason, Option<H160>, Vec<u8>) {\n\t\tfn check_first_byte(config: &Config, code: &[u8]) -> Result<(), ExitError> {\n\t\t\tif config.disallow_executable_format && Some(&Opcode::EOFMAGIC.as_u8()) == code.first()\n\t\t\t{\n\t\t\t\treturn Err(ExitError::InvalidCode(Opcode::EOFMAGIC));\n\t\t\t}\n\t\t\tOk(())\n\t\t}\n\t\tlog::debug!(target: \"evm\", \"Create execution using address {}: {:?}\", created_address, reason);\n\t\tmatch reason {\n\t\t\tExitReason::Succeed(s) => {\n\t\t\t\tlet out = return_data;\n\t\t\t\tlet address = created_address;\n\t\t\t\tif let Err(e) = check_first_byte(self.config, &out) {\n\t\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t\treturn (e.into(), None, Vec::new());\n\t\t\t\t}\n\t\t\t\tif let Some(limit) = self.config.create_contract_limit {\n\t\t\t\t\tif out.len() > limit {\n\t\t\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t\t\treturn (ExitError::CreateContractLimit.into(), None, Vec::new());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmatch self\n\t\t\t\t\t.state\n\t\t\t\t\t.metadata_mut()\n\t\t\t\t\t.gasometer\n\t\t\t\t\t.record_deposit(out.len())\n\t\t\t\t{\n\t\t\t\t\tOk(()) => {\n\t\t\t\t\t\tif let Err(e) = self.record_external_operation(\n\t\t\t\t\t\t\tcrate::ExternalOperation::Write(U256::from(out.len())),\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t\t\t\treturn (e.into(), None, Vec::new());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet exit_result = self.exit_substate(StackExitKind::Succeeded);\n\t\t\t\t\t\tself.state.set_code(address, out);\n\t\t\t\t\t\tif let Err(e) = exit_result {\n\t\t\t\t\t\t\treturn (e.into(), None, Vec::new());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t(ExitReason::Succeed(s), Some(address), Vec::new())\n\t\t\t\t\t}\n\t\t\t\t\tErr(e) => {\n\t\t\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t\t\t(ExitReason::Error(e), None, Vec::new())\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tExitReason::Error(e) => {\n\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t(ExitReason::Error(e), None, Vec::new())\n\t\t\t}\n\t\t\tExitReason::Revert(e) => {\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Reverted);\n\t\t\t\t(ExitReason::Revert(e), None, return_data)\n\t\t\t}\n\t\t\tExitReason::Fatal(e) => {\n\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t(ExitReason::Fatal(e), None, Vec::new())\n\t\t\t}\n\t\t}\n\t}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn is_tchar(c: char) -> bool {\n    matches!(\n        c,\n        'a'..='z'\n        | 'A'..='Z'\n        | '0'..='9'\n        | '!'\n        | '#'\n        | '$'\n        | '%'\n        | '&'\n        | '\\''\n        | '*'\n        | '+'\n        | '-'\n        | '.'\n        | '^'\n        | '_'\n        | '`'\n        | '|'\n        | '~'\n    )\n}\npub(crate) fn is_valid(&self) -> bool {\n        // token per https://www.rfc-editor.org/rfc/rfc9110#section-5.1\n        // tchar per https://www.rfc-editor.org/rfc/rfc9110#section-5.6.2\n        !self.is_empty() && self.0.chars().all(is_tchar)\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub async fn create_pm_report(\n  data: Json<CreatePrivateMessageReport>,\n  context: Data<LemmyContext>,\n  local_user_view: LocalUserView,\n) -> Result<Json<PrivateMessageReportResponse>, LemmyError> {\n  let local_site = LocalSite::read(&mut context.pool()).await?;\n  let reason = data.reason.trim().to_string();\n  check_report_reason(&reason, &local_site)?;\n  let person_id = local_user_view.person.id;\n  let private_message_id = data.private_message_id;\n  let private_message = PrivateMessage::read(&mut context.pool(), private_message_id).await?;\n  if person_id != private_message.recipient_id {\n    Err(LemmyErrorType::CouldntCreateReport)?\n  }\n  let report_form = PrivateMessageReportForm {\n    creator_id: person_id,\n    private_message_id,\n    original_pm_text: private_message.content,\n    reason,\n  };\n  let report = PrivateMessageReport::report(&mut context.pool(), &report_form)\n    .await\n    .with_lemmy_type(LemmyErrorType::CouldntCreateReport)?;\n  let private_message_report_view =\n    PrivateMessageReportView::read(&mut context.pool(), report.id).await?;\n  if local_site.reports_email_admins {\n    send_new_report_email_to_admins(\n      &private_message_report_view.creator.name,\n      &private_message_report_view.private_message_creator.name,\n      &mut context.pool(),\n      context.settings(),\n    )\n    .await?;\n  }\n  Ok(Json(PrivateMessageReportResponse {\n    private_message_report_view,\n  }))\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn pgsql_parse_response(i: &[u8]) -> IResult<&[u8], PgsqlBEMessage> {\n    let (i, pseudo_header) = peek(tuple((be_u8, be_u32)))(i)?;\n    let (i, message) =\n            match pseudo_header.0 {\n                b'E' => pgsql_parse_error_response(i)?,\n                b'K' => parse_backend_key_data_message(i)?,\n                b'N' => pgsql_parse_notice_response(i)?,\n                b'R' => pgsql_parse_authentication_message(i)?,\n                b'S' => parse_parameter_status_message(i)?,\n                b'C' => parse_command_complete(i)?,\n                b'Z' => parse_ready_for_query(i)?,\n                b'T' => parse_row_description(i)?,\n                b'A' => parse_notification_response(i)?,\n                b'D' => parse_consolidated_data_row(i)?,\n                _ => {\n                    let (i, identifier) = be_u8(i)?;\n                    let (i, length) = verify(be_u32, |&x| x > PGSQL_LENGTH_FIELD)(i)?;\n                    let (i, payload) = take(length - PGSQL_LENGTH_FIELD)(i)?;\n                    let unknown = PgsqlBEMessage::UnknownMessageType (RegularPacket{\n                        identifier,\n                        length,\n                        payload: payload.to_vec(),\n                    });\n                    (i, unknown)\n                }\n            };\n    Ok((i, message))\n}\nfn test_parse_sasl_final_authentication_message() {\n        let buf: &[u8] = &[\n            /* R */ 0x52, /* 54 */ 0x00, 0x00, 0x00, 0x36, /* 12 */ 0x00, 0x00,\n            0x00, 0x0c, /* signature */ 0x76, 0x3d, 0x64, 0x31, 0x50, 0x58, 0x61, 0x38, 0x54,\n            0x4b, 0x46, 0x50, 0x5a, 0x72, 0x52, 0x33, 0x4d, 0x42, 0x52, 0x6a, 0x4c, 0x79, 0x33,\n            0x2b, 0x4a, 0x36, 0x79, 0x78, 0x72, 0x66, 0x77, 0x2f, 0x7a, 0x7a, 0x70, 0x38, 0x59,\n            0x54, 0x39, 0x65, 0x78, 0x56, 0x37, 0x73, 0x38, 0x3d,\n        ];\n        let ok_res = PgsqlBEMessage::AuthenticationSASLFinal(AuthenticationMessage {\n            identifier: b'R',\n            length: 54,\n            auth_type: 12,\n            payload: br#\"v=d1PXa8TKFPZrR3MBRjLy3+J6yxrfw/zzp8YT9exV7s8=\"#.to_vec(),\n        });\n        let result = pgsql_parse_response(buf);\n        match result {\n            Ok((remainder, message)) => {\n                assert_eq!(message, ok_res);\n                assert_eq!(remainder.len(), 0);\n            }\n            Err(Err::Error(err)) => {\n                panic!(\"Shouldn't be error {:?}, expected Ok(_)\", err.code);\n            }\n            Err(Err::Incomplete(needed)) => {\n                panic!(\"Shouldn't be incomplete {:?}, expected OK(_)\", needed);\n            }\n            _ => panic!(\"Unexpected behavior, expected Ok(_)\"),\n        }\n        let result_incomplete = pgsql_parse_response(&buf[0..34]);\n        match result_incomplete {\n            Err(Err::Incomplete(needed)) => {\n                assert_eq!(needed, Needed::new(21));\n            }\n            _ => panic!(\"Unexpected behavior, expected incomplete.\"),\n        }\n        let bad_buf: &[u8] = &[\n            /* ` */ 0x60, /* 54 */ 0x00, 0x00, 0x00, 0x36, /* 12 */ 0x00, 0x00,\n            0x00, 0x0c, /* signature */ 0x76, 0x3d, 0x64, 0x31, 0x50, 0x58, 0x61, 0x38, 0x54,\n            0x4b, 0x46, 0x50, 0x5a, 0x72, 0x52, 0x33, 0x4d, 0x42, 0x52, 0x6a, 0x4c, 0x79, 0x33,\n            0x2b, 0x4a, 0x36, 0x79, 0x78, 0x72, 0x66, 0x77, 0x2f, 0x7a, 0x7a, 0x70, 0x38, 0x59,\n            0x54, 0x39, 0x65, 0x78, 0x56, 0x37, 0x73, 0x38, 0x3d,\n        ];\n        let (remainder, result) = pgsql_parse_response(bad_buf).expect(\"parsing sasl final response failed\");\n        let res = PgsqlBEMessage::UnknownMessageType(RegularPacket {\n            identifier: b'`',\n            length: 54,\n            payload: bad_buf[5..].to_vec(),\n        });\n        assert_eq!(result, res);\n        assert!(remainder.is_empty());\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "use std::ffi::OsStr;\nuse std::io::{self, Read, Write};\nuse std::os::windows::io::{AsRawHandle, FromRawHandle, RawHandle};\nuse std::sync::atomic::Ordering::{Relaxed, SeqCst};\nuse std::sync::atomic::{AtomicBool, AtomicUsize};\nuse std::sync::{Arc, Mutex};\nuse std::{fmt, mem, slice};\nuse windows_sys::Win32::Foundation::{\n    ERROR_BROKEN_PIPE, ERROR_IO_INCOMPLETE, ERROR_IO_PENDING, ERROR_NO_DATA, ERROR_PIPE_CONNECTED,\n    ERROR_PIPE_LISTENING, HANDLE, INVALID_HANDLE_VALUE,\n};\nuse windows_sys::Win32::Storage::FileSystem::{\n    ReadFile, WriteFile, FILE_FLAG_FIRST_PIPE_INSTANCE, FILE_FLAG_OVERLAPPED, PIPE_ACCESS_DUPLEX,\n};\nuse windows_sys::Win32::System::Pipes::{\n    ConnectNamedPipe, CreateNamedPipeW, DisconnectNamedPipe, PIPE_TYPE_BYTE,\n    PIPE_UNLIMITED_INSTANCES,\n};\nuse windows_sys::Win32::System::IO::{\n    CancelIoEx, GetOverlappedResult, OVERLAPPED, OVERLAPPED_ENTRY,\n};\nuse crate::event::Source;\nuse crate::sys::windows::iocp::{CompletionPort, CompletionStatus};\nuse crate::sys::windows::{Event, Handle, Overlapped};\nuse crate::Registry;\nuse crate::{Interest, Token};\npub struct NamedPipe {\n    inner: Arc<Inner>,\n}\n#[repr(C)]\nstruct Inner {\n    connect: Overlapped,\n    read: Overlapped,\n    write: Overlapped,\n    event: Overlapped,\n    handle: Handle,\n    connecting: AtomicBool,\n    io: Mutex<Io>,\n    pool: Mutex<BufferPool>,\n}\nimpl Inner {\n    unsafe fn ptr_from_conn_overlapped(ptr: *mut OVERLAPPED) -> *const Inner {\n        ptr.cast()\n    }\n    unsafe fn ptr_from_read_overlapped(ptr: *mut OVERLAPPED) -> *const Inner {\n        (ptr as *mut Overlapped).wrapping_sub(1) as *const Inner\n    }\n    unsafe fn ptr_from_write_overlapped(ptr: *mut OVERLAPPED) -> *const Inner {\n        (ptr as *mut Overlapped).wrapping_sub(2) as *const Inner\n    }\n    unsafe fn ptr_from_event_overlapped(ptr: *mut OVERLAPPED) -> *const Inner {\n        (ptr as *mut Overlapped).wrapping_sub(3) as *const Inner\n    }\n    pub unsafe fn connect_overlapped(&self, overlapped: *mut OVERLAPPED) -> io::Result<bool> {\n        if ConnectNamedPipe(self.handle.raw(), overlapped) != 0 {\n            return Ok(true);\n        }\n        let err = io::Error::last_os_error();\n        match err.raw_os_error().map(|e| e as u32) {\n            Some(ERROR_PIPE_CONNECTED) => Ok(true),\n            Some(ERROR_NO_DATA) => Ok(true),\n            Some(ERROR_IO_PENDING) => Ok(false),\n            _ => Err(err),\n        }\n    }\n    pub fn disconnect(&self) -> io::Result<()> {\n        if unsafe { DisconnectNamedPipe(self.handle.raw()) } == 0 {\n            Err(io::Error::last_os_error())\n        } else {\n            Ok(())\n        }\n    }\n    pub unsafe fn read_overlapped(\n        &self,\n        buf: &mut [u8],\n        overlapped: *mut OVERLAPPED,\n    ) -> io::Result<Option<usize>> {\n        let len = std::cmp::min(buf.len(), u32::MAX as usize) as u32;\n        let res = ReadFile(\n            self.handle.raw(),\n            buf.as_mut_ptr() as *mut _,\n            len,\n            std::ptr::null_mut(),\n            overlapped,\n        );\n        if res == 0 {\n            let err = io::Error::last_os_error();\n            if err.raw_os_error() != Some(ERROR_IO_PENDING as i32) {\n                return Err(err);\n            }\n        }\n        let mut bytes = 0;\n        let res = GetOverlappedResult(self.handle.raw(), overlapped, &mut bytes, 0);\n        if res == 0 {\n            let err = io::Error::last_os_error();\n            if err.raw_os_error() == Some(ERROR_IO_INCOMPLETE as i32) {\n                Ok(None)\n            } else {\n                Err(err)\n            }\n        } else {\n            Ok(Some(bytes as usize))\n        }\n    }\n    pub unsafe fn write_overlapped(\n        &self,\n        buf: &[u8],\n        overlapped: *mut OVERLAPPED,\n    ) -> io::Result<Option<usize>> {\n        let len = std::cmp::min(buf.len(), u32::MAX as usize) as u32;\n        let res = WriteFile(\n            self.handle.raw(),\n            buf.as_ptr() as *const _,\n            len,\n            std::ptr::null_mut(),\n            overlapped,\n        );\n        if res == 0 {\n            let err = io::Error::last_os_error();\n            if err.raw_os_error() != Some(ERROR_IO_PENDING as i32) {\n                return Err(err);\n            }\n        }\n        let mut bytes = 0;\n        let res = GetOverlappedResult(self.handle.raw(), overlapped, &mut bytes, 0);\n        if res == 0 {\n            let err = io::Error::last_os_error();\n            if err.raw_os_error() == Some(ERROR_IO_INCOMPLETE as i32) {\n                Ok(None)\n            } else {\n                Err(err)\n            }\n        } else {\n            Ok(Some(bytes as usize))\n        }\n    }\n    #[inline]\n    unsafe fn result(&self, overlapped: *mut OVERLAPPED) -> io::Result<usize> {\n        let mut transferred = 0;\n        let r = GetOverlappedResult(self.handle.raw(), overlapped, &mut transferred, 0);\n        if r == 0 {\n            Err(io::Error::last_os_error())\n        } else {\n            Ok(transferred as usize)\n        }\n    }\n}\n#[test]\nfn ptr_from() {\n    use std::mem::ManuallyDrop;\n    use std::ptr;\n    let pipe = unsafe { ManuallyDrop::new(NamedPipe::from_raw_handle(ptr::null_mut())) };\n    let inner: &Inner = &pipe.inner;\n    assert_eq!(\n        inner as *const Inner,\n        unsafe { Inner::ptr_from_conn_overlapped(&inner.connect as *const _ as *mut OVERLAPPED) },\n        \"`ptr_from_conn_overlapped` incorrect\"\n    );\n    assert_eq!(\n        inner as *const Inner,\n        unsafe { Inner::ptr_from_read_overlapped(&inner.read as *const _ as *mut OVERLAPPED) },\n        \"`ptr_from_read_overlapped` incorrect\"\n    );\n    assert_eq!(\n        inner as *const Inner,\n        unsafe { Inner::ptr_from_write_overlapped(&inner.write as *const _ as *mut OVERLAPPED) },\n        \"`ptr_from_write_overlapped` incorrect\"\n    );\n}\nstruct Io {\n    cp: Option<Arc<CompletionPort>>,\n    token: Option<Token>,\n    read: State,\n    write: State,\n    connect_error: Option<io::Error>,\n}\n#[derive(Debug)]\nenum State {\n    None,\n    Pending(Vec<u8>, usize),\n    Ok(Vec<u8>, usize),\n    Err(io::Error),\n}\nstatic NEXT_TOKEN: AtomicUsize = AtomicUsize::new(1);\nfn would_block() -> io::Error {\n    io::ErrorKind::WouldBlock.into()\n}\nimpl NamedPipe {\n    pub fn new<A: AsRef<OsStr>>(addr: A) -> io::Result<NamedPipe> {\n        use std::os::windows::ffi::OsStrExt;\n        let name: Vec<_> = addr.as_ref().encode_wide().chain(Some(0)).collect();\n        let h = unsafe {\n            CreateNamedPipeW(\n                name.as_ptr(),\n                PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE | FILE_FLAG_OVERLAPPED,\n                PIPE_TYPE_BYTE,\n                PIPE_UNLIMITED_INSTANCES,\n                65536,\n                65536,\n                0,\n                std::ptr::null_mut(),\n            )\n        };\n        if h == INVALID_HANDLE_VALUE {\n            Err(io::Error::last_os_error())\n        } else {\n            Ok(unsafe { Self::from_raw_handle(h as RawHandle) })\n        }\n    }\n    pub fn connect(&self) -> io::Result<()> {\n        if self.inner.connecting.swap(true, SeqCst) {\n            return Err(would_block());\n        }\n        let res = unsafe {\n            let overlapped = self.inner.connect.as_ptr() as *mut _;\n            self.inner.connect_overlapped(overlapped)\n        };\n        match res {\n            Ok(true) => {\n                self.inner.connecting.store(false, SeqCst);\n                Inner::post_register(&self.inner, None);\n                Ok(())\n            }\n            Ok(false) => {\n                mem::forget(self.inner.clone());\n                Err(would_block())\n            }\n            Err(e) => {\n                self.inner.connecting.store(false, SeqCst);\n                Err(e)\n            }\n        }\n    }\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        Ok(self.inner.io.lock().unwrap().connect_error.take())\n    }\n    pub fn disconnect(&self) -> io::Result<()> {\n        self.inner.disconnect()\n    }\n}\nimpl FromRawHandle for NamedPipe {\n    unsafe fn from_raw_handle(handle: RawHandle) -> NamedPipe {\n        NamedPipe {\n            inner: Arc::new(Inner {\n                handle: Handle::new(handle as HANDLE),\n                connect: Overlapped::new(connect_done),\n                connecting: AtomicBool::new(false),\n                read: Overlapped::new(read_done),\n                write: Overlapped::new(write_done),\n                event: Overlapped::new(event_done),\n                io: Mutex::new(Io {\n                    cp: None,\n                    token: None,\n                    read: State::None,\n                    write: State::None,\n                    connect_error: None,\n                }),\n                pool: Mutex::new(BufferPool::with_capacity(2)),\n            }),\n        }\n    }\n}\nimpl Read for NamedPipe {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        <&NamedPipe as Read>::read(&mut &*self, buf)\n    }\n}\nimpl Write for NamedPipe {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        <&NamedPipe as Write>::write(&mut &*self, buf)\n    }\n    fn flush(&mut self) -> io::Result<()> {\n        <&NamedPipe as Write>::flush(&mut &*self)\n    }\n}\nimpl<'a> Read for &'a NamedPipe {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        let mut state = self.inner.io.lock().unwrap();\n        if state.token.is_none() {\n            return Err(would_block());\n        }\n        match mem::replace(&mut state.read, State::None) {\n            State::None => Err(would_block()),\n            State::Pending(buf, amt) => {\n                state.read = State::Pending(buf, amt);\n                Err(would_block())\n            }\n            State::Ok(data, cur) => {\n                let n = {\n                    let mut remaining = &data[cur..];\n                    remaining.read(buf)?\n                };\n                let next = cur + n;\n                if next != data.len() {\n                    state.read = State::Ok(data, next);\n                } else {\n                    self.inner.put_buffer(data);\n                    Inner::schedule_read(&self.inner, &mut state, None);\n                }\n                Ok(n)\n            }\n            State::Err(e) => {\n                Inner::schedule_read(&self.inner, &mut state, None);\n                if e.raw_os_error() == Some(ERROR_BROKEN_PIPE as i32) {\n                    Ok(0)\n                } else {\n                    Err(e)\n                }\n            }\n        }\n    }\n}\nimpl<'a> Write for &'a NamedPipe {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        let mut io = self.inner.io.lock().unwrap();\n        if io.token.is_none() {\n            return Err(would_block());\n        }\n        match io.write {\n            State::None => {}\n            State::Err(_) => match mem::replace(&mut io.write, State::None) {\n                State::Err(e) => return Err(e),\n                _ => unreachable!(),\n            },\n            _ => {\n                return Err(would_block());\n            }\n        }\n        let mut owned_buf = self.inner.get_buffer();\n        owned_buf.extend(buf);\n        match Inner::maybe_schedule_write(&self.inner, owned_buf, 0, &mut io)? {\n            Some(n) => Ok(n),\n            None => Ok(buf.len()),\n        }\n    }\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\nimpl Source for NamedPipe {\n    fn register(&mut self, registry: &Registry, token: Token, _: Interest) -> io::Result<()> {\n        let mut io = self.inner.io.lock().unwrap();\n        io.check_association(registry, false)?;\n        if io.token.is_some() {\n            return Err(io::Error::new(\n                io::ErrorKind::AlreadyExists,\n                \"I/O source already registered with a `Registry`\",\n            ));\n        }\n        if io.cp.is_none() {\n            let selector = registry.selector();\n            io.cp = Some(selector.clone_port());\n            let inner_token = NEXT_TOKEN.fetch_add(2, Relaxed) + 2;\n            selector.inner.cp.add_handle(inner_token, self)?;\n        }\n        io.token = Some(token);\n        drop(io);\n        Inner::post_register(&self.inner, None);\n        Ok(())\n    }\n    fn reregister(&mut self, registry: &Registry, token: Token, _: Interest) -> io::Result<()> {\n        let mut io = self.inner.io.lock().unwrap();\n        io.check_association(registry, true)?;\n        io.token = Some(token);\n        drop(io);\n        Inner::post_register(&self.inner, None);\n        Ok(())\n    }\n    fn deregister(&mut self, registry: &Registry) -> io::Result<()> {\n        let mut io = self.inner.io.lock().unwrap();\n        io.check_association(registry, true)?;\n        if io.token.is_none() {\n            return Err(io::Error::new(\n                io::ErrorKind::NotFound,\n                \"I/O source not registered with `Registry`\",\n            ));\n        }\n        io.token = None;\n        Ok(())\n    }\n}\nimpl AsRawHandle for NamedPipe {\n    fn as_raw_handle(&self) -> RawHandle {\n        self.inner.handle.raw() as RawHandle\n    }\n}\nimpl fmt::Debug for NamedPipe {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.inner.handle.fmt(f)\n    }\n}\nimpl Drop for NamedPipe {\n    fn drop(&mut self) {\n        unsafe {\n            if self.inner.connecting.load(SeqCst) {\n                drop(cancel(&self.inner.handle, &self.inner.connect));\n            }\n            let io = self.inner.io.lock().unwrap();\n            if let State::Pending(..) = io.read {\n                drop(cancel(&self.inner.handle, &self.inner.read));\n            }\n        }\n    }\n}\nimpl Inner {\n    fn schedule_read(me: &Arc<Inner>, io: &mut Io, events: Option<&mut Vec<Event>>) -> bool {\n        match io.read {\n            State::None => {}\n            _ => return true,\n        }\n        let mut buf = me.get_buffer();\n        let e = unsafe {\n            let overlapped = me.read.as_ptr() as *mut _;\n            let slice = slice::from_raw_parts_mut(buf.as_mut_ptr(), buf.capacity());\n            me.read_overlapped(slice, overlapped)\n        };\n        match e {\n            Ok(_) => {\n                io.read = State::Pending(buf, 0); \n                mem::forget(me.clone());\n                true\n            }\n            Err(ref e) if e.raw_os_error() == Some(ERROR_PIPE_LISTENING as i32) => false,\n            Err(e) => {\n                io.read = State::Err(e);\n                io.notify_readable(me, events);\n                true\n            }\n        }\n    }\n    fn maybe_schedule_write(\n        me: &Arc<Inner>,\n        buf: Vec<u8>,\n        pos: usize,\n        io: &mut Io,\n    ) -> io::Result<Option<usize>> {\n        let e = unsafe {\n            let overlapped = me.write.as_ptr() as *mut _;\n            me.write_overlapped(&buf[pos..], overlapped)\n        };\n        match e {\n            Ok(Some(n)) => {\n                io.write = State::Ok(buf, pos);\n                mem::forget(me.clone());\n                Ok(Some(n))\n            }\n            Ok(None) => {\n                io.write = State::Pending(buf, pos);\n                mem::forget(me.clone());\n                Ok(None)\n            }\n            Err(e) => Err(e),\n        }\n    }\n    fn schedule_write(\n        me: &Arc<Inner>,\n        buf: Vec<u8>,\n        pos: usize,\n        io: &mut Io,\n        events: Option<&mut Vec<Event>>,\n    ) {\n        match Inner::maybe_schedule_write(me, buf, pos, io) {\n            Ok(Some(_)) => {\n                let state = mem::replace(&mut io.write, State::None);\n                io.write = match state {\n                    State::Ok(buf, pos) => State::Pending(buf, pos),\n                    _ => unreachable!(),\n                };\n                mem::forget(me.clone());\n            }\n            Ok(None) => (),\n            Err(e) => {\n                io.write = State::Err(e);\n                io.notify_writable(me, events);\n            }\n        }\n    }\n    fn post_register(me: &Arc<Inner>, mut events: Option<&mut Vec<Event>>) {\n        let mut io = me.io.lock().unwrap();\n        #[allow(clippy::needless_option_as_deref)]\n        if Inner::schedule_read(me, &mut io, events.as_deref_mut()) {\n            if let State::None = io.write {\n                io.notify_writable(me, events);\n            }\n        }\n    }\n    fn get_buffer(&self) -> Vec<u8> {\n        self.pool.lock().unwrap().get(4 * 1024)\n    }\n    fn put_buffer(&self, buf: Vec<u8>) {\n        self.pool.lock().unwrap().put(buf)\n    }\n}\nunsafe fn cancel(handle: &Handle, overlapped: &Overlapped) -> io::Result<()> {\n    let ret = CancelIoEx(handle.raw(), overlapped.as_ptr());\n    if ret == 0 {\n        Err(io::Error::last_os_error())\n    } else {\n        Ok(())\n    }\n}\nfn connect_done(status: &OVERLAPPED_ENTRY, events: Option<&mut Vec<Event>>) {\n    let status = CompletionStatus::from_entry(status);\n    let me = unsafe { Arc::from_raw(Inner::ptr_from_conn_overlapped(status.overlapped())) };\n    let prev = me.connecting.swap(false, SeqCst);\n    assert!(prev, \"NamedPipe was not previously connecting\");\n    debug_assert_eq!(status.bytes_transferred(), 0);\n    unsafe {\n        match me.result(status.overlapped()) {\n            Ok(n) => debug_assert_eq!(n, 0),\n            Err(e) => me.io.lock().unwrap().connect_error = Some(e),\n        }\n    }\n    Inner::post_register(&me, events);\n}\nfn read_done(status: &OVERLAPPED_ENTRY, events: Option<&mut Vec<Event>>) {\n    let status = CompletionStatus::from_entry(status);\n    let me = unsafe { Arc::from_raw(Inner::ptr_from_read_overlapped(status.overlapped())) };\n    let mut io = me.io.lock().unwrap();\n    let mut buf = match mem::replace(&mut io.read, State::None) {\n        State::Pending(buf, _) => buf,\n        _ => unreachable!(),\n    };\n    unsafe {\n        match me.result(status.overlapped()) {\n            Ok(n) => {\n                debug_assert_eq!(status.bytes_transferred() as usize, n);\n                buf.set_len(status.bytes_transferred() as usize);\n                io.read = State::Ok(buf, 0);\n            }\n            Err(e) => {\n                debug_assert_eq!(status.bytes_transferred(), 0);\n                io.read = State::Err(e);\n            }\n        }\n    }\n    io.notify_readable(&me, events);\n}\nfn write_done(status: &OVERLAPPED_ENTRY, events: Option<&mut Vec<Event>>) {\n    let status = CompletionStatus::from_entry(status);\n    let me = unsafe { Arc::from_raw(Inner::ptr_from_write_overlapped(status.overlapped())) };\n    let mut io = me.io.lock().unwrap();\n    let (buf, pos) = match mem::replace(&mut io.write, State::None) {\n        State::Ok(..) => {\n            io.notify_writable(&me, events);\n            return;\n        }\n        State::Pending(buf, pos) => (buf, pos),\n        _ => unreachable!(),\n    };\n    unsafe {\n        match me.result(status.overlapped()) {\n            Ok(n) => {\n                debug_assert_eq!(status.bytes_transferred() as usize, n);\n                let new_pos = pos + (status.bytes_transferred() as usize);\n                if new_pos == buf.len() {\n                    me.put_buffer(buf);\n                    io.notify_writable(&me, events);\n                } else {\n                    Inner::schedule_write(&me, buf, new_pos, &mut io, events);\n                }\n            }\n            Err(e) => {\n                debug_assert_eq!(status.bytes_transferred(), 0);\n                io.write = State::Err(e);\n                io.notify_writable(&me, events);\n            }\n        }\n    }\n}\nfn event_done(status: &OVERLAPPED_ENTRY, events: Option<&mut Vec<Event>>) {\n    let status = CompletionStatus::from_entry(status);\n    let me = unsafe { Arc::from_raw(Inner::ptr_from_event_overlapped(status.overlapped())) };\n    let io = me.io.lock().unwrap();\n    if io.token.is_some() {\n        if let Some(events) = events {\n            let mut ev = Event::from_completion_status(&status);\n            ev.data >>= 1;\n            events.push(ev);\n        }\n    }\n}\nimpl Io {\n    fn check_association(&self, registry: &Registry, required: bool) -> io::Result<()> {\n        match self.cp {\n            Some(ref cp) if !registry.selector().same_port(cp) => Err(io::Error::new(\n                io::ErrorKind::AlreadyExists,\n                \"I/O source already registered with a different `Registry`\",\n            )),\n            None if required => Err(io::Error::new(\n                io::ErrorKind::NotFound,\n                \"I/O source not registered with `Registry`\",\n            )),\n            _ => Ok(()),\n        }\n    }\n    fn notify_readable(&self, me: &Arc<Inner>, events: Option<&mut Vec<Event>>) {\n        if let Some(token) = self.token {\n            let mut ev = Event::new(token);\n            ev.set_readable();\n            if let Some(events) = events {\n                events.push(ev);\n            } else {\n                self.schedule_event(me, ev);\n            }\n        }\n    }\n    fn notify_writable(&self, me: &Arc<Inner>, events: Option<&mut Vec<Event>>) {\n        if let Some(token) = self.token {\n            let mut ev = Event::new(token);\n            ev.set_writable();\n            if let Some(events) = events {\n                events.push(ev);\n            } else {\n                self.schedule_event(me, ev);\n            }\n        }\n    }\n    fn schedule_event(&self, me: &Arc<Inner>, mut event: Event) {\n        event.data <<= 1;\n        event.data += 1;\n        let completion_status =\n            event.to_completion_status_with_overlapped(me.event.as_ptr() as *mut _);\n        match self.cp.as_ref().unwrap().post(completion_status) {\n            Ok(_) => {\n                mem::forget(me.clone());\n            }\n            Err(_) => {\n            }\n        }\n    }\n}\nstruct BufferPool {\n    pool: Vec<Vec<u8>>,\n}\nimpl BufferPool {\n    fn with_capacity(cap: usize) -> BufferPool {\n        BufferPool {\n            pool: Vec::with_capacity(cap),\n        }\n    }\n    fn get(&mut self, default_cap: usize) -> Vec<u8> {\n        self.pool\n            .pop()\n            .unwrap_or_else(|| Vec::with_capacity(default_cap))\n    }\n    fn put(&mut self, mut buf: Vec<u8>) {\n        if self.pool.len() < self.pool.capacity() {\n            unsafe {\n                buf.set_len(0);\n            }\n            self.pool.push(buf);\n        }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub use impl_::*;\npub struct ChildPipeFd(pub i64);\nmod impl_ {\n  use std::cell::RefCell;\n  use std::future::Future;\n  use std::io;\n  use std::mem;\n  #[cfg(unix)]\n  use std::os::fd::FromRawFd;\n  #[cfg(unix)]\n  use std::os::fd::RawFd;\n  use std::pin::Pin;\n  use std::rc::Rc;\n  use std::task::Context;\n  use std::task::Poll;\n  use deno_core::error::bad_resource_id;\n  use deno_core::error::AnyError;\n  use deno_core::op2;\n  use deno_core::serde_json;\n  use deno_core::AsyncRefCell;\n  use deno_core::CancelFuture;\n  use deno_core::CancelHandle;\n  use deno_core::OpState;\n  use deno_core::RcRef;\n  use deno_core::ResourceId;\n  use pin_project_lite::pin_project;\n  use tokio::io::AsyncBufRead;\n  use tokio::io::AsyncWriteExt;\n  use tokio::io::BufReader;\n  #[cfg(unix)]\n  use tokio::net::unix::OwnedReadHalf;\n  #[cfg(unix)]\n  use tokio::net::unix::OwnedWriteHalf;\n  #[cfg(unix)]\n  use tokio::net::UnixStream;\n  #[cfg(windows)]\n  type NamedPipeClient = tokio::net::windows::named_pipe::NamedPipeClient;\n  #[op2]\n  #[smi]\n  pub fn op_node_child_ipc_pipe(\n    state: &mut OpState,\n  ) -> Result<Option<ResourceId>, AnyError> {\n    let fd = match state.try_borrow_mut::<crate::ChildPipeFd>() {\n      Some(child_pipe_fd) => child_pipe_fd.0,\n      None => return Ok(None),\n    };\n    Ok(Some(\n      state.resource_table.add(IpcJsonStreamResource::new(fd)?),\n    ))\n  }\n  #[op2(async)]\n  pub async fn op_node_ipc_write(\n    state: Rc<RefCell<OpState>>,\n    #[smi] rid: ResourceId,\n    #[serde] value: serde_json::Value,\n  ) -> Result<(), AnyError> {\n    let stream = state\n      .borrow()\n      .resource_table\n      .get::<IpcJsonStreamResource>(rid)\n      .map_err(|_| bad_resource_id())?;\n    stream.write_msg(value).await?;\n    Ok(())\n  }\n  #[op2(async)]\n  #[serde]\n  pub async fn op_node_ipc_read(\n    state: Rc<RefCell<OpState>>,\n    #[smi] rid: ResourceId,\n  ) -> Result<serde_json::Value, AnyError> {\n    let stream = state\n      .borrow()\n      .resource_table\n      .get::<IpcJsonStreamResource>(rid)\n      .map_err(|_| bad_resource_id())?;\n    let cancel = stream.cancel.clone();\n    let mut stream = RcRef::map(stream, |r| &r.read_half).borrow_mut().await;\n    let msgs = stream.read_msg().or_cancel(cancel).await??;\n    Ok(msgs)\n  }\n  pub struct IpcJsonStreamResource {\n    read_half: AsyncRefCell<IpcJsonStream>,\n    #[cfg(unix)]\n    write_half: AsyncRefCell<OwnedWriteHalf>,\n    #[cfg(windows)]\n    write_half: AsyncRefCell<tokio::io::WriteHalf<NamedPipeClient>>,\n    cancel: Rc<CancelHandle>,\n  }\n  impl deno_core::Resource for IpcJsonStreamResource {\n    fn close(self: Rc<Self>) {\n      self.cancel.cancel();\n    }\n  }\n  #[cfg(unix)]\n  fn pipe(stream: RawFd) -> Result<(OwnedReadHalf, OwnedWriteHalf), io::Error> {\n    let unix_stream = UnixStream::from_std(unsafe {\n      std::os::unix::net::UnixStream::from_raw_fd(stream)\n    })?;\n    Ok(unix_stream.into_split())\n  }\n  #[cfg(windows)]\n  fn pipe(\n    handle: i64,\n  ) -> Result<\n    (\n      tokio::io::ReadHalf<NamedPipeClient>,\n      tokio::io::WriteHalf<NamedPipeClient>,\n    ),\n    io::Error,\n  > {\n    let pipe = unsafe { NamedPipeClient::from_raw_handle(handle as _)? };\n    Ok(tokio::io::split(pipe))\n  }\n  impl IpcJsonStreamResource {\n    pub fn new(stream: i64) -> Result<Self, std::io::Error> {\n      let (read_half, write_half) = pipe(stream as _)?;\n      Ok(Self {\n        read_half: AsyncRefCell::new(IpcJsonStream::new(read_half)),\n        write_half: AsyncRefCell::new(write_half),\n        cancel: Default::default(),\n      })\n    }\n    #[cfg(unix)]\n    #[cfg(test)]\n    fn from_stream(stream: UnixStream) -> Self {\n      let (read_half, write_half) = stream.into_split();\n      Self {\n        read_half: AsyncRefCell::new(IpcJsonStream::new(read_half)),\n        write_half: AsyncRefCell::new(write_half),\n        cancel: Default::default(),\n      }\n    }\n    #[cfg(windows)]\n    #[cfg(test)]\n    fn from_stream(pipe: NamedPipeClient) -> Self {\n      let (read_half, write_half) = tokio::io::split(pipe);\n      Self {\n        read_half: AsyncRefCell::new(IpcJsonStream::new(read_half)),\n        write_half: AsyncRefCell::new(write_half),\n        cancel: Default::default(),\n      }\n    }\n    async fn write_msg(\n      self: Rc<Self>,\n      msg: serde_json::Value,\n    ) -> Result<(), AnyError> {\n      let mut write_half =\n        RcRef::map(self, |r| &r.write_half).borrow_mut().await;\n      let mut buf = Vec::new();\n      serde_json::to_writer(&mut buf, &msg)?;\n      buf.push(b'\\n');\n      write_half.write_all(&buf).await?;\n      Ok(())\n    }\n  }\n  #[inline]\n  fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n    #[cfg(all(target_os = \"macos\", target_arch = \"aarch64\"))]\n    return unsafe { neon::neon_memchr(haystack, needle, haystack.len()) };\n    #[cfg(not(all(target_os = \"macos\", target_arch = \"aarch64\")))]\n    return haystack.iter().position(|&b| b == needle);\n  }\n  const INITIAL_CAPACITY: usize = 1024 * 64;\n  struct IpcJsonStream {\n    #[cfg(unix)]\n    pipe: BufReader<OwnedReadHalf>,\n    #[cfg(windows)]\n    pipe: BufReader<tokio::io::ReadHalf<NamedPipeClient>>,\n    buffer: Vec<u8>,\n  }\n  impl IpcJsonStream {\n    #[cfg(unix)]\n    fn new(pipe: OwnedReadHalf) -> Self {\n      Self {\n        pipe: BufReader::with_capacity(INITIAL_CAPACITY, pipe),\n        buffer: Vec::with_capacity(INITIAL_CAPACITY),\n      }\n    }\n    #[cfg(windows)]\n    fn new(pipe: tokio::io::ReadHalf<NamedPipeClient>) -> Self {\n      Self {\n        pipe: BufReader::with_capacity(INITIAL_CAPACITY, pipe),\n        buffer: Vec::with_capacity(INITIAL_CAPACITY),\n      }\n    }\n    async fn read_msg(&mut self) -> Result<serde_json::Value, AnyError> {\n      let mut json = None;\n      let nread =\n        read_msg_inner(&mut self.pipe, &mut self.buffer, &mut json).await?;\n      if nread == 0 {\n        return Ok(serde_json::Value::Null);\n      }\n      let json = match json {\n        Some(v) => v,\n        None => {\n          simd_json::from_slice(&mut self.buffer[..nread])?\n        }\n      };\n      unsafe {\n        self.buffer.set_len(0);\n      }\n      Ok(json)\n    }\n  }\n  pin_project! {\n      #[must_use = \"futures do nothing unless you `.await` or poll them\"]\n      struct ReadMsgInner<'a, R: ?Sized> {\n          reader: &'a mut R,\n          buf: &'a mut Vec<u8>,\n          json: &'a mut Option<serde_json::Value>,\n          read: usize,\n      }\n  }\n  fn read_msg_inner<'a, R>(\n    reader: &'a mut R,\n    buf: &'a mut Vec<u8>,\n    json: &'a mut Option<serde_json::Value>,\n  ) -> ReadMsgInner<'a, R>\n  where\n    R: AsyncBufRead + ?Sized + Unpin,\n  {\n    ReadMsgInner {\n      reader,\n      buf,\n      json,\n      read: 0,\n    }\n  }\n  fn read_msg_internal<R: AsyncBufRead + ?Sized>(\n    mut reader: Pin<&mut R>,\n    cx: &mut Context<'_>,\n    buf: &mut Vec<u8>,\n    json: &mut Option<serde_json::Value>,\n    read: &mut usize,\n  ) -> Poll<io::Result<usize>> {\n    loop {\n      let (done, used) = {\n        let available = match reader.as_mut().poll_fill_buf(cx) {\n          std::task::Poll::Ready(t) => t?,\n          std::task::Poll::Pending => return std::task::Poll::Pending,\n        };\n        if let Some(i) = memchr(b'\\n', available) {\n          if *read == 0 {\n            let available = unsafe {\n              std::slice::from_raw_parts_mut(\n                available.as_ptr() as *mut u8,\n                available.len(),\n              )\n            };\n            json.replace(\n              simd_json::from_slice(&mut available[..i + 1])\n                .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?,\n            );\n          } else {\n            buf.extend_from_slice(&available[..=i]);\n          }\n          (true, i + 1)\n        } else {\n          buf.extend_from_slice(available);\n          (false, available.len())\n        }\n      };\n      reader.as_mut().consume(used);\n      *read += used;\n      if done || used == 0 {\n        return Poll::Ready(Ok(mem::replace(read, 0)));\n      }\n    }\n  }\n  impl<R: AsyncBufRead + ?Sized + Unpin> Future for ReadMsgInner<'_, R> {\n    type Output = io::Result<usize>;\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n      let me = self.project();\n      read_msg_internal(Pin::new(*me.reader), cx, me.buf, me.json, me.read)\n    }\n  }\n  #[cfg(all(target_os = \"macos\", target_arch = \"aarch64\"))]\n  mod neon {\n    use std::arch::aarch64::*;\n    pub unsafe fn neon_memchr(\n      str: &[u8],\n      c: u8,\n      length: usize,\n    ) -> Option<usize> {\n      let end = str.as_ptr().wrapping_add(length);\n      let mut ptr = str.as_ptr();\n      while ptr < end && (ptr as usize) & 0xF != 0 {\n        if *ptr == c {\n          return Some(ptr as usize - str.as_ptr() as usize);\n        }\n        ptr = ptr.wrapping_add(1);\n      }\n      let search_char = vdupq_n_u8(c);\n      while ptr.wrapping_add(16) <= end {\n        let chunk = vld1q_u8(ptr);\n        let comparison = vceqq_u8(chunk, search_char);\n        let result0 = vgetq_lane_u64(vreinterpretq_u64_u8(comparison), 0);\n        if result0 != 0 {\n          return Some(\n            (ptr as usize - str.as_ptr() as usize)\n              + result0.trailing_zeros() as usize / 8,\n          );\n        }\n        let result1 = vgetq_lane_u64(vreinterpretq_u64_u8(comparison), 1);\n        if result1 != 0 {\n          return Some(\n            (ptr as usize - str.as_ptr() as usize)\n              + 8\n              + result1.trailing_zeros() as usize / 8,\n          );\n        }\n        ptr = ptr.wrapping_add(16);\n      }\n      while ptr < end {\n        if *ptr == c {\n          return Some(ptr as usize - str.as_ptr() as usize);\n        }\n        ptr = ptr.wrapping_add(1);\n      }\n      None\n    }\n  }\n  #[cfg(test)]\n  mod tests {\n    use super::IpcJsonStreamResource;\n    use deno_core::serde_json;\n    use deno_core::serde_json::json;\n    use deno_core::RcRef;\n    use std::rc::Rc;\n    #[cfg(unix)]\n    pub async fn pair() -> (Rc<IpcJsonStreamResource>, tokio::net::UnixStream) {\n      let (a, b) = tokio::net::UnixStream::pair().unwrap();\n      let a = Rc::new(IpcJsonStreamResource::from_stream(a));\n      (a, b)\n    }\n    #[cfg(windows)]\n    pub async fn pair() -> (\n      Rc<IpcJsonStreamResource>,\n      tokio::net::windows::named_pipe::NamedPipeServer,\n    ) {\n      use tokio::net::windows::named_pipe::ClientOptions;\n      use tokio::net::windows::named_pipe::ServerOptions;\n      let name =\n        format!(r\"\\\\.\\pipe\\deno-named-pipe-test-{}\", rand::random::<u32>());\n      let server = ServerOptions::new().create(name.clone()).unwrap();\n      let client = ClientOptions::new().open(name).unwrap();\n      server.connect().await.unwrap();\n      let client = Rc::new(IpcJsonStreamResource::from_stream(client));\n      (client, server)\n    }\n    #[tokio::test]\n    async fn bench_ipc() -> Result<(), Box<dyn std::error::Error>> {\n      if std::env::var_os(\"BENCH_IPC_DENO\").is_none() {\n        return Ok(());\n      }\n      let (ipc, mut fd2) = pair().await;\n      let child = tokio::spawn(async move {\n        use tokio::io::AsyncWriteExt;\n        let size = 1024 * 1024;\n        let stri = \"x\".repeat(size);\n        let data = format!(\"\\\"{}\\\"\\n\", stri);\n        for _ in 0..100 {\n          fd2.write_all(data.as_bytes()).await?;\n        }\n        Ok::<_, std::io::Error>(())\n      });\n      let start = std::time::Instant::now();\n      let mut bytes = 0;\n      let mut ipc = RcRef::map(ipc, |r| &r.read_half).borrow_mut().await;\n      loop {\n        let msgs = ipc.read_msg().await?;\n        if msgs == serde_json::Value::Null {\n          break;\n        }\n        bytes += msgs.as_str().unwrap().len();\n        if start.elapsed().as_secs() > 5 {\n          break;\n        }\n      }\n      let elapsed = start.elapsed();\n      let mb = bytes as f64 / 1024.0 / 1024.0;\n      println!(\"{} mb/s\", mb / elapsed.as_secs_f64());\n      child.await??;\n      Ok(())\n    }\n    #[tokio::test]\n    async fn unix_ipc_json() -> Result<(), Box<dyn std::error::Error>> {\n      let (ipc, mut fd2) = pair().await;\n      let child = tokio::spawn(async move {\n        use tokio::io::AsyncReadExt;\n        use tokio::io::AsyncWriteExt;\n        const EXPECTED: &[u8] = b\"\\\"hello\\\"\\n\";\n        let mut buf = [0u8; EXPECTED.len()];\n        let n = fd2.read_exact(&mut buf).await?;\n        assert_eq!(&buf[..n], EXPECTED);\n        fd2.write_all(b\"\\\"world\\\"\\n\").await?;\n        Ok::<_, std::io::Error>(())\n      });\n      ipc.clone().write_msg(json!(\"hello\")).await?;\n      let mut ipc = RcRef::map(ipc, |r| &r.read_half).borrow_mut().await;\n      let msgs = ipc.read_msg().await?;\n      assert_eq!(msgs, json!(\"world\"));\n      child.await??;\n      Ok(())\n    }\n    #[tokio::test]\n    async fn unix_ipc_json_multi() -> Result<(), Box<dyn std::error::Error>> {\n      let (ipc, mut fd2) = pair().await;\n      let child = tokio::spawn(async move {\n        use tokio::io::AsyncReadExt;\n        use tokio::io::AsyncWriteExt;\n        const EXPECTED: &[u8] = b\"\\\"hello\\\"\\n\\\"world\\\"\\n\";\n        let mut buf = [0u8; EXPECTED.len()];\n        let n = fd2.read_exact(&mut buf).await?;\n        assert_eq!(&buf[..n], EXPECTED);\n        fd2.write_all(b\"\\\"foo\\\"\\n\\\"bar\\\"\\n\").await?;\n        Ok::<_, std::io::Error>(())\n      });\n      ipc.clone().write_msg(json!(\"hello\")).await?;\n      ipc.clone().write_msg(json!(\"world\")).await?;\n      let mut ipc = RcRef::map(ipc, |r| &r.read_half).borrow_mut().await;\n      let msgs = ipc.read_msg().await?;\n      assert_eq!(msgs, json!(\"foo\"));\n      child.await??;\n      Ok(())\n    }\n    #[tokio::test]\n    async fn unix_ipc_json_invalid() -> Result<(), Box<dyn std::error::Error>> {\n      let (ipc, mut fd2) = pair().await;\n      let child = tokio::spawn(async move {\n        tokio::io::AsyncWriteExt::write_all(&mut fd2, b\"\\n\\n\").await?;\n        Ok::<_, std::io::Error>(())\n      });\n      let mut ipc = RcRef::map(ipc, |r| &r.read_half).borrow_mut().await;\n      let _err = ipc.read_msg().await.unwrap_err();\n      child.await??;\n      Ok(())\n    }\n    #[test]\n    fn memchr() {\n      let str = b\"hello world\";\n      assert_eq!(super::memchr(b'h', str), Some(0));\n      assert_eq!(super::memchr(b'w', str), Some(6));\n      assert_eq!(super::memchr(b'd', str), Some(10));\n      assert_eq!(super::memchr(b'x', str), None);\n      let empty = b\"\";\n      assert_eq!(super::memchr(b'\\n', empty), None);\n    }\n  }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn escape_control_characters(s: &str) -> std::borrow::Cow<str> {\n  if !s.contains(|c: char| c.is_ascii_control() || c.is_control()) {\n    return std::borrow::Cow::Borrowed(s);\n  }\n  let mut output = String::with_capacity(s.len() * 2);\n  for c in s.chars() {\n    match c {\n      c if c.is_ascii_control() => output.push_str(\n        &colors::white_bold_on_red(c.escape_debug().to_string()).to_string(),\n      ),\n      c if c.is_control() => output.push_str(\n        &colors::white_bold_on_red(c.escape_debug().to_string()).to_string(),\n      ),\n      c => output.push(c),\n    }\n  }\n  output.into()\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub(super) fn main_router<RF>(\n    configuration: &Configuration,\n) -> axum::Router<(), DecompressionBody<Body>>\nwhere\n    RF: RouterFactory,\n{\n    let mut router = Router::new().route(\n        &configuration.supergraph.sanitized_path(),\n        get({\n            move |Extension(service): Extension<RF>, request: Request<DecompressionBody<Body>>| {\n                handle_graphql(service.create().boxed(), request)\n            }\n        })\n        .post({\n            move |Extension(service): Extension<RF>, request: Request<DecompressionBody<Body>>| {\n                handle_graphql(service.create().boxed(), request)\n            }\n        }),\n    );\n    if configuration.supergraph.path == \"/*\" {\n        router = router.route(\n            \"/\",\n            get({\n                move |Extension(service): Extension<RF>,\n                      request: Request<DecompressionBody<Body>>| {\n                    handle_graphql(service.create().boxed(), request)\n                }\n            })\n            .post({\n                move |Extension(service): Extension<RF>,\n                      request: Request<DecompressionBody<Body>>| {\n                    handle_graphql(service.create().boxed(), request)\n                }\n            }),\n        );\n    }\n    router\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "   fn resume_func<T, Results>(\n        &mut self,\n        mut ctx: StoreContextMut<T>,\n        host_func: Func,\n        params: impl CallParams,\n        results: Results,\n    ) -> Result<<Results as CallResults>::Results, TaggedTrap>\n    where\n        Results: CallResults,\n    {\n        self.stack\n            .values\n            .drop(host_func.ty(ctx.as_context()).params().len());\n        let call_params = params.call_params();\n        self.stack.values.reserve(call_params.len())?;\n        self.stack.values.extend(call_params);\n        assert!(\n            self.stack.frames.peek().is_some(),\n            \"a frame must be on the call stack upon resumption\"\n        );\n        self.execute_wasm_func(ctx.as_context_mut())?;\n        let results = self.write_results_back(results);\n        Ok(results)\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "async fn main() {\n    let addr: std::net::SocketAddr = ([127, 0, 0, 1], 3000).into();\n    let counter = Arc::new(AtomicU64::new(0));\n    let mut listener = tls_listener::builder(tls_acceptor())\n        .accept_batch_size(NonZeroUsize::new(10).unwrap())\n        .listen(TcpListener::bind(addr).await.expect(\"Failed to bind port\"));\n    let (tx, mut rx) = mpsc::channel::<Acceptor>(1);\n    let http = http1::Builder::new();\n    loop {\n        tokio::select! {\n            conn = listener.accept() => {\n                match conn {\n                    Ok((conn, remote_addr)) => {\n                        let http = http.clone();\n                        let tx = tx.clone();\n                        let counter = counter.clone();\n                        tokio::spawn(async move {\n                            let svc = service_fn(move |request| handle_request(tx.clone(), counter.clone(), request));\n                            if let Err(err) = http.serve_connection(TokioIo::new(conn), svc).await {\n                                eprintln!(\"Application error (client address: {remote_addr}): {err}\");\n                            }\n                        });\n                    },\n                    Err(e) => {\n                        if let Some(remote_addr) = e.peer_addr() {\n                            eprint!(\"[client {remote_addr}] \");\n                        }\n                        eprintln!(\"Bad connection: {}\", e);\n                    }\n                }\n            },\n            message = rx.recv() => {\n                let acceptor = message.expect(\"Channel should not be closed\");\n                println!(\"Rotating certificate...\");\n                listener.replace_acceptor(acceptor);\n            }\n        }\n    }\n}\npub fn poll_accept(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<<Self as Stream>::Item> {\n        let mut this = self.project();\n        loop {\n            let mut empty_listener = false;\n            for _ in 0..this.accept_batch_size.get() {\n                match this.listener.as_mut().poll_accept(cx) {\n                    Poll::Pending => {\n                        empty_listener = true;\n                        break;\n                    }\n                    Poll::Ready(Ok((conn, addr))) => {\n                        this.waiting.push(Waiting {\n                            inner: timeout(*this.timeout, this.tls.accept(conn)),\n                            peer_addr: Some(addr),\n                        });\n                    }\n                    Poll::Ready(Err(e)) => {\n                        return Poll::Ready(Err(Error::ListenerError(e)));\n                    }\n                }\n            }\n            match this.waiting.poll_next_unpin(cx) {\n                Poll::Ready(Some(result)) => return Poll::Ready(result),\n                Poll::Ready(None) | Poll::Pending => {\n                    if empty_listener {\n                        return Poll::Pending;\n                    }\n                }\n            }\n        }\n    }\n    pub fn accept_batch_size(&mut self, size: NonZeroUsize) -> &mut Self {\n        self.accept_batch_size = size;\n        self\n    }\npub fn listen<A: AsyncAccept>(&self, listener: A) -> TlsListener<A, T>\n    where\n        T: AsyncTls<A::Connection>,\n    {\n        TlsListener {\n            listener,\n            tls: self.tls.clone(),\n            waiting: FuturesUnordered::new(),\n            accept_batch_size: self.accept_batch_size,\n            timeout: self.handshake_timeout,\n        }\n    }\npub fn builder<T>(tls: T) -> Builder<T> {\n    Builder {\n        tls,\n        accept_batch_size: DEFAULT_ACCEPT_BATCH_SIZE,\n        handshake_timeout: DEFAULT_HANDSHAKE_TIMEOUT,\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "  pub(crate) fn process_alert(&mut self, alert: &AlertMessagePayload) -> Result<(), Error> {\n        if let AlertLevel::Unknown(_) = alert.level {\n            return Err(self.send_fatal_alert(\n                AlertDescription::IllegalParameter,\n                Error::AlertReceived(alert.description),\n            ));\n        }\n        if self.may_receive_application_data && alert.description == AlertDescription::CloseNotify {\n            self.has_received_close_notify = true;\n            return Ok(());\n        }\n        let err = Error::AlertReceived(alert.description);\n        if alert.level == AlertLevel::Warning {\n            if self.is_tls13() && alert.description != AlertDescription::UserCanceled {\n                return Err(self.send_fatal_alert(AlertDescription::DecodeError, err));\n            } else {\n                warn!(\"TLS alert warning received: {:?}\", alert);\n                return Ok(());\n            }\n        }\n        Err(err)\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "  fn hash_subgraph_query(schema_str: &str, query: &str) -> String {\n        let schema = Valid::assume_valid(Schema::parse(schema_str, \"schema.graphql\").unwrap());\n        let doc = Document::parse(query, \"query.graphql\").unwrap();\n        let exec = doc\n            .to_executable(&schema)\n            .unwrap()\n            .validate(&schema)\n            .unwrap();\n        let mut visitor = QueryHashVisitor::new(&schema, schema_str, &exec);\n        traverse::document(&mut visitor, &exec, None).unwrap();\n        hex::encode(visitor.finish())\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn poll(&mut self, cx: &mut Context<'_>) -> Poll<Result<Stream>> {\n        loop {\n            if self.socket.poll_ready_unpin(cx).is_ready() {\n                if let Some(frame) = self.rtt.next_ping() {\n                    self.socket.start_send_unpin(frame.into())?;\n                    continue;\n                }\n                if let Some(frame) = self.pending_frames.pop_front() {\n                    self.socket.start_send_unpin(frame)?;\n                    continue;\n                }\n            }\n            if self.pending_frames.len() == MAX_FRAME_BUFFER {\n                return Poll::Ready(Err(ConnectionError::Closed));\n            }\n            match self.socket.poll_flush_unpin(cx)? {\n                Poll::Ready(()) => {}\n                Poll::Pending => {}\n            }\n            match self.stream_receivers.poll_next_unpin(cx) {\n                Poll::Ready(Some((_, Some(StreamCommand::SendFrame(frame))))) => {\n                    self.on_send_frame(frame);\n                    continue;\n                }\n                Poll::Ready(Some((id, Some(StreamCommand::CloseStream { ack })))) => {\n                    self.on_close_stream(id, ack);\n                    continue;\n                }\n                Poll::Ready(Some((id, None))) => {\n                    self.on_drop_stream(id);\n                    continue;\n                }\n                Poll::Ready(None) => {\n                    self.no_streams_waker = Some(cx.waker().clone());\n                }\n                Poll::Pending => {}\n            }\n            match self.socket.poll_next_unpin(cx) {\n                Poll::Ready(Some(frame)) => {\n                    if let Some(stream) = self.on_frame(frame?)? {\n                        return Poll::Ready(Ok(stream));\n                    }\n                    continue;\n                }\n                Poll::Ready(None) => {\n                    return Poll::Ready(Err(ConnectionError::Closed));\n                }\n                Poll::Pending => {}\n            }\n            return Poll::Pending;\n        }\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn load_certificates(\n    certificates_der: &Option<Vec<PathBuf>>,\n    certificates_pem: &Option<Vec<PathBuf>>,\n) -> Result<Vec<Certificate>> {\n    const CERT_READ_ERROR: &str = \"Failed to read certificate\";\n    const CERT_PARSE_ERROR: &str = \"Failed to parse certificate\";\n    let mut certs = vec![];\n    for path in certificates_der.iter().flatten() {\n        let mut buf = vec![];\n        File::open(path)\n            .context(CERT_READ_ERROR)?\n            .read_to_end(&mut buf)\n            .context(CERT_READ_ERROR)?;\n        let cert = Certificate::from_der(&buf).context(CERT_PARSE_ERROR)?;\n        certs.push(cert);\n    }\n    for path in certificates_pem.iter().flatten() {\n        let mut buf = vec![];\n        File::open(path)\n            .context(CERT_READ_ERROR)?\n            .read_to_end(&mut buf)\n            .context(CERT_READ_ERROR)?;\n        let cert = Certificate::from_pem(&buf).context(CERT_PARSE_ERROR)?;\n        certs.push(cert);\n    }\n    Ok(certs)\n}\npub fn construct_client(\n    root_certificates: Vec<Certificate>,\n    danger_accept_invalid_certs: bool,\n    danger_accept_invalid_hostnames: bool,\n) -> reqwest::Result<Client> {\n    let mut headers = HeaderMap::new();\n    headers.insert(\"Sec-Fetch-Site\", HeaderValue::from_static(\"none\"));\n    headers.insert(\"Sec-Fetch-Dest\", HeaderValue::from_static(\"manifest\"));\n    let mut builder = Client::builder()\n        .user_agent(APP_USER_AGENT)\n        .default_headers(headers)\n        .danger_accept_invalid_certs(danger_accept_invalid_certs)\n        .danger_accept_invalid_hostnames(danger_accept_invalid_hostnames);\n    if danger_accept_invalid_certs || danger_accept_invalid_hostnames {\n        warn!(\"Certificate or hostname verification is disabled\");\n        warn!(\"This is a dangerous option that should be used with care\");\n    }\n    for certificate in root_certificates {\n        builder = builder.add_root_certificate(certificate);\n    }\n    builder.build()\n}\npub(crate) fn construct_certificates_and_client(\n    certificates_der: &Option<Vec<PathBuf>>,\n    certificates_pem: &Option<Vec<PathBuf>>,\n    danger_accept_invalid_certs: bool,\n    danger_accept_invalid_hostnames: bool,\n) -> Result<Client> {\n    const CLIENT_CERT_ERROR: &str = \"Failed to load HTTP client certificates\";\n    const CLIENT_CONSTRUCT_ERROR: &str = \"Failed to construct HTTP client\";\n    construct_client(\n        load_certificates(certificates_der, certificates_pem).context(CLIENT_CERT_ERROR)?,\n        danger_accept_invalid_certs,\n        danger_accept_invalid_hostnames,\n    )\n    .context(CLIENT_CONSTRUCT_ERROR)\n}\npub fn sanitize_string(string: &str) -> String {\n    string.chars().filter(|char| !char.is_control()).collect()\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub enum Error {\n    #[error(\"Failed to attach Java VM to tunnel thread\")]\n    AttachJvmToThread(#[source] jnix::jni::errors::Error),\n    #[error(\"Failed to allow socket to bypass tunnel\")]\n    Bypass,\n    #[error(\"Failed to call Java method TalpidVpnService.{0}\")]\n    CallMethod(&'static str, #[source] jnix::jni::errors::Error),\n    #[error(\"Failed to create Java VM handle clone\")]\n    CloneJavaVm(#[source] jnix::jni::errors::Error),\n    #[error(\"Failed to find TalpidVpnService.{0} method\")]\n    FindMethod(&'static str, #[source] jnix::jni::errors::Error),\n    #[error(\"Attempt to configure the tunnel with an invalid DNS server address(es): {0:?}\")]\n    InvalidDnsServers(Vec<IpAddr>),\n    #[error(\"Received an invalid result from TalpidVpnService.{0}: {1}\")]\n    InvalidMethodResult(&'static str, String),\n    #[error(\"Failed to create tunnel device\")]\n    TunnelDeviceError,\n    #[error(\"Permission denied when trying to create tunnel\")]\n    PermissionDenied,\n}\npub struct AndroidTunProvider {\n    jvm: Arc<JavaVM>,\n    class: GlobalRef,\n    object: GlobalRef,\n    last_tun_config: TunConfig,\n    allow_lan: bool,\n    custom_dns_servers: Option<Vec<IpAddr>>,\n    allowed_lan_networks: Vec<IpNetwork>,\n}\nimpl AndroidTunProvider {\n    pub fn new(\n        context: AndroidContext,\n        allow_lan: bool,\n        custom_dns_servers: Option<Vec<IpAddr>>,\n        allowed_lan_networks: Vec<IpNetwork>,\n    ) -> Self {\n        let env = JnixEnv::from(\n            context\n                .jvm\n                .attach_current_thread_as_daemon()\n                .expect(\"Failed to attach thread to Java VM\"),\n        );\n        let talpid_vpn_service_class = env.get_class(\"net/mullvad/talpid/TalpidVpnService\");\n        AndroidTunProvider {\n            jvm: context.jvm,\n            class: talpid_vpn_service_class,\n            object: context.vpn_service,\n            last_tun_config: TunConfig::default(),\n            allow_lan,\n            custom_dns_servers,\n            allowed_lan_networks,\n        }\n    }\n    pub fn set_allow_lan(&mut self, allow_lan: bool) -> Result<(), Error> {\n        if self.allow_lan != allow_lan {\n            self.allow_lan = allow_lan;\n            self.recreate_tun_if_open()?;\n        }\n        Ok(())\n    }\n    pub fn set_dns_servers(&mut self, servers: Option<Vec<IpAddr>>) -> Result<(), Error> {\n        if self.custom_dns_servers != servers {\n            self.custom_dns_servers = servers;\n            self.recreate_tun_if_open()?;\n        }\n        Ok(())\n    }\n    pub fn get_tun(&mut self, config: TunConfig) -> Result<VpnServiceTun, Error> {\n        let tun_fd = self.get_tun_fd(config.clone())?;\n        self.last_tun_config = config;\n        let jvm = unsafe { JavaVM::from_raw(self.jvm.get_java_vm_pointer()) }\n            .map_err(Error::CloneJavaVm)?;\n        Ok(VpnServiceTun {\n            tunnel: tun_fd,\n            jvm,\n            class: self.class.clone(),\n            object: self.object.clone(),\n        })\n    }\n    pub fn create_blocking_tun(&mut self) -> Result<(), Error> {\n        let mut config = TunConfig::default();\n        self.prepare_tun_config(&mut config);\n        let _ = self.get_tun(config)?;\n        Ok(())\n    }\n    pub fn create_tun(&mut self) -> Result<(), Error> {\n        let result = self.call_method(\n            \"createTun\",\n            \"()V\",\n            JavaType::Primitive(Primitive::Void),\n            &[],\n        )?;\n        match result {\n            JValue::Void => Ok(()),\n            value => Err(Error::InvalidMethodResult(\n                \"createTun\",\n                format!(\"{:?}\", value),\n            )),\n        }\n    }\n    pub fn close_tun(&mut self) {\n        let result = self.call_method(\"closeTun\", \"()V\", JavaType::Primitive(Primitive::Void), &[]);\n        let error = match result {\n            Ok(JValue::Void) => None,\n            Ok(value) => Some(Error::InvalidMethodResult(\n                \"closeTun\",\n                format!(\"{:?}\", value),\n            )),\n            Err(error) => Some(error),\n        };\n        if let Some(error) = error {\n            log::error!(\n                \"{}\",\n                error.display_chain_with_msg(\"Failed to close the tunnel\")\n            );\n        }\n    }\n    fn get_tun_fd(&mut self, mut config: TunConfig) -> Result<RawFd, Error> {\n        self.prepare_tun_config(&mut config);\n        let env = self.env()?;\n        let java_config = config.into_java(&env);\n        let result = self.call_method(\n            \"getTun\",\n            \"(Lnet/mullvad/talpid/tun_provider/TunConfig;)Lnet/mullvad/talpid/CreateTunResult;\",\n            JavaType::Object(\"net/mullvad/talpid/CreateTunResult\".to_owned()),\n            &[JValue::Object(java_config.as_obj())],\n        )?;\n        match result {\n            JValue::Object(result) => CreateTunResult::from_java(&env, result).into(),\n            value => Err(Error::InvalidMethodResult(\"getTun\", format!(\"{:?}\", value))),\n        }\n    }\n    fn recreate_tun_if_open(&mut self) -> Result<(), Error> {\n        let mut actual_config = self.last_tun_config.clone();\n        self.prepare_tun_config(&mut actual_config);\n        let env = self.env()?;\n        let java_config = actual_config.into_java(&env);\n        let result = self.call_method(\n            \"recreateTunIfOpen\",\n            \"(Lnet/mullvad/talpid/tun_provider/TunConfig;)V\",\n            JavaType::Primitive(Primitive::Void),\n            &[JValue::Object(java_config.as_obj())],\n        )?;\n        match result {\n            JValue::Void => Ok(()),\n            value => Err(Error::InvalidMethodResult(\"getTun\", format!(\"{:?}\", value))),\n        }\n    }\n    fn prepare_tun_config(&self, config: &mut TunConfig) {\n        self.prepare_tun_config_for_allow_lan(config);\n        self.prepare_tun_config_for_custom_dns(config);\n        maybe_set_dummy_dns_servers(config);\n    }\n    fn prepare_tun_config_for_allow_lan(&self, config: &mut TunConfig) {\n        if self.allow_lan {\n            let (required_ipv4_routes, required_ipv6_routes) = config\n                .required_routes\n                .iter()\n                .cloned()\n                .partition::<Vec<_>, _>(|route| route.is_ipv4());\n            let (original_lan_ipv4_networks, original_lan_ipv6_networks) = self\n                .allowed_lan_networks\n                .iter()\n                .cloned()\n                .partition::<Vec<_>, _>(|network| network.is_ipv4());\n            let lan_ipv4_networks = original_lan_ipv4_networks\n                .into_iter()\n                .flat_map(|network| network.sub_all(required_ipv4_routes.iter().cloned()))\n                .collect::<Vec<_>>();\n            let lan_ipv6_networks = original_lan_ipv6_networks\n                .into_iter()\n                .flat_map(|network| network.sub_all(required_ipv6_routes.iter().cloned()))\n                .collect::<Vec<_>>();\n            let routes = config\n                .routes\n                .iter()\n                .flat_map(|&route| {\n                    if route.is_ipv4() {\n                        route.sub_all(lan_ipv4_networks.iter().cloned())\n                    } else {\n                        route.sub_all(lan_ipv6_networks.iter().cloned())\n                    }\n                })\n                .collect();\n            config.routes = routes;\n        }\n    }\n    fn prepare_tun_config_for_custom_dns(&self, config: &mut TunConfig) {\n        if let Some(custom_dns_servers) = self.custom_dns_servers.clone() {\n            config.dns_servers = custom_dns_servers;\n        }\n    }\n    pub fn bypass(&mut self, socket: RawFd) -> Result<(), Error> {\n        let env = JnixEnv::from(\n            self.jvm\n                .attach_current_thread_as_daemon()\n                .map_err(Error::AttachJvmToThread)?,\n        );\n        let create_tun_method = env\n            .get_method_id(&self.class, \"bypass\", \"(I)Z\")\n            .map_err(|cause| Error::FindMethod(\"bypass\", cause))?;\n        let result = env\n            .call_method_unchecked(\n                self.object.as_obj(),\n                create_tun_method,\n                JavaType::Primitive(Primitive::Boolean),\n                &[JValue::Int(socket)],\n            )\n            .map_err(|cause| Error::CallMethod(\"bypass\", cause))?;\n        match result {\n            JValue::Bool(0) => Err(Error::Bypass),\n            JValue::Bool(_) => Ok(()),\n            value => Err(Error::InvalidMethodResult(\"bypass\", format!(\"{:?}\", value))),\n        }\n    }\n    fn call_method(\n        &self,\n        name: &'static str,\n        signature: &str,\n        return_type: JavaType,\n        parameters: &[JValue<'_>],\n    ) -> Result<JValue<'_>, Error> {\n        let env = JnixEnv::from(\n            self.jvm\n                .attach_current_thread_as_daemon()\n                .map_err(Error::AttachJvmToThread)?,\n        );\n        let method_id = env\n            .get_method_id(&self.class, name, signature)\n            .map_err(|cause| Error::FindMethod(name, cause))?;\n        env.call_method_unchecked(self.object.as_obj(), method_id, return_type, parameters)\n            .map_err(|cause| Error::CallMethod(name, cause))\n    }\n    fn env(&self) -> Result<JnixEnv<'_>, Error> {\n        let jni_env = self\n            .jvm\n            .attach_current_thread_as_daemon()\n            .map_err(Error::AttachJvmToThread)?;\n        Ok(JnixEnv::from(jni_env))\n    }\n}\nfn maybe_set_dummy_dns_servers(config: &mut TunConfig) {\n    if !config.dns_servers.is_empty() {\n        return;\n    }\n    config.dns_servers = vec![\"192.0.2.1\".parse().unwrap()];\n}\npub struct VpnServiceTun {\n    tunnel: RawFd,\n    jvm: JavaVM,\n    class: GlobalRef,\n    object: GlobalRef,\n}\nimpl VpnServiceTun {\n    pub fn interface_name(&self) -> &str {\n        \"tun\"\n    }\n    pub fn bypass(&mut self, socket: RawFd) -> Result<(), Error> {\n        let env = JnixEnv::from(\n            self.jvm\n                .attach_current_thread_as_daemon()\n                .map_err(Error::AttachJvmToThread)?,\n        );\n        let create_tun_method = env\n            .get_method_id(&self.class, \"bypass\", \"(I)Z\")\n            .map_err(|cause| Error::FindMethod(\"bypass\", cause))?;\n        let result = env\n            .call_method_unchecked(\n                self.object.as_obj(),\n                create_tun_method,\n                JavaType::Primitive(Primitive::Boolean),\n                &[JValue::Int(socket)],\n            )\n            .map_err(|cause| Error::CallMethod(\"bypass\", cause))?;\n        if !bool::from_java(&env, result) {\n            return Err(Error::Bypass);\n        }\n        Ok(())\n    }\n}\nimpl AsRawFd for VpnServiceTun {\n    fn as_raw_fd(&self) -> RawFd {\n        self.tunnel\n    }\n}\nimpl Default for TunConfig {\n    fn default() -> Self {\n        TunConfig {\n            addresses: vec![IpAddr::V4(Ipv4Addr::new(10, 0, 0, 1))],\n            dns_servers: Vec::new(),\n            routes: vec![\n                IpNetwork::new(IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0)), 0)\n                    .expect(\"Invalid IP network prefix for IPv4 address\"),\n                IpNetwork::new(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), 0)\n                    .expect(\"Invalid IP network prefix for IPv6 address\"),\n            ],\n            required_routes: vec![],\n            mtu: 1380,\n        }\n    }\n}\n#[derive(FromJava)]\n#[jnix(package = \"net.mullvad.talpid\")]\nenum CreateTunResult {\n    Success { tun_fd: i32 },\n    InvalidDnsServers { addresses: Vec<IpAddr> },\n    PermissionDenied,\n    TunnelDeviceError,\n}\nimpl From<CreateTunResult> for Result<RawFd, Error> {\n    fn from(result: CreateTunResult) -> Self {\n        match result {\n            CreateTunResult::Success { tun_fd } => Ok(tun_fd),\n            CreateTunResult::InvalidDnsServers { addresses } => {\n                Err(Error::InvalidDnsServers(addresses))\n            }\n            CreateTunResult::PermissionDenied => Err(Error::PermissionDenied),\n            CreateTunResult::TunnelDeviceError => Err(Error::TunnelDeviceError),\n        }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "public static int decompress(\n            final Object inputBase,\n            final long inputAddress,\n            final long inputLimit,\n            final Object outputBase,\n            final long outputAddress,\n            final long outputLimit)\n            throws MalformedInputException\n    {\n        if (inputAddress == inputLimit) {\n            return 0;\n        }\n        final long fastOutputLimit = outputLimit - SIZE_OF_LONG;\n        long input = inputAddress;\n        long output = outputAddress;\n        while (input < inputLimit) {\n            boolean firstCommand = true;\n            int lastLiteralLength = 0;\n            while (true) {\n                if (input >= inputLimit) {\n                    throw new MalformedInputException(input - inputAddress);\n                }\n                int command = UNSAFE.getByte(inputBase, input++) & 0xFF;\n                int matchLength;\n                int matchOffset;\n                int literalLength;\n                if ((command & 0b1111_0000) == 0b0000_0000) {\n                    if (lastLiteralLength == 0) {\n                        matchOffset = 0;\n                        matchLength = 0;\n                        literalLength = command & 0b1111;\n                        if (literalLength == 0) {\n                            literalLength = 0b1111;\n                            int nextByte = 0;\n                            while (input < inputLimit && (nextByte = UNSAFE.getByte(inputBase, input++) & 0xFF) == 0) {\n                                literalLength += 0b1111_1111;\n                            }\n                            literalLength += nextByte;\n                        }\n                        literalLength += 3;\n                    }\n                    else if (lastLiteralLength <= 3) {\n                        matchLength = 2;\n                        if (input >= inputLimit) {\n                            throw new MalformedInputException(input - inputAddress);\n                        }\n                        matchOffset = (command & 0b1100) >>> 2;\n                        matchOffset |= (UNSAFE.getByte(inputBase, input++) & 0xFF) << 2;\n                        literalLength = (command & 0b0000_0011);\n                    }\n                    else {\n                        matchLength = 3;\n                        if (input >= inputLimit) {\n                            throw new MalformedInputException(input - inputAddress);\n                        }\n                        matchOffset = (command & 0b1100) >>> 2;\n                        matchOffset |= (UNSAFE.getByte(inputBase, input++) & 0xFF) << 2;\n                        matchOffset |= 0b1000_0000_0000;\n                        literalLength = (command & 0b0000_0011);\n                    }\n                }\n                else if (firstCommand) {\n                    matchLength = 0;\n                    matchOffset = 0;\n                    literalLength = command - 17;\n                }\n                else if ((command & 0b1111_0000) == 0b0001_0000) {\n                    matchLength = command & 0b111;\n                    if (matchLength == 0) {\n                        matchLength = 0b111;\n                        int nextByte = 0;\n                        while (input < inputLimit && (nextByte = UNSAFE.getByte(inputBase, input++) & 0xFF) == 0) {\n                            matchLength += 0b1111_1111;\n                        }\n                        matchLength += nextByte;\n                    }\n                    matchLength += 2;\n                    if (input + SIZE_OF_SHORT > inputLimit) {\n                        throw new MalformedInputException(input - inputAddress);\n                    }\n                    int trailer = UNSAFE.getShort(inputBase, input) & 0xFFFF;\n                    input += SIZE_OF_SHORT;\n                    matchOffset = (command & 0b1000) << 11;\n                    matchOffset += trailer >> 2;\n                    if (matchOffset == 0) {\n                        break;\n                    }\n                    matchOffset += 0b11_1111_1111_1111;\n                    literalLength = trailer & 0b11;\n                }\n                else if ((command & 0b1110_0000) == 0b0010_0000) {\n                    matchLength = command & 0b1_1111;\n                    if (matchLength == 0) {\n                        matchLength = 0b1_1111;\n                        int nextByte = 0;\n                        while (input < inputLimit && (nextByte = UNSAFE.getByte(inputBase, input++) & 0xFF) == 0) {\n                            matchLength += 0b1111_1111;\n                        }\n                        matchLength += nextByte;\n                    }\n                    matchLength += 2;\n                    if (input + SIZE_OF_SHORT > inputLimit) {\n                        throw new MalformedInputException(input - inputAddress);\n                    }\n                    int trailer = UNSAFE.getShort(inputBase, input) & 0xFFFF;\n                    input += SIZE_OF_SHORT;\n                    matchOffset = trailer >>> 2;\n                    literalLength = trailer & 0b11;\n                }\n                else if ((command & 0b1100_0000) != 0) {\n                    matchLength = (command & 0b1110_0000) >>> 5;\n                    matchLength += 1;\n                    if (input >= inputLimit) {\n                        throw new MalformedInputException(input - inputAddress);\n                    }\n                    matchOffset = (command & 0b0001_1100) >>> 2;\n                    matchOffset |= (UNSAFE.getByte(inputBase, input++) & 0xFF) << 3;\n                    literalLength = (command & 0b0000_0011);\n                }\n                else {\n                    String binary = toBinary(command);\n                    throw new MalformedInputException(input - 1, \"Invalid LZO command \" + binary);\n                }\n                firstCommand = false;\n                if (matchLength < 0) {\n                    throw new MalformedInputException(input - inputAddress);\n                }\n                if (matchLength != 0) {\n                    matchOffset++;\n                    long matchAddress = output - matchOffset;\n                    if (matchAddress < outputAddress || output + matchLength > outputLimit) {\n                        throw new MalformedInputException(input - inputAddress);\n                    }\n                    long matchOutputLimit = output + matchLength;\n                    if (output > fastOutputLimit) {\n                        while (output < matchOutputLimit) {\n                            UNSAFE.putByte(outputBase, output++, UNSAFE.getByte(outputBase, matchAddress++));\n                        }\n                    }\n                    else {\n                        if (matchOffset < SIZE_OF_LONG) {\n                            int increment32 = DEC_32_TABLE[matchOffset];\n                            int decrement64 = DEC_64_TABLE[matchOffset];\n                            UNSAFE.putByte(outputBase, output, UNSAFE.getByte(outputBase, matchAddress));\n                            UNSAFE.putByte(outputBase, output + 1, UNSAFE.getByte(outputBase, matchAddress + 1));\n                            UNSAFE.putByte(outputBase, output + 2, UNSAFE.getByte(outputBase, matchAddress + 2));\n                            UNSAFE.putByte(outputBase, output + 3, UNSAFE.getByte(outputBase, matchAddress + 3));\n                            output += SIZE_OF_INT;\n                            matchAddress += increment32;\n                            UNSAFE.putInt(outputBase, output, UNSAFE.getInt(outputBase, matchAddress));\n                            output += SIZE_OF_INT;\n                            matchAddress -= decrement64;\n                        }\n                        else {\n                            UNSAFE.putLong(outputBase, output, UNSAFE.getLong(outputBase, matchAddress));\n                            matchAddress += SIZE_OF_LONG;\n                            output += SIZE_OF_LONG;\n                        }\n                        if (matchOutputLimit >= fastOutputLimit) {\n                            if (matchOutputLimit > outputLimit) {\n                                throw new MalformedInputException(input - inputAddress);\n                            }\n                            while (output < fastOutputLimit) {\n                                UNSAFE.putLong(outputBase, output, UNSAFE.getLong(outputBase, matchAddress));\n                                matchAddress += SIZE_OF_LONG;\n                                output += SIZE_OF_LONG;\n                            }\n                            while (output < matchOutputLimit) {\n                                UNSAFE.putByte(outputBase, output++, UNSAFE.getByte(outputBase, matchAddress++));\n                            }\n                        }\n                        else {\n                            while (output < matchOutputLimit) {\n                                UNSAFE.putLong(outputBase, output, UNSAFE.getLong(outputBase, matchAddress));\n                                matchAddress += SIZE_OF_LONG;\n                                output += SIZE_OF_LONG;\n                            }\n                        }\n                    }\n                    output = matchOutputLimit; \n                }\n                if (literalLength < 0) {\n                    throw new MalformedInputException(input - inputAddress);\n                }\n                long literalOutputLimit = output + literalLength;\n                if (literalOutputLimit > fastOutputLimit || input + literalLength > inputLimit - SIZE_OF_LONG) {\n                    if (literalOutputLimit > outputLimit || input + literalLength > inputLimit) {\n                        throw new MalformedInputException(input - inputAddress);\n                    }\n                    UNSAFE.copyMemory(inputBase, input, outputBase, output, literalLength);\n                    input += literalLength;\n                    output += literalLength;\n                }\n                else {\n                    do {\n                        UNSAFE.putLong(outputBase, output, UNSAFE.getLong(inputBase, input));\n                        input += SIZE_OF_LONG;\n                        output += SIZE_OF_LONG;\n                    }\n                    while (output < literalOutputLimit);\n                    input -= (output - literalOutputLimit); \n                    output = literalOutputLimit;\n                }\n                lastLiteralLength = literalLength;\n            }\n        }\n        return (int) (output - outputAddress);\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "  async fn download_inner(\n    &self,\n    url: impl reqwest::IntoUrl,\n    maybe_header: Option<(HeaderName, HeaderValue)>,\n    progress_guard: Option<&UpdateGuard>,\n  ) -> Result<Option<Vec<u8>>, DownloadError> {\n    let response = self.get_redirected_response(url, maybe_header).await?;\n    if response.status() == 404 {\n      return Ok(None);\n    } else if !response.status().is_success() {\n      let status = response.status();\n      let maybe_response_text = response.text().await.ok();\n      return Err(DownloadError::BadResponse(BadResponseError {\n        status_code: status,\n        response_text: maybe_response_text\n          .map(|s| s.trim().to_string())\n          .filter(|s| !s.is_empty()),\n      }));\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "async fn main() -> Result<()> {\n    setup_logger().unwrap_or_default();\n    let args: Args = Args::parse();\n    match args.subcommand {\n        Commands::Run {\n            http_port,\n            http_host,\n            telnet_port,\n            telnet_host,\n            cloudflare_support,\n            read_bearer_token_from_stdin\n        } => {\n            let bearer_token = {\n                let mut buf = String::new();\n                stdin().read_line(&mut buf).expect(\"failed to read from stdin\");\n                buf.trim_end().to_string()\n            };\n            WRITE_TOKEN.set(bearer_token).unwrap();\n            let http_server = HttpServer::new(move || {\n                let logger_format = if cloudflare_support {\n                    r#\"%a (CF '%{CF-Connecting-IP}i') %t \"%r\" %s \"%{Referer}i\" \"%{User-Agent}i\" \"#\n                } else {\n                    r#\"%a %t \"%r\" %s \"%{Referer}i\" \"%{User-Agent}i\" \"#\n                };\n                App::new()\n                    .service(prefixed_service(\"/api\")\n                        .service(\n                            (\n                                prefixed_service(\"/article\")\n                                    .service(\n                                        (\n                                            article::create,\n                                            article::fetch,\n                                            article::update,\n                                            article::remove,\n                                        )\n                                    ),\n                                article::list,\n                                prefixed_service(\"/meta\")\n                                    .service(meta::change_id)\n                            )\n                        )\n                    )\n                    .app_data(\n                        BearerAuthConfig::default()\n                            .realm(\"Perform write operation\")\n                            .scope(\"article:write\"),\n                    )\n                    .wrap(Logger::new(logger_format))\n                    .wrap(cors_middleware_factory())\n            });\n        tokio::spawn({\n            Server::build()\n                .bind(\"echo\", (telnet_host, telnet_port), move || {\n                    fn_service(move |stream: TcpStream| {\n                        telnet_server_service(stream)\n                    })\n                })?\n                .run()\n        });\n        http_server\n                    .bind((http_host, http_port))?\n                    .run()\n                    .await\n                    .context(\"while running server\")?;\n                Ok(())\n            }\n        Commands::Import { file_path, article_id } => {\n            if !file_path.exists() {\n                bail!(\"You can not import non-existent file\")\n            }\n            if !file_path.is_file() {\n                debug!(\"is_dir: {}\", file_path.is_dir());\n                debug!(\"is_symlink: {}\", file_path.is_symlink());\n                debug!(\"metadata: {:?}\", file_path.metadata()?);\n                bail!(\"Non-file paths are not supported\")\n            }\n            let content = {\n                let mut fd = BufReader::new(File::open(file_path)?);\n                let mut buf = vec![];\n                fd.read_to_end(&mut buf)?;\n                String::from_utf8(buf)\n            };\n            match content {\n                Ok(content) => {\n                    GLOBAL_FILE.create_entry(&article_id, content).await?;\n                    info!(\"Successfully imported as {article_id}.\");\n                    Ok(())\n                }\n                Err(err) => {\n                    bail!(\"The file is not UTF-8: {err}\\\n                    Please review following list:\\\n                    - The file is not binary\\\n                    - The text is encoded with UTF-8\\\n                    Especially, importing Shift-JIS texts are NOT supported.\")\n                }\n            }\n        }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "use crate::carrier::Carrier;\nuse crate::consts;\nuse crate::country;\nuse crate::error;\nuse crate::extension::Extension;\nuse crate::metadata::{Database, DATABASE};\nuse crate::national_number::NationalNumber;\nuse crate::phone_number::{PhoneNumber, Type};\nuse crate::validator::{self, Validation};\nuse nom::{branch::alt, IResult};\n#[macro_use]\npub mod helper;\npub mod natural;\npub mod rfc3966;\npub mod valid;\npub fn parse<S: AsRef<str>>(\n    country: Option<country::Id>,\n    string: S,\n) -> Result<PhoneNumber, error::Parse> {\n    parse_with(&DATABASE, country, string)\n}\npub fn parse_with<S: AsRef<str>>(\n    database: &Database,\n    country: Option<country::Id>,\n    string: S,\n) -> Result<PhoneNumber, error::Parse> {\n    fn phone_number(i: &str) -> IResult<&str, helper::Number> {\n        parse! { i => alt((rfc3966::phone_number, natural::phone_number)) }\n    }\n    let (_, mut number) = phone_number(string.as_ref()).or(Err(error::Parse::NoNumber))?;\n    number = helper::country_code(database, country, number)?;\n    if let Some(meta) = country.and_then(|c| database.by_id(c.as_ref())) {\n        let mut potential = helper::national_number(meta, number.clone());\n        if let Some(prefix) = meta.national_prefix.as_ref() {\n            if potential.national.starts_with(prefix) {\n                potential.national = helper::trim(potential.national, prefix.len());\n            }\n        }\n        if validator::length(meta, &potential, Type::Unknown) != Validation::TooShort {\n            number = potential;\n        }\n    }\n    if number.national.len() < consts::MIN_LENGTH_FOR_NSN {\n        return Err(error::Parse::TooShortNsn);\n    }\n    if number.national.len() > consts::MAX_LENGTH_FOR_NSN {\n        return Err(error::Parse::TooLong);\n    }\n    Ok(PhoneNumber {\n        code: country::Code {\n            value: number.prefix.map(|p| p.parse()).unwrap_or(Ok(0))?,\n            source: number.country,\n        },\n        national: NationalNumber::new(\n            number.national.parse()?,\n            number.national.chars().take_while(|&c| c == '0').count() as u8,\n        ),\n        extension: number.extension.map(|s| Extension(s.into_owned())),\n        carrier: number.carrier.map(|s| Carrier(s.into_owned())),\n    })\n}\n#[cfg(test)]\nmod test {\n    use crate::country;\n    use crate::national_number::NationalNumber;\n    use crate::parser;\n    use crate::phone_number::PhoneNumber;\n    #[test]\n    fn parse() {\n        let mut number = PhoneNumber {\n            code: country::Code {\n                value: 64,\n                source: country::Source::Default,\n            },\n            national: NationalNumber::new(33316005, 0),\n            extension: None,\n            carrier: None,\n        };\n        number.code.source = country::Source::Default;\n        assert_eq!(\n            number,\n            parser::parse(Some(country::NZ), \"033316005\").unwrap()\n        );\n        assert_eq!(\n            number,\n            parser::parse(Some(country::NZ), \"33316005\").unwrap()\n        );\n        assert_eq!(\n            number,\n            parser::parse(Some(country::NZ), \"03-331 6005\").unwrap()\n        );\n        assert_eq!(\n            number,\n            parser::parse(Some(country::NZ), \"03 331 6005\").unwrap()\n        );\n        number.code.source = country::Source::Plus;\n        assert_eq!(\n            number,\n            parser::parse(Some(country::NZ), \"tel:03-331-6005;phone-context=+64\").unwrap()\n        );\n        assert_eq!(\n            number,\n            parser::parse(Some(country::NZ), \"tel:03-331-6005;phone-context=+64;a=%A1\").unwrap()\n        );\n        assert_eq!(\n            number,\n            parser::parse(\n                Some(country::NZ),\n                \"tel:03-331-6005;isub=12345;phone-context=+64\"\n            )\n            .unwrap()\n        );\n        assert_eq!(\n            number,\n            parser::parse(Some(country::NZ), \"tel:+64-3-331-6005;isub=12345\").unwrap()\n        );\n        assert_eq!(\n            number,\n            parser::parse(Some(country::NZ), \"03-331-6005;phone-context=+64\").unwrap()\n        );\n        number.code.source = country::Source::Idd;\n        assert_eq!(\n            number,\n            parser::parse(Some(country::NZ), \"0064 3 331 6005\").unwrap()\n        );\n        assert_eq!(\n            number,\n            parser::parse(Some(country::US), \"01164 3 331 6005\").unwrap()\n        );\n        number.code.source = country::Source::Plus;\n        assert_eq!(\n            number,\n            parser::parse(Some(country::US), \"+64 3 331 6005\").unwrap()\n        );\n        assert_eq!(\n            number,\n            parser::parse(Some(country::US), \"+01164 3 331 6005\").unwrap()\n        );\n        assert_eq!(\n            number,\n            parser::parse(Some(country::NZ), \"+0064 3 331 6005\").unwrap()\n        );\n        assert_eq!(\n            number,\n            parser::parse(Some(country::NZ), \"+ 00 64 3 331 6005\").unwrap()\n        );\n        let number = PhoneNumber {\n            code: country::Code {\n                value: 64,\n                source: country::Source::Number,\n            },\n            national: NationalNumber::new(64123456, 0),\n            extension: None,\n            carrier: None,\n        };\n        assert_eq!(\n            number,\n            parser::parse(Some(country::NZ), \"64(0)64123456\").unwrap()\n        );\n        assert_eq!(\n            PhoneNumber {\n                code: country::Code {\n                    value: 49,\n                    source: country::Source::Default,\n                },\n                national: NationalNumber::new(30123456, 0),\n                extension: None,\n                carrier: None,\n            },\n            parser::parse(Some(country::DE), \"301/23456\").unwrap()\n        );\n        assert_eq!(\n            PhoneNumber {\n                code: country::Code {\n                    value: 81,\n                    source: country::Source::Plus,\n                },\n                national: NationalNumber::new(2345, 0,),\n                extension: None,\n                carrier: None,\n            },\n            parser::parse(Some(country::JP), \"+81 *2345\").unwrap()\n        );\n        assert_eq!(\n            PhoneNumber {\n                code: country::Code {\n                    value: 64,\n                    source: country::Source::Default,\n                },\n                national: NationalNumber::new(12, 0,),\n                extension: None,\n                carrier: None,\n            },\n            parser::parse(Some(country::NZ), \"12\").unwrap()\n        );\n        assert_eq!(\n            PhoneNumber {\n                code: country::Code {\n                    value: 55,\n                    source: country::Source::Default,\n                },\n                national: NationalNumber::new(3121286979, 0),\n                extension: None,\n                carrier: Some(\"12\".into()),\n            },\n            parser::parse(Some(country::BR), \"012 3121286979\").unwrap()\n        );\n    }\n    #[test]\n    fn issue_43() {\n        let res = parser::parse(None, \" 2 22#:\");\n        assert!(res.is_err());\n    }\n    #[test]\n    fn advisory_1() {\n        let res = parser::parse(None, \".;phone-context=\");\n        assert!(res.is_err(), \"{res:?}\");\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "async fn assert_rcc_configuration(rcc_config: &RCCConfig) -> AnyhowResult<()> {\n    let mut rcc_config_diag_command = Command::new(&rcc_config.binary_path);\n    rcc_config_diag_command\n        .arg(\"configuration\")\n        .arg(\"diagnostics\");\n    let stdout = String::from_utf8(rcc_config_diag_command.output().await?.stdout)?;\n    assert!(stdout.contains(\"telemetry-enabled                     ...  \\\"false\\\"\"));\n    if let RCCProfileConfig::Custom(custom_rcc_profile_config) = &rcc_config.profile_config {\n        assert!(stdout.contains(&format!(\n            \"config-active-profile                 ...  \\\"{}\\\"\",\n            custom_rcc_profile_config.name\n        )));\n    }\n    Ok(())\n}\nasync fn assert_working_directory(\n    working_directory: &Utf8Path,\n    headed_user_name: &str,\n) -> AnyhowResult<()> {\n    assert_permissions(\n        &working_directory,\n        &format!(\"{headed_user_name}:(OI)(CI)(F)\"),\n    )\n    .await?;\n    assert!(working_directory.is_dir());\n    assert_eq!(\n        directory_entries(working_directory, 1),\n        [\"environment_building\", \"plans\", \"rcc_setup\"]\n    );\n    assert_eq!(\n        directory_entries(working_directory.join(\"rcc_setup\"), 1),\n        [\n            \"custom_profile_import_current_user.stderr\",\n            \"custom_profile_import_current_user.stdout\",\n            &format!(\"custom_profile_import_user_{headed_user_name}.bat\"),\n            &format!(\"custom_profile_import_user_{headed_user_name}.exit_code\"),\n            &format!(\"custom_profile_import_user_{headed_user_name}.stderr\"),\n            &format!(\"custom_profile_import_user_{headed_user_name}.stdout\"),\n            \"custom_profile_switch_current_user.stderr\",\n            \"custom_profile_switch_current_user.stdout\",\n            &format!(\"custom_profile_switch_user_{headed_user_name}.bat\"),\n            &format!(\"custom_profile_switch_user_{headed_user_name}.exit_code\"),\n            &format!(\"custom_profile_switch_user_{headed_user_name}.stderr\"),\n            &format!(\"custom_profile_switch_user_{headed_user_name}.stdout\"),\n            \"holotree_initialization_current_user.stderr\",\n            \"holotree_initialization_current_user.stdout\",\n            &format!(\"holotree_initialization_user_{headed_user_name}.bat\"),\n            &format!(\"holotree_initialization_user_{headed_user_name}.exit_code\"),\n            &format!(\"holotree_initialization_user_{headed_user_name}.stderr\"),\n            &format!(\"holotree_initialization_user_{headed_user_name}.stdout\"),\n            \"long_path_support_enabling.stderr\",\n            \"long_path_support_enabling.stdout\",\n            \"telemetry_disabling_current_user.stderr\",\n            \"telemetry_disabling_current_user.stdout\",\n            &format!(\"telemetry_disabling_user_{headed_user_name}.bat\"),\n            &format!(\"telemetry_disabling_user_{headed_user_name}.exit_code\"),\n            &format!(\"telemetry_disabling_user_{headed_user_name}.stderr\"),\n            &format!(\"telemetry_disabling_user_{headed_user_name}.stdout\")\n        ]\n    );\n    assert_eq!(\n        directory_entries(working_directory.join(\"environment_building\"), 1),\n        [\n            \"rcc_headed.bat\",\n            \"rcc_headed.exit_code\",\n            \"rcc_headed.stderr\",\n            \"rcc_headed.stdout\",\n            \"rcc_headless.stderr\",\n            \"rcc_headless.stdout\"\n        ]\n    );\n    assert_eq!(\n        directory_entries(working_directory.join(\"plans\"), 1),\n        [\"no_rcc\", \"rcc_headed\", \"rcc_headless\"]\n    );\n    assert!(!directory_entries(working_directory.join(\"plans\").join(\"no_rcc\"), 1).is_empty());\n    let entries_rcc_headed =\n        directory_entries(working_directory.join(\"plans\").join(\"rcc_headed\"), 2).join(\"\");\n    assert!(entries_rcc_headed.contains(\"rebot.xml\"));\n    assert!(entries_rcc_headed.contains(\"1.bat\"));\n    let entries_rcc_headless =\n        directory_entries(working_directory.join(\"plans\").join(\"rcc_headless\"), 2).join(\"\");\n    assert!(entries_rcc_headless.contains(\"rebot.xml\"));\n    assert!(!entries_rcc_headless.contains(\"1.bat\"));\n    Ok(())\n}\nfn rcc_setup(\n    global_config: &GlobalConfig,\n    rcc_plans: Vec<Plan>,\n    rcc_setup_failures: &mut RCCSetupFailures,\n) -> AnyhowResult<Vec<Plan>> {\n    let mut sucessful_plans: Vec<Plan>;\n    debug!(\"Disabling RCC telemetry\");\n    (sucessful_plans, rcc_setup_failures.telemetry_disabling) =\n        disable_rcc_telemetry(global_config, rcc_plans)\n            .context(\"Received termination signal while disabling RCC telemetry\")?;\n    if !rcc_setup_failures.telemetry_disabling.is_empty() {\n        error!(\n            \"Dropping the following plans due to RCC telemetry disabling failure: {}\",\n            failed_plan_ids_human_readable(rcc_setup_failures.telemetry_disabling.keys())\n        );\n    }\n    debug!(\"Configuring RCC profile\");\n    (sucessful_plans, rcc_setup_failures.profile_configuring) =\n        configure_rcc_profile(global_config, sucessful_plans)\n            .context(\"Received termination signal while configuring RCC profile\")?;\n    if !rcc_setup_failures.profile_configuring.is_empty() {\n        error!(\n            \"Dropping the following plans due to profile configuring failure: {}\",\n            failed_plan_ids_human_readable(rcc_setup_failures.profile_configuring.keys())\n        );\n    }\n    debug!(\"Enabling support for long paths\");\n    (sucessful_plans, rcc_setup_failures.long_path_support) =\n        enable_long_path_support(global_config, sucessful_plans)\n            .context(\"Received termination signal while enabling support for long paths\")?;\n    if !rcc_setup_failures.long_path_support.is_empty() {\n        error!(\n            \"Dropping the following plans due to long path support enabling failure: {}\",\n            failed_plan_ids_human_readable(rcc_setup_failures.long_path_support.keys())\n        );\n    }\n    debug!(\"Initializing holotree\");\n    (sucessful_plans, rcc_setup_failures.holotree_init) =\n        holotree_init(global_config, sucessful_plans)\n            .context(\"Received termination signal while initializing holotree\")?;\n    if !rcc_setup_failures.holotree_init.is_empty() {\n        error!(\n            \"Dropping the following plans due to holotree initialization failure: {}\",\n            failed_plan_ids_human_readable(rcc_setup_failures.holotree_init.keys())\n        );\n    }\n    Ok(sucessful_plans)\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn is_verified(&self) -> bool {\n        self.own_identity.as_ref().is_some_and(|own_identity| {\n            own_identity.is_verified() && own_identity.is_identity_signed(&self.inner).is_ok()\n        })\n    }\n",
    "output": "fixed"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn sift_up(&mut self, start: usize, mut pos: usize) {\n        unsafe {\n            let new = replace(&mut self.data[pos], zeroed());\n            while pos > start {\n                let parent = (pos - 1) >> 1;\n                if new <= self.data[parent] { break; }\n                let x = replace(&mut self.data[parent], zeroed());\n                ptr::write(&mut self.data[pos], x);\n                pos = parent;\n            }\n            ptr::write(&mut self.data[pos], new);\n        }\n    }\nfn sift_down_range(&mut self, mut pos: usize, end: usize) {\n        unsafe {\n            let start = pos;\n            let new = replace(&mut self.data[pos], zeroed());\n            let mut child = 2 * pos + 1;\n            while child < end {\n                let right = child + 1;\n                if right < end && !(self.data[child] > self.data[right]) {\n                    child = right;\n                }\n                let x = replace(&mut self.data[child], zeroed());\n                ptr::write(&mut self.data[pos], x);\n                pos = child;\n                child = 2 * pos + 1;\n            }\n            ptr::write(&mut self.data[pos], new);\n            self.sift_up(start, pos);\n        }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "_WM_ParseNewMus(uint8_t *mus_data, uint32_t mus_size) {\n    uint8_t mus_hdr[] = { 'M', 'U', 'S', 0x1A };\n    uint32_t mus_song_ofs = 0;\n    uint32_t mus_song_len = 0;\n    uint16_t mus_ch_cnt1 = 0;\n    uint16_t mus_ch_cnt2 = 0;\n    uint16_t mus_no_instr = 0;\n    uint32_t mus_data_ofs = 0;\n    uint16_t * mus_mid_instr = NULL;\n    uint16_t mus_instr_cnt = 0;\n    struct _mdi *mus_mdi;\n    uint32_t mus_divisions = 60;\n    float tempo_f = 0.0;\n    uint16_t mus_freq = 0;\n    float samples_per_tick_f = 0.0;\n    uint8_t mus_event[] = { 0, 0, 0, 0 };\n    uint8_t mus_event_size = 0;\n    uint8_t mus_prev_vol[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n    uint32_t setup_ret = 0;\n    uint32_t mus_ticks = 0;\n    uint32_t sample_count = 0;\n    float sample_count_f = 0.0;\n    float sample_remainder = 0.0;\n    uint16_t pitchbend_tmp = 0;\n    if (mus_size < 17) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_MUS, \"File too short\", 0);\n        return NULL;\n    }\n    if (memcmp(mus_data, mus_hdr, 4)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_MUS, NULL, 0);\n        return NULL;\n    }\n    // Get Song Length\n    mus_song_len = (mus_data[5] << 8) | mus_data[4];\n    // Get Song Offset\n    mus_song_ofs = (mus_data[7] << 8) | mus_data[6];\n    // Have yet to determine what this actually is.\n    mus_ch_cnt1 = (mus_data[9] << 8) | mus_data[8];\n    mus_ch_cnt2 = (mus_data[11] << 8) | mus_data[10];\n    UNUSED(mus_ch_cnt1);\n    UNUSED(mus_ch_cnt2);\n    // Number of instruments defined\n    mus_no_instr = (mus_data[13] << 8) | mus_data[12];\n    // Skip next 2 data bytes\n    mus_data_ofs = 16;\n    // Check that we have enough data to check the rest\n    if (mus_size < (mus_data_ofs + (mus_no_instr << 1) + mus_song_len)) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_MUS, \"File too short\", 0);\n        return NULL;\n    }\n    // Instrument definition\n    mus_mid_instr = malloc(mus_no_instr * sizeof(uint16_t));\n    for (mus_instr_cnt = 0; mus_instr_cnt < mus_no_instr; mus_instr_cnt++) {\n        mus_mid_instr[mus_instr_cnt] = (mus_data[mus_data_ofs + 1] << 8) | mus_data[mus_data_ofs];\n        mus_data_ofs += 2;\n    }\n    // make sure we are at song offset\n    mus_data_ofs = mus_song_ofs;\n    // do some calculations so we know how many samples per mus tick\n    mus_freq = _cvt_get_option(WM_CO_FREQUENCY);\n    if (mus_freq == 0) mus_freq = 140;\n    if ((_WM_MixerOptions & WM_MO_ROUNDTEMPO)) {\n        tempo_f = (float) (60000000 / mus_freq) + 0.5f;\n    } else {\n        tempo_f = (float) (60000000 / mus_freq);\n    }\n    samples_per_tick_f = _WM_GetSamplesPerTick(mus_divisions, (uint32_t)tempo_f);\n    // initialise the mdi structure\n    mus_mdi = _WM_initMDI();\n    _WM_midi_setup_divisions(mus_mdi, mus_divisions);\n    _WM_midi_setup_tempo(mus_mdi, (uint32_t)tempo_f);\n    // lets do this\n    do {\n        // Build the event\n    _mus_build_event:\n#if 1\n        // Mus drums happen on channel 15, swap channel 9 & 15\n        // DEBUG\n        MUS_EVENT_DEBUG(\"Before\", mus_data[mus_data_ofs], 0);\n        if ((mus_data[mus_data_ofs] & 0x0f) == 0x0f) {\n            mus_data[mus_data_ofs] = (mus_data[mus_data_ofs] & 0xf0) | 0x09;\n        } else if ((mus_data[mus_data_ofs] & 0x0f) == 0x09) {\n            mus_data[mus_data_ofs] = (mus_data[mus_data_ofs] & 0xf0) | 0x0f;\n        }\n        // DEBUG\n        MUS_EVENT_DEBUG(\"After\", mus_data[mus_data_ofs], 0);\n#endif\n        switch ((mus_data[mus_data_ofs] >> 4) & 0x07) {\n            case 0: // Note Off\n                mus_event_size = 2;\n                mus_event[0] = 0x80 | (mus_data[mus_data_ofs] & 0x0f);\n                mus_event[1] = mus_data[mus_data_ofs + 1];\n                mus_event[2] = 0;\n                mus_event[3] = 0;\n                break;\n            case 1: // Note On\n                if (mus_data[mus_data_ofs + 1] & 0x80) {\n                    mus_event_size = 3;\n                    mus_event[0] = 0x90 | (mus_data[mus_data_ofs] & 0x0f);\n                    mus_event[1] = mus_data[mus_data_ofs + 1] & 0x7f;\n                    mus_event[2] = mus_data[mus_data_ofs + 2];\n                    mus_event[3] = 0;\n                    mus_prev_vol[mus_data[mus_data_ofs] & 0x0f] = mus_event[2];\n                } else {\n                    mus_event_size = 2;\n                    mus_event[0] = 0x90 | (mus_data[mus_data_ofs] & 0x0f);\n                    mus_event[1] = mus_data[mus_data_ofs + 1];\n                    mus_event[2] = mus_prev_vol[mus_data[mus_data_ofs] & 0x0f];\n                    mus_event[3] = 0;\n                }\n                break;\n            case 2: // Pitch Bend\n                mus_event_size = 2;\n                mus_event[0] = 0xe0 | (mus_data[mus_data_ofs] & 0x0f);\n                pitchbend_tmp = mus_data[mus_data_ofs + 1] << 6;\n                mus_event[1] = pitchbend_tmp & 0x7f;\n                mus_event[2] = (pitchbend_tmp >> 7) & 0x7f;\n                mus_event[3] = 0;\n                break;\n            case 3:\n                mus_event_size = 2;\n                switch (mus_data[mus_data_ofs + 1]) {\n                    case 10: // All Sounds Off\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 120;\n                        mus_event[2] = 0;\n                        mus_event[3] = 0;\n                        break;\n                    case 11: // All Notes Off\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 123;\n                        mus_event[2] = 0;\n                        mus_event[3] = 0;\n                        break;\n                    case 12: // Mono (Not supported by WildMIDI)\n                        /*\n                         **************************\n                         FIXME: Add dummy mdi event\n                         **************************\n                         */\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 126;\n                        mus_event[2] = 0;\n                        mus_event[3] = 0;\n                        break;\n                    case 13: // Poly (Not supported by WildMIDI)\n                        /*\n                         **************************\n                         FIXME: Add dummy mdi event\n                         **************************\n                         */\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 127;\n                        mus_event[2] = 0;\n                        mus_event[3] = 0;\n                        break;\n                    case 14: // Reset All Controllers\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 121;\n                        mus_event[2] = 0;\n                        mus_event[3] = 0;\n                        break;\n                    default: // Unsupported\n                        goto _mus_next_data;\n                }\n                break;\n            case 4:\n                mus_event_size = 3;\n                switch (mus_data[mus_data_ofs + 1]) {\n                    case 0: // Patch\n                        /*\n                         *************************************************\n                         FIXME: Check if setting is MIDI or MUS instrument\n                         *************************************************\n                         */\n                        mus_event[0] = 0xc0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = mus_data[mus_data_ofs + 2];\n                        mus_event[2] = 0;\n                        mus_event[3] = 0;\n                        break;\n                    case 1: // Bank Select\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 0;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 2: // Modulation (Not supported by WildMidi)\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 1;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 3: // Volume\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 7;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 4: // Pan\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 10;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 5: // Expression\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 11;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 6: // Reverb (Not supported by WildMidi)\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 91;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 7: // Chorus (Not supported by WildMidi)\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 93;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 8: // Sustain\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 64;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    case 9: // Soft Peddle (Not supported by WildMidi)\n                        mus_event[0] = 0xb0 | (mus_data[mus_data_ofs] & 0x0f);\n                        mus_event[1] = 67;\n                        mus_event[2] = mus_data[mus_data_ofs + 2];\n                        mus_event[3] = 0;\n                        break;\n                    default: // Unsupported\n                        goto _mus_next_data;\n                }\n                break;\n            case 5:\n                mus_event_size = 1;\n                goto _mus_next_data;\n                break;\n            case 6:\n                goto _mus_end_of_song;\n                break;\n            case 7:\n                mus_event_size = 1;\n                goto _mus_next_data;\n                break;\n        }\n        setup_ret = _WM_SetupMidiEvent(mus_mdi, (uint8_t *)mus_event, 0);\n        if (setup_ret == 0) {\n            goto _mus_end;\n        }\n    _mus_next_data:\n        if (!(mus_data[mus_data_ofs] & 0x80)) {\n            mus_data_ofs += mus_event_size;\n            goto _mus_build_event;\n        }\n        mus_data_ofs += mus_event_size;\n        mus_ticks = 0;\n        do {\n            mus_ticks = (mus_ticks << 7) | (mus_data[mus_data_ofs++] & 0x7f);\n        } while (mus_data[mus_data_ofs - 1] & 0x80);\n        sample_count_f = ((float)mus_ticks * samples_per_tick_f) + sample_remainder;\n        sample_count = (uint32_t)sample_count_f;\n        sample_remainder = sample_count_f - (float)sample_count;\n        mus_mdi->events[mus_mdi->event_count - 1].samples_to_next = sample_count;\n        mus_mdi->extra_info.approx_total_samples += sample_count;\n    } while (mus_data_ofs < mus_size);\n_mus_end_of_song:\n    // Finalise mdi structure\n    if ((mus_mdi->reverb = _WM_init_reverb(_WM_SampleRate, _WM_reverb_room_width, _WM_reverb_room_length, _WM_reverb_listen_posx, _WM_reverb_listen_posy)) == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, \"to init reverb\", 0);\n        goto _mus_end;\n    }\n    _WM_midi_setup_endoftrack(mus_mdi);\n    mus_mdi->extra_info.current_sample = 0;\n    mus_mdi->current_event = &mus_mdi->events[0];\n    mus_mdi->samples_to_mix = 0;\n    mus_mdi->note = NULL;\n    _WM_ResetToStart(mus_mdi);\n_mus_end:\n    free(mus_mid_instr);\n    if (mus_mdi->reverb) return (mus_mdi);\n    _WM_freeMDI(mus_mdi);\n    return NULL;\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "\tfn is_web_proxy_token_valid(&self, token: &str) -> bool;\n}\nimpl<F> WebProxyTokens for F where F: Fn(String) -> bool + Send + Sync {\n\tfn is_web_proxy_token_valid(&self, token: &str) -> bool { self(token.to_owned()) }\n}\nfn should_correctly_handle_long_label_when_splitted() {\n\tlet (server, fetch) = serve_with_fetch(\"xolrg9fePeQyKLnL\");\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET /styles.css?test=123 HTTP/1.1\\r\\n\\\n\t\t\tHost: f1qprwk775k6am35a5wmpk3e9gnpgx3me1sk.mbsfcdqpwx3jd5h7ax39dxq2wvb5dhqpww3fe9t2wrvfdm.web.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\tresponse.assert_status(\"HTTP/1.1 200 OK\");\n\tassert_security_headers_for_embed(&response.headers);\n\tfetch.assert_requested(\"https://contribution.melonport.com/styles.css?test=123\");\n\tfetch.assert_no_more_requests();\n}\nfn should_disallow_non_get_requests() {\n\tlet (server, fetch) = serve_with_fetch(\"token\");\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tPOST / HTTP/1.1\\r\\n\\\n\t\t\tHost: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\\r\\n\\\n\t\t\tContent-Type: application/json\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\t123\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\tresponse.assert_status(\"HTTP/1.1 405 Method Not Allowed\");\n\tassert_security_headers_for_embed(&response.headers);\n\tfetch.assert_no_more_requests();\n}\nfn should_fix_absolute_requests_based_on_referer() {\n\tlet (server, fetch) = serve_with_fetch(\"token\");\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET /styles.css HTTP/1.1\\r\\n\\\n\t\t\tHost: localhost:8080\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\tReferer: http://localhost:8080/web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\tresponse.assert_status(\"HTTP/1.1 302 Found\");\n\tresponse.assert_header(\"Location\", \"/web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/styles.css\");\n\tfetch.assert_no_more_requests();\n}\nfn should_fix_absolute_requests_based_on_referer_in_url() {\n\tlet (server, fetch) = serve_with_fetch(\"token\");\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET /styles.css HTTP/1.1\\r\\n\\\n\t\t\tHost: localhost:8080\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\tReferer: http://localhost:8080/?__referer=web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\tresponse.assert_status(\"HTTP/1.1 302 Found\");\n\tresponse.assert_header(\"Location\", \"/web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/styles.css\");\n\tfetch.assert_no_more_requests();\n}\nfn should_return_error_on_invalid_protocol() {\n\tlet (server, fetch) = serve_with_fetch(\"token\");\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET /web/token/ftp/parity.io/ HTTP/1.1\\r\\n\\\n\t\t\tHost: localhost:8080\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\tresponse.assert_status(\"HTTP/1.1 400 Bad Request\");\n\tassert_security_headers_for_embed(&response.headers);\n\tfetch.assert_no_more_requests();\n}\nfn should_return_error_on_invalid_token() {\n\tlet (server, fetch) = serve_with_fetch(\"test\");\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET / HTTP/1.1\\r\\n\\\n\t\t\tHost: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\tresponse.assert_status(\"HTTP/1.1 400 Bad Request\");\n\tassert_security_headers_for_embed(&response.headers);\n\tfetch.assert_no_more_requests();\n}\nfn should_stream_web_content() {\n\tlet (server, fetch) = serve_with_fetch(\"token\");\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET / HTTP/1.1\\r\\n\\\n\t\t\tHost: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\tresponse.assert_status(\"HTTP/1.1 200 OK\");\n\tassert_security_headers_for_embed(&response.headers);\n\tfetch.assert_requested(\"https://parity.io/\");\n\tfetch.assert_no_more_requests();\n}\nfn should_support_base32_encoded_web_urls() {\n\tlet (server, fetch) = serve_with_fetch(\"token\");\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET /styles.css?test=123 HTTP/1.1\\r\\n\\\n\t\t\tHost: EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY.web.web3.site\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\tresponse.assert_status(\"HTTP/1.1 200 OK\");\n\tassert_security_headers_for_embed(&response.headers);\n\tfetch.assert_requested(\"https://parity.io/styles.css?test=123\");\n\tfetch.assert_no_more_requests();\n}\nfn should_support_base32_encoded_web_urls_as_path() {\n\tlet (server, fetch) = serve_with_fetch(\"token\");\n\tlet response = request(server,\n\t\t\"\\\n\t\t\tGET /web/EHQPPSBE5DM78X3GECX2YBVGC5S6JX3S5SMPY/styles.css?test=123 HTTP/1.1\\r\\n\\\n\t\t\tHost: localhost:8080\\r\\n\\\n\t\t\tConnection: close\\r\\n\\\n\t\t\t\\r\\n\\\n\t\t\"\n\t);\n\tresponse.assert_status(\"HTTP/1.1 200 OK\");\n\tassert_security_headers_for_embed(&response.headers);\n\tfetch.assert_requested(\"https://parity.io/styles.css?test=123\");\n\tfetch.assert_no_more_requests();\n}\n\tfn extract_target_url(&self, url: Option<Url>) -> Result<String, State<F>> {\n\t\tlet token_and_url = self.path.app_params.get(0)\n\t\t\t.map(|encoded| encoded.replace('.', \"\"))\n\t\t\t.and_then(|encoded| base32::decode(base32::Alphabet::Crockford, &encoded.to_uppercase()))\n\t\t\t.and_then(|data| String::from_utf8(data).ok())\n\t\t\t.ok_or_else(|| State::Error(ContentHandler::error(\n\t\t\t\tStatusCode::BadRequest,\n\t\t\t\t\"Invalid parameter\",\n\t\t\t\t\"Couldn't parse given parameter:\",\n\t\t\t\tself.path.app_params.get(0).map(String::as_str),\n\t\t\t\tself.embeddable_on.clone()\n\t\t\t)))?;\n\t\tlet mut token_it = token_and_url.split('+');\n\t\tlet token = token_it.next();\n\t\tlet target_url = token_it.next();\n\t\tmatch token {\n\t\t\tSome(token) if self.web_proxy_tokens.is_web_proxy_token_valid(token) => {},\n\t\t\t_ => {\n\t\t\t\treturn Err(State::Error(ContentHandler::error(\n\t\t\t\t\tStatusCode::BadRequest, \"Invalid Access Token\", \"Invalid or old web proxy access token supplied.\", Some(\"Try refreshing the page.\"), self.embeddable_on.clone()\n\t\t\t\t)));\n\t\t\t}\n\t\t}\n\t\tlet mut target_url = match target_url {\n\t\t\tSome(url) if url.starts_with(\"http://\") || url.starts_with(\"https://\") => url.to_owned(),\n\t\t\t_ => {\n\t\t\t\treturn Err(State::Error(ContentHandler::error(\n\t\t\t\t\tStatusCode::BadRequest, \"Invalid Protocol\", \"Invalid protocol used.\", None, self.embeddable_on.clone()\n\t\t\t\t)));\n\t\t\t}\n\t\t};\n\t\tif !target_url.ends_with(\"/\") {\n\t\t\ttarget_url = format!(\"{}/\", target_url);\n\t\t}\n\t\tlet (path, query) = match (&url, self.path.using_dapps_domains) {\n\t\t\t(&Some(ref url), true) => (&url.path[..], &url.query),\n\t\t\t(&Some(ref url), false) => (&url.path[2..], &url.query),\n\t\t\t_ => {\n\t\t\t\treturn Err(State::Error(ContentHandler::error(\n\t\t\t\t\tStatusCode::BadRequest, \"Invalid URL\", \"Couldn't parse URL\", None, self.embeddable_on.clone()\n\t\t\t\t)));\n\t\t\t}\n\t\t};\n\t\tlet query = match *query {\n\t\t\tSome(ref query) => format!(\"?{}\", query),\n\t\t\tNone => \"\".into(),\n\t\t};\n\t\tOk(format!(\"{}{}{}\", target_url, path.join(\"/\"), query))\n\t}\n\tpub fn dapps_middleware(\n\t\tdeps: Dependencies,\n\t\tdapps_path: PathBuf,\n\t\textra_dapps: Vec<PathBuf>,\n\t\tdapps_domain: String,\n\t) -> Result<Middleware, String> {\n\t\tlet signer = deps.signer;\n\t\tlet parity_remote = parity_reactor::Remote::new(deps.remote.clone());\n\t\tlet web_proxy_tokens = Arc::new(move |token| signer.is_valid_web_proxy_access_token(&token));\n\t\tOk(parity_dapps::Middleware::dapps(\n\t\t\tparity_remote,\n\t\t\tdeps.ui_address,\n\t\t\tdapps_path,\n\t\t\textra_dapps,\n\t\t\tdapps_domain,\n\t\t\tdeps.contract_client,\n\t\t\tdeps.sync_status,\n\t\t\tweb_proxy_tokens,\n\t\t\tdeps.fetch,\n\t\t))\n\t}\n\tpub fn generate_web_proxy_access_token(&self) -> String {\n\t\tlet token = random_string(16);\n\t\tlet mut tokens = self.web_proxy_tokens.lock();\n\t\ttokens.prune();\n\t\ttokens.insert(token.clone(), ());\n\t\ttoken\n\t}\n\tpub fn is_valid_web_proxy_access_token(&self, token: &String) -> bool {\n\t\tself.web_proxy_tokens.lock().contains_key(&token)\n\t}\n\tfn generate_web_proxy_token(&self) -> Result<String, Error> {\n\t\tOk(self.signer.generate_web_proxy_access_token())\n\t}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn reserve(&mut self, additional: usize) {\n        let old_cap = self.cap();\n        let used_cap = self.len() + 1;\n        let new_cap = used_cap.checked_add(additional)\n            .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n            .expect(\"capacity overflow\");\n        if new_cap > self.capacity() {\n            self.buf.reserve_exact(used_cap, new_cap - used_cap);\n            unsafe {\n                self.handle_cap_increase(old_cap);\n            }\n        }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn repeat(&self, n: usize) -> Vec<T> where T: Copy {\n        if n == 0 {\n            return Vec::new();\n        }\n        let mut buf = Vec::with_capacity(self.len() * n);\n        buf.extend(self);\n        {\n            let mut m = n >> 1;\n            while m > 0 {\n                unsafe {\n                    ptr::copy_nonoverlapping(\n                        buf.as_ptr(),\n                        (buf.as_mut_ptr() as *mut T).add(buf.len()),\n                        buf.len(),\n                    );\n                    let buf_len = buf.len();\n                    buf.set_len(buf_len * 2);\n                }\n                m >>= 1;\n            }\n        }\n        let rem_len = self.len() * n - buf.len(); \n        if rem_len > 0 {\n            unsafe {\n                ptr::copy_nonoverlapping(\n                    buf.as_ptr(),\n                    (buf.as_mut_ptr() as *mut T).add(buf.len()),\n                    rem_len,\n                );\n                let buf_cap = buf.capacity();\n                buf.set_len(buf_cap);\n            }\n        }\n        buf\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub unsafe fn guarded_transmute_vec_permissive<T>(mut bytes: Vec<u8>) -> Vec<T> {\n    PermissiveGuard::check::<T>(&bytes).unwrap();\n    let ptr = bytes.as_mut_ptr();\n    let capacity = bytes.capacity() / size_of::<T>();\n    let len = bytes.len() / size_of::<T>();\n    forget(bytes);\n    Vec::from_raw_parts(ptr as *mut T, capacity, len)\n}\npub unsafe fn guarded_transmute_to_bytes_vec<T>(mut from: Vec<T>) -> Vec<u8> {\n    let capacity = from.capacity() * size_of::<T>();\n    let len = from.len() * size_of::<T>();\n    let ptr = from.as_mut_ptr();\n    forget(from);\n    Vec::from_raw_parts(ptr as *mut u8, capacity, len)\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn is_unique(&mut self) -> bool {\n        if self.inner().weak.compare_exchange(1, usize::MAX, Acquire, Relaxed).is_ok() {\n            let unique = self.inner().strong.load(Relaxed) == 1;\n            self.inner().weak.store(1, Release); \n            unique\n        } else {\n            false\n        }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn from_buf(buf: A) -> SmallVec<A> {\n        SmallVec {\n            capacity: A::size(),\n            data: SmallVecData::from_inline(buf),\n        }\n    }\npub unsafe fn from_buf_and_len_unchecked(buf: A, len: usize) -> SmallVec<A> {\n        SmallVec {\n            capacity: len,\n            data: SmallVecData::from_inline(buf),\n        }\n    }\nfn from_inline(inline: A) -> SmallVecData<A> {\n        SmallVecData { inline: ManuallyDrop::new(inline) }\n    }\npub fn from_slice(slice: &[A::Item]) -> Self {\n        let len = slice.len();\n        if len <= A::size() {\n            SmallVec {\n                capacity: len,\n                data: SmallVecData::from_inline(unsafe {\n                    let mut data: A = mem::uninitialized();\n                    ptr::copy_nonoverlapping(slice.as_ptr(), data.ptr_mut(), len);\n                    data\n                })\n            }\n        } else {\n            let mut b = slice.to_vec();\n            let (ptr, cap) = (b.as_mut_ptr(), b.capacity());\n            mem::forget(b);\n            SmallVec {\n                capacity: cap,\n                data: SmallVecData::from_heap(ptr, len),\n            }\n        }\n    }\npub fn from_vec(mut vec: Vec<A::Item>) -> SmallVec<A> {\n        if vec.capacity() <= A::size() {\n            unsafe {\n                let mut data = SmallVecData::<A>::from_inline(mem::uninitialized());\n                let len = vec.len();\n                vec.set_len(0);\n                ptr::copy_nonoverlapping(vec.as_ptr(), data.inline_mut().ptr_mut(), len);\n                SmallVec {\n                    capacity: len,\n                    data,\n                }\n            }\n        } else {\n            let (ptr, cap, len) = (vec.as_mut_ptr(), vec.capacity(), vec.len());\n            mem::forget(vec);\n            SmallVec {\n                capacity: cap,\n                data: SmallVecData::from_heap(ptr, len),\n            }\n        }\n    }\npub fn grow(&mut self, new_cap: usize) {\n        unsafe {\n            let (ptr, &mut len, cap) = self.triple_mut();\n            let unspilled = !self.spilled();\n            assert!(new_cap >= len);\n            if new_cap <= self.inline_size() {\n                if unspilled {\n                    return;\n                }\n                self.data = SmallVecData::from_inline(mem::uninitialized());\n                ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);\n                self.capacity = len;\n            } else if new_cap != cap {\n                let mut vec = Vec::with_capacity(new_cap);\n                let new_alloc = vec.as_mut_ptr();\n                mem::forget(vec);\n                ptr::copy_nonoverlapping(ptr, new_alloc, len);\n                self.data = SmallVecData::from_heap(new_alloc, len);\n                self.capacity = new_cap;\n                if unspilled {\n                    return;\n                }\n            } else {\n                return;\n            }\n            deallocate(ptr, cap);\n        }\n    }\nunsafe fn inline(&self) -> &A {\n        &self.inline\n    }\nunsafe fn inline_mut(&mut self) -> &mut A {\n        &mut self.inline\n    }\nunsafe fn into_inline(self) -> A { ManuallyDrop::into_inner(self.inline) }\npub fn into_inner(self) -> Result<A, Self> {\n        if self.spilled() || self.len() != A::size() {\n            Err(self)\n        } else {\n            unsafe {\n                let data = ptr::read(&self.data);\n                mem::forget(self);\n                Ok(data.into_inline())\n            }\n        }\n    }\npub fn new() -> SmallVec<A> {\n        unsafe {\n            SmallVec {\n                capacity: 0,\n                data: SmallVecData::from_inline(mem::uninitialized()),\n            }\n        }\n    }\npub fn shrink_to_fit(&mut self) {\n        if !self.spilled() {\n            return;\n        }\n        let len = self.len();\n        if self.inline_size() >= len {\n            unsafe {\n                let (ptr, len) = self.data.heap();\n                self.data = SmallVecData::from_inline(mem::uninitialized());\n                ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);\n                deallocate(ptr, self.capacity);\n                self.capacity = len;\n            }\n        } else if self.capacity() > len {\n            self.grow(len);\n        }\n    }\nfn triple(&self) -> (*const A::Item, usize, usize) {\n        unsafe {\n            if self.spilled() {\n                let (ptr, len) = self.data.heap();\n                (ptr, len, self.capacity)\n            } else {\n                (self.data.inline().ptr(), self.capacity, A::size())\n            }\n        }\n    }\nfn triple_mut(&mut self) -> (*mut A::Item, &mut usize, usize) {\n        unsafe {\n            if self.spilled() {\n                let &mut (ptr, ref mut len_ptr) = self.data.heap_mut();\n                (ptr, len_ptr, self.capacity)\n            } else {\n                (self.data.inline_mut().ptr_mut(), &mut self.capacity, A::size())\n            }\n        }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_tuple(\"Iter\")\n         .field(&self.ring)\n         .field(&self.tail)\n         .field(&self.head)\n         .finish()\n    }\nfn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_tuple(\"IterMut\")\n         .field(&self.ring)\n         .field(&self.tail)\n         .field(&self.head)\n         .finish()\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "    fn ready(&mut self, poll: &mut mio::Poll, ev: &mio::Event) {\n        if ev.readiness().is_readable() {\n            self.do_tls_read();\n            self.try_plain_read();\n            self.try_back_read();\n        }\n        if ev.readiness().is_writable() {\n            self.do_tls_write_and_handle_error();\n        }\n        if self.closing && !self.tls_session.wants_write() {\n            let _ = self.socket.shutdown(Shutdown::Both);\n            self.close_back();\n            self.closed = true;\n        } else {\n            self.reregister(poll);\n        }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn parse_short_str_(&mut self) -> Result<&'de str> {\n        let idx = self.iidx + 1;\n        let src: &[u8] = unsafe { &self.input.get_unchecked(idx..) };\n        #[allow(clippy::cast_ptr_alignment)]\n        let v: __m256i =\n            unsafe { _mm256_loadu_si256(src.get_unchecked(..32).as_ptr() as *const __m256i) };\n        let bs_bits: u32 = unsafe {\n            static_cast_u32!(_mm256_movemask_epi8(_mm256_cmpeq_epi8(\n                v,\n                _mm256_set1_epi8(b'\\\\' as i8)\n            )))\n        };\n        let quote_mask = unsafe { _mm256_cmpeq_epi8(v, _mm256_set1_epi8(b'\"' as i8)) };\n        let quote_bits = unsafe { static_cast_u32!(_mm256_movemask_epi8(quote_mask)) };\n        if (bs_bits.wrapping_sub(1) & quote_bits) != 0 {\n            let quote_dist: u32 = trailingzeroes(u64::from(quote_bits)) as u32;\n            self.str_offset = idx + quote_dist as usize;\n            unsafe {\n                let v = self.input.get_unchecked(idx..idx + quote_dist as usize) as *const [u8]\n                    as *const str;\n                Ok(&*v)\n            }\n        } else {\n            self.parse_str_()\n        }\n    }\nfn parse_str_(&mut self) -> Result<&'de str> {\n        use std::slice::from_raw_parts_mut;\n        let idx = self.iidx + 1;\n        let needs_relocation = idx - self.str_offset <= 32;\n        let dst: &mut [u8] = if needs_relocation {\n            &mut self.strings\n        } else {\n            let ptr = self.input.as_mut_ptr();\n            unsafe {\n                from_raw_parts_mut(ptr.add(self.str_offset), self.input.len() - self.str_offset)\n            }\n        };\n        let src: &[u8] = unsafe { &self.input.get_unchecked(idx..) };\n        let mut src_i: usize = 0;\n        let mut dst_i: usize = 0;\n        loop {\n            #[allow(clippy::cast_ptr_alignment)]\n            let v: __m256i =\n                unsafe { _mm256_loadu_si256(src.as_ptr().add(src_i) as *const __m256i) };\n            #[allow(clippy::cast_ptr_alignment)]\n            unsafe {\n                _mm256_storeu_si256(dst.as_mut_ptr().add(dst_i) as *mut __m256i, v)\n            };\n            let bs_bits: u32 = unsafe {\n                static_cast_u32!(_mm256_movemask_epi8(_mm256_cmpeq_epi8(\n                    v,\n                    _mm256_set1_epi8(b'\\\\' as i8)\n                )))\n            };\n            let quote_mask = unsafe { _mm256_cmpeq_epi8(v, _mm256_set1_epi8(b'\"' as i8)) };\n            let quote_bits = unsafe { static_cast_u32!(_mm256_movemask_epi8(quote_mask)) };\n            if (bs_bits.wrapping_sub(1) & quote_bits) != 0 {\n                let quote_dist: u32 = trailingzeroes(u64::from(quote_bits)) as u32;\n                dst_i += quote_dist as usize;\n                unsafe {\n                    if needs_relocation {\n                        self.input\n                            .get_unchecked_mut(self.str_offset..self.str_offset + dst_i as usize)\n                            .clone_from_slice(&self.strings.get_unchecked(..dst_i));\n                    }\n                    let v = self\n                        .input\n                        .get_unchecked(self.str_offset..self.str_offset + dst_i as usize)\n                        as *const [u8] as *const str;\n                    self.str_offset += dst_i as usize;\n                    return Ok(&*v);\n                }\n            }\n            if (quote_bits.wrapping_sub(1) & bs_bits) != 0 {\n                let bs_dist: u32 = trailingzeroes(u64::from(bs_bits));\n                let escape_char: u8 = unsafe { *src.get_unchecked(src_i + bs_dist as usize + 1) };\n                if escape_char == b'u' {\n                    // move src/dst up to the start; they will be further adjusted\n                    // within the unicode codepoint handling code.\n                    src_i += bs_dist as usize;\n                    dst_i += bs_dist as usize;\n                    let (o, s) = if let Ok(r) =\n                        handle_unicode_codepoint(unsafe { src.get_unchecked(src_i..) }, unsafe {\n                            dst.get_unchecked_mut(dst_i..)\n                        }) {\n                        r\n                    } else {\n                        return Err(self.error(ErrorType::InvlaidUnicodeCodepoint));\n                    };\n                    if o == 0 {\n                        return Err(self.error(ErrorType::InvlaidUnicodeCodepoint));\n                    };\n                    // We moved o steps forword at the destiation and 6 on the source\n                    src_i += s;\n                    dst_i += o;\n                } else {\n                    // simple 1:1 conversion. Will eat bs_dist+2 characters in input and\n                    // write bs_dist+1 characters to output\n                    // note this may reach beyond the part of the buffer we've actually\n                    let escape_result: u8 =\n                        unsafe { *ESCAPE_MAP.get_unchecked(escape_char as usize) };\n                    if escape_result == 0 {\n                        return Err(self.error(ErrorType::InvalidEscape));\n                    }\n                    unsafe {\n                        *dst.get_unchecked_mut(dst_i + bs_dist as usize) = escape_result;\n                    }\n                    src_i += bs_dist as usize + 2;\n                    dst_i += bs_dist as usize + 1;\n                }\n            } else {\n                src_i += 32;\n                dst_i += 32;\n            }\n        }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn parse_cmd(cmd_str: &str, _sender_address: AccountAddress) -> Result<ast::Cmd> {\n    let stripped_string = &strip_comments(cmd_str);\n    let parser = syntax::CmdParser::new();\n    match parser.parse(stripped_string) {\n        Ok(cmd) => Ok(cmd),\n        Err(e) => handle_error(e, cmd_str),\n    }\n}\npub fn parse_module(modules_str: &str) -> Result<ast::ModuleDefinition> {\n    let stripped_string = &strip_comments(modules_str);\n    let parser = syntax::ModuleParser::new();\n    match parser.parse(stripped_string) {\n        Ok(module) => Ok(module),\n        Err(e) => handle_error(e, modules_str),\n    }\n}\npub fn parse_program(program_str: &str) -> Result<ast::Program> {\n    let stripped_string = &strip_comments(program_str);\n    let parser = syntax::ProgramParser::new();\n    match parser.parse(stripped_string) {\n        Ok(program) => Ok(program),\n        Err(e) => handle_error(e, program_str),\n    }\n}\npub fn parse_script(script_str: &str) -> Result<ast::Script> {\n    let stripped_string = &strip_comments(script_str);\n    let parser = syntax::ScriptParser::new();\n    match parser.parse(stripped_string) {\n        Ok(script) => Ok(script),\n        Err(e) => handle_error(e, script_str),\n    }\n}\nfn strip_comments(string: &str) -> String {\n    let line_comments = Regex::new(r\"(?m)//.*$\").unwrap();\n    line_comments.replace_all(string, \"$1\").into_owned()\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "#[inline] fn map_elements<B, F: FnMut(A) -> B>(self, mut f: F) -> Matrix<B, M, N>\n      where M: ArrayLength<B>, N: ArrayLength<GenericArray<B, M>> {\n        let Matrix(a) = self;\n        let mut c: GenericArray<GenericArray<B, M>, N> = unsafe { mem::uninitialized() };\n        for i in 0..N::to_usize() { for j in 0..M::to_usize() { unsafe {\n            ptr::write(&mut c[i][j], f(ptr::read(&a[i][j])))\n        } } }\n        mem::forget(a);\n        Matrix(c)\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn resolve_index_to_str(&self, index: usize) -> Option<(&str, usize)> {\n        let bytes = self.buffer.get(index..)?;\n        let (str_len, str_len_bytes) = decode_var_usize(bytes)?;\n        let index_str = index + str_len_bytes;\n        let str_bytes = self.buffer.get(index_str..index_str + str_len)?;\n        let string = unsafe { str::from_utf8_unchecked(str_bytes) };\n        Some((string, index_str + str_len))\n    }\nunsafe fn resolve_index_to_str_unchecked(&self, index: usize) -> &str {\n        let slice_len = unsafe { self.buffer.get_unchecked(index..) };\n        let (str_len, str_len_bytes) = unsafe { decode_var_usize_unchecked(slice_len) };\n        let start_str = index + str_len_bytes;\n        let str_bytes =\n            unsafe { self.buffer.get_unchecked(start_str..start_str + str_len) };\n        unsafe { str::from_utf8_unchecked(str_bytes) }\n    }\nfn push_string(&mut self, string: &str) -> S {\n        let symbol = self.next_symbol();\n        let str_len = string.len();\n        let str_bytes = string.as_bytes();\n        self.encode_var_usize(str_len);\n        self.buffer.extend(str_bytes);\n        self.len_strings += 1;\n        symbol\n    }\nfn with_capacity(capacity: usize) -> Self {\n        const LEN_USIZE: usize = mem::size_of::<usize>();\n        const DEFAULT_STR_LEN: usize = 5;\n        let bytes_per_string = DEFAULT_STR_LEN * LEN_USIZE;\n        Self {\n            len_strings: 0,\n            buffer: Vec::with_capacity(capacity * bytes_per_string),\n            marker: Default::default(),\n        }\n    }\nfn resolve(&self, symbol: Self::Symbol) -> Option<&str> {\n        self.resolve_index_to_str(symbol.to_usize())\n            .map(|(string, _next_str_index)| string)\n    }\npub fn new(backend: &'a BufferBackend<S>) -> Self {\n        Self {\n            backend,\n            yielded: 0,\n            current: 0,\n        }\n    }\nfn next(&mut self) -> Option<Self::Item> {\n        self.backend.resolve_index_to_str(self.current).and_then(\n            |(string, next_string_index)| {\n                let symbol = S::try_from_usize(self.current)?;\n                self.current = next_string_index;\n                self.yielded += 1;\n                Some((symbol, string))\n            },\n        )\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "    fn check_overflow(&self) -> bool {\n        let mut yes: bool = false;\n        let mut no: bool = false;\n        no = no || (self.0[7] < SECP256K1_N_7); \n        no = no || (self.0[6] < SECP256K1_N_6); \n        no = no || (self.0[5] < SECP256K1_N_5); \n        no = no || (self.0[4] < SECP256K1_N_4);\n        yes = yes || ((self.0[4] > SECP256K1_N_4) && !no);\n        no = no || ((self.0[3] < SECP256K1_N_3) && !yes);\n        yes = yes || ((self.0[3] > SECP256K1_N_3) && !no);\n        no = no || ((self.0[2] < SECP256K1_N_2) && !yes);\n        yes = yes || ((self.0[2] > SECP256K1_N_2) && !no);\n        no = no || ((self.0[1] < SECP256K1_N_1) && !yes);\n        yes = yes || ((self.0[1] > SECP256K1_N_1) && !no);\n        yes = yes || ((self.0[0] >= SECP256K1_N_0) && !no);\n        return yes;\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn into_iter(mut self) -> IntoIter<K, V> {\n        let (head, tail) = if !self.head.is_null() {\n            unsafe { ((*self.head).prev, (*self.head).next) }\n        } else {\n            (ptr::null_mut(), ptr::null_mut())\n        };\n        let len = self.len();\n        if !self.head.is_null() {\n            unsafe { drop_empty_node(self.head) }\n        }\n        self.clear_free_list();\n        self.map = unsafe { mem::uninitialized() };\n        mem::forget(self);\n        IntoIter {\n            head: head,\n            tail: tail,\n            remaining: len,\n            marker: marker::PhantomData,\n        }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "src/theme/searcher/searcher.js\nfunction formatSearchResult(result, searchterms) {\n        var teaser = makeTeaser(escapeHTML(result.doc.body), searchterms);\n        teaser_count++;\n        var url = doc_urls[result.ref].split(\"#\");\n        if (url.length == 1) { \n            url.push(\"\");\n        }\n        return '<a href=\"' + path_to_root + url[0] + '?' + URL_MARK_PARAM + '=' + searchterms + '#' + url[1]\n            + '\" aria-details=\"teaser_' + teaser_count + '\">' + result.doc.breadcrumbs + '</a>'\n            + '<span class=\"teaser\" id=\"teaser_' + teaser_count + '\" aria-label=\"Search Result Teaser\">' \n            + teaser + '</span>';\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn inner_lookup_wildcard(\n        &self,\n        name: &LowerName,\n        record_type: RecordType,\n        and_rrsigs: bool,\n        supported_algorithms: SupportedAlgorithms,\n    ) -> Option<Arc<RecordSet>> {\n        let wildcard = if name.is_wildcard() {\n            return None;\n        } else {\n            name.clone().into_wildcard()\n        };\n        self.inner_lookup(&wildcard, record_type, and_rrsigs, supported_algorithms)\n            .map(|rrset| {\n                let mut new_answer =\n                    RecordSet::new(name.borrow(), rrset.record_type(), rrset.ttl());\n                let (records, _rrsigs): (Vec<&Record>, Vec<&Record>) = rrset\n                    .records(and_rrsigs, supported_algorithms)\n                    .partition(|r| r.record_type() != RecordType::DNSSEC(DNSSECRecordType::RRSIG));\n                for record in records {\n                    new_answer.add_rdata(record.rdata().clone());\n                }\n                #[cfg(feature = \"dnssec\")]\n                for rrsig in _rrsigs {\n                    new_answer.insert_rrsig(rrsig.clone())\n                }\n                Arc::new(new_answer)\n            })\n    }\npub fn try_from_config(\n        origin: Name,\n        zone_type: ZoneType,\n        allow_axfr: bool,\n        root_dir: Option<&Path>,\n        config: &FileConfig,\n    ) -> Result<Self, String> {\n        use std::fs::File;\n        use std::io::Read;\n        use trust_dns_client::serialize::txt::{Lexer, Parser};\n        let zone_path = root_dir\n            .map(PathBuf::from)\n            .unwrap_or_else(PathBuf::new)\n            .join(&config.zone_file_path);\n        info!(\"loading zone file: {:?}\", zone_path);\n        let mut file = File::open(&zone_path)\n            .map_err(|e| format!(\"error opening {}: {:?}\", zone_path.display(), e))?;\n        let mut buf = String::new();\n        file.read_to_string(&mut buf)\n            .map_err(|e| format!(\"failed to read {}: {:?}\", zone_path.display(), e))?;\n        let lexer = Lexer::new(&buf);\n        let (origin, records) = Parser::new()\n            .parse(lexer, Some(origin))\n            .map_err(|e| format!(\"failed to parse {}: {:?}\", zone_path.display(), e))?;\n        info!(\n            \"zone file loaded: {} with {} records\",\n            origin,\n            records.len()\n        );\n        FileAuthority::new(origin, records, zone_type, allow_axfr)\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "Path\nfn try_alloc_layout_fast(&self, layout: Layout) -> Option<NonNull<u8>> {\n        unsafe {\n            let footer = self.current_chunk_footer.get();\n            let footer = footer.as_ref();\n            let ptr = footer.ptr.get().as_ptr();\n            let start = footer.data.as_ptr();\n            debug_assert!(start <= ptr);\n            debug_assert!(ptr as *const u8 <= footer as *const _ as *const u8);\n            if (ptr as usize) < layout.size() {\n                return None;\n            }\n            let ptr = ptr.wrapping_sub(layout.size());\n            let aligned_ptr = round_mut_ptr_down_to(ptr, layout.align());\n            if aligned_ptr >= start {\n                let aligned_ptr = NonNull::new_unchecked(aligned_ptr);\n                footer.ptr.set(aligned_ptr);\n                Some(aligned_ptr)\n            } else {\n                None\n            }\n        }\n    }\nPath\nfn alloc_layout_slow(&self, layout: Layout) -> Option<NonNull<u8>> {\n        unsafe {\n            let size = layout.size();\n            let allocation_limit_remaining = self.allocation_limit_remaining();\n            let current_footer = self.current_chunk_footer.get();\n            let current_layout = current_footer.as_ref().layout;\n            let min_new_chunk_size = layout.size().max(DEFAULT_CHUNK_SIZE_WITHOUT_FOOTER);\n            let mut base_size = (current_layout.size() - FOOTER_SIZE)\n                .checked_mul(2)?\n                .max(min_new_chunk_size);\n            let chunk_memory_details = iter::from_fn(|| {\n                let bypass_min_chunk_size_for_small_limits = matches!(self.allocation_limit(), Some(limit) if layout.size() < limit\n                            && base_size >= layout.size()\n                            && limit < DEFAULT_CHUNK_SIZE_WITHOUT_FOOTER\n                            && self.allocated_bytes() == 0);\n                if base_size >= min_new_chunk_size || bypass_min_chunk_size_for_small_limits {\n                    let size = base_size;\n                    base_size /= 2;\n                    Bump::new_chunk_memory_details(Some(size), layout)\n                } else {\n                    None\n                }\n            });\n            let new_footer = chunk_memory_details\n                .filter_map(|chunk_memory_details| {\n                    if Bump::chunk_fits_under_limit(\n                        allocation_limit_remaining,\n                        chunk_memory_details,\n                    ) {\n                        Bump::new_chunk(chunk_memory_details, layout, current_footer)\n                    } else {\n                        None\n                    }\n                })\n                .next()?;\n            debug_assert_eq!(\n                new_footer.as_ref().data.as_ptr() as usize % layout.align(),\n                0\n            );\n            self.current_chunk_footer.set(new_footer);\n            let new_footer = new_footer.as_ref();\n            let mut ptr = new_footer.ptr.get().as_ptr().sub(size);\n            ptr = round_mut_ptr_down_to(ptr, layout.align());\n            debug_assert!(\n                ptr as *const _ <= new_footer,\n                \"{:p} <= {:p}\",\n                ptr,\n                new_footer\n            );\n            let ptr = NonNull::new_unchecked(ptr);\n            new_footer.ptr.set(ptr);\n            Some(ptr)\n        }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn log(err_code: c_int, msg: &str) {\n    let msg = CString::new(msg).expect(\"SQLite log messages cannot contain embedded zeroes\");\n    unsafe {\n        ffi::sqlite3_log(err_code, msg.as_ptr());\n        ffi::sqlite3_log(err_code, b\"%s\\0\" as *const _ as *const c_char, msg.as_ptr());\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn set_aux<T: 'static>(&self, arg: c_int, value: T) {\n        let boxed = Box::into_raw(Box::new(AuxData {\n            id: TypeId::of::<T>(),\n            value,\n        }));\n        unsafe {\n            ffi::sqlite3_set_auxdata(\n                self.ctx,\n                arg,\n                boxed as *mut c_void,\n                Some(free_boxed_value::<AuxData<T>>),\n            )\n        };\n    }\npub fn get_aux<T: 'static>(&self, arg: c_int) -> Result<Option<&T>> {\n        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxData<T> };\n        if p.is_null() {\n            Ok(None)\n        } else {\n            let id = unsafe { (*p).id };\n            if TypeId::of::<T>() != id {\n                Err(Error::GetAuxWrongType)\n            } else {\n                Ok(Some(unsafe { &(*p).value }))\n            }\n        }\n    }\nfn regexp_with_auxilliary(ctx: &Context<'_>) -> Result<bool> {\n        assert_eq!(ctx.len(), 2, \"called with unexpected number of arguments\");\n        let saved_re: Option<&Regex> = ctx.get_aux(0)?;\n        let new_re = match saved_re {\n            None => {\n                let s = ctx.get::<String>(0)?;\n                match Regex::new(&s) {\n                    Ok(r) => Some(r),\n                    Err(err) => return Err(Error::UserFunctionError(Box::new(err))),\n                }\n            }\n            Some(_) => None,\n        };\n        let is_match = {\n            let re = saved_re.unwrap_or_else(|| new_re.as_ref().unwrap());\n            let text = ctx\n                .get_raw(1)\n                .as_str()\n                .map_err(|e| Error::UserFunctionError(e.into()))?;\n            re.is_match(text)\n        };\n        if let Some(re) = new_re {\n            ctx.set_aux(0, re);\n        }\n        Ok(is_match)\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn with_capacity(cap: usize) -> Self {\n        assert!(cap > 0, \"capacity must be positive\");\n        let mark_bit = (cap + 1).next_power_of_two();\n        let one_lap = mark_bit * 2;\n        let head = 0;\n        let tail = 0;\n        let buffer = {\n            let mut v: Vec<Slot<T>> = (0..cap)\n                .map(|i| {\n                    Slot {\n                        stamp: AtomicUsize::new(i),\n                        msg: UnsafeCell::new(MaybeUninit::uninit()),\n                    }\n                })\n                .collect();\n            let ptr = v.as_mut_ptr();\n            mem::forget(v);\n            ptr\n        };\n        Channel {\n            buffer,\n            cap,\n            one_lap,\n            mark_bit,\n            head: CachePadded::new(AtomicUsize::new(head)),\n            tail: CachePadded::new(AtomicUsize::new(tail)),\n            senders: SyncWaker::new(),\n            receivers: SyncWaker::new(),\n            _marker: PhantomData,\n        }\n    }\nfn drop(&mut self) {\n        let hix = self.head.load(Ordering::Relaxed) & (self.mark_bit - 1);\n        for i in 0..self.len() {\n            let index = if hix + i < self.cap {\n                hix + i\n            } else {\n                hix + i - self.cap\n            };\n            unsafe {\n                let p = {\n                    let slot = &mut *self.buffer.add(index);\n                    let msg = &mut *slot.msg.get();\n                    msg.as_mut_ptr()\n                };\n                p.drop_in_place();\n            }\n        }\n        unsafe {\n            Vec::from_raw_parts(self.buffer, 0, self.cap);\n        }\n    }\npub fn new(cap: usize) -> ArrayQueue<T> {\n        assert!(cap > 0, \"capacity must be non-zero\");\n        let head = 0;\n        let tail = 0;\n        let buffer = {\n            let mut v: Vec<Slot<T>> = (0..cap)\n                .map(|i| {\n                    Slot {\n                        stamp: AtomicUsize::new(i),\n                        value: UnsafeCell::new(MaybeUninit::uninit()),                    }\n                })\n                .collect();\n            let ptr = v.as_mut_ptr();\n            mem::forget(v);\n            ptr\n        };\n        let one_lap = (cap + 1).next_power_of_two();\n        ArrayQueue {\n            buffer,\n            cap,\n            one_lap,\n            head: CachePadded::new(AtomicUsize::new(head)),\n            tail: CachePadded::new(AtomicUsize::new(tail)),\n            _marker: PhantomData,\n        }\n    }\nfn drop(&mut self) {\n        let hix = self.head.load(Ordering::Relaxed) & (self.one_lap - 1);\n        for i in 0..self.len() {\n            let index = if hix + i < self.cap {\n                hix + i\n            } else {\n                hix + i - self.cap\n            };\n            unsafe {\n                let p = {\n                    let slot = &mut *self.buffer.add(index);\n                    let value = &mut *slot.value.get();\n                    value.as_mut_ptr()\n                };\n                p.drop_in_place();\n            }\n        }\n        unsafe {\n            Vec::from_raw_parts(self.buffer, 0, self.cap);\n        }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn waker<W>(wake: Arc<W>) -> Waker\nwhere\n    W: ArcWake,\n{\n    let ptr = Arc::into_raw(wake) as *const ();\n    unsafe {\n        Waker::from_raw(RawWaker::new(ptr, waker_vtable::<W>()))\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn from(other: Py<T>) -> Self {\n        let Py(ptr, _) = other;\n        Py(ptr, PhantomData)\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "Vfn add_assign(&mut self, other: T) {\n        self.0 += other;\n        assert!(!self.0.is_nan(), \"Addition resulted in NaN\");\n    }\nfn sub_assign(&mut self, other: T) {\n        self.0 -= other;\n        assert!(!self.0.is_nan(), \"Subtraction resulted in NaN\");\n    }\nfn mul_assign(&mut self, other: T) {\n        self.0 *= other;\n        assert!(!self.0.is_nan(), \"Multiplication resulted in NaN\");\n    }\nfn div_assign(&mut self, other: T) {\n        self.0 /= other;\n        assert!(!self.0.is_nan(), \"Division resulted in NaN\");\n    }\nfn rem_assign(&mut self, other: T) {\n        self.0 %= other;\n        assert!(!self.0.is_nan(), \"Rem resulted in NaN\");\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn random() -> Self {\n                unsafe {\n                    let mut array: [T; $s] = std::mem::uninitialized();\n                    for i in 0..$s {\n                        std::ptr::write(&mut array[i], T::random());\n                    }\n                    array\n                }\n            }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn retain<F>(&mut self, mut f: F)\n    where\n        F: FnMut(char) -> bool,\n    {\n        let len = self.len();\n        let mut del_bytes = 0;\n        let mut idx = 0;\n        while idx < len {\n            let ch = unsafe { self.get_unchecked(idx..len).chars().next().unwrap() };\n            let ch_len = ch.len_utf8();\n            if !f(ch) {\n                del_bytes += ch_len;\n            } else if del_bytes > 0 {\n                unsafe {\n                    ptr::copy(\n                        self.vec.as_ptr().add(idx),\n                        self.vec.as_mut_ptr().add(idx - del_bytes),\n                        ch_len,\n                    );\n                }\n            }\n            idx += ch_len;\n        }\n        if del_bytes > 0 {\n            unsafe {\n                self.vec.set_len(len - del_bytes);\n            }\n        }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn make_contiguous(&mut self) -> &mut [T] {\n        if self.is_contiguous() {\n            let tail = self.tail;\n            let head = self.head;\n            return unsafe { &mut self.buffer_as_mut_slice()[tail..head] };\n        }\n        let buf = self.buf.ptr();\n        let cap = self.cap();\n        let len = self.len();\n        let free = self.tail - self.head;\n        let tail_len = cap - self.tail;\n        if free >= tail_len {\n            unsafe {\n                ptr::copy(buf, buf.add(tail_len), self.head);\n                ptr::copy_nonoverlapping(buf.add(self.tail), buf, tail_len);\n                self.tail = 0;\n                self.head = len;\n            }\n        } else if free >= self.head {\n            unsafe {\n                ptr::copy(buf.add(self.tail), buf.add(self.head), tail_len);\n                ptr::copy_nonoverlapping(buf, buf.add(self.head + tail_len), self.head);\n                self.tail = self.head;\n                self.head = self.tail + len;\n            }\n        } else {\n            let mut left_edge: usize = 0;\n            let mut right_edge: usize = self.tail;\n            unsafe {\n                while left_edge < len && right_edge != cap {\n                    let mut right_offset = 0;\n                    for i in left_edge..right_edge {\n                        right_offset = (i - left_edge) % (cap - right_edge);\n                        let src: isize = (right_edge + right_offset) as isize;\n                        ptr::swap(buf.add(i), buf.offset(src));\n                    }\n                    let n_ops = right_edge - left_edge;\n                    left_edge += n_ops;\n                    right_edge += right_offset + 1;\n                }\n                self.tail = 0;\n                self.head = len;\n            }\n        }\n        let tail = self.tail;\n        let head = self.head;\n        unsafe { &mut self.buffer_as_mut_slice()[tail..head] }\n    }\nfn from(mut other: VecDeque<T>) -> Self {\n        other.make_contiguous();\n        unsafe {\n            let other = ManuallyDrop::new(other);\n            let buf = other.buf.ptr();\n            let len = other.len();\n            let cap = other.cap();\n            if other.head != 0 {\n                    ptr::copy(buf.add(other.tail), buf, len);\n            }\n            Vec::from_raw_parts(buf, len, cap)\n        }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn discard_exact(&mut self, mut len: usize) -> io::Result<()> {\n        while len > 0 {\n            let consume_len = match self.fill_buf() {\n                Ok(buf) if buf.is_empty() =>\n                    return Err(io::Error::new(\n                        io::ErrorKind::UnexpectedEof, \"unexpected EOF\")),\n                Ok(buf) => buf.len().min(len),\n                Err(e) if e.kind() == io::ErrorKind::Interrupted => continue,\n                Err(e) => return Err(e),\n            };\n            self.consume(consume_len);\n            len -= consume_len;\n        }\n        Ok(())\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn parse(buf: &mut BytesMut, ctx: ParseContext<'_>) -> ParseResult<RequestLine> {\n        debug_assert!(!buf.is_empty(), \"parse called with empty buf\");\n        let mut keep_alive;\n        let is_http_11;\n        let subject;\n        let version;\n        let len;\n        let headers_len;\n        let mut headers_indices: [HeaderIndices; MAX_HEADERS] = unsafe { mem::uninitialized() };\n        {\n            let mut headers: [httparse::Header<'_>; MAX_HEADERS] = unsafe { mem::uninitialized() };\n            trace!(\n                \"Request.parse([Header; {}], [u8; {}])\",\n                headers.len(),\n                buf.len()\n            );\n            let mut req = httparse::Request::new(&mut headers);\n            let bytes = buf.as_ref();\n            match req.parse(bytes) {\n                Ok(httparse::Status::Complete(parsed_len)) => {\n                    trace!(\"Request.parse Complete({})\", parsed_len);\n                    len = parsed_len;\n                    subject = RequestLine(\n                        Method::from_bytes(req.method.unwrap().as_bytes())?,\n                        req.path.unwrap().parse()?,\n                    );\n                    version = if req.version.unwrap() == 1 {\n                        keep_alive = true;\n                        is_http_11 = true;\n                        Version::HTTP_11\n                    } else {\n                        keep_alive = false;\n                        is_http_11 = false;\n                        Version::HTTP_10\n                    };\n                    trace!(\"headers: {:?}\", &req.headers);\n                    record_header_indices(bytes, &req.headers, &mut headers_indices)?;\n                    headers_len = req.headers.len();\n                }\n                Ok(httparse::Status::Partial) => return Ok(None),\n                Err(err) => {\n                    return Err(match err {\n                        httparse::Error::Token => {\n                            if req.method.is_none() {\n                                Parse::Method\n                            } else {\n                                debug_assert!(req.path.is_none());\n                                Parse::Uri\n                            }\n                        }\n                        other => other.into(),\n                    });\n                }\n            }\n        };\n        let slice = buf.split_to(len).freeze();\n        let mut decoder = DecodedLength::ZERO;\n        let mut expect_continue = false;\n        let mut con_len = None;\n        let mut is_te = false;\n        let mut is_te_chunked = false;\n        let mut wants_upgrade = subject.0 == Method::CONNECT;\n        let mut headers = ctx.cached_headers.take().unwrap_or_else(HeaderMap::new);\n        headers.reserve(headers_len);\n        for header in &headers_indices[..headers_len] {\n            let name = header_name!(&slice[header.name.0..header.name.1]);\n            let value = header_value!(slice.slice(header.value.0..header.value.1));\n            match name {\n                header::TRANSFER_ENCODING => {\n                    if !is_http_11 {\n                        debug!(\"HTTP/1.0 cannot have Transfer-Encoding header\");\n                        return Err(Parse::Header);\n                    }\n                    is_te = true;\n                    if headers::is_chunked_(&value) {\n                        is_te_chunked = true;\n                        decoder = DecodedLength::CHUNKED;\n                    }\n                }\n                header::CONTENT_LENGTH => {\n                    if is_te {\n                        continue;\n                    }\n                    let len = value\n                        .to_str()\n                        .map_err(|_| Parse::Header)\n                        .and_then(|s| s.parse().map_err(|_| Parse::Header))?;\n                    if let Some(prev) = con_len {\n                        if prev != len {\n                            debug!(\n                                \"multiple Content-Length headers with different values: [{}, {}]\",\n                                prev, len,\n                            );\n                            return Err(Parse::Header);\n                        }\n                        continue;\n                    }\n                    decoder = DecodedLength::checked_new(len)?;\n                    con_len = Some(len);\n                }\n                header::CONNECTION => {\n                    if keep_alive {\n                        keep_alive = !headers::connection_close(&value);\n                    } else {\n                        keep_alive = headers::connection_keep_alive(&value);\n                    }\n                }\n                header::EXPECT => {\n                    expect_continue = value.as_bytes() == b\"100-continue\";\n                }\n                header::UPGRADE => {\n                    wants_upgrade = is_http_11;\n                }\n                _ => (),\n            }\n            headers.append(name, value);\n        }\n        if is_te && !is_te_chunked {\n            debug!(\"request with transfer-encoding header, but not chunked, bad request\");\n            return Err(Parse::Header);\n        }\n        *ctx.req_method = Some(subject.0.clone());\n        Ok(Some(ParsedMessage {\n            head: MessageHead {\n                version,\n                subject,\n                headers,\n                extensions: http::Extensions::default(),\n            },\n            decode: decoder,\n            expect_continue,\n            keep_alive,\n            wants_upgrade,\n        }))\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "    fn encode_table(self) -> &'static [u8; 64] {\n        match self {\n            CharacterSet::Standard => tables::STANDARD_ENCODE,\n            CharacterSet::UrlSafe => tables::URL_SAFE_ENCODE,\n            CharacterSet::Crypt => tables::CRYPT_ENCODE,\n            CharacterSet::Bcrypt => tables::BCRYPT_ENCODE,\n            CharacterSet::ImapMutf7 => tables::IMAP_MUTF7_ENCODE,\n            CharacterSet::BinHex => tables::BINHEX_ENCODE,\n        }\n    }\n    fn decode_table(self) -> &'static [u8; 256] {\n        match self {\n            CharacterSet::Standard => tables::STANDARD_DECODE,\n            CharacterSet::UrlSafe => tables::URL_SAFE_DECODE,\n            CharacterSet::Crypt => tables::CRYPT_DECODE,\n            CharacterSet::Bcrypt => tables::BCRYPT_DECODE,\n            CharacterSet::ImapMutf7 => tables::IMAP_MUTF7_DECODE,\n            CharacterSet::BinHex => tables::BINHEX_DECODE,\n        }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn insert_many<I: IntoIterator<Item = A::Item>>(&mut self, index: usize, iterable: I) {\n        let iter = iterable.into_iter();\n        if index == self.len() {\n            return self.extend(iter);\n        }\n        let (lower_size_bound, _) = iter.size_hint();\n        assert!(lower_size_bound <= core::isize::MAX as usize); \n        assert!(index + lower_size_bound >= index); \n        self.reserve(lower_size_bound);\n        unsafe {\n            let old_len = self.len();\n            assert!(index <= old_len);\n            let start = self.as_mut_ptr();\n            let mut ptr = start.add(index);\n            ptr::copy(ptr, ptr.add(lower_size_bound), old_len - index);\n            self.set_len(0);\n            let mut guard = DropOnPanic {\n                start,\n                skip: index..(index + lower_size_bound),\n                len: old_len + lower_size_bound,\n            };\n            let mut num_added = 0;\n            for element in iter {\n                let mut cur = ptr.add(num_added);\n                if num_added >= lower_size_bound {\n                    self.reserve(1);\n                    let start = self.as_mut_ptr();\n                    ptr = start.add(index);\n                    cur = ptr.add(num_added);\n                    ptr::copy(cur, cur.add(1), old_len - index);\n                    guard.start = start;\n                    guard.len += 1;\n                    guard.skip.end += 1;\n                }\n                ptr::write(cur, element);\n                guard.skip.start += 1;\n                num_added += 1;\n            }\n            mem::forget(guard);\n            if num_added < lower_size_bound {\n                ptr::copy(\n                    ptr.add(lower_size_bound),\n                    ptr.add(num_added),\n                    old_len - index,\n                );\n            }\n            self.set_len(old_len + num_added);\n        }\n        struct DropOnPanic<T> {\n            start: *mut T,\n            skip: Range<usize>,\n            len: usize,\n        }\n        impl<T> Drop for DropOnPanic<T> {\n            fn drop(&mut self) {\n                for i in 0..self.len {\n                    if !self.skip.contains(&i) {\n                        unsafe {\n                            ptr::drop_in_place(self.start.add(i));\n                        }\n                    }\n                }\n            }\n        }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn map_array(mut values: [T; $size], mut f: F) -> Self {\n                use std::{\n                    mem::forget,\n                    ptr::{read, write},\n                };\n                unsafe {\n                    let mut result: ::std::mem::MaybeUninit<[U; $size]> =\n                        ::std::mem::MaybeUninit::zeroed();\n                    for i in 0..$size {\n                        write(\n                            result.as_mut_ptr().cast::<U>().add(i),\n                            f(read(&mut values[i])),\n                        );\n                    }\n                    forget(values);\n                    result.assume_init()\n                }\n            }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn read_to_end_with_reservation<R, F>(\n    r: &mut R,\n    buf: &mut Vec<u8>,\n    mut reservation_size: F,\n) -> Result<usize>\nwhere\n    R: Read + ?Sized,\n    F: FnMut(&R) -> usize,\n{\n    let start_len = buf.len();\n    let mut g = Guard { len: buf.len(), buf };\n    let ret;\n    loop {\n        if g.len == g.buf.len() {\n            unsafe {\n                g.buf.reserve(reservation_size(r));\n                let capacity = g.buf.capacity();\n                g.buf.set_len(capacity);\n                r.initializer().initialize(&mut g.buf[g.len..]);\n            }\n        }\n        match r.read(&mut g.buf[g.len..]) {\n            Ok(0) => {\n                ret = Ok(g.len - start_len);\n                break;\n            }\n            Ok(n) => g.len += n,\n            Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n            Err(e) => {\n                ret = Err(e);\n                break;\n            }\n        }\n    }\n    ret\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "Vulnerable Function 1\nfn next(&mut self) -> Option<(A::Item, B::Item)> {\n        if self.index < self.len {\n            let i = self.index;\n            self.index += 1;\n            unsafe {\n                Some((self.a.__iterator_get_unchecked(i), self.b.__iterator_get_unchecked(i)))\n            }\n        } else if A::may_have_side_effect() && self.index < self.a.size() {\n            unsafe {\n                self.a.__iterator_get_unchecked(self.index);\n            }\n            self.index += 1;\n            None\n        } else {\n            None\n        }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "unsafe fn get_unchecked(&mut self, idx: usize) -> <Self as Iterator>::Item {\n        unsafe { (self.a.__iterator_get_unchecked(idx), self.b.__iterator_get_unchecked(idx)) }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn new(a: A, b: B) -> Self {\n        let len = cmp::min(a.size(), b.size());\n        Zip { a, b, index: 0, len }\n    }\nfn next(&mut self) -> Option<(A::Item, B::Item)> {\n        if self.index < self.len {\n            let i = self.index;\n            self.index += 1;\n            unsafe {\n                Some((self.a.__iterator_get_unchecked(i), self.b.__iterator_get_unchecked(i)))\n            }\n        } else if A::MAY_HAVE_SIDE_EFFECT && self.index < self.a.size() {\n            let i = self.index;\n            self.index += 1;\n            self.len += 1;\n            unsafe {\n                self.a.__iterator_get_unchecked(i);\n            }\n            None\n        } else {\n            None\n        }\n    }\nfn next_back(&mut self) -> Option<(A::Item, B::Item)>\n    where\n        A: DoubleEndedIterator + ExactSizeIterator,\n        B: DoubleEndedIterator + ExactSizeIterator,\n    {\n        if A::MAY_HAVE_SIDE_EFFECT || B::MAY_HAVE_SIDE_EFFECT {\n            let sz_a = self.a.size();\n            let sz_b = self.b.size();\n            if sz_a != sz_b {\n                let sz_a = self.a.size();\n                if A::MAY_HAVE_SIDE_EFFECT && sz_a > self.len {\n                    for _ in 0..sz_a - self.len {\n                        self.a.next_back();\n                    }\n                }\n                let sz_b = self.b.size();\n                if B::MAY_HAVE_SIDE_EFFECT && sz_b > self.len {\n                    for _ in 0..sz_b - self.len {\n                        self.b.next_back();\n                    }\n                }\n            }\n        }\n        if self.index < self.len {\n            self.len -= 1;\n            let i = self.len;\n            unsafe {\n                Some((self.a.__iterator_get_unchecked(i), self.b.__iterator_get_unchecked(i)))\n            }\n        } else {\n            None\n        }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn next(&mut self) -> Option<(A::Item, B::Item)> {\n        if self.index < self.len {\n            let i = self.index;\n            self.index += 1;\n            unsafe {\n                Some((self.a.__iterator_get_unchecked(i), self.b.__iterator_get_unchecked(i)))\n            }\n        } else if A::MAY_HAVE_SIDE_EFFECT && self.index < self.a.size() {\n            let i = self.index;\n            self.index += 1;\n            unsafe {\n                self.a.__iterator_get_unchecked(i);\n            }\n            None\n        } else {\n            None\n        }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn set(\n\t\t&mut self,\n\t\toffset: usize,\n\t\tvalue: &[u8],\n\t\ttarget_size: Option<usize>\n\t) -> Result<(), ExitFatal> {\n\t\tlet target_size = target_size.unwrap_or(value.len());\n\t\tif offset.checked_add(target_size)\n\t\t\t.map(|pos| pos > self.limit).unwrap_or(true)\n\t\t{\n\t\t\treturn Err(ExitFatal::NotSupported)\n\t\t}\n\t\tif self.data.len() < offset + target_size {\n\t\t\tself.data.resize(offset + target_size, 0);\n\t\t}\n\t\tfor index in 0..target_size {\n\t\t\tif self.data.len() > offset + index && value.len() > index {\n\t\t\t\tself.data[offset + index] = value[index];\n\t\t\t} else {\n\t\t\t\tself.data[offset + index] = 0;\n\t\t\t}\n\t\t}\n\t\tOk(())\n\t}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "void Compute(OpKernelContext* context) override {\n    const Tensor& x = context->input(0);\n    const Tensor& y = context->input(1);\n    const float min_x = context->input(2).flat<float>()(0);\n    const float max_x = context->input(3).flat<float>()(0);\n    const float min_y = context->input(4).flat<float>()(0);\n    const float max_y = context->input(5).flat<float>()(0);\n    BCast bcast(BCast::FromShape(x.shape()), BCast::FromShape(y.shape()));\n    if (!bcast.IsValid()) {\n      context->SetStatus(errors::InvalidArgument(\n          \"Incompatible shapes: \", x.shape().DebugString(), \" vs. \",\n          y.shape().DebugString()));\n      return;\n    }\n    Tensor* z;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                0, BCast::ToShape(bcast.output_shape()), &z));\n    OP_REQUIRES(context, (max_x > min_x),\n                errors::InvalidArgument(\"max_x must be larger than min_x.\"));\n    OP_REQUIRES(context, (max_y > min_y),\n                errors::InvalidArgument(\"max_y must be larger than min_y.\"));\n    const T* x_data = x.flat<T>().data();\n    const T* y_data = y.flat<T>().data();\n    Toutput* z_data = z->flat<Toutput>().data();\n    const float smallest_min = std::min(min_x, min_y);\n    const float largest_max = std::max(max_x, max_y);\n    const float biggest_range =\n        std::max(std::abs(smallest_min), std::abs(largest_max));\n    const float output_range = (biggest_range * (1 << 14));\n    const float min_z_value = -output_range;\n    const float max_z_value = output_range;\n    const int ndims = bcast.x_reshape().size();\n    if (ndims <= 1) {\n      if (x.NumElements() == 1) {\n        ScalarAddition<T, Toutput>(context, y_data, min_y, max_y,\n                                   y.NumElements(), x_data[0], min_x, max_x,\n                                   min_z_value, max_z_value, z_data);\n      } else if (y.NumElements() == 1) {\n        ScalarAddition<T, Toutput>(context, x_data, min_x, max_x,\n                                   x.NumElements(), y_data[0], min_y, max_y,\n                                   min_z_value, max_z_value, z_data);\n      } else {\n        VectorAddition<T, Toutput>(context, x_data, min_x, max_x, y_data, min_y,\n                                   max_y, x.NumElements(), min_z_value,\n                                   max_z_value, z_data);\n      }\n    } else if (ndims == 2) {\n      const T* vector_data;\n      int64 vector_num_elements;\n      float vector_min;\n      float vector_max;\n      const T* tensor_data;\n      int64 tensor_num_elements;\n      float tensor_min;\n      float tensor_max;\n      if (x.NumElements() < y.NumElements()) {\n        vector_data = x_data;\n        vector_num_elements = x.NumElements();\n        vector_min = min_x;\n        vector_max = max_x;\n        tensor_data = y_data;\n        tensor_num_elements = y.NumElements();\n        tensor_min = min_y;\n        tensor_max = max_y;\n      } else {\n        vector_data = y_data;\n        vector_num_elements = y.NumElements();\n        vector_min = min_y;\n        vector_max = max_y;\n        tensor_data = x_data;\n        tensor_num_elements = x.NumElements();\n        tensor_min = min_x;\n        tensor_max = max_x;\n      }\n      VectorTensorAddition<T, Toutput>(\n          vector_data, vector_min, vector_max, vector_num_elements, tensor_data,\n          tensor_min, tensor_max, tensor_num_elements, min_z_value, max_z_value,\n          z_data);\n    } else {\n      LOG(INFO) << \"ndims=\" << ndims;\n      LOG(INFO) << \"bcast.x_reshape()=\"\n                << TensorShape(bcast.x_reshape()).DebugString();\n      LOG(INFO) << \"bcast.y_reshape()=\"\n                << TensorShape(bcast.y_reshape()).DebugString();\n      LOG(INFO) << \"bcast.x_bcast()=\"\n                << TensorShape(bcast.x_bcast()).DebugString();\n      LOG(INFO) << \"bcast.y_bcast()=\"\n                << TensorShape(bcast.y_bcast()).DebugString();\n      context->SetStatus(errors::Unimplemented(\n          \"Broadcast between \", context->input(0).shape().DebugString(),\n          \" and \", context->input(1).shape().DebugString(),\n          \" is not supported yet.\"));\n      return;\n    }\n    Tensor* z_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &z_min));\n    z_min->flat<float>()(0) = min_z_value;\n    Tensor* z_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &z_max));\n    z_max->flat<float>()(0) = max_z_value;\n  }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n  int num_inputs = node->inputs->size;\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, num_inputs);\n  Subgraph* this_subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto* subgraphs = this_subgraph->GetSubgraphs();\n  TF_LITE_ENSURE(context, op_data->cond_subgraph_index < subgraphs->size());\n  TF_LITE_ENSURE(context, op_data->body_subgraph_index < subgraphs->size());\n  TF_LITE_ENSURE(context,\n                 op_data->cond_subgraph_index != op_data->body_subgraph_index);\n  Subgraph* cond_subgraph = (*subgraphs)[op_data->cond_subgraph_index].get();\n  Subgraph* body_subgraph = (*subgraphs)[op_data->body_subgraph_index].get();\n  TF_LITE_ENSURE_EQ(context, cond_subgraph->inputs().size(), num_inputs);\n  TF_LITE_ENSURE_EQ(context, cond_subgraph->outputs().size(), 1);\n  TF_LITE_ENSURE_EQ(context, body_subgraph->inputs().size(), num_inputs);\n  TF_LITE_ENSURE_EQ(context, body_subgraph->outputs().size(), num_inputs);\n  TF_LITE_ENSURE_OK(\n      context, CopyTensorsShapeAndType(\n                   context, this_subgraph, TfLiteIntArrayView(node->inputs),\n                   cond_subgraph, cond_subgraph->inputs(), true));\n  TF_LITE_ENSURE_OK(context, cond_subgraph->AllocateTensors());\n  TfLiteTensor* cond_output =\n      cond_subgraph->tensor(cond_subgraph->outputs()[0]);\n  if (IsDynamicTensor(cond_output)) {\n    op_data->cond_has_dynamic_output_tensors = true;\n  } else {\n    TF_LITE_ENSURE_STATUS(CheckCondOutput(context, cond_output));\n  }\n  TF_LITE_ENSURE_OK(\n      context, CopyTensorsShapeAndType(\n                   context, this_subgraph, TfLiteIntArrayView(node->inputs),\n                   body_subgraph, body_subgraph->inputs(), true));\n  TF_LITE_ENSURE_OK(context, body_subgraph->AllocateTensors());\n  if (body_subgraph->HasDynamicTensors()) {\n    op_data->body_has_dynamic_output_tensors = true;\n  } else {\n    for (int i = 0; i < num_inputs; ++i) {\n      TfLiteTensor* body_input =\n          body_subgraph->tensor(body_subgraph->inputs()[i]);\n      TfLiteTensor* body_output =\n          body_subgraph->tensor(body_subgraph->outputs()[i]);\n      TF_LITE_ENSURE_TYPES_EQ(context, body_input->type, body_output->type);\n      TF_LITE_ENSURE(context, !IsDynamicTensor(body_output));\n      if (!TfLiteIntArrayEqual(body_input->dims, body_output->dims)) {\n        op_data->body_has_dynamic_output_tensors = true;\n        break;\n      }\n    }\n  }\n  for (int i = 0; i < num_inputs; ++i) {\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));\n    if (op_data->body_has_dynamic_output_tensors) {\n      SetTensorToDynamic(output);\n    } else {\n      TfLiteTensor* body_output =\n          body_subgraph->tensor(body_subgraph->outputs()[i]);\n      TfLiteIntArray* output_size = TfLiteIntArrayCopy(body_output->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, output, output_size));\n    }\n  }\n  return kTfLiteOk;\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n  int num_inputs = node->inputs->size;\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, num_inputs);\n  Subgraph* this_subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto* subgraphs = this_subgraph->GetSubgraphs();\n  TF_LITE_ENSURE(context, op_data->cond_subgraph_index < subgraphs->size());\n  TF_LITE_ENSURE(context, op_data->body_subgraph_index < subgraphs->size());\n  TF_LITE_ENSURE(context,\n                 op_data->cond_subgraph_index != op_data->body_subgraph_index);\n  Subgraph* cond_subgraph = (*subgraphs)[op_data->cond_subgraph_index].get();\n  Subgraph* body_subgraph = (*subgraphs)[op_data->body_subgraph_index].get();\n  TF_LITE_ENSURE_EQ(context, cond_subgraph->inputs().size(), num_inputs);\n  TF_LITE_ENSURE_EQ(context, cond_subgraph->outputs().size(), 1);\n  TF_LITE_ENSURE_EQ(context, body_subgraph->inputs().size(), num_inputs);\n  TF_LITE_ENSURE_EQ(context, body_subgraph->outputs().size(), num_inputs);\n  TF_LITE_ENSURE_OK(\n      context, CopyTensorsShapeAndType(\n                   context, this_subgraph, TfLiteIntArrayView(node->inputs),\n                   cond_subgraph, cond_subgraph->inputs(), true));\n  TF_LITE_ENSURE_OK(context, cond_subgraph->AllocateTensors());\n  TfLiteTensor* cond_output =\n      cond_subgraph->tensor(cond_subgraph->outputs()[0]);\n  if (IsDynamicTensor(cond_output)) {\n    op_data->cond_has_dynamic_output_tensors = true;\n  } else {\n    TF_LITE_ENSURE_STATUS(CheckCondOutput(context, cond_output));\n  }\n  TF_LITE_ENSURE_OK(\n      context, CopyTensorsShapeAndType(\n                   context, this_subgraph, TfLiteIntArrayView(node->inputs),\n                   body_subgraph, body_subgraph->inputs(), true));\n  TF_LITE_ENSURE_OK(context, body_subgraph->AllocateTensors());\n  if (body_subgraph->HasDynamicTensors()) {\n    op_data->body_has_dynamic_output_tensors = true;\n  } else {\n    for (int i = 0; i < num_inputs; ++i) {\n      TfLiteTensor* body_input =\n          body_subgraph->tensor(body_subgraph->inputs()[i]);\n      TfLiteTensor* body_output =\n          body_subgraph->tensor(body_subgraph->outputs()[i]);\n      TF_LITE_ENSURE_TYPES_EQ(context, body_input->type, body_output->type);\n      TF_LITE_ENSURE(context, !IsDynamicTensor(body_output));\n      if (!TfLiteIntArrayEqual(body_input->dims, body_output->dims)) {\n        op_data->body_has_dynamic_output_tensors = true;\n        break;\n      }\n    }\n  }\n  for (int i = 0; i < num_inputs; ++i) {\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));\n    if (op_data->body_has_dynamic_output_tensors) {\n      SetTensorToDynamic(output);\n    } else {\n      TfLiteTensor* body_output =\n          body_subgraph->tensor(body_subgraph->outputs()[i]);\n      TfLiteIntArray* output_size = TfLiteIntArrayCopy(body_output->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, output, output_size));\n    }\n  }\n  return kTfLiteOk;\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn read_ipv4_addr(&mut self) -> Option<Ipv4Addr> {\n        self.read_atomically(|p| {\n            let mut groups = [0; 4];\n            for (i, slot) in groups.iter_mut().enumerate() {\n                *slot = p.read_separator('.', i, |p| p.read_number(10, None))?;\n            }\n            Some(groups.into())\n        })\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub(super) fn drop_remaining(&mut self) {\n        unsafe {\n            ptr::drop_in_place(self.as_mut_slice());\n        }\n        self.ptr = self.end;\n    }\n    pub(super) fn forget_allocation(&mut self) {\n        self.cap = 0;\n        self.buf = unsafe { NonNull::new_unchecked(RawVec::NEW.ptr()) };\n        self.ptr = self.buf.as_ptr();\n        self.end = self.buf.as_ptr();\n    }\ndefault fn from_iter(mut iterator: I) -> Self {\n        if mem::size_of::<T>() == 0\n            || mem::size_of::<T>()\n                != mem::size_of::<<<I as SourceIter>::Source as AsIntoIter>::Item>()\n            || mem::align_of::<T>()\n                != mem::align_of::<<<I as SourceIter>::Source as AsIntoIter>::Item>()\n        {\n            return SpecFromIterNested::from_iter(iterator);\n        }\n        let (src_buf, src_ptr, dst_buf, dst_end, cap) = unsafe {\n            let inner = iterator.as_inner().as_into_iter();\n            (\n                inner.buf.as_ptr(),\n                inner.ptr,\n                inner.buf.as_ptr() as *mut T,\n                inner.end as *const T,\n                inner.cap,\n            )\n        };\n        let len = SpecInPlaceCollect::collect_in_place(&mut iterator, dst_buf, dst_end);\n        let src = unsafe { iterator.as_inner().as_into_iter() };\n        debug_assert_eq!(src_buf, src.buf.as_ptr());\n        if src.ptr != src_ptr {\n            debug_assert!(\n                unsafe { dst_buf.add(len) as *const _ } <= src.ptr,\n                \"InPlaceIterable contract violation, write pointer advanced beyond read pointer\"\n            );\n        }\n        src.drop_remaining();\n        src.forget_allocation();\n        let vec = unsafe { Vec::from_raw_parts(dst_buf, len, cap) };\n        vec\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32)\n                                         -> Result<T, ParseIntError> {\n    use self::IntErrorKind::*;\n    use self::ParseIntError as PIE;\n    assert!(radix >= 2 && radix <= 36,\n           \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n           radix);\n    if src.is_empty() {\n        return Err(PIE { kind: Empty });\n    }\n    let is_signed_ty = T::from_u32(0) > T::min_value();\n    let src = src.as_bytes();\n    match (src[0], &src[1..])  {\n        (b'-', digits) if digits.is_empty() => Err(PIE { kind: Empty }),\n        (b'-', digits) if is_signed_ty => {\n            let mut result = T::from_u32(0);\n            for &c in digits {\n                let x = match (c as char).to_digit(radix) {\n                    Some(x) => x,\n                    None => return Err(PIE { kind: InvalidDigit }),\n                };\n                result = match result.checked_mul(radix) {\n                    Some(result) => result,\n                    None => return Err(PIE { kind: Underflow }),\n                };\n                result = match result.checked_sub(x) {\n                    Some(result) => result,\n                    None => return Err(PIE { kind: Underflow }),\n                };\n            }\n            Ok(result)\n        },\n        (c, digits) => {\n            let mut result = match (c as char).to_digit(radix) {\n                Some(x) => T::from_u32(x),\n                None => return Err(PIE { kind: InvalidDigit }),\n            };\n            for &c in digits {\n                let x = match (c as char).to_digit(radix) {\n                    Some(x) => x,\n                    None => return Err(PIE { kind: InvalidDigit }),\n                };\n                result = match result.checked_mul(radix) {\n                    Some(result) => result,\n                    None => return Err(PIE { kind: Overflow }),\n                };\n                result = match result.checked_add(x) {\n                    Some(result) => result,\n                    None => return Err(PIE { kind: Overflow }),\n                };\n            }\n            Ok(result)\n        }\n    }\n}\nPath\nVulnerable Function 2\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub async fn mksnap(handle: &CoreDB, con: &mut Connection, act: ActionGroup) -> TResult<()> {\n    let howmany = act.howmany();\n    if howmany == 0 {\n        if !handle.is_snapshot_enabled() {\n            let error = \"err-snapshot-disabled\";\n            con.write_response(GroupBegin(1)).await?;\n            let error = RespCodes::OtherError(Some(error.to_string()));\n            return con.write_response(error).await;\n        }\n        let mut was_engine_error = false;\n        let mut snap_result = None;\n        let mut engine_was_busy = false;\n        {\n            let snaphandle = handle.snapcfg.clone();\n            let snapstatus = (*snaphandle)\n                .as_ref()\n                .unwrap_or_else(|| unsafe { unreachable_unchecked() });\n            let snapengine = SnapshotEngine::new(snapstatus.max, &handle, None);\n            if snapengine.is_err() {\n                was_engine_error = true;\n            } else {\n                if snapstatus.is_busy() {\n                    engine_was_busy = true;\n                } else {\n                    let mut snapengine =\n                        snapengine.unwrap_or_else(|_| unsafe { unreachable_unchecked() });\n                    snap_result = snapengine.mksnap();\n                }\n            }\n        }\n        if was_engine_error {\n            return con\n                .write_response(responses::fresp::R_SERVER_ERR.to_owned())\n                .await;\n        }\n        if engine_was_busy {\n            con.write_response(GroupBegin(1)).await?;\n            let error = RespCodes::OtherError(Some(\"err-snapshot-busy\".to_owned()));\n            return con.write_response(error).await;\n        }\n        if let Some(succeeded) = snap_result {\n            if succeeded {\n                return con\n                    .write_response(responses::fresp::R_OKAY.to_owned())\n                    .await;\n            } else {\n                return con\n                    .write_response(responses::fresp::R_SERVER_ERR.to_owned())\n                    .await;\n            }\n        } else {\n            con.write_response(GroupBegin(1)).await?;\n            let error = RespCodes::OtherError(Some(\"err-access-after-termsig\".to_owned()));\n            return con.write_response(error).await;\n        }\n    } else {\n        if howmany == 1 {\n            let snapname = act\n                .get_ref()\n                .get(1)\n                .unwrap_or_else(|| unsafe { unreachable_unchecked() });\n            let mut path = PathBuf::from(DIR_SNAPSHOT);\n            path.push(\"remote\");\n            path.push(snapname.to_owned() + \".snapshot\");\n            let failed;\n            {\n                match diskstore::flush_data(&path, &handle.acquire_read().get_ref()) {\n                    Ok(_) => failed = false,\n                    Err(e) => {\n                        log::error!(\"Error while creating snapshot: {}\", e);\n                        failed = true;\n                    }\n                }\n            }\n            if failed {\n                return con\n                    .write_response(responses::fresp::R_SERVER_ERR.to_owned())\n                    .await;\n            } else {\n                return con\n                    .write_response(responses::fresp::R_OKAY.to_owned())\n                    .await;\n            }\n        } else {\n            return con\n                .write_response(responses::fresp::R_ACTION_ERR.to_owned())\n                .await;\n        }\n    }\n}\n    pub async fn run(&mut self) -> TResult<()> {\n        loop {\n            self.climit.acquire().await.forget();\n            let stream = self.accept().await?;\n            let mut chandle = CHandler {\n                db: self.db.clone(),\n                con: Connection::new(stream),\n                climit: self.climit.clone(),\n                terminator: Terminator::new(self.signal.subscribe()),\n                _term_sig_tx: self.terminate_tx.clone(),\n            };\n            tokio::spawn(async move {\n                if let Err(e) = chandle.run().await {\n                    eprintln!(\"Error: {}\", e);\n                }\n            });\n        }\n    }\n    async fn set_values<T>(\n        values_split_with_whitespace: T,\n        homwany: usize,\n        stream: &mut tokio::net::TcpStream,\n    ) where\n        T: AsRef<str>,\n    {\n        use tokio::prelude::*;\n        let mut query = String::from(\"MSET \");\n        query.push_str(values_split_with_whitespace.as_ref());\n        let count_bytes_len = homwany.to_string().as_bytes().len();\n        let q = libtdb::terrapipe::proc_query(query);\n        stream.write_all(&q).await.unwrap();\n        let res_should_be =\n            format!(\"#2\\n*1\\n#2\\n&1\\n:{}\\n{}\\n\", count_bytes_len, homwany).into_bytes();\n        let mut response = vec![0; res_should_be.len()];\n        stream.read_exact(&mut response).await.unwrap();\n        assert_eq!(response, res_should_be);\n    }\nfn main() {\n    benchtool::runner();\n}\nfn parse_dbtest(mut input: syn::ItemFn, rand: u16) -> Result<TokenStream, syn::Error> {\n    let sig = &mut input.sig;\n    let fname = sig.ident.to_string();\n    let body = &input.block;\n    let attrs = &input.attrs;\n    let vis = &input.vis;\n    let header = quote! {\n        #[::core::prelude::v1::test]\n    };\n    if sig.asyncness.is_none() {\n        let msg = \"`dbtest` functions need to be async\";\n        return Err(syn::Error::new_spanned(sig.fn_token, msg));\n    }\n    sig.asyncness = None;\n    let body = quote! {\n        let asyncdb = crate::coredb::CoreDB::new(\n            crate::config::BGSave::Disabled,\n            crate::config::SnapshotConfig::default(),\n            None\n        ).unwrap();\n        let addr = crate::tests::start_test_server(#rand, Some(asyncdb.clone())).await;\n        let mut stream = tokio::net::TcpStream::connect(&addr).await.unwrap();\n        #body\n        stream.shutdown(::std::net::Shutdown::Write).unwrap();\n        asyncdb.finish_db();\n        drop(asyncdb);\n    };\n    let result = quote! {\n        #header\n        #(#attrs)*\n        #vis #sig {\n            tokio::runtime::Builder::new_multi_thread()\n            .worker_threads(4)\n            .thread_name(#fname)\n            .thread_stack_size(3 * 1024 * 1024)\n            .enable_all()\n            .build()\n            .unwrap()\n            .block_on(async { #body });\n        }\n    };\n    Ok(result.into())\n}\nfn parse_test_module(args: TokenStream, item: TokenStream) -> TokenStream {\n    let input = syn::parse_macro_input!(item as syn::ItemMod);\n    let content = match input.content {\n        Some((_, c)) => c,\n        None => {\n            return syn::Error::new_spanned(&input, \"Couldn't get the module content\")\n                .to_compile_error()\n                .into()\n        }\n    };\n    let args = syn::parse_macro_input!(args as syn::AttributeArgs);\n    let mut skips = Vec::new();\n    for arg in args {\n        match arg {\n            syn::NestedMeta::Meta(syn::Meta::NameValue(namevalue)) => {\n                let ident = namevalue.path.get_ident();\n                if ident.is_none() {\n                    let msg = \"Must have specified ident\";\n                    return syn::Error::new_spanned(namevalue, msg)\n                        .to_compile_error()\n                        .into();\n                }\n                match ident.unwrap().to_string().to_lowercase().as_str() {\n                    \"skip\" => {\n                        let skip_lit = namevalue.lit.clone();\n                        let span = skip_lit.span();\n                        skips = match parse_string(skip_lit, span, \"skip\") {\n                            Ok(s) => s,\n                            Err(_) => {\n                                return syn::Error::new_spanned(\n                                    namevalue,\n                                    \"Expected a value for argument `skip`\",\n                                )\n                                .to_compile_error()\n                                .into();\n                            }\n                        }\n                        .split_whitespace()\n                        .map(|val| val.to_string())\n                        .collect();\n                    }\n                    x => {\n                        let msg = format!(\"Unknown attribute {} is specified; expected `skip`\", x);\n                        return syn::Error::new_spanned(namevalue, msg)\n                            .to_compile_error()\n                            .into();\n                    }\n                }\n            }\n            _ => (),\n        }\n    }\n    let modname = &input.ident;\n    if modname.to_string() != \"__private\" {\n        return syn::Error::new_spanned(\n            modname,\n            \"By convention, all the modules using the `dbtest` macro have to be called `__private`\",\n        )\n        .to_compile_error()\n        .into();\n    }\n    let mut rng = thread_rng();\n    let mut in_set = HashSet::<u16>::new();\n    let mut result = quote! {};\n    for item in content {\n        let mut rand: u16 = rng.gen_range(1025, 65535);\n        #[cfg(not(target_os = \"windows\"))]\n        {\n            while in_set.contains(&rand) {\n                rand = rng.gen_range(1025, 65535);\n            }\n        }\n        #[cfg(target_os = \"windows\")]\n        {\n            in_set.insert(5357);\n            in_set.insert(7680);\n            while in_set.contains(&rand) || (rand >= 49670 && rand <= 50293) {\n                rand = rng.gen_range(1025, 65535);\n            }\n        }\n        in_set.insert(rand);\n        match item {\n            syn::Item::Fn(function) => {\n                if skips.contains(&function.sig.ident.to_string()) {\n                    result = quote! {\n                        #result\n                        #function\n                    };\n                    continue;\n                }\n                let inp = parse_test_sig(function, rand);\n                let __tok: syn::ItemFn = syn::parse_macro_input!(inp as syn::ItemFn);\n                let tok = quote! {\n                    #__tok\n                };\n                result = quote! {\n                    #result\n                    #tok\n                };\n            }\n            token => {\n                result = quote! {\n                    #result\n                    #token\n                };\n            }\n        }\n    }\n    result.into()\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn retrieve_less_version() -> Option<usize> {\n    let cmd = Command::new(\"less\").arg(\"--version\").output().ok()?;\n    parse_less_version(&cmd.stdout)\n}\n    fn try_pager(\n        quit_if_one_screen: bool,\n        pager_from_config: Option<String>,\n        config: &config::Config,\n    ) -> Result<Self> {\n        let mut replace_arguments_to_less = false;\n        let pager_from_env = match (\n            env::var(\"DELTA_PAGER\"),\n            env::var(\"BAT_PAGER\"),\n            env::var(\"PAGER\"),\n        ) {\n            (Ok(delta_pager), _, _) => Some(delta_pager),\n            (_, Ok(bat_pager), _) => Some(bat_pager),\n            (_, _, Ok(pager)) => {\n                replace_arguments_to_less = true;\n                Some(pager)\n            }\n            _ => None,\n        };\n        if pager_from_config.is_some() {\n            replace_arguments_to_less = false;\n        }\n        let pager = pager_from_config\n            .or(pager_from_env)\n            .unwrap_or_else(|| String::from(\"less\"));\n        let pagerflags =\n            shell_words::split(&pager).chain_err(|| \"Could not parse pager command.\")?;\n        match pagerflags.split_first() {\n            Some((pager_name, args)) => {\n                let pager_path = PathBuf::from(pager_name);\n                let is_less = pager_path.file_stem() == Some(&OsString::from(\"less\"));\n                let mut process = if is_less {\n                    let mut p = Command::new(&pager_path);\n                    if args.is_empty() || replace_arguments_to_less {\n                        p.args(vec![\"--RAW-CONTROL-CHARS\"]);\n                        match retrieve_less_version() {\n                            None => {\n                                p.arg(\"--no-init\");\n                            }\n                            Some(version)\n                                if (version < 530 || (cfg!(windows) && version < 558)) =>\n                            {\n                                p.arg(\"--no-init\");\n                            }\n                            _ => {}\n                        }\n                        if quit_if_one_screen {\n                            p.arg(\"--quit-if-one-screen\");\n                        }\n                    } else {\n                        p.args(args);\n                    }\n                    p.env(\"LESSCHARSET\", \"UTF-8\");\n                    p\n                } else {\n                    if pager_path.file_stem() == Some(&OsString::from(\"delta\")) {\n                        eprintln!(\n                            \"\\\nIt looks like you have set delta as the value of $PAGER. \\\nThis would result in a non-terminating recursion. \\\ndelta is not an appropriate value for $PAGER \\\n(but it is an appropriate value for $GIT_PAGER).\"\n                        );\n                        std::process::exit(1);\n                    }\n                    let mut p = Command::new(&pager_path);\n                    p.args(args);\n                    p\n                };\n                if is_less && config.navigate {\n                    if let Ok(hist_file) =\n                        navigate::copy_less_hist_file_and_append_navigate_regexp(config)\n                    {\n                        process.env(\"LESSHISTFILE\", hist_file);\n                        if config.show_themes {\n                            process.arg(\"+n\");\n                        }\n                    }\n                }\n                Ok(process\n                    .env(\"LESSANSIENDCHARS\", \"mK\")\n                    .stdin(Stdio::piped())\n                    .spawn()\n                    .map(OutputType::Pager)\n                    .unwrap_or_else(|_| OutputType::stdout()))\n            }\n            None => Ok(OutputType::stdout()),\n        }\n    }\nfn diff(\n    minus_file: Option<&PathBuf>,\n    plus_file: Option<&PathBuf>,\n    config: &config::Config,\n    writer: &mut dyn Write,\n) -> i32 {\n    use std::io::BufReader;\n    let die = || {\n        eprintln!(\n            \"\\\nThe main way to use delta is to configure it as the pager for git: \\\nsee https://github.com/dandavison/delta#configuration. \\\nYou can also use delta to diff two files: `delta file_A file_B`.\"\n        );\n        process::exit(config.error_exit_code);\n    };\n    let diff_command = \"git\";\n    let minus_file = minus_file.unwrap_or_else(die);\n    let plus_file = plus_file.unwrap_or_else(die);\n    let mut diff_process = process::Command::new(PathBuf::from(diff_command))\n        .args(&[\"diff\", \"--no-index\"])\n        .args(&[minus_file, plus_file])\n        .stdout(process::Stdio::piped())\n        .spawn()\n        .unwrap_or_else(|err| {\n            eprintln!(\"Failed to execute the command '{}': {}\", diff_command, err);\n            process::exit(config.error_exit_code);\n        });\n    let exit_code = diff_process\n        .wait()\n        .unwrap_or_else(|_| {\n            delta_unreachable(&format!(\"'{}' process not running.\", diff_command));\n        })\n        .code()\n        .unwrap_or_else(|| {\n            eprintln!(\"'{}' process terminated without exit status.\", diff_command);\n            process::exit(config.error_exit_code);\n        });\n    if let Err(error) = delta(\n        BufReader::new(diff_process.stdout.unwrap()).byte_lines(),\n        writer,\n        &config,\n    ) {\n        match error.kind() {\n            ErrorKind::BrokenPipe => process::exit(0),\n            _ => {\n                eprintln!(\"{}\", error);\n                process::exit(config.error_exit_code);\n            }\n        }\n    };\n    exit_code\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn retrieve_less_version(less_path: &dyn AsRef<OsStr>) -> Option<usize> {\n    let cmd = Command::new(less_path).arg(\"--version\").output().ok()?;\n    parse_less_version(&cmd.stdout)\n}\n    fn try_pager(\n        single_screen_action: SingleScreenAction,\n        wrapping_mode: WrappingMode,\n        pager_from_config: Option<&str>,\n    ) -> Result<Self> {\n        use crate::pager::{self, PagerKind, PagerSource};\n        use std::process::{Command, Stdio};\n        let pager_opt =\n            pager::get_pager(pager_from_config).chain_err(|| \"Could not parse pager command.\")?;\n        let pager = match pager_opt {\n            Some(pager) => pager,\n            None => return Ok(OutputType::stdout()),\n        };\n        if pager.kind == PagerKind::Bat {\n            return Err(ErrorKind::InvalidPagerValueBat.into());\n        }\n        let mut p = Command::new(&pager.bin);\n        let args = pager.args;\n        if pager.kind == PagerKind::Less {\n            let replace_arguments_to_less = pager.source == PagerSource::EnvVarPager;\n            if args.is_empty() || replace_arguments_to_less {\n                p.arg(\"--RAW-CONTROL-CHARS\");\n                if single_screen_action == SingleScreenAction::Quit {\n                    p.arg(\"--quit-if-one-screen\");\n                }\n                if wrapping_mode == WrappingMode::NoWrapping(true) {\n                    p.arg(\"--chop-long-lines\");\n                }\n                match retrieve_less_version(&pager.bin) {\n                    None => {\n                        p.arg(\"--no-init\");\n                    }\n                    Some(version) if (version < 530 || (cfg!(windows) && version < 558)) => {\n                        p.arg(\"--no-init\");\n                    }\n                    _ => {}\n                }\n            } else {\n                p.args(args);\n            }\n            p.env(\"LESSCHARSET\", \"UTF-8\");\n        } else {\n            p.args(args);\n        };\n        Ok(p.stdin(Stdio::piped())\n            .spawn()\n            .map(OutputType::Pager)\n            .unwrap_or_else(|_| OutputType::stdout()))\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "    pub async fn run(&mut self) -> TResult<()> {\n        loop {\n            self.base.climit.acquire().await.unwrap().forget();\n            let stream = self.accept().await?;\n            let mut chandle = ConnectionHandler::new(\n                self.base.db.clone(),\n                Connection::new(stream),\n                self.base.climit.clone(),\n                Terminator::new(self.base.signal.subscribe()),\n                self.base.terminate_tx.clone(),\n            );\n            tokio::spawn(async move {\n                if let Err(e) = chandle.run().await {\n                    log::error!(\"Error: {}\", e);\n                }\n            });\n        }\n    }\n    pub async fn run(&mut self) -> TResult<()> {\n        loop {\n            self.base.climit.acquire().await.unwrap().forget();\n            let stream = self.accept().await?;\n            let mut sslhandle = ConnectionHandler::new(\n                self.base.db.clone(),\n                Connection::new(stream),\n                self.base.climit.clone(),\n                Terminator::new(self.base.signal.subscribe()),\n                self.base.terminate_tx.clone(),\n            );\n            tokio::spawn(async move {\n                if let Err(e) = sslhandle.run().await {\n                    log::error!(\"Error: {}\", e);\n                }\n            });\n        }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn write_ignition(\n    mountpoint: &Path,\n    digest_in: &Option<IgnitionHash>,\n    mut config_in: &File,\n) -> Result<()> {\n    eprintln!(\"Writing Ignition config\");\n    if let Some(ref digest) = digest_in {\n        digest\n            .validate(&mut config_in)\n            .context(\"failed to validate Ignition configuration digest\")?;\n        config_in\n            .seek(SeekFrom::Start(0))\n            .context(\"rewinding Ignition configuration file\")?;\n    };\n    let mut config_dest = mountpoint.to_path_buf();\n    config_dest.push(\"ignition\");\n    create_dir_all(&config_dest).context(\"creating Ignition config directory\")?;\n    config_dest.push(\"config.ign\");\n    let mut config_out = OpenOptions::new()\n        .write(true)\n        .create_new(true)\n        .open(&config_dest)\n        .with_context(|| {\n            format!(\n                \"opening destination Ignition config {}\",\n                config_dest.display()\n            )\n        })?;\n    copy(&mut config_in, &mut config_out).context(\"writing Ignition config\")?;\n    Ok(())\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn validate_unsigned(_source: TransactionSource, call: &Self::Call) -> TransactionValidity {\n\t\t\tif let Call::transact(transaction) = call {\n\t\t\t\tif let Some(chain_id) = transaction.signature.chain_id() {\n\t\t\t\t\tif chain_id != T::ChainId::get() {\n\t\t\t\t\t\treturn InvalidTransaction::Custom(\n\t\t\t\t\t\t\tTransactionValidationError::InvalidChainId as u8,\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.into();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet origin = Self::recover_signer(&transaction).ok_or_else(|| {\n\t\t\t\t\tInvalidTransaction::Custom(TransactionValidationError::InvalidSignature as u8)\n\t\t\t\t})?;\n\t\t\t\tif transaction.gas_limit >= T::BlockGasLimit::get() {\n\t\t\t\t\treturn InvalidTransaction::Custom(\n\t\t\t\t\t\tTransactionValidationError::InvalidGasLimit as u8,\n\t\t\t\t\t)\n\t\t\t\t\t.into();\n\t\t\t\t}\n\t\t\t\tlet account_data = pallet_evm::Pallet::<T>::account_basic(&origin);\n\t\t\t\tif transaction.nonce < account_data.nonce {\n\t\t\t\t\treturn InvalidTransaction::Stale.into();\n\t\t\t\t}\n\t\t\t\tlet fee = transaction.gas_price.saturating_mul(transaction.gas_limit);\n\t\t\t\tlet total_payment = transaction.value.saturating_add(fee);\n\t\t\t\tif account_data.balance < total_payment {\n\t\t\t\t\treturn InvalidTransaction::Payment.into();\n\t\t\t\t}\n\t\t\t\tlet min_gas_price = T::FeeCalculator::min_gas_price();\n\t\t\t\tif transaction.gas_price < min_gas_price {\n\t\t\t\t\treturn InvalidTransaction::Payment.into();\n\t\t\t\t}\n\t\t\t\tlet mut builder = ValidTransactionBuilder::default()\n\t\t\t\t\t.and_provides((origin, transaction.nonce))\n\t\t\t\t\t.priority(transaction.gas_price.unique_saturated_into());\n\t\t\t\tif transaction.nonce > account_data.nonce {\n\t\t\t\t\tif let Some(prev_nonce) = transaction.nonce.checked_sub(1.into()) {\n\t\t\t\t\t\tbuilder = builder.and_requires((origin, prev_nonce))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuilder.build()\n\t\t\t} else {\n\t\t\t\tErr(InvalidTransaction::Call.into())\n\t\t\t}\n\t\t}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "\tfn do_transact(source: H160, transaction: Transaction) -> DispatchResultWithPostInfo {\n\t\tlet transaction_hash =\n\t\t\tH256::from_slice(Keccak256::digest(&rlp::encode(&transaction)).as_slice());\n\t\tlet transaction_index = Pending::<T>::get().len() as u32;\n\t\tlet (to, _, info) = Self::execute(\n\t\t\tsource,\n\t\t\ttransaction.input.clone(),\n\t\t\ttransaction.value,\n\t\t\ttransaction.gas_limit,\n\t\t\tSome(transaction.gas_price),\n\t\t\tSome(transaction.nonce),\n\t\t\ttransaction.action,\n\t\t\tNone,\n\t\t)?;\n\t\tlet (reason, status, used_gas, dest) = match info {\n\t\t\tCallOrCreateInfo::Call(info) => (\n\t\t\t\tinfo.exit_reason,\n\t\t\t\tTransactionStatus {\n\t\t\t\t\ttransaction_hash,\n\t\t\t\t\ttransaction_index,\n\t\t\t\t\tfrom: source,\n\t\t\t\t\tto,\n\t\t\t\t\tcontract_address: None,\n\t\t\t\t\tlogs: info.logs.clone(),\n\t\t\t\t\tlogs_bloom: {\n\t\t\t\t\t\tlet mut bloom: Bloom = Bloom::default();\n\t\t\t\t\t\tSelf::logs_bloom(info.logs, &mut bloom);\n\t\t\t\t\t\tbloom\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tinfo.used_gas,\n\t\t\t\tto,\n\t\t\t),\n\t\t\tCallOrCreateInfo::Create(info) => (\n\t\t\t\tinfo.exit_reason,\n\t\t\t\tTransactionStatus {\n\t\t\t\t\ttransaction_hash,\n\t\t\t\t\ttransaction_index,\n\t\t\t\t\tfrom: source,\n\t\t\t\t\tto,\n\t\t\t\t\tcontract_address: Some(info.value),\n\t\t\t\t\tlogs: info.logs.clone(),\n\t\t\t\t\tlogs_bloom: {\n\t\t\t\t\t\tlet mut bloom: Bloom = Bloom::default();\n\t\t\t\t\t\tSelf::logs_bloom(info.logs, &mut bloom);\n\t\t\t\t\t\tbloom\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tinfo.used_gas,\n\t\t\t\tSome(info.value),\n\t\t\t),\n\t\t};\n\t\tlet receipt = ethereum::Receipt {\n\t\t\tstate_root: match reason {\n\t\t\t\tExitReason::Succeed(_) => H256::from_low_u64_be(1),\n\t\t\t\tExitReason::Error(_) => H256::from_low_u64_le(0),\n\t\t\t\tExitReason::Revert(_) => H256::from_low_u64_le(0),\n\t\t\t\tExitReason::Fatal(_) => H256::from_low_u64_le(0),\n\t\t\t},\n\t\t\tused_gas,\n\t\t\tlogs_bloom: status.clone().logs_bloom,\n\t\t\tlogs: status.clone().logs,\n\t\t};\n\t\tPending::<T>::append((transaction, status, receipt));\n\t\tSelf::deposit_event(Event::Executed(\n\t\t\tsource,\n\t\t\tdest.unwrap_or_default(),\n\t\t\ttransaction_hash,\n\t\t\treason,\n\t\t));\n\t\tOk(PostDispatchInfo {\n\t\t\tactual_weight: Some(T::GasWeightMapping::gas_to_weight(\n\t\t\t\tused_gas.unique_saturated_into(),\n\t\t\t)),\n\t\t\tpays_fee: Pays::No,\n\t\t})\n\t\t.into()\n\t}\npub fn ensure_ethereum_transaction<OuterOrigin>(o: OuterOrigin) -> Result<H160, &'static str>\nwhere\n\tOuterOrigin: Into<Result<RawOrigin, OuterOrigin>>,\n{\n\tmatch o.into() {\n\t\tOk(RawOrigin::EthereumTransaction(n)) => Ok(n),\n\t\t_ => Err(\"bad origin: expected to be an Ethereum transaction\"),\n\t}\n}\npub struct EnsureEthereumTransaction;\nimpl<O: Into<Result<RawOrigin, O>> + From<RawOrigin>> EnsureOrigin<O>\n\tfor EnsureEthereumTransaction\n{\n\ttype Success = H160;\n\tfn try_origin(o: O) -> Result<Self::Success, O> {\n\t\to.into().and_then(|o| match o {\n\t\t\tRawOrigin::EthereumTransaction(id) => Ok(id),\n\t\t})\n\t}\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\tfn successful_origin() -> O {\n\t\tO::from(RawOrigin::EthereumTransaction(Default::default()))\n\t}\n}\nimpl<T: Config> Call<T>\nwhere\n\tOriginFor<T>: Into<Result<RawOrigin, OriginFor<T>>>,\n{\n\tpub fn is_self_contained(&self) -> bool {\n\t\tmatch self {\n\t\t\tCall::transact(_) => true,\n\t\t\t_ => false,\n\t\t}\n\t}\n\tpub fn check_self_contained(&self) -> Option<Result<H160, TransactionValidityError>> {\n\t\tif let Call::transact(transaction) = self {\n\t\t\tlet check = || {\n\t\t\t\tlet origin = Pallet::<T>::recover_signer(&transaction).ok_or_else(|| {\n\t\t\t\t\tInvalidTransaction::Custom(TransactionValidationError::InvalidSignature as u8)\n\t\t\t\t})?;\n\t\t\t\tOk(origin)\n\t\t\t};\n\t\t\tSome(check())\n\t\t} else {\n\t\t\tNone\n\t\t}\n\t}\n\tpub fn validate_self_contained(&self, origin: &H160) -> Option<TransactionValidity> {\n\t\tif let Call::transact(transaction) = self {\n\t\t\tlet validate = || {\n\t\t\t\tlet mut gasometer = evm::gasometer::Gasometer::new(\n\t\t\t\t\ttransaction.gas_limit.low_u64(),\n\t\t\t\t\t<T as pallet_evm::Config>::config(),\n\t\t\t\t);\n\t\t\t\tlet transaction_cost = match transaction.action {\n\t\t\t\t\tTransactionAction::Call(_) => {\n\t\t\t\t\t\tevm::gasometer::call_transaction_cost(&transaction.input)\n\t\t\t\t\t}\n\t\t\t\t\tTransactionAction::Create => {\n\t\t\t\t\t\tevm::gasometer::create_transaction_cost(&transaction.input)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\tfn on_initialize(_: T::BlockNumber) -> Weight {\n\t\t\tPending::<T>::kill();\n\t\t\tif let Ok(log) = fp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()) {\n\t\t\t\tlet PreLog::Block(block) = log;\n\t\t\t\tfor transaction in block.transactions {\n\t\t\t\t\tlet source = Self::recover_signer(&transaction).expect(\n\t\t\t\t\t\t\"pre-block transaction signature invalid; the block cannot be built\",\n\t\t\t\t\t);\n\t\t\t\t\tSelf::do_transact(source, transaction).expect(\n\t\t\t\t\t\t\"pre-block transaction verification failed; the block cannot be built\",\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\t0\n\t\t}\n\t\tpub fn transact(\n\t\t\torigin: OriginFor<T>,\n\t\t\ttransaction: Transaction,\n\t\t) -> DispatchResultWithPostInfo {\n\t\t\tlet source = ensure_ethereum_transaction(origin)?;\n\t\t\tensure!(\n\t\t\t\tfp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()).is_err(),\n\t\t\t\tError::<T>::PreLogExists,\n\t\t\t);\n\t\t\tSelf::do_transact(source, transaction)\n\t\t}\nfn transaction_with_invalid_nonce_should_not_work() {\n\tlet (pairs, mut ext) = new_test_ext(1);\n\tlet alice = &pairs[0];\n\text.execute_with(|| {\n\t\tlet mut transaction = default_erc20_creation_unsigned_transaction();\n\t\ttransaction.nonce = U256::from(1);\n\t\tlet signed = transaction.sign(&alice.private_key);\n\t\tlet call = crate::Call::<Test>::transact(signed);\n\t\tlet source = call.check_self_contained().unwrap().unwrap();\n\t\tassert_eq!(\n\t\t\tcall.validate_self_contained(&source).unwrap(),\n\t\t\tValidTransactionBuilder::default()\n\t\t\t\t.and_provides((alice.address, U256::from(1)))\n\t\t\t\t.priority(1u64)\n\t\t\t\t.and_requires((alice.address, U256::from(0)))\n\t\t\t\t.build()\n\t\t);\n\t\tlet t = default_erc20_creation_transaction(alice);\n\t\tassert_ok!(Ethereum::execute(\n\t\t\talice.address,\n\t\t\tt.input,\n\t\t\tt.value,\n\t\t\tt.gas_limit,\n\t\t\tSome(t.gas_price),\n\t\t\tSome(t.nonce),\n\t\t\tt.action,\n\t\t\tNone,\n\t\t));\n\t\ttransaction.nonce = U256::from(0);\n\t\tlet signed2 = transaction.sign(&alice.private_key);\n\t\tlet call2 = crate::Call::<Test>::transact(signed2);\n\t\tlet source2 = call2.check_self_contained().unwrap().unwrap();\n\t\tassert_err!(\n\t\t\tcall2.validate_self_contained(&source2).unwrap(),\n\t\t\tInvalidTransaction::Stale\n\t\t);\n\t});\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn jumpi(state: &mut Machine) -> Control {\n\tpop_u256!(state, dest);\n\tpop!(state, value);\n\tlet dest = as_usize_or_fail!(dest, ExitError::InvalidJump);\n\tif value != H256::zero() {\n\t\tif state.valids.is_valid(dest) {\n\t\t\tControl::Jump(dest)\n\t\t} else {\n\t\t\tControl::Exit(ExitError::InvalidJump.into())\n\t\t}\n\t} else {\n\t\tControl::Continue(1)\n\t}\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "Status SparseCountSparseOutputShapeFn(InferenceContext *c) {\n  auto rank = c->Dim(c->input(0), 1);\n  auto nvals = c->UnknownDim();\n  c->set_output(0, c->Matrix(nvals, rank));  \n  c->set_output(1, c->Vector(nvals));        \n  c->set_output(2, c->Vector(rank));         \n  return Status::OK();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "    fn drop(&mut self) {\n        if self.needs_inst_drop {\n            unsafe {\n                let inst = self.inst.as_mut();\n                let region: Arc<dyn RegionInternal> = inst.alloc().region.clone();\n                std::ptr::drop_in_place(inst);\n                mem::drop(region);\n            }\n        }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "    pub fn clone_cstring_safely(out_ptr: *const c_char) -> Result<CString> {\n        if out_ptr.is_null() {\n            return_errno!(EINVAL, \"NULL address is invalid\");\n        }\n        let cstr = unsafe { CStr::from_ptr(out_ptr) };\n        let cstring = CString::from(cstr);\n        if !is_inside_user_space(out_ptr as *const u8, cstring.as_bytes().len()) {\n            return_errno!(EFAULT, \"the whole buffer is not in the user space\");\n        }\n        Ok(cstring)\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "export const marked = (markdownStr: string, blockParsers = blockElementParserList, inlineParsers = inlineElementParserList): string => {\n  for (const parser of blockParsers) {\n    const matchResult = parser.matcher(markdownStr);\n    if (!matchResult) {\n      continue;\n    }\n    const matchedStr = matchResult[0];\n    const retainContent = markdownStr.slice(matchedStr.length);\n    if (parser.name === \"br\") {\n      return parser.renderer(matchedStr) + marked(retainContent, blockParsers, inlineParsers);\n    } else {\n      if (retainContent === \"\") {\n        return parser.renderer(matchedStr);\n      } else if (retainContent.startsWith(\"\\n\")) {\n        return parser.renderer(matchedStr) + marked(retainContent.slice(1), blockParsers, inlineParsers);\n      }\n    }\n  }\n  let matchedInlineParser = undefined;\n  let matchedIndex = -1;\n  for (const parser of inlineParsers) {\n    const matchResult = parser.matcher(markdownStr);\n    if (!matchResult) {\n      continue;\n    }\n    if (parser.name === \"plain text\" && matchedInlineParser !== undefined) {\n      continue;\n    }\n    const startIndex = matchResult.index as number;\n    if (matchedInlineParser === undefined || matchedIndex > startIndex) {\n      matchedInlineParser = parser;\n      matchedIndex = startIndex;\n    }\n  }\n  if (matchedInlineParser) {\n    const matchResult = matchedInlineParser.matcher(markdownStr);\n    if (matchResult) {\n      const matchedStr = matchResult[0];\n      const matchedLength = matchedStr.length;\n      const prefixStr = markdownStr.slice(0, matchedIndex);\n      const suffixStr = markdownStr.slice(matchedIndex + matchedLength);\n      return prefixStr + matchedInlineParser.renderer(matchedStr) + marked(suffixStr, [], inlineParsers);\n    }\n  }\n  return markdownStr;\n};\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "export const marked = (markdownStr: string, blockParsers = blockElementParserList, inlineParsers = inlineElementParserList): string => {\n  for (const parser of blockParsers) {\n    const matchResult = parser.matcher(markdownStr);\n    if (!matchResult) {\n      continue;\n    }\n    const matchedStr = matchResult[0];\n    const retainContent = markdownStr.slice(matchedStr.length);\n    if (parser.name === \"br\") {\n      return parser.renderer(matchedStr) + marked(retainContent, blockParsers, inlineParsers);\n    } else {\n      if (retainContent === \"\") {\n        return parser.renderer(matchedStr);\n      } else if (retainContent.startsWith(\"\\n\")) {\n        return parser.renderer(matchedStr) + marked(retainContent.slice(1), blockParsers, inlineParsers);\n      }\n    }\n  }\n  let matchedInlineParser = undefined;\n  let matchedIndex = -1;\n  for (const parser of inlineParsers) {\n    const matchResult = parser.matcher(markdownStr);\n    if (!matchResult) {\n      continue;\n    }\n    if (parser.name === \"plain text\" && matchedInlineParser !== undefined) {\n      continue;\n    }\n    const startIndex = matchResult.index as number;\n    if (matchedInlineParser === undefined || matchedIndex > startIndex) {\n      matchedInlineParser = parser;\n      matchedIndex = startIndex;\n    }\n  }\n  if (matchedInlineParser) {\n    const matchResult = matchedInlineParser.matcher(markdownStr);\n    if (matchResult) {\n      const matchedStr = matchResult[0];\n      const matchedLength = matchedStr.length;\n      const prefixStr = markdownStr.slice(0, matchedIndex);\n      const suffixStr = markdownStr.slice(matchedIndex + matchedLength);\n      return prefixStr + matchedInlineParser.renderer(matchedStr) + marked(suffixStr, [], inlineParsers);\n    }\n  }\n  return markdownStr;\n};\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "export const marked = (markdownStr: string, blockParsers = blockElementParserList, inlineParsers = inlineElementParserList): string => {\n  for (const parser of blockParsers) {\n    const matchResult = parser.matcher(markdownStr);\n    if (!matchResult) {\n      continue;\n    }\n    const matchedStr = matchResult[0];\n    const retainContent = markdownStr.slice(matchedStr.length);\n    if (parser.name === \"br\") {\n      return parser.renderer(matchedStr) + marked(retainContent, blockParsers, inlineParsers);\n    } else {\n      if (retainContent === \"\") {\n        return parser.renderer(matchedStr);\n      } else if (retainContent.startsWith(\"\\n\")) {\n        return parser.renderer(matchedStr) + marked(retainContent.slice(1), blockParsers, inlineParsers);\n      }\n    }\n  }\n  let matchedInlineParser = undefined;\n  let matchedIndex = -1;\n  for (const parser of inlineParsers) {\n    const matchResult = parser.matcher(markdownStr);\n    if (!matchResult) {\n      continue;\n    }\n    if (parser.name === \"plain text\" && matchedInlineParser !== undefined) {\n      continue;\n    }\n    const startIndex = matchResult.index as number;\n    if (matchedInlineParser === undefined || matchedIndex > startIndex) {\n      matchedInlineParser = parser;\n      matchedIndex = startIndex;\n    }\n  }\n  if (matchedInlineParser) {\n    const matchResult = matchedInlineParser.matcher(markdownStr);\n    if (matchResult) {\n      const matchedStr = matchResult[0];\n      const matchedLength = matchedStr.length;\n      const prefixStr = markdownStr.slice(0, matchedIndex);\n      const suffixStr = markdownStr.slice(matchedIndex + matchedLength);\n      return prefixStr + matchedInlineParser.renderer(matchedStr) + marked(suffixStr, [], inlineParsers);\n    }\n  }\n  return markdownStr;\n};\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn calculate_gas_cost(\n\tbase_length: u64,\n\texp_length: u64,\n\tmod_length: u64,\n\texponent: &BigUint,\n) -> u64 {\n\tfn calculate_multiplication_complexity(base_length: u64, mod_length: u64) -> u64 {\n\t\tlet max_length = max(base_length, mod_length);\n\t\tlet mut words = max_length / 8;\n\t\tif max_length % 8 > 0 {\n\t\t\twords += 1;\n\t\t}\n\t\twords * words\n\t}\n\tfn calculate_iteration_count(exp_length: u64, exponent: &BigUint) -> u64 {\n\t\tlet mut iteration_count: u64 = 0;\n\t\tif exp_length <= 32 && exponent.is_zero() {\n\t\t\titeration_count = 0;\n\t\t} else if exp_length <= 32 {\n\t\t\titeration_count = exponent.bits() - 1;\n\t\t} else if exp_length > 32 {\n\t\t\tlet bytes: [u8; 32] = [0xFF; 32];\n\t\t\tlet max_256_bit_uint = BigUint::from_bytes_be(&bytes);\n\t\t\titeration_count =\n\t\t\t\t(8 * (exp_length - 32)) + ((exponent.bitand(max_256_bit_uint)).bits() - 1);\n\t\t}\n\t\tmax(iteration_count, 1)\n\t}\n\tlet multiplication_complexity = calculate_multiplication_complexity(base_length, mod_length);\n\tlet iteration_count = calculate_iteration_count(exp_length, exponent);\n\tlet gas = max(\n\t\tMIN_GAS_COST,\n\t\tmultiplication_complexity * iteration_count / 3,\n\t);\n\tgas\n}\n\tfn calculate_iteration_count(exp_length: u64, exponent: &BigUint) -> u64 {\n\t\tlet mut iteration_count: u64 = 0;\n\t\tif exp_length <= 32 && exponent.is_zero() {\n\t\t\titeration_count = 0;\n\t\t} else if exp_length <= 32 {\n\t\t\titeration_count = exponent.bits() - 1;\n\t\t} else if exp_length > 32 {\n\t\t\tlet bytes: [u8; 32] = [0xFF; 32];\n\t\t\tlet max_256_bit_uint = BigUint::from_bytes_be(&bytes);\n\t\t\titeration_count =\n\t\t\t\t(8 * (exp_length - 32)) + ((exponent.bitand(max_256_bit_uint)).bits() - 1);\n\t\t}\n\t\tmax(iteration_count, 1)\n\t}\n\tfn calculate_multiplication_complexity(base_length: u64, mod_length: u64) -> u64 {\n\t\tlet max_length = max(base_length, mod_length);\n\t\tlet mut words = max_length / 8;\n\t\tif max_length % 8 > 0 {\n\t\t\twords += 1;\n\t\t}\n\t\twords * words\n\t}\n\tfn execute(\n\t\tinput: &[u8],\n\t\ttarget_gas: Option<u64>,\n\t\t_context: &Context,\n\t\t_is_static: bool,\n\t) -> PrecompileResult {\n\t\tif input.len() < 96 {\n\t\t\treturn Err(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"input must contain at least 96 bytes\".into()),\n\t\t\t});\n\t\t};\n\t\tlet max_size_big = BigUint::from_u32(1024).expect(\"can't create BigUint\");\n\t\tlet mut buf = [0; 32];\n\t\tbuf.copy_from_slice(&input[0..32]);\n\t\tlet base_len_big = BigUint::from_bytes_be(&buf);\n\t\tif base_len_big > max_size_big {\n\t\t\treturn Err(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"unreasonably large base length\".into()),\n\t\t\t});\n\t\t}\n\t\tbuf.copy_from_slice(&input[32..64]);\n\t\tlet exp_len_big = BigUint::from_bytes_be(&buf);\n\t\tif exp_len_big > max_size_big {\n\t\t\treturn Err(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"unreasonably large exponent length\".into()),\n\t\t\t});\n\t\t}\n\t\tbuf.copy_from_slice(&input[64..96]);\n\t\tlet mod_len_big = BigUint::from_bytes_be(&buf);\n\t\tif mod_len_big > max_size_big {\n\t\t\treturn Err(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"unreasonably large exponent length\".into()),\n\t\t\t});\n\t\t}\n\t\tlet base_len = base_len_big.to_usize().expect(\"base_len out of bounds\");\n\t\tlet exp_len = exp_len_big.to_usize().expect(\"exp_len out of bounds\");\n\t\tlet mod_len = mod_len_big.to_usize().expect(\"mod_len out of bounds\");\n\t\tlet total_len = base_len + exp_len + mod_len + 96;\n\t\tif input.len() < total_len {\n\t\t\treturn Err(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"insufficient input size\".into()),\n\t\t\t});\n\t\t}\n\t\tlet (r, gas_cost) = if base_len == 0 && mod_len == 0 {\n\t\t\t(BigUint::zero(), MIN_GAS_COST)\n\t\t} else {\n\t\t\tlet base_start = 96; \n\t\t\tlet base = BigUint::from_bytes_be(&input[base_start..base_start + base_len]);\n\t\t\tlet exp_start = base_start + base_len;\n\t\t\tlet exponent = BigUint::from_bytes_be(&input[exp_start..exp_start + exp_len]);\n\t\t\tlet gas_cost =\n\t\t\t\tcalculate_gas_cost(base_len as u64, exp_len as u64, mod_len as u64, &exponent);\n\t\t\tif let Some(gas_left) = target_gas {\n\t\t\t\tif gas_left < gas_cost {\n\t\t\t\t\treturn Err(PrecompileFailure::Error {\n\t\t\t\t\t\texit_status: ExitError::OutOfGas,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t\tlet mod_start = exp_start + exp_len;\n\t\t\tlet modulus = BigUint::from_bytes_be(&input[mod_start..mod_start + mod_len]);\n\t\t\tif modulus.is_zero() || modulus.is_one() {\n\t\t\t\t(BigUint::zero(), gas_cost)\n\t\t\t} else {\n\t\t\t\t(base.modpow(&exponent, &modulus), gas_cost)\n\t\t\t}\n\t\t};\n\t\tlet bytes = r.to_bytes_be();\n\t\tif bytes.len() == mod_len {\n\t\t\tOk(PrecompileOutput {\n\t\t\t\texit_status: ExitSucceed::Returned,\n\t\t\t\tcost: gas_cost,\n\t\t\t\toutput: bytes.to_vec(),\n\t\t\t\tlogs: Default::default(),\n\t\t\t})\n\t\t} else if bytes.len() < mod_len {\n\t\t\tlet mut ret = Vec::with_capacity(mod_len);\n\t\t\tret.extend(core::iter::repeat(0).take(mod_len - bytes.len()));\n\t\t\tret.extend_from_slice(&bytes[..]);\n\t\t\tOk(PrecompileOutput {\n\t\t\t\texit_status: ExitSucceed::Returned,\n\t\t\t\tcost: gas_cost,\n\t\t\t\toutput: ret.to_vec(),\n\t\t\t\tlogs: Default::default(),\n\t\t\t})\n\t\t} else {\n\t\t\tErr(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"failed\".into()),\n\t\t\t})\n\t\t}\n\t}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn emit_muldivmod<E: UserDefinedError>(jit: &mut JitCompiler, opc: u8, src: u8, dst: u8, imm: Option<i64>) -> Result<(), EbpfError<E>> {\n    let mul = (opc & ebpf::BPF_ALU_OP_MASK) == (ebpf::MUL32_IMM & ebpf::BPF_ALU_OP_MASK);\n    let div = (opc & ebpf::BPF_ALU_OP_MASK) == (ebpf::DIV32_IMM & ebpf::BPF_ALU_OP_MASK);\n    let sdiv = (opc & ebpf::BPF_ALU_OP_MASK) == (ebpf::SDIV32_IMM & ebpf::BPF_ALU_OP_MASK);\n    let modrm = (opc & ebpf::BPF_ALU_OP_MASK) == (ebpf::MOD32_IMM & ebpf::BPF_ALU_OP_MASK);\n    let size = if (opc & ebpf::BPF_CLS_MASK) == ebpf::BPF_ALU64 { OperandSize::S64 } else { OperandSize::S32 };\n    let sdiv_anchor =  if sdiv { TARGET_PC_LOCAL_ANCHOR - jit.offset_in_text_section } else { 0 };\n    if (div || sdiv || modrm) && imm.is_none() {\n        X86Instruction::load_immediate(OperandSize::S64, R11, jit.pc as i64).emit(jit)?;\n        X86Instruction::test(size, src, src, None).emit(jit)?; \n        emit_jcc(jit, 0x84, TARGET_PC_DIV_BY_ZERO)?;\n    }\n    if sdiv && imm.unwrap_or(-1) == -1 {\n        if imm.is_none() {\n            X86Instruction::cmp_immediate(size, src, -1, None).emit(jit)?;\n            emit_jcc(jit, 0x85, sdiv_anchor)?;\n        }\n        X86Instruction::load_immediate(size, R11, if size == OperandSize::S64 { i64::MIN } else { i32::MIN as i64 }).emit(jit)?;\n        X86Instruction::cmp(size, dst, R11, None).emit(jit)?;\n        emit_jcc(jit, 0x85, sdiv_anchor)?;\n        X86Instruction::load_immediate(OperandSize::S64, R11, jit.pc as i64).emit(jit)?;\n        emit_jmp(jit, TARGET_PC_DIV_OVERFLOW)?;\n    }\n    if sdiv {\n        set_anchor(jit, sdiv_anchor);\n    }\n    if dst != RAX {\n        X86Instruction::push(RAX, None).emit(jit)?;\n    }\n    if dst != RDX {\n        X86Instruction::push(RDX, None).emit(jit)?;\n    }\n    if let Some(imm) = imm {\n        if should_sanitize_constant(jit, imm) {\n            emit_sanitized_load_immediate(jit, OperandSize::S64, R11, imm)?;\n        } else {\n            X86Instruction::load_immediate(OperandSize::S64, R11, imm).emit(jit)?;\n        }\n    } else {\n        X86Instruction::mov(OperandSize::S64, src, R11).emit(jit)?;\n    }\n    if dst != RAX {\n        X86Instruction::mov(OperandSize::S64, dst, RAX).emit(jit)?;\n    }\n    if div || modrm {\n        emit_alu(jit, size, 0x31, RDX, RDX, 0, None)?;\n    } else if sdiv {\n        X86Instruction {\n            size,\n            opcode: 0x99,\n            modrm: false,\n            ..X86Instruction::default()\n        }.emit(jit)?;\n    }\n    emit_alu(jit, size, 0xf7, if mul { 4 } else if sdiv { 7 } else { 6 }, R11, 0, None)?;\n    if dst != RDX {\n        if modrm {\n            X86Instruction::mov(OperandSize::S64, RDX, dst).emit(jit)?;\n        }\n        X86Instruction::pop(RDX).emit(jit)?;\n    }\n    if dst != RAX {\n        if div || sdiv || mul {\n            X86Instruction::mov(OperandSize::S64, RAX, dst).emit(jit)?;\n        }\n        X86Instruction::pop(RAX).emit(jit)?;\n    }\n    if size == OperandSize::S32 && opc & ebpf::BPF_ALU_OP_MASK == ebpf::BPF_MUL {\n        X86Instruction::sign_extend_i32_to_i64(dst, dst).emit(jit)?;\n    }\n    Ok(())\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "  void Compute(OpKernelContext* context) override {\n    const Tensor& rhs = context->input(1);\n    context->forward_ref_input_to_ref_output(0, 0);\n    AllocatorAttributes attr;\n    if (!relax_constraints_) {\n      attr.set_gpu_compatible(true);\n      attr.set_nic_compatible(true);\n    }\n    {\n      mutex_lock l(*context->input_ref_mutex(0));\n      const Tensor& old_lhs = context->mutable_input(0,  true);\n      const bool same_shape = old_lhs.shape().IsSameSize(rhs.shape());\n      if (validate_shape_) {\n        OP_REQUIRES(context, same_shape,\n                    errors::InvalidArgument(\n                        \"Assign requires shapes of both tensors to match. \"\n                        \"lhs shape= \",\n                        old_lhs.shape().DebugString(),\n                        \" rhs shape= \", rhs.shape().DebugString()));\n      }\n      if (old_lhs.IsInitialized() &&\n          old_lhs.shape().num_elements() == rhs.shape().num_elements()) {\n        Tensor reshaped_old_lhs;\n        if (same_shape) {\n          reshaped_old_lhs = old_lhs;\n        } else {\n          CHECK(reshaped_old_lhs.CopyFrom(old_lhs, rhs.shape()));\n          context->replace_ref_input(0, reshaped_old_lhs,\n                                      true);\n        }\n        if (use_exclusive_lock_) {\n          Copy(context, &reshaped_old_lhs, rhs);\n          return;\n        }\n      } else {\n        std::unique_ptr<Tensor> input_alias = context->forward_input(\n            1, OpKernelContext::Params::kNoReservation ,\n            rhs.dtype(), rhs.shape(), DEVICE_MEMORY, attr);\n        if (input_alias != nullptr) {\n          context->replace_ref_input(0, *input_alias,  true);\n          return;\n        }\n        Tensor copy_tensor;\n        OP_REQUIRES_OK(context,\n                       context->allocate_temp(old_lhs.dtype(), rhs.shape(),\n                                              &copy_tensor, attr));\n        context->clear_recorded_memory();\n        context->replace_ref_input(0, copy_tensor,  true);\n        if (use_exclusive_lock_) {\n          Copy(context, &copy_tensor, rhs);\n          return;\n        }\n      }\n    }\n    Tensor old_unlocked_lhs = context->mutable_input(0,  false);\n    Copy(context, &old_unlocked_lhs, rhs);\n  }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn fetch_add(&self, val: $t) -> $t {\n                let a = unsafe { &*(self.value.get() as *const $atomic) };\n                a.fetch_add(val, Ordering::AcqRel)\n            }\npub fn fetch_sub(&self, val: $t) -> $t {\n                let a = unsafe { &*(self.value.get() as *const $atomic) };\n                a.fetch_sub(val, Ordering::AcqRel)\n            }\npub fn fetch_and(&self, val: $t) -> $t {\n                let a = unsafe { &*(self.value.get() as *const $atomic) };\n                a.fetch_and(val, Ordering::AcqRel)\n            }\npub fn fetch_or(&self, val: $t) -> $t {\n                let a = unsafe { &*(self.value.get() as *const $atomic) };\n                a.fetch_or(val, Ordering::AcqRel)\n            }\npub fn fetch_xor(&self, val: $t) -> $t {\n                let a = unsafe { &*(self.value.get() as *const $atomic) };\n                a.fetch_xor(val, Ordering::AcqRel)\n            }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "    fn c(&mut self, expr: &Hir) -> ResultOrEmpty {\n        use crate::prog;\n        use regex_syntax::hir::HirKind::*;\n        self.check_size()?;\n        match *expr.kind() {\n            Empty => Ok(None),\n            Literal(hir::Literal::Unicode(c)) => self.c_char(c),\n            Literal(hir::Literal::Byte(b)) => {\n                assert!(self.compiled.uses_bytes());\n                self.c_byte(b)\n            }\n            Class(hir::Class::Unicode(ref cls)) => self.c_class(cls.ranges()),\n            Class(hir::Class::Bytes(ref cls)) => {\n                if self.compiled.uses_bytes() {\n                    self.c_class_bytes(cls.ranges())\n                } else {\n                    assert!(cls.is_all_ascii());\n                    let mut char_ranges = vec![];\n                    for r in cls.iter() {\n                        let (s, e) = (r.start() as char, r.end() as char);\n                        char_ranges.push(hir::ClassUnicodeRange::new(s, e));\n                    }\n                    self.c_class(&char_ranges)\n                }\n            }\n            Anchor(hir::Anchor::StartLine) if self.compiled.is_reverse => {\n                self.byte_classes.set_range(b'\\n', b'\\n');\n                self.c_empty_look(prog::EmptyLook::EndLine)\n            }\n            Anchor(hir::Anchor::StartLine) => {\n                self.byte_classes.set_range(b'\\n', b'\\n');\n                self.c_empty_look(prog::EmptyLook::StartLine)\n            }\n            Anchor(hir::Anchor::EndLine) if self.compiled.is_reverse => {\n                self.byte_classes.set_range(b'\\n', b'\\n');\n                self.c_empty_look(prog::EmptyLook::StartLine)\n            }\n            Anchor(hir::Anchor::EndLine) => {\n                self.byte_classes.set_range(b'\\n', b'\\n');\n                self.c_empty_look(prog::EmptyLook::EndLine)\n            }\n            Anchor(hir::Anchor::StartText) if self.compiled.is_reverse => {\n                self.c_empty_look(prog::EmptyLook::EndText)\n            }\n            Anchor(hir::Anchor::StartText) => {\n                self.c_empty_look(prog::EmptyLook::StartText)\n            }\n            Anchor(hir::Anchor::EndText) if self.compiled.is_reverse => {\n                self.c_empty_look(prog::EmptyLook::StartText)\n            }\n            Anchor(hir::Anchor::EndText) => {\n                self.c_empty_look(prog::EmptyLook::EndText)\n            }\n            WordBoundary(hir::WordBoundary::Unicode) => {\n                if !cfg!(feature = \"unicode-perl\") {\n                    return Err(Error::Syntax(\n                        \"Unicode word boundaries are unavailable when \\\n                         the unicode-perl feature is disabled\"\n                            .to_string(),\n                    ));\n                }\n                self.compiled.has_unicode_word_boundary = true;\n                self.byte_classes.set_word_boundary();\n                self.byte_classes.set_range(0, 0x7F);\n                self.c_empty_look(prog::EmptyLook::WordBoundary)\n            }\n            WordBoundary(hir::WordBoundary::UnicodeNegate) => {\n                if !cfg!(feature = \"unicode-perl\") {\n                    return Err(Error::Syntax(\n                        \"Unicode word boundaries are unavailable when \\\n                         the unicode-perl feature is disabled\"\n                            .to_string(),\n                    ));\n                }\n                self.compiled.has_unicode_word_boundary = true;\n                self.byte_classes.set_word_boundary();\n                self.byte_classes.set_range(0, 0x7F);\n                self.c_empty_look(prog::EmptyLook::NotWordBoundary)\n            }\n            WordBoundary(hir::WordBoundary::Ascii) => {\n                self.byte_classes.set_word_boundary();\n                self.c_empty_look(prog::EmptyLook::WordBoundaryAscii)\n            }\n            WordBoundary(hir::WordBoundary::AsciiNegate) => {\n                self.byte_classes.set_word_boundary();\n                self.c_empty_look(prog::EmptyLook::NotWordBoundaryAscii)\n            }\n            Group(ref g) => match g.kind {\n                hir::GroupKind::NonCapturing => self.c(&g.hir),\n                hir::GroupKind::CaptureIndex(index) => {\n                    if index as usize >= self.compiled.captures.len() {\n                        self.compiled.captures.push(None);\n                    }\n                    self.c_capture(2 * index as usize, &g.hir)\n                }\n                hir::GroupKind::CaptureName { index, ref name } => {\n                    if index as usize >= self.compiled.captures.len() {\n                        let n = name.to_string();\n                        self.compiled.captures.push(Some(n.clone()));\n                        self.capture_name_idx.insert(n, index as usize);\n                    }\n                    self.c_capture(2 * index as usize, &g.hir)\n                }\n            },\n            Concat(ref es) => {\n                if self.compiled.is_reverse {\n                    self.c_concat(es.iter().rev())\n                } else {\n                    self.c_concat(es)\n                }\n            }\n            Alternation(ref es) => self.c_alternate(&**es),\n            Repetition(ref rep) => self.c_repeat(rep),\n        }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "    pub fn emit(\n        &self,\n    ) -> (\n        MachBuffer<I>,\n        Vec<CodeOffset>,\n        Vec<(CodeOffset, CodeOffset)>,\n    )\n    where\n        I: MachInstEmit,\n    {\n        let _tt = timing::vcode_emit();\n        let mut buffer = MachBuffer::new();\n        let mut state = I::State::new(&*self.abi);\n        let cfg_metadata = self.flags().machine_code_cfg_info();\n        let mut bb_starts: Vec<Option<CodeOffset>> = vec![];\n        buffer.reserve_labels_for_blocks(self.num_blocks() as BlockIndex);\n        buffer.reserve_labels_for_constants(&self.constants);\n        let mut inst_end_offsets = vec![0; self.insts.len()];\n        let mut label_inst_indices = vec![0; self.num_blocks()];\n        let mut final_order: SmallVec<[BlockIndex; 16]> = smallvec![];\n        let mut cold_blocks: SmallVec<[BlockIndex; 16]> = smallvec![];\n        for block in 0..self.num_blocks() {\n            let block = block as BlockIndex;\n            if self.block_order.is_cold(block) {\n                cold_blocks.push(block);\n            } else {\n                final_order.push(block);\n            }\n        }\n        let first_cold_block = cold_blocks.first().cloned();\n        final_order.extend(cold_blocks.clone());\n        let mut safepoint_idx = 0;\n        let mut cur_srcloc = None;\n        let mut last_offset = None;\n        let mut start_of_cold_code = None;\n        for block in final_order {\n            let new_offset = I::align_basic_block(buffer.cur_offset());\n            while new_offset > buffer.cur_offset() {\n                let nop = I::gen_nop((new_offset - buffer.cur_offset()) as usize);\n                nop.emit(&mut buffer, &self.emit_info, &mut Default::default());\n            }\n            assert_eq!(buffer.cur_offset(), new_offset);\n            if Some(block) == first_cold_block {\n                start_of_cold_code = Some(buffer.cur_offset());\n            }\n            let (start, end) = self.block_ranges[block as usize];\n            buffer.bind_label(MachLabel::from_block(block));\n            label_inst_indices[block as usize] = start;\n            if cfg_metadata {\n                let cur_offset = buffer.cur_offset();\n                if last_offset.is_some() && cur_offset <= last_offset.unwrap() {\n                    for i in (0..bb_starts.len()).rev() {\n                        if bb_starts[i].is_some() && cur_offset > bb_starts[i].unwrap() {\n                            break;\n                        }\n                        bb_starts[i] = None;\n                    }\n                }\n                bb_starts.push(Some(cur_offset));\n                last_offset = Some(cur_offset);\n            }\n            for iix in start..end {\n                let srcloc = self.srclocs[iix as usize];\n                if cur_srcloc != Some(srcloc) {\n                    if cur_srcloc.is_some() {\n                        buffer.end_srcloc();\n                    }\n                    buffer.start_srcloc(srcloc);\n                    cur_srcloc = Some(srcloc);\n                }\n                state.pre_sourceloc(cur_srcloc.unwrap_or(SourceLoc::default()));\n                if safepoint_idx < self.safepoint_insns.len()\n                    && self.safepoint_insns[safepoint_idx] == iix\n                {\n                    if self.safepoint_slots[safepoint_idx].len() > 0 {\n                        let stack_map = self.abi.spillslots_to_stack_map(\n                            &self.safepoint_slots[safepoint_idx][..],\n                            &state,\n                        );\n                        state.pre_safepoint(stack_map);\n                    }\n                    safepoint_idx += 1;\n                }\n                self.insts[iix as usize].emit(&mut buffer, &self.emit_info, &mut state);\n                if self.generate_debug_info {\n                    let l = &mut inst_end_offsets[0..iix as usize];\n                    for end in l.iter_mut().rev() {\n                        if *end > buffer.cur_offset() {\n                            *end = buffer.cur_offset();\n                        } else {\n                            break;\n                        }\n                    }\n                    inst_end_offsets[iix as usize] = buffer.cur_offset();\n                }\n            }\n            if cur_srcloc.is_some() {\n                buffer.end_srcloc();\n                cur_srcloc = None;\n            }\n            if block < (self.num_blocks() - 1) as BlockIndex {\n                let next_block = block + 1;\n                let next_block_range = self.block_ranges[next_block as usize];\n                let next_block_size = next_block_range.1 - next_block_range.0;\n                let worst_case_next_bb = I::worst_case_size() * next_block_size;\n                if buffer.island_needed(worst_case_next_bb) {\n                    buffer.emit_island(worst_case_next_bb);\n                }\n            }\n        }\n        for (constant, data) in self.constants.iter() {\n            let label = buffer.get_label_for_constant(constant);\n            buffer.defer_constant(label, data.alignment(), data.as_slice(), u32::max_value());\n        }\n        if self.generate_debug_info {\n            for end in inst_end_offsets.iter_mut().rev() {\n                if *end > buffer.cur_offset() {\n                    *end = buffer.cur_offset();\n                } else {\n                    break;\n                }\n            }\n            *self.insts_layout.borrow_mut() = InstsLayoutInfo {\n                inst_end_offsets,\n                label_inst_indices,\n                start_of_cold_code,\n            };\n        }\n        let mut final_bb_starts = vec![];\n        let mut bb_edges = vec![];\n        if cfg_metadata {\n            for block in 0..self.num_blocks() {\n                if bb_starts[block].is_none() {\n                    continue;\n                }\n                let from = bb_starts[block].unwrap();\n                final_bb_starts.push(from);\n                let succs = self.block_succs(BlockIx::new(block as u32));\n                for succ in succs.iter() {\n                    let to = buffer.resolve_label_offset(MachLabel::from_block(succ.get()));\n                    bb_edges.push((from, to));\n                }\n            }\n        }\n        (buffer, final_bb_starts, bb_edges)\n    }\nfn pass_funcref_in_and_out_of_wasm() -> anyhow::Result<()> {\n    let (mut store, module) = ref_types_module(\n        r#\"\n            (module\n                (func (export \"func\") (param funcref) (result funcref)\n                    local.get 0\n                )\n            )\n        \"#,\n    )?;\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let func = instance.get_func(&mut store, \"func\").unwrap();\n    {\n        let mut results = [Val::I32(0)];\n        func.call(\n            &mut store,\n            &[Val::FuncRef(Some(func.clone()))],\n            &mut results,\n        )?;\n        let result_func = results[0].unwrap_funcref().unwrap();\n        assert_eq!(func.ty(&store), result_func.ty(&store));\n    }\n    {\n        let mut results = [Val::I32(0)];\n        func.call(&mut store, &[Val::FuncRef(None)], &mut results)?;\n        let result_func = results[0].unwrap_funcref();\n        assert!(result_func.is_none());\n    }\n    {\n        let other_instance = Instance::new(&mut store, &module, &[])?;\n        let other_instance_func = other_instance.get_func(&mut store, \"func\").unwrap();\n        let mut results = [Val::I32(0)];\n        func.call(\n            &mut store,\n            &[Val::FuncRef(Some(other_instance_func.clone()))],\n            &mut results,\n        )?;\n        assert_eq!(results.len(), 1);\n        let result_func = results[0].unwrap_funcref().unwrap();\n        assert_eq!(other_instance_func.ty(&store), result_func.ty(&store));\n    }\n    {\n        let (mut other_store, other_module) = ref_types_module(r#\"(module (func (export \"f\")))\"#)?;\n        let other_store_instance = Instance::new(&mut other_store, &other_module, &[])?;\n        let f = other_store_instance\n            .get_func(&mut other_store, \"f\")\n            .unwrap();\n        assert!(func\n            .call(&mut store, &[Val::FuncRef(Some(f))], &mut [Val::I32(0)])\n            .is_err());\n    }\n    Ok(())\n}\nfn many_live_refs() -> anyhow::Result<()> {\n    let mut wat = r#\"\n        (module\n            ;; Make new `externref`s.\n            (import \"\" \"make_ref\" (func $make_ref (result externref)))\n            ;; Observe an `externref` so it is kept live.\n            (import \"\" \"observe_ref\" (func $observe_ref (param externref)))\n            (func (export \"many_live_refs\")\n    \"#\n    .to_string();\n    const NUM_LIVE_REFS: usize = 1024;\n    for _ in 0..NUM_LIVE_REFS {\n        wat.push_str(\"(call $make_ref)\\n\");\n    }\n    for _ in 0..NUM_LIVE_REFS {\n        wat.push_str(\"(call $observe_ref)\\n\");\n    }\n    wat.push_str(\n        \"\n            ) ;; func\n        ) ;; module\n        \",\n    );\n    let (mut store, module) = ref_types_module(&wat)?;\n    let live_refs = Arc::new(AtomicUsize::new(0));\n    let make_ref = Func::wrap(&mut store, {\n        let live_refs = live_refs.clone();\n        move || Some(ExternRef::new(CountLiveRefs::new(live_refs.clone())))\n    });\n    let observe_ref = Func::wrap(&mut store, |r: Option<ExternRef>| {\n        let r = r.unwrap();\n        let r = r.data().downcast_ref::<CountLiveRefs>().unwrap();\n        assert!(r.live_refs.load(SeqCst) > 0);\n    });\n    let instance = Instance::new(&mut store, &module, &[make_ref.into(), observe_ref.into()])?;\n    let many_live_refs = instance.get_func(&mut store, \"many_live_refs\").unwrap();\n    many_live_refs.call(&mut store, &[], &mut [])?;\n    store.gc();\n    assert_eq!(live_refs.load(SeqCst), 0);\n    return Ok(());\n    struct CountLiveRefs {\n        live_refs: Arc<AtomicUsize>,\n    }\n    impl CountLiveRefs {\n        fn new(live_refs: Arc<AtomicUsize>) -> Self {\n            live_refs.fetch_add(1, SeqCst);\n            Self { live_refs }\n        }\n    }\n    impl Drop for CountLiveRefs {\n        fn drop(&mut self) {\n            self.live_refs.fetch_sub(1, SeqCst);\n        }\n    }\n}\npub(crate) fn ref_types_module(\n    source: &str,\n) -> anyhow::Result<(wasmtime::Store<()>, wasmtime::Module)> {\n    use wasmtime::*;\n    let _ = env_logger::try_init();\n    let mut config = Config::new();\n    config.wasm_reference_types(true);\n    let engine = Engine::new(&config)?;\n    let store = Store::new(&engine, ());\n    let module = Module::new(&engine, source)?;\n    Ok((store, module))\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "static int somfy_iohc_decode(r_device *decoder, bitbuffer_t *bitbuffer)\n{\n    uint8_t const preamble_pattern[] = {0x57, 0xfd, 0x99};\n    uint8_t b[19 + 15]; \n    if (bitbuffer->num_rows != 1)\n        return DECODE_ABORT_EARLY;\n    int offset = bitbuffer_search(bitbuffer, 0, 0, preamble_pattern, 24) + 24;\n    if (offset >= bitbuffer->bits_per_row[0] - 19 * 10)\n        return DECODE_ABORT_EARLY;\n    int num_bits = bitbuffer->bits_per_row[0] - offset;\n    int len = extract_bytes_uart(bitbuffer->bb[0], offset, num_bits, b);\n    if (len < 19)\n        return DECODE_ABORT_LENGTH;\n    if ((b[0] & 0xf0) != 0xf0)\n        return DECODE_ABORT_EARLY;\n    int msg_len = b[0] & 0xf; \n    if (len < 19 + msg_len)\n        return DECODE_ABORT_LENGTH;\n    if (crc16lsb(b, len, 0x8408, 0x0000) != 0) \n        return DECODE_FAIL_MIC;\n    bitrow_printf(b, len * 8, \"%s: offset %d, num_bits %d, len %d, msg_len %d\\n\", __func__, offset, num_bits, len, msg_len);\n    int msg_type = (b[0]);\n    int dst_id   = ((unsigned)b[4] << 24) | (b[3] << 16) | (b[2] << 8) | (b[1]); \n    int src_id   = ((unsigned)b[8] << 24) | (b[7] << 16) | (b[6] << 8) | (b[5]); \n    int counter  = (b[len - 10] << 8) | (b[len - 9]);\n    char msg_str[15 * 2 + 1];\n    bitrow_snprint(&b[9], msg_len * 8, msg_str, 15 * 2 + 1);\n    char mac_str[13];\n    bitrow_snprint(&b[len - 8], 6 * 8, mac_str, 13);\n    data_t *data = data_make(\n            \"model\",            \"\",                 DATA_STRING, \"Somfy-IOHC\",\n            \"id\",               \"\",                 DATA_FORMAT, \"%08x\", DATA_INT, src_id,\n            \"dst_id\",           \"Dest ID\",          DATA_FORMAT, \"%08x\", DATA_INT, dst_id,\n            \"msg_type\",         \"Msg type\",         DATA_FORMAT, \"%02x\", DATA_INT, msg_type,\n            \"msg\",              \"Message\",          DATA_STRING, msg_str,\n            \"counter\",          \"Counter\",          DATA_INT,    counter,\n            \"mac\",              \"MAC\",              DATA_STRING, mac_str,\n            \"mic\",              \"Integrity\",        DATA_STRING, \"CRC\",\n            NULL);\n    decoder_output_data(decoder, data);\n    return 1;\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "static int somfy_iohc_decode(r_device *decoder, bitbuffer_t *bitbuffer)\n{\n    uint8_t const preamble_pattern[] = {0x57, 0xfd, 0x99};\n    uint8_t b[19 + 15]; \n    if (bitbuffer->num_rows != 1)\n        return DECODE_ABORT_EARLY;\n    int offset = bitbuffer_search(bitbuffer, 0, 0, preamble_pattern, 24) + 24;\n    if (offset >= bitbuffer->bits_per_row[0] - 19 * 10)\n        return DECODE_ABORT_EARLY;\n    int num_bits = bitbuffer->bits_per_row[0] - offset;\n    int len = extract_bytes_uart(bitbuffer->bb[0], offset, num_bits, b);\n    if (len < 19)\n        return DECODE_ABORT_LENGTH;\n    if ((b[0] & 0xf0) != 0xf0)\n        return DECODE_ABORT_EARLY;\n    int msg_len = b[0] & 0xf; \n    if (len < 19 + msg_len)\n        return DECODE_ABORT_LENGTH;\n    if (crc16lsb(b, len, 0x8408, 0x0000) != 0) \n        return DECODE_FAIL_MIC;\n    bitrow_printf(b, len * 8, \"%s: offset %d, num_bits %d, len %d, msg_len %d\\n\", __func__, offset, num_bits, len, msg_len);\n    int msg_type = (b[0]);\n    int dst_id   = ((unsigned)b[4] << 24) | (b[3] << 16) | (b[2] << 8) | (b[1]); \n    int src_id   = ((unsigned)b[8] << 24) | (b[7] << 16) | (b[6] << 8) | (b[5]); \n    int counter  = (b[len - 10] << 8) | (b[len - 9]);\n    char msg_str[15 * 2 + 1];\n    bitrow_snprint(&b[9], msg_len * 8, msg_str, 15 * 2 + 1);\n    char mac_str[13];\n    bitrow_snprint(&b[len - 8], 6 * 8, mac_str, 13);\n    data_t *data = data_make(\n            \"model\",            \"\",                 DATA_STRING, \"Somfy-IOHC\",\n            \"id\",               \"\",                 DATA_FORMAT, \"%08x\", DATA_INT, src_id,\n            \"dst_id\",           \"Dest ID\",          DATA_FORMAT, \"%08x\", DATA_INT, dst_id,\n            \"msg_type\",         \"Msg type\",         DATA_FORMAT, \"%02x\", DATA_INT, msg_type,\n            \"msg\",              \"Message\",          DATA_STRING, msg_str,\n            \"counter\",          \"Counter\",          DATA_INT,    counter,\n            \"mac\",              \"MAC\",              DATA_STRING, mac_str,\n            \"mic\",              \"Integrity\",        DATA_STRING, \"CRC\",\n            NULL);\n    decoder_output_data(decoder, data);\n    return 1;\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "async fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let args = set_command_line_args().get_matches();\n    env::set_var(\"RUST_LOG\", \"swhkd=warn\");\n    if args.is_present(\"debug\") {\n        env::set_var(\"RUST_LOG\", \"swhkd=trace\");\n    }\n    env_logger::init();\n    log::trace!(\"Logger initialized.\");\n    let pidfile: String = String::from(\"/tmp/swhkd.pid\");\n    if Path::new(&pidfile).exists() {\n        log::trace!(\"Reading {} file and checking for running instances.\", pidfile);\n        let swhkd_pid = match fs::read_to_string(&pidfile) {\n            Ok(swhkd_pid) => swhkd_pid,\n            Err(e) => {\n                log::error!(\"Unable to read {} to check all running instances\", e);\n                exit(1);\n            }\n        };\n        log::debug!(\"Previous PID: {}\", swhkd_pid);\n        let mut sys = System::new_all();\n        sys.refresh_all();\n        for (pid, process) in sys.processes() {\n            if pid.to_string() == swhkd_pid && process.exe() == env::current_exe().unwrap() {\n                log::error!(\"Swhkd is already running!\");\n                log::error!(\"pid of existing swhkd process: {}\", pid.to_string());\n                log::error!(\"To close the existing swhkd process, run `sudo killall swhkd`\");\n                exit(1);\n            }\n        }\n    }\n    match fs::write(&pidfile, id().to_string()) {\n        Ok(_) => {}\n        Err(e) => {\n            log::error!(\"Unable to write to {}: {}\", pidfile, e);\n            exit(1);\n        }\n    }\n    if check_user_permissions().is_err() {\n        exit(1);\n    }\n    let load_config = || {\n        seteuid(env::var(\"PKEXEC_UID\").unwrap().parse::<u32>().unwrap()); \n        let config_file_path: std::path::PathBuf = if args.is_present(\"config\") {\n            Path::new(args.value_of(\"config\").unwrap()).to_path_buf()\n        } else {\n            fetch_xdg_config_path()\n        };\n        log::debug!(\"Using config file path: {:#?}\", config_file_path);\n        let hotkeys = match config::load(&config_file_path) {\n            Err(e) => {\n                log::error!(\"Config Error: {}\", e);\n                exit(1);\n            }\n            Ok(out) => out,\n        };\n        for hotkey in &hotkeys {\n            log::debug!(\"hotkey: {:#?}\", hotkey);\n        }\n        hotkeys\n    };\n    let mut hotkeys = load_config();\n    seteuid(0); \n    log::trace!(\"Attempting to find all keyboard file descriptors.\");\n    let keyboard_devices: Vec<Device> =\n        evdev::enumerate().filter(check_device_is_keyboard).collect();\n    let mut uinput_device = match uinput::create_uinput_device() {\n        Ok(dev) => dev,\n        Err(e) => {\n            log::error!(\"Err: {:#?}\", e);\n            exit(1);\n        }\n    };\n    if keyboard_devices.is_empty() {\n        log::error!(\"No valid keyboard device was detected!\");\n        exit(1);\n    }\n    log::debug!(\"{} Keyboard device(s) detected.\", keyboard_devices.len());\n    let modifiers_map: HashMap<Key, config::Modifier> = HashMap::from([\n        (Key::KEY_LEFTMETA, config::Modifier::Super),\n        (Key::KEY_RIGHTMETA, config::Modifier::Super),\n        (Key::KEY_LEFTMETA, config::Modifier::Super),\n        (Key::KEY_RIGHTMETA, config::Modifier::Super),\n        (Key::KEY_LEFTALT, config::Modifier::Alt),\n        (Key::KEY_RIGHTALT, config::Modifier::Alt),\n        (Key::KEY_LEFTCTRL, config::Modifier::Control),\n        (Key::KEY_RIGHTCTRL, config::Modifier::Control),\n        (Key::KEY_LEFTSHIFT, config::Modifier::Shift),\n        (Key::KEY_RIGHTSHIFT, config::Modifier::Shift),\n    ]);\n    let repeat_cooldown_duration: u64 = if args.is_present(\"cooldown\") {\n        args.value_of(\"cooldown\").unwrap().parse::<u64>().unwrap()\n    } else {\n        250\n    };\n    let mut signals = Signals::new(&[\n        SIGUSR1, SIGUSR2, SIGHUP, SIGABRT, SIGBUS, SIGCHLD, SIGCONT, SIGINT, SIGPIPE, SIGQUIT,\n        SIGSYS, SIGTERM, SIGTRAP, SIGTSTP, SIGVTALRM, SIGXCPU, SIGXFSZ,\n    ])?;\n    let mut execution_is_paused = false;\n    let mut last_hotkey: Option<config::Hotkey> = None;\n    let mut pending_release: bool = false;\n    let mut keyboard_states: Vec<KeyboardState> = Vec::new();\n    let mut keyboard_stream_map = StreamMap::new();\n    for (i, mut device) in keyboard_devices.into_iter().enumerate() {\n        let _ = device.grab();\n        keyboard_stream_map.insert(i, device.into_event_stream()?);\n        keyboard_states.push(KeyboardState::new());\n    }\n    let hotkey_repeat_timer = sleep(Duration::from_millis(0));\n    tokio::pin!(hotkey_repeat_timer);\n    loop {\n        select! {\n            _ = &mut hotkey_repeat_timer, if &last_hotkey.is_some() => {\n                let hotkey = last_hotkey.clone().unwrap();\n                if hotkey.keybinding.on_release {\n                    continue;\n                }\n                send_command(hotkey.clone());\n                hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));\n            }\n            Some(signal) = signals.next() => {\n                match signal {\n                    SIGUSR1 => {\n                        execution_is_paused = true;\n                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {\n                            let _ = device.ungrab();\n                        }\n                    }\n                    SIGUSR2 => {\n                        execution_is_paused = false;\n                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {\n                            let _ = device.grab();\n                        }\n                    }\n                    SIGHUP => {\n                        hotkeys = load_config();\n                    }\n                    SIGINT => {\n                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {\n                            let _ = device.ungrab();\n                        }\n                        log::warn!(\"Received SIGINT signal, exiting...\");\n                        exit(1);\n                    }\n                    _ => {\n                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {\n                            let _ = device.ungrab();\n                        }\n                        log::warn!(\"Received signal: {:#?}\", signal);\n                        log::warn!(\"Exiting...\");\n                        exit(1);\n                    }\n                }\n            }\n            Some((i, Ok(event))) = keyboard_stream_map.next() => {\n                let keyboard_state = &mut keyboard_states[i];\n                let key = match event.kind() {\n                    InputEventKind::Key(keycode) => keycode,\n                    _ => continue\n                };\n                match event.value() {\n                    1 => {\n                        if let Some(modifier) = modifiers_map.get(&key) {\n                            keyboard_state.state_modifiers.insert(*modifier);\n                        } else {\n                            keyboard_state.state_keysyms.insert(key);\n                        }\n                    }\n                    0 => {\n                        if last_hotkey.is_some() && pending_release {\n                            pending_release = false;\n                            send_command(last_hotkey.clone().unwrap());\n                            last_hotkey = None;\n                        }\n                        if let Some(modifier) = modifiers_map.get(&key) {\n                            if let Some(hotkey) = &last_hotkey {\n                                if hotkey.modifiers().contains(modifier) {\n                                    last_hotkey = None;\n                                }\n                            }\n                            keyboard_state.state_modifiers.remove(modifier);\n                        } else if keyboard_state.state_keysyms.contains(key) {\n                            if let Some(hotkey) = &last_hotkey {\n                                if key == hotkey.keysym() {\n                                    last_hotkey = None;\n                                }\n                            }\n                            keyboard_state.state_keysyms.remove(key);\n                        }\n                    }\n                    _ => {}\n                }\n                let possible_hotkeys: Vec<&config::Hotkey> = hotkeys.iter()\n                    .filter(|hotkey| hotkey.modifiers().len() == keyboard_state.state_modifiers.len())\n                    .collect();\n                let event_in_hotkeys = hotkeys.iter().any(|hotkey| {\n                    hotkey.keysym().code() == event.code() &&\n                    keyboard_state.state_modifiers\n                        .iter()\n                        .all(|x| hotkey.modifiers().contains(x)) &&\n                    keyboard_state.state_modifiers.len() == hotkey.modifiers().len()\n                    && !hotkey.is_send()\n                        });\n                if !event_in_hotkeys {\n                    uinput_device.emit(&[event]).unwrap();\n                }\n                if execution_is_paused || possible_hotkeys.is_empty() || last_hotkey.is_some() {\n                    continue;\n                }\n                log::debug!(\"state_modifiers: {:#?}\", keyboard_state.state_modifiers);\n                log::debug!(\"state_keysyms: {:#?}\", keyboard_state.state_keysyms);\n                log::debug!(\"hotkey: {:#?}\", possible_hotkeys);\n                for hotkey in possible_hotkeys {\n                    if keyboard_state.state_modifiers.iter().all(|x| hotkey.modifiers().contains(x))\n                        && keyboard_state.state_modifiers.len() == hotkey.modifiers().len()\n                        && keyboard_state.state_keysyms.contains(hotkey.keysym())\n                    {\n                        last_hotkey = Some(hotkey.clone());\n                        if pending_release { break; }\n                        if hotkey.is_on_release() {\n                            pending_release = true;\n                            break;\n                        }\n                        send_command(hotkey.clone());\n                        hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn main() -> std::io::Result<()> {\n    env::set_var(\"RUST_LOG\", \"swhks=trace\");\n    env_logger::init();\n    let pid_file_path = String::from(\"/tmp/swhks.pid\");\n    let sock_file_path = String::from(format!(\"/run/user/{}/swhkd.sock\", unistd::Uid::current()));\n    if Path::new(&pid_file_path).exists() {\n        log::trace!(\"Reading {} file and checking for running instances.\", pid_file_path);\n        let swhkd_pid = match fs::read_to_string(&pid_file_path) {\n            Ok(swhkd_pid) => swhkd_pid,\n            Err(e) => {\n                log::error!(\"Unable to read {} to check all running instances\", e);\n                exit(1);\n            }\n        };\n        log::debug!(\"Previous PID: {}\", swhkd_pid);\n        let mut sys = System::new_all();\n        sys.refresh_all();\n        for (pid, process) in sys.processes() {\n            if pid.to_string() == swhkd_pid && process.exe() == env::current_exe().unwrap() {\n                log::error!(\"Server is already running!\");\n                exit(1);\n            }\n        }\n    }\n    if Path::new(&sock_file_path).exists() {\n        log::trace!(\"Sockfile exists, attempting to remove it.\");\n        match fs::remove_file(&sock_file_path) {\n            Ok(_) => {\n                log::debug!(\"Removed old socket file\");\n            }\n            Err(e) => {\n                log::error!(\"Error removing the socket file!: {}\", e);\n                log::error!(\"You can manually remove the socket file: {}\", sock_file_path);\n                exit(1);\n            }\n        };\n    }\n    match fs::write(&pid_file_path, id().to_string()) {\n        Ok(_) => {}\n        Err(e) => {\n            log::error!(\"Unable to write to {}: {}\", pid_file_path, e);\n            exit(1);\n        }\n    }\n    let listener = UnixListener::bind(sock_file_path)?;\n    loop {\n        match listener.accept() {\n            Ok((mut socket, address)) => {\n                let mut response = String::new();\n                socket.read_to_string(&mut response)?;\n                run_system_command(&response);\n                log::debug!(\"Socket: {:?} Address: {:?} Response: {}\", socket, address, response);\n            }\n            Err(e) => log::error!(\"accept function failed: {:?}\", e),\n        }\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "async fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let args = set_command_line_args().get_matches();\n    env::set_var(\"RUST_LOG\", \"swhkd=warn\");\n    if args.is_present(\"debug\") {\n        env::set_var(\"RUST_LOG\", \"swhkd=trace\");\n    }\n    env_logger::init();\n    log::trace!(\"Logger initialized.\");\n    let pidfile: String = String::from(\"/tmp/swhkd.pid\");\n    if Path::new(&pidfile).exists() {\n        log::trace!(\"Reading {} file and checking for running instances.\", pidfile);\n        let swhkd_pid = match fs::read_to_string(&pidfile) {\n            Ok(swhkd_pid) => swhkd_pid,\n            Err(e) => {\n                log::error!(\"Unable to read {} to check all running instances\", e);\n                exit(1);\n            }\n        };\n        log::debug!(\"Previous PID: {}\", swhkd_pid);\n        let mut sys = System::new_all();\n        sys.refresh_all();\n        for (pid, process) in sys.processes() {\n            if pid.to_string() == swhkd_pid && process.exe() == env::current_exe().unwrap() {\n                log::error!(\"Swhkd is already running!\");\n                log::error!(\"pid of existing swhkd process: {}\", pid.to_string());\n                log::error!(\"To close the existing swhkd process, run `sudo killall swhkd`\");\n                exit(1);\n            }\n        }\n    }\n    match fs::write(&pidfile, id().to_string()) {\n        Ok(_) => {}\n        Err(e) => {\n            log::error!(\"Unable to write to {}: {}\", pidfile, e);\n            exit(1);\n        }\n    }\n    if check_user_permissions().is_err() {\n        exit(1);\n    }\n    let load_config = || {\n        seteuid(env::var(\"PKEXEC_UID\").unwrap().parse::<u32>().unwrap()); \n        let config_file_path: std::path::PathBuf = if args.is_present(\"config\") {\n            Path::new(args.value_of(\"config\").unwrap()).to_path_buf()\n        } else {\n            fetch_xdg_config_path()\n        };\n        log::debug!(\"Using config file path: {:#?}\", config_file_path);\n        if !config_file_path.exists() {\n            log::error!(\"{:#?} doesn't exist\", config_file_path);\n            exit(1);\n        }\n        let hotkeys = match config::load(&config_file_path) {\n            Err(e) => {\n                log::error!(\"Config Error: {}\", e);\n                exit(1);\n            }\n            Ok(out) => out,\n        };\n        for hotkey in &hotkeys {\n            log::debug!(\"hotkey: {:#?}\", hotkey);\n        }\n        hotkeys\n    };\n    let mut hotkeys = load_config();\n    seteuid(0); \n    log::trace!(\"Attempting to find all keyboard file descriptors.\");\n    let keyboard_devices: Vec<Device> =\n        evdev::enumerate().filter(check_device_is_keyboard).collect();\n    let mut uinput_device = match uinput::create_uinput_device() {\n        Ok(dev) => dev,\n        Err(e) => {\n            log::error!(\"Err: {:#?}\", e);\n            exit(1);\n        }\n    };\n    if keyboard_devices.is_empty() {\n        log::error!(\"No valid keyboard device was detected!\");\n        exit(1);\n    }\n    log::debug!(\"{} Keyboard device(s) detected.\", keyboard_devices.len());\n    let modifiers_map: HashMap<Key, config::Modifier> = HashMap::from([\n        (Key::KEY_LEFTMETA, config::Modifier::Super),\n        (Key::KEY_RIGHTMETA, config::Modifier::Super),\n        (Key::KEY_LEFTMETA, config::Modifier::Super),\n        (Key::KEY_RIGHTMETA, config::Modifier::Super),\n        (Key::KEY_LEFTALT, config::Modifier::Alt),\n        (Key::KEY_RIGHTALT, config::Modifier::Alt),\n        (Key::KEY_LEFTCTRL, config::Modifier::Control),\n        (Key::KEY_RIGHTCTRL, config::Modifier::Control),\n        (Key::KEY_LEFTSHIFT, config::Modifier::Shift),\n        (Key::KEY_RIGHTSHIFT, config::Modifier::Shift),\n    ]);\n    let repeat_cooldown_duration: u64 = if args.is_present(\"cooldown\") {\n        args.value_of(\"cooldown\").unwrap().parse::<u64>().unwrap()\n    } else {\n        250\n    };\n    let mut signals = Signals::new(&[\n        SIGUSR1, SIGUSR2, SIGHUP, SIGABRT, SIGBUS, SIGCHLD, SIGCONT, SIGINT, SIGPIPE, SIGQUIT,\n        SIGSYS, SIGTERM, SIGTRAP, SIGTSTP, SIGVTALRM, SIGXCPU, SIGXFSZ,\n    ])?;\n    let mut execution_is_paused = false;\n    let mut last_hotkey: Option<config::Hotkey> = None;\n    let mut pending_release: bool = false;\n    let mut keyboard_states: Vec<KeyboardState> = Vec::new();\n    let mut keyboard_stream_map = StreamMap::new();\n    for (i, mut device) in keyboard_devices.into_iter().enumerate() {\n        let _ = device.grab();\n        keyboard_stream_map.insert(i, device.into_event_stream()?);\n        keyboard_states.push(KeyboardState::new());\n    }\n    let hotkey_repeat_timer = sleep(Duration::from_millis(0));\n    tokio::pin!(hotkey_repeat_timer);\n    loop {\n        select! {\n            _ = &mut hotkey_repeat_timer, if &last_hotkey.is_some() => {\n                let hotkey = last_hotkey.clone().unwrap();\n                if hotkey.keybinding.on_release {\n                    continue;\n                }\n                send_command(hotkey.clone());\n                hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));\n            }\n            Some(signal) = signals.next() => {\n                match signal {\n                    SIGUSR1 => {\n                        execution_is_paused = true;\n                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {\n                            let _ = device.ungrab();\n                        }\n                    }\n                    SIGUSR2 => {\n                        execution_is_paused = false;\n                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {\n                            let _ = device.grab();\n                        }\n                    }\n                    SIGHUP => {\n                        hotkeys = load_config();\n                    }\n                    SIGINT => {\n                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {\n                            let _ = device.ungrab();\n                        }\n                        log::warn!(\"Received SIGINT signal, exiting...\");\n                        exit(1);\n                    }\n                    _ => {\n                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {\n                            let _ = device.ungrab();\n                        }\n                        log::warn!(\"Received signal: {:#?}\", signal);\n                        log::warn!(\"Exiting...\");\n                        exit(1);\n                    }\n                }\n            }\n            Some((i, Ok(event))) = keyboard_stream_map.next() => {\n                let keyboard_state = &mut keyboard_states[i];\n                let key = match event.kind() {\n                    InputEventKind::Key(keycode) => keycode,\n                    _ => continue\n                };\n                match event.value() {\n                    1 => {\n                        if let Some(modifier) = modifiers_map.get(&key) {\n                            keyboard_state.state_modifiers.insert(*modifier);\n                        } else {\n                            keyboard_state.state_keysyms.insert(key);\n                        }\n                    }\n                    0 => {\n                        if last_hotkey.is_some() && pending_release {\n                            pending_release = false;\n                            send_command(last_hotkey.clone().unwrap());\n                            last_hotkey = None;\n                        }\n                        if let Some(modifier) = modifiers_map.get(&key) {\n                            if let Some(hotkey) = &last_hotkey {\n                                if hotkey.modifiers().contains(modifier) {\n                                    last_hotkey = None;\n                                }\n                            }\n                            keyboard_state.state_modifiers.remove(modifier);\n                        } else if keyboard_state.state_keysyms.contains(key) {\n                            if let Some(hotkey) = &last_hotkey {\n                                if key == hotkey.keysym() {\n                                    last_hotkey = None;\n                                }\n                            }\n                            keyboard_state.state_keysyms.remove(key);\n                        }\n                    }\n                    _ => {}\n                }\n                let possible_hotkeys: Vec<&config::Hotkey> = hotkeys.iter()\n                    .filter(|hotkey| hotkey.modifiers().len() == keyboard_state.state_modifiers.len())\n                    .collect();\n                let event_in_hotkeys = hotkeys.iter().any(|hotkey| {\n                    hotkey.keysym().code() == event.code() &&\n                    keyboard_state.state_modifiers\n                        .iter()\n                        .all(|x| hotkey.modifiers().contains(x)) &&\n                    keyboard_state.state_modifiers.len() == hotkey.modifiers().len()\n                    && !hotkey.is_send()\n                        });\n                if !event_in_hotkeys {\n                    uinput_device.emit(&[event]).unwrap();\n                }\n                if execution_is_paused || possible_hotkeys.is_empty() || last_hotkey.is_some() {\n                    continue;\n                }\n                log::debug!(\"state_modifiers: {:#?}\", keyboard_state.state_modifiers);\n                log::debug!(\"state_keysyms: {:#?}\", keyboard_state.state_keysyms);\n                log::debug!(\"hotkey: {:#?}\", possible_hotkeys);\n                for hotkey in possible_hotkeys {\n                    if keyboard_state.state_modifiers.iter().all(|x| hotkey.modifiers().contains(x))\n                        && keyboard_state.state_modifiers.len() == hotkey.modifiers().len()\n                        && keyboard_state.state_keysyms.contains(hotkey.keysym())\n                    {\n                        last_hotkey = Some(hotkey.clone());\n                        if pending_release { break; }\n                        if hotkey.is_on_release() {\n                            pending_release = true;\n                            break;\n                        }\n                        send_command(hotkey.clone());\n                        hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\npub fn seteuid(uid: u32) {\n    let uid = nix::unistd::Uid::from_raw(uid);\n    match nix::unistd::seteuid(uid) {\n        Ok(_) => log::debug!(\"Dropping privileges...\"),\n        Err(e) => {\n            log::error!(\"Failed to set UID: {:#?}\", e);\n            exit(1);\n        }\n    }\n}\nfn sock_send(command: &str) -> std::io::Result<()> {\n    let mut stream = UnixStream::connect(\"/tmp/swhkd.sock\")?;\n    stream.write_all(command.as_bytes())?;\n    Ok(())\n}\nfn main() -> std::io::Result<()> {\n    env::set_var(\"RUST_LOG\", \"swhks=trace\");\n    env_logger::init();\n    let pid_file_path = String::from(\"/tmp/swhks.pid\");\n    let sock_file_path = String::from(\"/tmp/swhkd.sock\");\n    if Path::new(&pid_file_path).exists() {\n        log::trace!(\"Reading {} file and checking for running instances.\", pid_file_path);\n        let swhkd_pid = match fs::read_to_string(&pid_file_path) {\n            Ok(swhkd_pid) => swhkd_pid,\n            Err(e) => {\n                log::error!(\"Unable to read {} to check all running instances\", e);\n                exit(1);\n            }\n        };\n        log::debug!(\"Previous PID: {}\", swhkd_pid);\n        let mut sys = System::new_all();\n        sys.refresh_all();\n        for (pid, process) in sys.processes() {\n            if pid.to_string() == swhkd_pid && process.exe() == env::current_exe().unwrap() {\n                log::error!(\"Server is already running!\");\n                exit(1);\n            }\n        }\n    }\n    if Path::new(&sock_file_path).exists() {\n        log::trace!(\"Sockfile exists, attempting to remove it.\");\n        match fs::remove_file(&sock_file_path) {\n            Ok(_) => {\n                log::debug!(\"Removed old socket file\");\n            }\n            Err(e) => {\n                log::error!(\"Error removing the socket file!: {}\", e);\n                log::error!(\"You can manually remove the socket file: {}\", sock_file_path);\n                exit(1);\n            }\n        };\n    }\n    match fs::write(&pid_file_path, id().to_string()) {\n        Ok(_) => {}\n        Err(e) => {\n            log::error!(\"Unable to write to {}: {}\", pid_file_path, e);\n            exit(1);\n        }\n    }\n    let listener = UnixListener::bind(sock_file_path)?;\n    loop {\n        match listener.accept() {\n            Ok((mut socket, address)) => {\n                let mut response = String::new();\n                socket.read_to_string(&mut response)?;\n                run_system_command(&response);\n                log::debug!(\"Socket: {:?} Address: {:?} Response: {}\", socket, address, response);\n            }\n            Err(e) => log::error!(\"accept function failed: {:?}\", e),\n        }\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "async fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let args = set_command_line_args().get_matches();\n    env::set_var(\"RUST_LOG\", \"swhkd=warn\");\n    if args.is_present(\"debug\") {\n        env::set_var(\"RUST_LOG\", \"swhkd=trace\");\n    }\n    env_logger::init();\n    log::trace!(\"Logger initialized.\");\n    let pidfile: String = String::from(\"/tmp/swhkd.pid\");\n    if Path::new(&pidfile).exists() {\n        log::trace!(\"Reading {} file and checking for running instances.\", pidfile);\n        let swhkd_pid = match fs::read_to_string(&pidfile) {\n            Ok(swhkd_pid) => swhkd_pid,\n            Err(e) => {\n                log::error!(\"Unable to read {} to check all running instances\", e);\n                exit(1);\n            }\n        };\n        log::debug!(\"Previous PID: {}\", swhkd_pid);\n        let mut sys = System::new_all();\n        sys.refresh_all();\n        for (pid, process) in sys.processes() {\n            if pid.to_string() == swhkd_pid && process.exe() == env::current_exe().unwrap() {\n                log::error!(\"Swhkd is already running!\");\n                log::error!(\"pid of existing swhkd process: {}\", pid.to_string());\n                log::error!(\"To close the existing swhkd process, run `sudo killall swhkd`\");\n                exit(1);\n            }\n        }\n    }\n    match fs::write(&pidfile, id().to_string()) {\n        Ok(_) => {}\n        Err(e) => {\n            log::error!(\"Unable to write to {}: {}\", pidfile, e);\n            exit(1);\n        }\n    }\n    if check_user_permissions().is_err() {\n        exit(1);\n    }\n    let load_config = || {\n        let config_file_path: std::path::PathBuf = if args.is_present(\"config\") {\n            Path::new(args.value_of(\"config\").unwrap()).to_path_buf()\n        } else {\n            fetch_xdg_config_path()\n        };\n        log::debug!(\"Using config file path: {:#?}\", config_file_path);\n        if !config_file_path.exists() {\n            log::error!(\"{:#?} doesn't exist\", config_file_path);\n            exit(1);\n        }\n        let hotkeys = match config::load(&config_file_path) {\n            Err(e) => {\n                log::error!(\"Config Error: {}\", e);\n                exit(1);\n            }\n            Ok(out) => out,\n        };\n        for hotkey in &hotkeys {\n            log::debug!(\"hotkey: {:#?}\", hotkey);\n        }\n        hotkeys\n    };\n    let mut hotkeys = load_config();\n    log::trace!(\"Attempting to find all keyboard file descriptors.\");\n    let keyboard_devices: Vec<Device> =\n        evdev::enumerate().filter(check_device_is_keyboard).collect();\n    let mut uinput_device = match uinput::create_uinput_device() {\n        Ok(dev) => dev,\n        Err(e) => {\n            log::error!(\"Err: {:#?}\", e);\n            exit(1);\n        }\n    };\n    if keyboard_devices.is_empty() {\n        log::error!(\"No valid keyboard device was detected!\");\n        exit(1);\n    }\n    log::debug!(\"{} Keyboard device(s) detected.\", keyboard_devices.len());\n    let modifiers_map: HashMap<Key, config::Modifier> = HashMap::from([\n        (Key::KEY_LEFTMETA, config::Modifier::Super),\n        (Key::KEY_RIGHTMETA, config::Modifier::Super),\n        (Key::KEY_LEFTMETA, config::Modifier::Super),\n        (Key::KEY_RIGHTMETA, config::Modifier::Super),\n        (Key::KEY_LEFTALT, config::Modifier::Alt),\n        (Key::KEY_RIGHTALT, config::Modifier::Alt),\n        (Key::KEY_LEFTCTRL, config::Modifier::Control),\n        (Key::KEY_RIGHTCTRL, config::Modifier::Control),\n        (Key::KEY_LEFTSHIFT, config::Modifier::Shift),\n        (Key::KEY_RIGHTSHIFT, config::Modifier::Shift),\n    ]);\n    let repeat_cooldown_duration: u64 = if args.is_present(\"cooldown\") {\n        args.value_of(\"cooldown\").unwrap().parse::<u64>().unwrap()\n    } else {\n        250\n    };\n    let mut signals = Signals::new(&[\n        SIGUSR1, SIGUSR2, SIGHUP, SIGABRT, SIGBUS, SIGCHLD, SIGCONT, SIGINT, SIGPIPE, SIGQUIT,\n        SIGSYS, SIGTERM, SIGTRAP, SIGTSTP, SIGVTALRM, SIGXCPU, SIGXFSZ,\n    ])?;\n    let mut execution_is_paused = false;\n    let mut last_hotkey: Option<config::Hotkey> = None;\n    let mut pending_release: bool = false;\n    let mut keyboard_states: Vec<KeyboardState> = Vec::new();\n    let mut keyboard_stream_map = StreamMap::new();\n    for (i, mut device) in keyboard_devices.into_iter().enumerate() {\n        let _ = device.grab();\n        keyboard_stream_map.insert(i, device.into_event_stream()?);\n        keyboard_states.push(KeyboardState::new());\n    }\n    let hotkey_repeat_timer = sleep(Duration::from_millis(0));\n    tokio::pin!(hotkey_repeat_timer);\n    loop {\n        select! {\n            _ = &mut hotkey_repeat_timer, if &last_hotkey.is_some() => {\n                let hotkey = last_hotkey.clone().unwrap();\n                if hotkey.keybinding.on_release {\n                    continue;\n                }\n                send_command(hotkey.clone());\n                hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));\n            }\n            Some(signal) = signals.next() => {\n                match signal {\n                    SIGUSR1 => {\n                        execution_is_paused = true;\n                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {\n                            let _ = device.ungrab();\n                        }\n                    }\n                    SIGUSR2 => {\n                        execution_is_paused = false;\n                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {\n                            let _ = device.grab();\n                        }\n                    }\n                    SIGHUP => {\n                        hotkeys = load_config();\n                    }\n                    SIGINT => {\n                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {\n                            let _ = device.ungrab();\n                        }\n                        log::warn!(\"Received SIGINT signal, exiting...\");\n                        exit(1);\n                    }\n                    _ => {\n                        for mut device in evdev::enumerate().filter(check_device_is_keyboard) {\n                            let _ = device.ungrab();\n                        }\n                        log::warn!(\"Received signal: {:#?}\", signal);\n                        log::warn!(\"Exiting...\");\n                        exit(1);\n                    }\n                }\n            }\n            Some((i, Ok(event))) = keyboard_stream_map.next() => {\n                let keyboard_state = &mut keyboard_states[i];\n                let key = match event.kind() {\n                    InputEventKind::Key(keycode) => keycode,\n                    _ => continue\n                };\n                match event.value() {\n                    1 => {\n                        if let Some(modifier) = modifiers_map.get(&key) {\n                            keyboard_state.state_modifiers.insert(*modifier);\n                        } else {\n                            keyboard_state.state_keysyms.insert(key);\n                        }\n                    }\n                    0 => {\n                        if last_hotkey.is_some() && pending_release {\n                            pending_release = false;\n                            send_command(last_hotkey.clone().unwrap());\n                            last_hotkey = None;\n                        }\n                        if let Some(modifier) = modifiers_map.get(&key) {\n                            if let Some(hotkey) = &last_hotkey {\n                                if hotkey.modifiers().contains(modifier) {\n                                    last_hotkey = None;\n                                }\n                            }\n                            keyboard_state.state_modifiers.remove(modifier);\n                        } else if keyboard_state.state_keysyms.contains(key) {\n                            if let Some(hotkey) = &last_hotkey {\n                                if key == hotkey.keysym() {\n                                    last_hotkey = None;\n                                }\n                            }\n                            keyboard_state.state_keysyms.remove(key);\n                        }\n                    }\n                    _ => {}\n                }\n                let possible_hotkeys: Vec<&config::Hotkey> = hotkeys.iter()\n                    .filter(|hotkey| hotkey.modifiers().len() == keyboard_state.state_modifiers.len())\n                    .collect();\n                let event_in_hotkeys = hotkeys.iter().any(|hotkey| {\n                    hotkey.keysym().code() == event.code() &&\n                    keyboard_state.state_modifiers\n                        .iter()\n                        .all(|x| hotkey.modifiers().contains(x)) &&\n                    keyboard_state.state_modifiers.len() == hotkey.modifiers().len()\n                    && !hotkey.is_send()\n                        });\n                if !event_in_hotkeys {\n                    uinput_device.emit(&[event]).unwrap();\n                }\n                if execution_is_paused || possible_hotkeys.is_empty() || last_hotkey.is_some() {\n                    continue;\n                }\n                log::debug!(\"state_modifiers: {:#?}\", keyboard_state.state_modifiers);\n                log::debug!(\"state_keysyms: {:#?}\", keyboard_state.state_keysyms);\n                log::debug!(\"hotkey: {:#?}\", possible_hotkeys);\n                for hotkey in possible_hotkeys {\n                    if keyboard_state.state_modifiers.iter().all(|x| hotkey.modifiers().contains(x))\n                        && keyboard_state.state_modifiers.len() == hotkey.modifiers().len()\n                        && keyboard_state.state_keysyms.contains(hotkey.keysym())\n                    {\n                        last_hotkey = Some(hotkey.clone());\n                        if pending_release { break; }\n                        if hotkey.is_on_release() {\n                            pending_release = true;\n                            break;\n                        }\n                        send_command(hotkey.clone());\n                        hotkey_repeat_timer.as_mut().reset(Instant::now() + Duration::from_millis(repeat_cooldown_duration));\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "    pub fn parse(input: &'i str, options: ParseOptions) -> Result<Self, ParseError> {\n        let rule = parse::parse(input)?;\n        rule.validate(&options)?;\n        Ok(Rulex(rule))\n    }\n    pub fn compile(&self, options: CompileOptions) -> Result<String, CompileError> {\n        let mut used_names = HashMap::new();\n        let mut groups_count = 0;\n        self.0.get_capturing_groups(&mut groups_count, &mut used_names, false)?;\n        let empty_span = Span::new(0, 0);\n        let start = Rule::Boundary(Boundary::new(BoundaryKind::Start, empty_span));\n        let end = Rule::Boundary(Boundary::new(BoundaryKind::End, empty_span));\n        let grapheme = Rule::Grapheme(Grapheme { span: empty_span });\n        let codepoint = Rule::CharClass(CharClass::new(CharGroup::CodePoint, empty_span));\n        let builtins = vec![\n            (\"Start\", &start),\n            (\"End\", &end),\n            (\"Grapheme\", &grapheme),\n            (\"G\", &grapheme),\n            (\"Codepoint\", &codepoint),\n            (\"C\", &codepoint),\n        ];\n        let mut state = CompileState {\n            next_idx: 1,\n            used_names,\n            groups_count,\n            default_quantifier: RegexQuantifier::Greedy,\n            variables: builtins,\n            current_vars: Default::default(),\n        };\n        let compiled = self.0.comp(options, &mut state)?;\n        let mut buf = String::new();\n        compiled.codegen(&mut buf, options.flavor);\n        Ok(buf)\n    }\n    pub fn parse_and_compile(\n        input: &'i str,\n        parse_options: ParseOptions,\n        compile_options: CompileOptions,\n    ) -> Result<String, CompileError> {\n        let parsed = Self::parse(input, parse_options)?;\n        parsed.compile(compile_options)\n    }\n    pub(super) fn from(source: &'i str, tokens: &'b [(Token, Span)]) -> Result<Self, ParseError> {\n        let error = tokens.iter().find_map(|&(t, span)| match t {\n            Token::Error => Some((span, None)),\n            Token::ErrorMsg(m) => Some((span, Some(m))),\n            _ => None,\n        });\n        if let Some((span, msg)) = error {\n            return match msg {\n                Some(msg) => Err(ParseErrorKind::LexErrorWithMessage(msg).at(span)),\n                None => Err(ParseErrorKind::UnknownToken.at(span)),\n            };\n        }\n        Ok(Input { source, tokens })\n    }\n    fn iter_elements(&self) -> Self::IterElem {\n        Input { source: self.source, tokens: self.tokens }\n    }\n    fn take(&self, count: usize) -> Self {\n        let tokens = &self.tokens[..count];\n        Input { source: self.source, tokens }\n    }\n    fn take_split(&self, count: usize) -> (Self, Self) {\n        let (left, right) = self.tokens.split_at(count);\n        (Input { source: self.source, tokens: left }, Input { source: self.source, tokens: right })\n    }\npub(crate) fn parse(source: &str) -> Result<Rule<'_>, ParseError> {\n    let tokens = super::tokenize::tokenize(source);\n    let input = Input::from(source, &tokens)?;\n    let (rest, rules) = parse_modified(input)?;\n    if rest.is_empty() {\n        Ok(rules)\n    } else {\n        Err(ParseErrorKind::LeftoverTokens.at(rest.span()))\n    }\n}\npub(super) fn parse_modified<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    enum ModifierKind {\n        Enable,\n        Disable,\n    }\n    try_map2(\n        pair(\n            many0(alt((\n                map(\n                    tuple((\n                        alt((\n                            map(\"enable\", |(_, span)| (ModifierKind::Enable, span)),\n                            map(\"disable\", |(_, span)| (ModifierKind::Disable, span)),\n                        )),\n                        value(BooleanSetting::Lazy, \"lazy\"),\n                        Token::Semicolon,\n                    )),\n                    |((kind, span_start), value, (_, span_end))| {\n                        let stmt = match kind {\n                            ModifierKind::Enable => Stmt::Enable(value),\n                            ModifierKind::Disable => Stmt::Disable(value),\n                        };\n                        (stmt, span_start.join(span_end))\n                    },\n                ),\n                map(\n                    tuple((\n                        \"let\",\n                        cut(Token::Identifier),\n                        cut(Token::Equals),\n                        cut(parse_or),\n                        cut(Token::Semicolon),\n                    )),\n                    |((_, span_start), (name, name_span), _, rule, (_, span_end))| {\n                        (Stmt::Let(Let::new(name, rule, name_span)), span_start.join(span_end))\n                    },\n                ),\n            ))),\n            parse_or,\n        ),\n        |(stmts, mut rule): (Vec<(Stmt, Span)>, _)| {\n            if stmts.len() > 1 {\n                let mut set = HashSet::new();\n                for (stmt, _) in &stmts {\n                    if let Stmt::Let(l) = stmt {\n                        if set.contains(l.name()) {\n                            return Err(ParseErrorKind::LetBindingExists.at(l.name_span));\n                        }\n                        set.insert(l.name());\n                    }\n                }\n            }\n            let span_end = rule.span();\n            for (stmt, span) in stmts.into_iter().rev() {\n                rule = Rule::StmtExpr(Box::new(StmtExpr::new(stmt, rule, span.join(span_end))));\n            }\n            Ok(rule)\n        },\n        nom::Err::Failure,\n    )(input)\n}\npub(super) fn parse_fixes<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    alt((\n        try_map(\n            pair(Token::Not, opt(parse_fixes)),\n            |(_, rule)| {\n                if let Some(mut rule) = rule {\n                    rule.negate()?;\n                    Ok(rule)\n                } else {\n                    Err(ParseErrorKind::Expected(\"expression\"))\n                }\n            },\n            nom::Err::Failure,\n        ),\n        map(pair(parse_lookaround, parse_modified), |((kind, span), rule)| {\n            let span = span.join(rule.span());\n            Rule::Lookaround(Box::new(Lookaround::new(rule, kind, span)))\n        }),\n        try_map2(\n            pair(parse_atom, many0(parse_repetition)),\n            |(mut rule, repetitions)| {\n                let mut prev_syntax = RepSyntax::ExplicitQuantifier;\n                for (kind, quantifier, span, syntax) in repetitions {\n                    if matches!(\n                        (&prev_syntax, &syntax),\n                        (RepSyntax::Other | RepSyntax::QuestionMark, RepSyntax::QuestionMark)\n                    ) {\n                        return Err(ParseErrorKind::Repetition(\n                            RepetitionError::QuestionMarkAfterRepetition,\n                        )\n                        .at(span));\n                    }\n                    prev_syntax = syntax;\n                    let span = rule.span().join(span);\n                    rule =\n                        Rule::Repetition(Box::new(Repetition::new(rule, kind, quantifier, span)));\n                }\n                Ok(rule)\n            },\n            nom::Err::Failure,\n        ),\n    ))(input)\n}\npub(super) fn parse_lookaround<'i, 'b>(\n    input: Input<'i, 'b>,\n) -> PResult<'i, 'b, (LookaroundKind, Span)> {\n    alt((\n        map(Token::LookAhead, |(_, span)| (LookaroundKind::Ahead, span)),\n        map(Token::LookBehind, |(_, span)| (LookaroundKind::Behind, span)),\n    ))(input)\n}\npub(super) enum RepSyntax {\n    ExplicitQuantifier,\n    QuestionMark,\n    Other,\n}\npub(super) fn parse_repetition<'i, 'b>(\n    input: Input<'i, 'b>,\n) -> PResult<'i, 'b, (RepetitionKind, Quantifier, Span, RepSyntax)> {\n    map(\n        pair(\n            alt((\n                map(Token::QuestionMark, |(_, span)| {\n                    (RepetitionKind::zero_one(), span, RepSyntax::QuestionMark)\n                }),\n                map(Token::Star, |(_, span)| (RepetitionKind::zero_inf(), span, RepSyntax::Other)),\n                map(Token::Plus, |(_, span)| (RepetitionKind::one_inf(), span, RepSyntax::Other)),\n                parse_braced_repetition,\n            )),\n            map(\n                opt(alt((\n                    map(\"greedy\", |(_, span)| (Quantifier::Greedy, span)),\n                    map(\"lazy\", |(_, span)| (Quantifier::Lazy, span)),\n                ))),\n                |a| match a {\n                    Some((q, span)) => (q, span, RepSyntax::ExplicitQuantifier),\n                    None => (Quantifier::Default, Span::default(), RepSyntax::Other),\n                },\n            ),\n        ),\n        |((kind, span1, rs1), (quantifier, span2, rs2))| {\n            (\n                kind,\n                quantifier,\n                span1.join(span2),\n                match (rs1, rs2) {\n                    (_, RepSyntax::ExplicitQuantifier) => RepSyntax::ExplicitQuantifier,\n                    (RepSyntax::QuestionMark, _) => RepSyntax::QuestionMark,\n                    _ => RepSyntax::Other,\n                },\n            )\n        },\n    )(input)\n}\npub(super) fn parse_braced_repetition<'i, 'b>(\n    input: Input<'i, 'b>,\n) -> PResult<'i, 'b, (RepetitionKind, Span, RepSyntax)> {\n    fn parse_u32<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, u32> {\n        try_map(Token::Number, |(s, _)| from_str(s), nom::Err::Failure)(input)\n    }\n    map(\n        tuple((\n            Token::OpenBrace,\n            cut(alt((\n                try_map(\n                    separated_pair(opt(parse_u32), Token::Comma, opt(parse_u32)),\n                    |(lower, upper)| Ok(RepetitionKind::try_from((lower.unwrap_or(0), upper))?),\n                    nom::Err::Failure,\n                ),\n                map(parse_u32, RepetitionKind::fixed),\n            ))),\n            cut(Token::CloseBrace),\n        )),\n        |((_, start), rep, (_, end))| (rep, start.join(end), RepSyntax::Other),\n    )(input)\n}\npub(super) fn parse_atom<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    alt((\n        parse_group,\n        parse_string,\n        parse_char_class,\n        parse_boundary,\n        parse_reference,\n        map(parse_code_point, |(c, span)| {\n            Rule::CharClass(CharClass::new(CharGroup::from_char(c), span))\n        }),\n        parse_range,\n        parse_variable,\n        try_map(Token::Dot, |_| Err(ParseErrorKind::Dot), nom::Err::Failure),\n        err(|| ParseErrorKind::Expected(\"expression\")),\n    ))(input)\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn parse_quoted_text(input: &str) -> Result<Cow<'_, str>, ParseErrorKind> {\n    Ok(match input.as_bytes()[0] {\n        b'\"' => {\n            let mut s = strip_first_last(input);\n            let mut buf = String::new();\n            loop {\n                let mut chars = s.chars();\n                match chars.next() {\n                    Some('\\\\') => match chars.next() {\n                        Some('\\\\') => {\n                            buf.push('\\\\');\n                            s = &s[1..];\n                        }\n                        Some('\"') => {\n                            buf.push('\"');\n                            s = &s[1..];\n                        }\n                        _ => {\n                            return Err(ParseErrorKind::InvalidEscapeInStringAt(\n                                input.len() - s.len(),\n                            ));\n                        }\n                    },\n                    Some(c) => buf.push(c),\n                    None => break,\n                }\n                s = &s[1..];\n            }\n            Cow::Owned(buf)\n        }\n        _ => Cow::Borrowed(strip_first_last(input)),\n    })\n}\nfn try_map<'i, 'b, O1, O2, P, M, EM>(\n    mut parser: P,\n    mut map: M,\n    err_kind: EM,\n) -> impl FnMut(Input<'i, 'b>) -> IResult<Input<'i, 'b>, O2, ParseError>\nwhere\n    P: Parser<Input<'i, 'b>, O1, ParseError>,\n    M: FnMut(O1) -> Result<O2, ParseErrorKind>,\n    EM: Copy + FnOnce(ParseError) -> nom::Err<ParseError>,\n{\n    move |input| {\n        let span = input.span();\n        let (rest, o1) = parser.parse(input)?;\n        let o2 = map(o1).map_err(|e| err_kind(e.at(span)))?;\n        Ok((rest, o2))\n    }\n}\nfn try_map2<'i, 'b, O1, O2, P, M, EM>(\n    mut parser: P,\n    mut map: M,\n    err_kind: EM,\n) -> impl FnMut(Input<'i, 'b>) -> IResult<Input<'i, 'b>, O2, ParseError>\nwhere\n    P: Parser<Input<'i, 'b>, O1, ParseError>,\n    M: FnMut(O1) -> Result<O2, ParseError>,\n    EM: Copy + FnOnce(ParseError) -> nom::Err<ParseError>,\n{\n    move |input| {\n        let (rest, o1) = parser.parse(input)?;\n        let o2 = map(o1).map_err(err_kind)?;\n        Ok((rest, o2))\n    }\n}\nfn err<'i, 'b, T>(\n    mut error_fn: impl FnMut() -> ParseErrorKind,\n) -> impl FnMut(Input<'i, 'b>) -> IResult<Input<'i, 'b>, T, ParseError> {\n    move |input| Err(nom::Err::Error(error_fn().at(input.span())))\n}\npub(crate) fn tokenize(mut input: &str) -> Vec<(Token, Span)> {\n    let mut result = vec![];\n    let mut offset = 0;\n    loop {\n        let input_len = input.len();\n        input = input.trim_start();\n        while input.starts_with('#') {\n            input = input.trim_start_matches(|c| c != '\\n').trim_start();\n        }\n        offset += input_len - input.len();\n        match input.chars().next() {\n            None => break,\n            Some(c) => {\n                let (len, token) = consume_chain! {\n                    input, c;\n                    if input.starts_with(\"<%\") => (2, Token::BStart);\n                    if input.starts_with(\"%>\") => (2, Token::BEnd);\n                    if input.starts_with(\">>\") => (2, Token::LookAhead);\n                    if input.starts_with(\"<<\") => (2, Token::LookBehind);\n                    if input.starts_with(\"::\") => (2, Token::Backref);\n                    if c == '%' => (1, Token::BWord);\n                    if c == '*' => (1, Token::Star);\n                    if c == '+' => (1, Token::Plus);\n                    if c == '?' => (1, Token::QuestionMark);\n                    if c == '|' => (1, Token::Pipe);\n                    if c == ':' => (1, Token::Colon);\n                    if c == ')' => (1, Token::CloseParen);\n                    if c == '{' => (1, Token::OpenBrace);\n                    if c == '}' => (1, Token::CloseBrace);\n                    if c == ',' => (1, Token::Comma);\n                    if c == '!' => (1, Token::Not);\n                    if c == '[' => (1, Token::OpenBracket);\n                    if c == '-' => (1, Token::Dash);\n                    if c == ']' => (1, Token::CloseBracket);\n                    if c == '.' => (1, Token::Dot);\n                    if c == ';' => (1, Token::Semicolon);\n                    if c == '=' => (1, Token::Equals);\n                    if c == '\\'' => match input[1..].find('\\'') {\n                        Some(len_inner) => (len_inner + 2, Token::String),\n                        None => (input.len(), Token::ErrorMsg(ParseErrorMsg::UnclosedString)),\n                    };\n                    if c == '\"' => match find_unescaped_quote(&input[1..]) {\n                        Some(len_inner) => (len_inner + 2, Token::String),\n                        None => (input.len(), Token::ErrorMsg(ParseErrorMsg::UnclosedString)),\n                    };\n                    if let Some(rest) = input.strip_prefix(\"U+\") => {\n                        match rest.find(|c: char| !c.is_ascii_hexdigit()) {\n                            Some(0) => (1, Token::Error),\n                            Some(len_inner) => (len_inner + 2, Token::CodePoint),\n                            None => (input.len(), Token::CodePoint),\n                        }\n                    };\n                    if matches!(c, '0'..='9') => (\n                        input.find(|c: char| !matches!(c, '0'..='9')).unwrap_or(input.len()),\n                        Token::Number,\n                    );\n                    if c.is_alphabetic() || c == '_' => (\n                        input.find(|c: char| !c.is_alphanumeric() && c != '_').unwrap_or(input.len()),\n                        Token::Identifier,\n                    );\n                    if c == '^' => (1, Token::ErrorMsg(ParseErrorMsg::Caret));\n                    if c == '$' => (1, Token::ErrorMsg(ParseErrorMsg::Dollar));\n                    if let Some(rest) = input.strip_prefix(\"(?\") => (\n                        match rest.chars().next() {\n                            Some('<') => {\n                                let name_len = rest.chars()\n                                    .skip(1)\n                                    .take_while(char::is_ascii_alphanumeric)\n                                    .count();\n                                if name_len > 0 && matches!(rest.chars().nth(1 + name_len), Some('>')) {\n                                    4 + name_len\n                                } else if let Some('=' | '!') = rest.chars().nth(1) {\n                                    4\n                                } else {\n                                    3\n                                }\n                            }\n                            Some('P') if matches!(rest.chars().nth(1), Some('<')) => {\n                                let name_len = rest.chars()\n                                    .skip(2)\n                                    .take_while(char::is_ascii_alphanumeric)\n                                    .count();\n                                if name_len > 0 && matches!(rest.chars().nth(2 + name_len), Some('>')) {\n                                    5 + name_len\n                                } else {\n                                    4\n                                }\n                            },\n                            Some('>' | '!' | ':' | '=' | '(' | '|') => 3,\n                            _ => 2,\n                        },\n                        Token::ErrorMsg(ParseErrorMsg::SpecialGroup),\n                    );\n                    if c == '(' => (1, Token::OpenParen);\n                    if c == '\\\\' => {\n                        if input.starts_with(\"\\\\u{\") || input.starts_with(\"\\\\x{\") {\n                            match input[3..].find('}') {\n                                Some(len) => (len + 4, Token::ErrorMsg(ParseErrorMsg::BackslashUnicode)),\n                                None => (2, Token::ErrorMsg(ParseErrorMsg::Backslash)),\n                            }\n                        } else if let Some(rest) = input.strip_prefix(\"\\\\u\") {\n                            match rest.find(|c: char| !c.is_ascii_hexdigit()).unwrap_or(rest.len()) {\n                                4.. => (6, Token::ErrorMsg(ParseErrorMsg::BackslashU4)),\n                                _ => (2, Token::ErrorMsg(ParseErrorMsg::Backslash)),\n                            }\n                        } else if let Some(rest) = input.strip_prefix(\"\\\\x\") {\n                            match rest.find(|c: char| !c.is_ascii_hexdigit()).unwrap_or(rest.len()) {\n                                2.. => (4, Token::ErrorMsg(ParseErrorMsg::BackslashX2)),\n                                _ => (2, Token::ErrorMsg(ParseErrorMsg::Backslash)),\n                            }\n                        } else if let Some(rest) = input.strip_prefix(\"\\\\k<\") {\n                            match rest.find('>') {\n                                Some(len) => (len + 4, Token::ErrorMsg(ParseErrorMsg::BackslashK)),\n                                _ => (2, Token::ErrorMsg(ParseErrorMsg::Backslash)),\n                            }\n                        } else if input.len() >= 2 {\n                            (2, Token::ErrorMsg(ParseErrorMsg::Backslash))\n                        } else {\n                            (1, Token::Error)\n                        }\n                    };\n                };\n                let start = offset;\n                offset += len;\n                input = &input[len..];\n                result.push((token, Span::new(start, offset)));\n            }\n        }\n    }\n    result\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "\tpub fn execute(\n\t\tfrom: H160,\n\t\ttransaction: &Transaction,\n\t\tconfig: Option<evm::Config>,\n\t) -> Result<\n\t\t(Option<H160>, Option<H160>, CallOrCreateInfo),\n\t\tDispatchErrorWithPostInfo<PostDispatchInfo>,\n\t> {\n\t\tlet (\n\t\t\tinput,\n\t\t\tvalue,\n\t\t\tgas_limit,\n\t\t\tmax_fee_per_gas,\n\t\t\tmax_priority_fee_per_gas,\n\t\t\tnonce,\n\t\t\taction,\n\t\t\taccess_list,\n\t\t) = {\n\t\t\tmatch transaction {\n\t\t\t\tTransaction::Legacy(t) => (\n\t\t\t\t\tt.input.clone(),\n\t\t\t\t\tt.value,\n\t\t\t\t\tt.gas_limit,\n\t\t\t\t\tSome(t.gas_price),\n\t\t\t\t\tSome(t.gas_price),\n\t\t\t\t\tSome(t.nonce),\n\t\t\t\t\tt.action,\n\t\t\t\t\tVec::new(),\n\t\t\t\t),\n\t\t\t\tTransaction::EIP2930(t) => {\n\t\t\t\t\tlet access_list: Vec<(H160, Vec<H256>)> = t\n\t\t\t\t\t\t.access_list\n\t\t\t\t\t\t.iter()\n\t\t\t\t\t\t.map(|item| (item.address, item.storage_keys.clone()))\n\t\t\t\t\t\t.collect();\n\t\t\t\t\t(\n\t\t\t\t\t\tt.input.clone(),\n\t\t\t\t\t\tt.value,\n\t\t\t\t\t\tt.gas_limit,\n\t\t\t\t\t\tSome(t.gas_price),\n\t\t\t\t\t\tSome(t.gas_price),\n\t\t\t\t\t\tSome(t.nonce),\n\t\t\t\t\t\tt.action,\n\t\t\t\t\t\taccess_list,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tTransaction::EIP1559(t) => {\n\t\t\t\t\tlet access_list: Vec<(H160, Vec<H256>)> = t\n\t\t\t\t\t\t.access_list\n\t\t\t\t\t\t.iter()\n\t\t\t\t\t\t.map(|item| (item.address, item.storage_keys.clone()))\n\t\t\t\t\t\t.collect();\n\t\t\t\t\t(\n\t\t\t\t\t\tt.input.clone(),\n\t\t\t\t\t\tt.value,\n\t\t\t\t\t\tt.gas_limit,\n\t\t\t\t\t\tSome(t.max_fee_per_gas),\n\t\t\t\t\t\tSome(t.max_priority_fee_per_gas),\n\t\t\t\t\t\tSome(t.nonce),\n\t\t\t\t\t\tt.action,\n\t\t\t\t\t\taccess_list,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tlet is_transactional = true;\n\t\tlet validate = false;\n\t\tmatch action {\n\t\t\tethereum::TransactionAction::Call(target) => {\n\t\t\t\tlet res = match T::Runner::call(\n\t\t\t\t\tfrom,\n\t\t\t\t\ttarget,\n\t\t\t\t\tinput,\n\t\t\t\t\tvalue,\n\t\t\t\t\tgas_limit.low_u64(),\n\t\t\t\t\tmax_fee_per_gas,\n\t\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\t\tnonce,\n\t\t\t\t\taccess_list,\n\t\t\t\t\tis_transactional,\n\t\t\t\t\tvalidate,\n\t\t\t\t\tconfig.as_ref().unwrap_or_else(|| T::config()),\n\t\t\t\t) {\n\t\t\t\t\tOk(res) => res,\n\t\t\t\t\tErr(e) => {\n\t\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tOk((Some(target), None, CallOrCreateInfo::Call(res)))\n\t\t\t}\n\t\t\tethereum::TransactionAction::Create => {\n\t\t\t\tlet res = match T::Runner::create(\n\t\t\t\t\tfrom,\n\t\t\t\t\tinput,\n\t\t\t\t\tvalue,\n\t\t\t\t\tgas_limit.low_u64(),\n\t\t\t\t\tmax_fee_per_gas,\n\t\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\t\tnonce,\n\t\t\t\t\taccess_list,\n\t\t\t\t\tis_transactional,\n\t\t\t\t\tvalidate,\n\t\t\t\t\tconfig.as_ref().unwrap_or_else(|| T::config()),\n\t\t\t\t) {\n\t\t\t\t\tOk(res) => res,\n\t\t\t\t\tErr(e) => {\n\t\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tOk((None, Some(res.value), CallOrCreateInfo::Create(res)))\n\t\t\t}\n\t\t}\n\t}\n\t\tfn config() -> &'static EvmConfig {\n\t\t\t&LONDON_CONFIG\n\t\t}\n\t}\n\t#[pallet::call]\n\timpl<T: Config> Pallet<T> {\n\t\t#[pallet::weight(0)]\n\t\tpub fn withdraw(\n\t\t\torigin: OriginFor<T>,\n\t\t\taddress: H160,\n\t\t\tvalue: BalanceOf<T>,\n\t\t) -> DispatchResult {\n\t\t\tlet destination = T::WithdrawOrigin::ensure_address_origin(&address, origin)?;\n\t\t\tlet address_account_id = T::AddressMapping::into_account_id(address);\n\t\t\tT::Currency::transfer(\n\t\t\t\t&address_account_id,\n\t\t\t\t&destination,\n\t\t\t\tvalue,\n\t\t\t\tExistenceRequirement::AllowDeath,\n\t\t\t)?;\n\t\t\tOk(())\n\t\t}\n\t\t#[pallet::weight(T::GasWeightMapping::gas_to_weight(*gas_limit))]\n\t\tpub fn call(\n\t\t\torigin: OriginFor<T>,\n\t\t\tsource: H160,\n\t\t\ttarget: H160,\n\t\t\tinput: Vec<u8>,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: u64,\n\t\t\tmax_fee_per_gas: U256,\n\t\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t\t) -> DispatchResultWithPostInfo {\n\t\t\tT::CallOrigin::ensure_address_origin(&source, origin)?;\n\t\t\tlet is_transactional = true;\n\t\t\tlet validate = true;\n\t\t\tlet info = match T::Runner::call(\n\t\t\t\tsource,\n\t\t\t\ttarget,\n\t\t\t\tinput,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tSome(max_fee_per_gas),\n\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\tnonce,\n\t\t\t\taccess_list,\n\t\t\t\tis_transactional,\n\t\t\t\tvalidate,\n\t\t\t\tT::config(),\n\t\t\t) {\n\t\t\t\tOk(info) => info,\n\t\t\t\tErr(e) => {\n\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t};\n\t\t\tmatch info.exit_reason {\n\t\t\t\tExitReason::Succeed(_) => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::Executed(target));\n\t\t\t\t}\n\t\t\t\t_ => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::ExecutedFailed(target));\n\t\t\t\t}\n\t\t\t};\n\t\t\tOk(PostDispatchInfo {\n\t\t\t\tactual_weight: Some(T::GasWeightMapping::gas_to_weight(\n\t\t\t\t\tinfo.used_gas.unique_saturated_into(),\n\t\t\t\t)),\n\t\t\t\tpays_fee: Pays::No,\n\t\t\t})\n\t\t}\n\t\t#[pallet::weight(T::GasWeightMapping::gas_to_weight(*gas_limit))]\n\t\tpub fn create(\n\t\t\torigin: OriginFor<T>,\n\t\t\tsource: H160,\n\t\t\tinit: Vec<u8>,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: u64,\n\t\t\tmax_fee_per_gas: U256,\n\t\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t\t) -> DispatchResultWithPostInfo {\n\t\t\tT::CallOrigin::ensure_address_origin(&source, origin)?;\n\t\t\tlet is_transactional = true;\n\t\t\tlet validate = true;\n\t\t\tlet info = match T::Runner::create(\n\t\t\t\tsource,\n\t\t\t\tinit,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tSome(max_fee_per_gas),\n\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\tnonce,\n\t\t\t\taccess_list,\n\t\t\t\tis_transactional,\n\t\t\t\tvalidate,\n\t\t\t\tT::config(),\n\t\t\t) {\n\t\t\t\tOk(info) => info,\n\t\t\t\tErr(e) => {\n\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t};\n\t\t\tmatch info {\n\t\t\t\tCreateInfo {\n\t\t\t\t\texit_reason: ExitReason::Succeed(_),\n\t\t\t\t\tvalue: create_address,\n\t\t\t\t\t..\n\t\t\t\t} => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::Created(create_address));\n\t\t\t\t}\n\t\t\t\tCreateInfo {\n\t\t\t\t\texit_reason: _,\n\t\t\t\t\tvalue: create_address,\n\t\t\t\t\t..\n\t\t\t\t} => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::CreatedFailed(create_address));\n\t\t\t\t}\n\t\t\t}\n\t\t\tOk(PostDispatchInfo {\n\t\t\t\tactual_weight: Some(T::GasWeightMapping::gas_to_weight(\n\t\t\t\t\tinfo.used_gas.unique_saturated_into(),\n\t\t\t\t)),\n\t\t\t\tpays_fee: Pays::No,\n\t\t\t})\n\t\t}\n\t\t#[pallet::weight(T::GasWeightMapping::gas_to_weight(*gas_limit))]\n\t\tpub fn create2(\n\t\t\torigin: OriginFor<T>,\n\t\t\tsource: H160,\n\t\t\tinit: Vec<u8>,\n\t\t\tsalt: H256,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: u64,\n\t\t\tmax_fee_per_gas: U256,\n\t\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t\t) -> DispatchResultWithPostInfo {\n\t\t\tT::CallOrigin::ensure_address_origin(&source, origin)?;\n\t\t\tlet is_transactional = true;\n\t\t\tlet validate = true;\n\t\t\tlet info = match T::Runner::create2(\n\t\t\t\tsource,\n\t\t\t\tinit,\n\t\t\t\tsalt,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tSome(max_fee_per_gas),\n\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\tnonce,\n\t\t\t\taccess_list,\n\t\t\t\tis_transactional,\n\t\t\t\tvalidate,\n\t\t\t\tT::config(),\n\t\t\t) {\n\t\t\t\tOk(info) => info,\n\t\t\t\tErr(e) => {\n\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t};\n\t\t\tmatch info {\n\t\t\t\tCreateInfo {\n\t\t\t\t\texit_reason: ExitReason::Succeed(_),\n\t\t\t\t\tvalue: create_address,\n\t\t\t\t\t..\n\t\t\t\t} => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::Created(create_address));\n\t\t\t\t}\n\t\t\t\tCreateInfo {\n\t\t\t\t\texit_reason: _,\n\t\t\t\t\tvalue: create_address,\n\t\t\t\t\t..\n\t\t\t\t} => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::CreatedFailed(create_address));\n\t\t\t\t}\n\t\t\t}\n\t\t\tOk(PostDispatchInfo {\n\t\t\t\tactual_weight: Some(T::GasWeightMapping::gas_to_weight(\n\t\t\t\t\tinfo.used_gas.unique_saturated_into(),\n\t\t\t\t)),\n\t\t\t\tpays_fee: Pays::No,\n\t\t\t})\n\t\t}\n\t}\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(super) fn deposit_event)]\n\tpub enum Event<T: Config> {\n\t\tLog(Log),\n\t\tCreated(H160),\n\t\tCreatedFailed(H160),\n\t\tExecuted(H160),\n\t\tExecutedFailed(H160),\n\t\tBalanceDeposit(T::AccountId, H160, U256),\n\t\tBalanceWithdraw(T::AccountId, H160, U256),\n\t}\n\t#[pallet::error]\n\tpub enum Error<T> {\n\t\tBalanceLow,\n\t\tFeeOverflow,\n\t\tPaymentOverflow,\n\t\tWithdrawFailed,\n\t\tGasPriceTooLow,\n\t\tInvalidNonce,\n\t\tGasLimitTooLow,\n\t\tGasLimitTooHigh,\n\t\tUndefined,\n\t}\n\timpl<T> From<InvalidEvmTransactionError> for Error<T> {\n\t\tfn from(validation_error: InvalidEvmTransactionError) -> Self {\n\t\t\tmatch validation_error {\n\t\t\t\tInvalidEvmTransactionError::GasLimitTooLow => Error::<T>::GasLimitTooLow,\n\t\t\t\tInvalidEvmTransactionError::GasLimitTooHigh => Error::<T>::GasLimitTooHigh,\n\t\t\t\tInvalidEvmTransactionError::GasPriceTooLow => Error::<T>::GasLimitTooLow,\n\t\t\t\tInvalidEvmTransactionError::PriorityFeeTooHigh => Error::<T>::GasPriceTooLow,\n\t\t\t\tInvalidEvmTransactionError::BalanceTooLow => Error::<T>::BalanceLow,\n\t\t\t\tInvalidEvmTransactionError::TxNonceTooLow => Error::<T>::InvalidNonce,\n\t\t\t\tInvalidEvmTransactionError::TxNonceTooHigh => Error::<T>::InvalidNonce,\n\t\t\t\tInvalidEvmTransactionError::InvalidPaymentInput => Error::<T>::GasPriceTooLow,\n\t\t\t\t_ => Error::<T>::Undefined,\n\t\t\t}\n\t\t}\n\t}\n\t#[pallet::genesis_config]\n\t#[cfg_attr(feature = \"std\", derive(Default))]\n\tpub struct GenesisConfig {\n\t\tpub accounts: std::collections::BTreeMap<H160, GenesisAccount>,\n\t}\n\t#[pallet::genesis_build]\n\timpl<T: Config> GenesisBuild<T> for GenesisConfig {\n\t\tfn build(&self) {\n\t\t\tfor (address, account) in &self.accounts {\n\t\t\t\tlet account_id = T::AddressMapping::into_account_id(*address);\n\t\t\t\tfor _ in 0..account.nonce.low_u128() {\n\t\t\t\t\tframe_system::Pallet::<T>::inc_account_nonce(&account_id);\n\t\t\t\t}\n\t\t\t\tT::Currency::deposit_creating(\n\t\t\t\t\t&account_id,\n\t\t\t\t\taccount.balance.low_u128().unique_saturated_into(),\n\t\t\t\t);\n\t\t\t\tPallet::<T>::create_account(*address, account.code.clone());\n\t\t\t\tfor (index, value) in &account.storage {\n\t\t\t\t\t<AccountStorages<T>>::insert(address, index, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t#[pallet::storage]\n\t#[pallet::getter(fn account_codes)]\n\tpub type AccountCodes<T: Config> = StorageMap<_, Blake2_128Concat, H160, Vec<u8>, ValueQuery>;\n\t#[pallet::storage]\n\t#[pallet::getter(fn account_storages)]\n\tpub type AccountStorages<T: Config> =\n\t\tStorageDoubleMap<_, Blake2_128Concat, H160, Blake2_128Concat, H256, H256, ValueQuery>;\n}\npub type BalanceOf<T> =\n\t<<T as Config>::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance;\ntype NegativeImbalanceOf<C, T> =\n\t<C as Currency<<T as frame_system::Config>::AccountId>>::NegativeImbalance;\npub trait EnsureAddressOrigin<OuterOrigin> {\n\ttype Success;\n\tfn ensure_address_origin(\n\t\taddress: &H160,\n\t\torigin: OuterOrigin,\n\t) -> Result<Self::Success, BadOrigin> {\n\t\tSelf::try_address_origin(address, origin).map_err(|_| BadOrigin)\n\t}\n\tfn try_address_origin(\n\t\taddress: &H160,\n\t\torigin: OuterOrigin,\n\t) -> Result<Self::Success, OuterOrigin>;\n}\npub struct EnsureAddressSame;\nimpl<OuterOrigin> EnsureAddressOrigin<OuterOrigin> for EnsureAddressSame\nwhere\n\tOuterOrigin: Into<Result<RawOrigin<H160>, OuterOrigin>> + From<RawOrigin<H160>>,\n{\n\ttype Success = H160;\n\tfn try_address_origin(address: &H160, origin: OuterOrigin) -> Result<H160, OuterOrigin> {\n\t\torigin.into().and_then(|o| match o {\n\t\t\tRawOrigin::Signed(who) if &who == address => Ok(who),\n\t\t\tr => Err(OuterOrigin::from(r)),\n\t\t})\n\t}\n}\npub struct EnsureAddressRoot<AccountId>(sp_std::marker::PhantomData<AccountId>);\nimpl<OuterOrigin, AccountId> EnsureAddressOrigin<OuterOrigin> for EnsureAddressRoot<AccountId>\nwhere\n\tOuterOrigin: Into<Result<RawOrigin<AccountId>, OuterOrigin>> + From<RawOrigin<AccountId>>,\n{\n\ttype Success = ();\n\tfn try_address_origin(_address: &H160, origin: OuterOrigin) -> Result<(), OuterOrigin> {\n\t\torigin.into().and_then(|o| match o {\n\t\t\tRawOrigin::Root => Ok(()),\n\t\t\tr => Err(OuterOrigin::from(r)),\n\t\t})\n\t}\n}\npub struct EnsureAddressNever<AccountId>(sp_std::marker::PhantomData<AccountId>);\nimpl<OuterOrigin, AccountId> EnsureAddressOrigin<OuterOrigin> for EnsureAddressNever<AccountId> {\n\ttype Success = AccountId;\n\tfn try_address_origin(_address: &H160, origin: OuterOrigin) -> Result<AccountId, OuterOrigin> {\n\t\tErr(origin)\n\t}\n}\npub struct EnsureAddressTruncated;\nimpl<OuterOrigin> EnsureAddressOrigin<OuterOrigin> for EnsureAddressTruncated\nwhere\n\tOuterOrigin: Into<Result<RawOrigin<AccountId32>, OuterOrigin>> + From<RawOrigin<AccountId32>>,\n{\n\ttype Success = AccountId32;\n\tfn try_address_origin(address: &H160, origin: OuterOrigin) -> Result<AccountId32, OuterOrigin> {\n\t\torigin.into().and_then(|o| match o {\n\t\t\tRawOrigin::Signed(who) if AsRef::<[u8; 32]>::as_ref(&who)[0..20] == address[0..20] => {\n\t\t\t\tOk(who)\n\t\t\t}\n\t\t\tr => Err(OuterOrigin::from(r)),\n\t\t})\n\t}\n}\npub trait AddressMapping<A> {\n\tfn into_account_id(address: H160) -> A;\n}\npub struct IdentityAddressMapping;\nimpl AddressMapping<H160> for IdentityAddressMapping {\n\tfn into_account_id(address: H160) -> H160 {\n\t\taddress\n\t}\n}\npub struct HashedAddressMapping<H>(sp_std::marker::PhantomData<H>);\nimpl<H: Hasher<Out = H256>> AddressMapping<AccountId32> for HashedAddressMapping<H> {\n\tfn into_account_id(address: H160) -> AccountId32 {\n\t\tlet mut data = [0u8; 24];\n\t\tdata[0..4].copy_from_slice(b\"evm:\");\n\t\tdata[4..24].copy_from_slice(&address[..]);\n\t\tlet hash = H::hash(&data);\n\t\tAccountId32::from(Into::<[u8; 32]>::into(hash))\n\t}\n}\npub trait BlockHashMapping {\n\tfn block_hash(number: u32) -> H256;\n}\npub struct SubstrateBlockHashMapping<T>(sp_std::marker::PhantomData<T>);\nimpl<T: Config> BlockHashMapping for SubstrateBlockHashMapping<T> {\n\tfn block_hash(number: u32) -> H256 {\n\t\tlet number = T::BlockNumber::from(number);\n\t\tH256::from_slice(frame_system::Pallet::<T>::block_hash(number).as_ref())\n\t}\n}\npub trait GasWeightMapping {\n\tfn gas_to_weight(gas: u64) -> Weight;\n\tfn weight_to_gas(weight: Weight) -> u64;\n}\nimpl GasWeightMapping for () {\n\tfn gas_to_weight(gas: u64) -> Weight {\n\t\tgas as Weight\n\t}\n\tfn weight_to_gas(weight: Weight) -> u64 {\n\t\tweight as u64\n\t}\n}\nstatic LONDON_CONFIG: EvmConfig = EvmConfig::london();\nimpl<T: Config> Pallet<T> {\n\tpub fn is_account_empty(address: &H160) -> bool {\n\t\tlet (account, _) = Self::account_basic(address);\n\t\tlet code_len = <AccountCodes<T>>::decode_len(address).unwrap_or(0);\n\t\taccount.nonce == U256::zero() && account.balance == U256::zero() && code_len == 0\n\t}\n\tpub fn remove_account_if_empty(address: &H160) {\n\t\tif Self::is_account_empty(address) {\n\t\t\tSelf::remove_account(address);\n\t\t}\n\t}\n\tpub fn remove_account(address: &H160) {\n\t\tif <AccountCodes<T>>::contains_key(address) {\n\t\t\tlet account_id = T::AddressMapping::into_account_id(*address);\n\t\t\tlet _ = frame_system::Pallet::<T>::dec_sufficients(&account_id);\n\t\t}\n\t\t<AccountCodes<T>>::remove(address);\n\t\tlet _ = <AccountStorages<T>>::remove_prefix(address, None);\n\t}\n\tpub fn create_account(address: H160, code: Vec<u8>) {\n\t\tif code.is_empty() {\n\t\t\treturn;\n\t\t}\n\t\tif !<AccountCodes<T>>::contains_key(&address) {\n\t\t\tlet account_id = T::AddressMapping::into_account_id(address);\n\t\t\tlet _ = frame_system::Pallet::<T>::inc_sufficients(&account_id);\n\t\t}\n\t\t<AccountCodes<T>>::insert(address, code);\n\t}\n\tpub fn account_basic(address: &H160) -> (Account, frame_support::weights::Weight) {\n\t\tlet account_id = T::AddressMapping::into_account_id(*address);\n\t\tlet nonce = frame_system::Pallet::<T>::account_nonce(&account_id);\n\t\tlet balance = T::Currency::reducible_balance(&account_id, true);\n\t\t(\n\t\t\tAccount {\n\t\t\t\tnonce: U256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(nonce)),\n\t\t\t\tbalance: U256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(balance)),\n\t\t\t},\n\tfn correct_and_deposit_fee(\n\t\twho: &H160,\n\t\tcorrected_fee: U256,\n\t\tbase_fee: U256,\n\t\talready_withdrawn: Self::LiquidityInfo,\n\t) -> Self::LiquidityInfo {\n\t\tif let Some(paid) = already_withdrawn {\n\t\t\tlet account_id = T::AddressMapping::into_account_id(*who);\n\t\t\tlet refund_amount = paid\n\t\t\t\t.peek()\n\t\t\t\t.saturating_sub(corrected_fee.low_u128().unique_saturated_into());\n\t\t\tlet refund_imbalance = C::deposit_into_existing(&account_id, refund_amount)\n\t\t\t\t.unwrap_or_else(|_| C::PositiveImbalance::zero());\n\t\t\tlet refund_imbalance = if C::minimum_balance().is_zero()\n\t\t\t\t&& refund_amount > C::Balance::zero()\n\t\t\t\t&& C::total_balance(&account_id).is_zero()\n\t\t\t{\n\t\t\t\tmatch C::make_free_balance_be(&account_id, refund_amount) {\n\t\t\t\t\tSignedImbalance::Positive(p) => p,\n\t\t\t\t\t_ => C::PositiveImbalance::zero(),\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trefund_imbalance\n\t\t\t};\n\t\t\tlet adjusted_paid = paid\n\t\t\t\t.offset(refund_imbalance)\n\t\t\t\t.same()\n\t\t\t\t.unwrap_or_else(|_| C::NegativeImbalance::zero());\n\t\t\tlet (base_fee, tip) = adjusted_paid.split(base_fee.low_u128().unique_saturated_into());\n\t\t\tOU::on_unbalanced(base_fee);\n\t\t\treturn Some(tip);\n\t\t}\n\t\tNone\n\t}\n\tfn withdraw_fee(who: &H160, fee: U256) -> Result<Self::LiquidityInfo, Error<T>> {\n\t\tif fee.is_zero() {\n\t\t\treturn Ok(None);\n\t\t}\n\t\tlet account_id = T::AddressMapping::into_account_id(*who);\n\t\tlet imbalance = C::withdraw(\n\t\t\t&account_id,\n\t\t\tfee.low_u128().unique_saturated_into(),\n\t\t\tWithdrawReasons::FEE,\n\t\t\tExistenceRequirement::AllowDeath,\n\t\t)\n\t\t.map_err(|_| Error::<T>::BalanceLow)?;\n\t\tOk(Some(imbalance))\n\t}\n\tpub fn metadata_mut(&mut self) -> &mut StackSubstateMetadata<'config> {\n\t\t&mut self.metadata\n\t}\n\tpub fn enter(&mut self, gas_limit: u64, is_static: bool) {\n\t\tlet mut entering = Self {\n\t\t\tmetadata: self.metadata.spit_child(gas_limit, is_static),\n\t\t\tparent: None,\n\t\t\tdeletes: BTreeSet::new(),\n\t\t\tlogs: Vec::new(),\n\t\t};\n\t\tmem::swap(&mut entering, self);\n\t\tself.parent = Some(Box::new(entering));\n\t\tsp_io::storage::start_transaction();\n\t}\n\tpub fn exit_commit(&mut self) -> Result<(), ExitError> {\n\t\tlet mut exited = *self.parent.take().expect(\"Cannot commit on root substate\");\n\t\tmem::swap(&mut exited, self);\n\t\tself.metadata.swallow_commit(exited.metadata)?;\n\t\tself.logs.append(&mut exited.logs);\n\t\tself.deletes.append(&mut exited.deletes);\n\t\tsp_io::storage::commit_transaction();\n\t\tOk(())\n\t}\n\tpub fn exit_revert(&mut self) -> Result<(), ExitError> {\n\t\tlet mut exited = *self.parent.take().expect(\"Cannot discard on root substate\");\n\t\tmem::swap(&mut exited, self);\n\t\tself.metadata.swallow_revert(exited.metadata)?;\n\t\tsp_io::storage::rollback_transaction();\n\t\tOk(())\n\t}\n\tpub fn exit_discard(&mut self) -> Result<(), ExitError> {\n\t\tlet mut exited = *self.parent.take().expect(\"Cannot discard on root substate\");\n\t\tmem::swap(&mut exited, self);\n\t\tself.metadata.swallow_discard(exited.metadata)?;\n\t\tsp_io::storage::rollback_transaction();\n\t\tOk(())\n\t}\n\tpub fn deleted(&self, address: H160) -> bool {\n\t\tif self.deletes.contains(&address) {\n\t\t\treturn true;\n\t\t}\n\t\tif let Some(parent) = self.parent.as_ref() {\n\t\t\treturn parent.deleted(address);\n\t\t}\n\t\tfalse\n\t}\n\tpub fn set_deleted(&mut self, address: H160) {\n\t\tself.deletes.insert(address);\n\t}\n\tpub fn log(&mut self, address: H160, topics: Vec<H256>, data: Vec<u8>) {\n\t\tself.logs.push(Log {\n\t\t\taddress,\n\t\t\ttopics,\n\t\t\tdata,\n\t\t});\n\t}\n\tfn recursive_is_cold<F: Fn(&Accessed) -> bool>(&self, f: &F) -> bool {\n\t\tlet local_is_accessed = self.metadata.accessed().as_ref().map(f).unwrap_or(false);\n\t\tif local_is_accessed {\n\t\t\tfalse\n\t\t} else {\n\t\t\tself.parent\n\t\t\t\t.as_ref()\n\t\t\t\t.map(|p| p.recursive_is_cold(f))\n\t\t\t\t.unwrap_or(true)\n\t\t}\n\t}\n}\npub struct SubstrateStackState<'vicinity, 'config, T> {\n\tvicinity: &'vicinity Vicinity,\n\tsubstate: SubstrateStackSubstate<'config>,\n\t_marker: PhantomData<T>,\n}\nimpl<'vicinity, 'config, T: Config> SubstrateStackState<'vicinity, 'config, T> {\n\tpub fn new(vicinity: &'vicinity Vicinity, metadata: StackSubstateMetadata<'config>) -> Self {\n\t\tSelf {\n\t\t\tvicinity,\n\t\t\tsubstate: SubstrateStackSubstate {\n\t\t\t\tmetadata,\n\t\t\t\tdeletes: BTreeSet::new(),\n\t\t\t\tlogs: Vec::new(),\n\t\t\t\tparent: None,\n\t\t\t},\n\t\t\t_marker: PhantomData,\n\t\t}\n\t}\n}\nimpl<'vicinity, 'config, T: Config> BackendT for SubstrateStackState<'vicinity, 'config, T> {\n\tfn gas_price(&self) -> U256 {\n\t\tself.vicinity.gas_price\n\t}\n\tfn origin(&self) -> H160 {\n\t\tself.vicinity.origin\n\t}\n\tfn block_hash(&self, number: U256) -> H256 {\n\t\tif number > U256::from(u32::max_value()) {\n\t\t\tH256::default()\n\t\t} else {\n\t\t\tT::BlockHashMapping::block_hash(number.as_u32())\n\t\t}\n\t}\n\tfn block_number(&self) -> U256 {\n\t\tlet number: u128 = frame_system::Pallet::<T>::block_number().unique_saturated_into();\n\t\tU256::from(number)\n\t}\n\tfn block_coinbase(&self) -> H160 {\n\t\tPallet::<T>::find_author()\n\t}\n\tfn block_timestamp(&self) -> U256 {\n\t\tlet now: u128 = pallet_timestamp::Pallet::<T>::get().unique_saturated_into();\n\t\tU256::from(now / 1000)\n\t}\n\tfn block_difficulty(&self) -> U256 {\n\t\tU256::zero()\n\t}\n\tfn block_gas_limit(&self) -> U256 {\n\t\tT::BlockGasLimit::get()\n\t}\n\tfn chain_id(&self) -> U256 {\n\t\tU256::from(T::ChainId::get())\n\t}\n\tfn exists(&self, _address: H160) -> bool {\n\t\ttrue\n\t}\n\tfn basic(&self, address: H160) -> evm::backend::Basic {\n\t\tlet (account, _) = Pallet::<T>::account_basic(&address);\n\t\tevm::backend::Basic {\n\t\t\tbalance: account.balance,\n\t\t\tnonce: account.nonce,\n\t\t}\n\t}\n\tfn code(&self, address: H160) -> Vec<u8> {\n\t\t<AccountCodes<T>>::get(&address)\n\t}\n\tfn storage(&self, address: H160, index: H256) -> H256 {\n\t\t<AccountStorages<T>>::get(address, index)\n\t}\n\tfn original_storage(&self, _address: H160, _index: H256) -> Option<H256> {\n\t\tNone\n\t}\n\tfn block_base_fee_per_gas(&self) -> sp_core::U256 {\n\t\tlet (base_fee, _) = T::FeeCalculator::min_gas_price();\n\t\tbase_fee\n\t}\n}\nimpl<'vicinity, 'config, T: Config> StackStateT<'config>\n\tfor SubstrateStackState<'vicinity, 'config, T>\n{\n\tfn metadata(&self) -> &StackSubstateMetadata<'config> {\n\t\tself.substate.metadata()\n\t}\n\tfn metadata_mut(&mut self) -> &mut StackSubstateMetadata<'config> {\n\t\tself.substate.metadata_mut()\n\t}\n\tfn enter(&mut self, gas_limit: u64, is_static: bool) {\n\t\tself.substate.enter(gas_limit, is_static)\n\t}\n\tfn exit_commit(&mut self) -> Result<(), ExitError> {\n\t\tself.substate.exit_commit()\n\t}\n\tfn exit_revert(&mut self) -> Result<(), ExitError> {\n\t\tself.substate.exit_revert()\n\t}\n\tfn exit_discard(&mut self) -> Result<(), ExitError> {\n\t\tself.substate.exit_discard()\n\t}\n\tfn is_empty(&self, address: H160) -> bool {\n\t\tPallet::<T>::is_account_empty(&address)\n\t}\n\tfn deleted(&self, address: H160) -> bool {\n\t\tself.substate.deleted(address)\n\t}\n\tfn inc_nonce(&mut self, address: H160) {\n\t\tlet account_id = T::AddressMapping::into_account_id(address);\n\t\tframe_system::Pallet::<T>::inc_account_nonce(&account_id);\n\t}\n\tfn set_storage(&mut self, address: H160, index: H256, value: H256) {\n\t\tif value == H256::default() {\n\t\t\tlog::debug!(\n\t\t\t\ttarget: \"evm\",\n\t\t\t\t\"Removing storage for {:?} [index: {:?}]\",\n\t\t\t\taddress,\n\t\t\t\tindex,\n\t\t\t);\n\t\t\t<AccountStorages<T>>::remove(address, index);\n\t\t} else {\n\t\t\tlog::debug!(\n\t\t\t\ttarget: \"evm\",\n\t\t\t\t\"Updating storage for {:?} [index: {:?}, value: {:?}]\",\n\t\t\t\taddress,\n\t\t\t\tindex,\n\t\t\t\tvalue,\n\t\t\t);\n\t\t\t<AccountStorages<T>>::insert(address, index, value);\n\t\t}\n\t}\n\tfn reset_storage(&mut self, address: H160) {\n\t\tlet _ = <AccountStorages<T>>::remove_prefix(address, None);\n\t}\n\tfn log(&mut self, address: H160, topics: Vec<H256>, data: Vec<u8>) {\n\t\tself.substate.log(address, topics, data)\n\t}\n\tfn set_deleted(&mut self, address: H160) {\n\t\tself.substate.set_deleted(address)\n\t}\n\tfn set_code(&mut self, address: H160, code: Vec<u8>) {\n\t\tlog::debug!(\n\t\t\ttarget: \"evm\",\n\t\t\t\"Inserting code ({} bytes) at {:?}\",\n\t\t\tcode.len(),\n\t\t\taddress\n\t\t);\n\t\tPallet::<T>::create_account(address, code);\n\t}\n\tfn transfer(&mut self, transfer: Transfer) -> Result<(), ExitError> {\n\t\tlet source = T::AddressMapping::into_account_id(transfer.source);\n\t\tlet target = T::AddressMapping::into_account_id(transfer.target);\n\t\tT::Currency::transfer(\n\t\t\t&source,\n\t\t\t&target,\n\t\t\ttransfer.value.low_u128().unique_saturated_into(),\n\t\t\tExistenceRequirement::AllowDeath,\n\t\t)\n\t\t.map_err(|_| ExitError::OutOfFund)\n\t}\n\tfn reset_balance(&mut self, _address: H160) {\n\t}\n\tfn touch(&mut self, _address: H160) {\n\t}\n\tfn is_cold(&self, address: H160) -> bool {\n\t\tself.substate\n\t\t\t.recursive_is_cold(&|a| a.accessed_addresses.contains(&address))\n\t}\n\tfn is_storage_cold(&self, address: H160, key: H256) -> bool {\n\t\tself.substate\n\t\t\t.recursive_is_cold(&|a: &Accessed| a.accessed_storage.contains(&(address, key)))\n\t}\n}\n\tfn transfer(&mut self, transfer: Transfer) -> Result<(), ExitError> {\n\t\tlet source = T::AddressMapping::into_account_id(transfer.source);\n\t\tlet target = T::AddressMapping::into_account_id(transfer.target);\n\t\tT::Currency::transfer(\n\t\t\t&source,\n\t\t\t&target,\n\t\t\ttransfer.value.low_u128().unique_saturated_into(),\n\t\t\tExistenceRequirement::AllowDeath,\n\t\t)\n\t\t.map_err(|_| ExitError::OutOfFund)\n\t}\nfn issuance_after_tip() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet before_tip = <Test as Config>::Currency::total_issuance();\n\t\tlet result = EVM::call(\n\t\t\tOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tU256::from(2_000_000_000),\n\t\t\tSome(U256::from(1)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tresult.expect(\"EVM can be called\");\n\t\tlet after_tip = <Test as Config>::Currency::total_issuance();\n\t\tlet (base_fee, _) = <Test as Config>::FeeCalculator::min_gas_price();\n\t\tassert_eq!(after_tip, (before_tip - (base_fee.low_u64() * 21_000)));\n\t});\n}\nfn refunds_and_priority_should_work() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet author = EVM::find_author();\n\t\tlet before_tip = EVM::account_basic(&author).0.balance;\n\t\tlet before_call = EVM::account_basic(&H160::default()).0.balance;\n\t\tlet tip = U256::from(1_500_000_000);\n\t\tlet max_fee_per_gas = U256::from(2_000_000_000);\n\t\tlet used_gas = U256::from(21_000);\n\t\tlet _ = EVM::call(\n\t\t\tOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tmax_fee_per_gas,\n\t\t\tSome(tip),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tlet (base_fee, _) = <Test as Config>::FeeCalculator::min_gas_price();\n\t\tlet actual_tip = (max_fee_per_gas - base_fee).min(tip) * used_gas;\n\t\tlet total_cost = (used_gas * base_fee) + U256::from(actual_tip) + U256::from(1);\n\t\tlet after_call = EVM::account_basic(&H160::default()).0.balance;\n\t\tassert_eq!(after_call, before_call - total_cost);\n\t\tlet after_tip = EVM::account_basic(&author).0.balance;\n\t\tassert_eq!(after_tip, (before_tip + actual_tip.low_u128()));\n\t});\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "    fn load_constant64_full(&mut self, value: u64) -> Reg {\n        let (num_half_words, size, negated) = if value >> 32 == 0 {\n            (2, OperandSize::Size32, (!value << 32) >> 32)\n        } else {\n            (4, OperandSize::Size64, !value)\n        };\n        let first_is_inverted = count_zero_half_words(negated, num_half_words)\n            > count_zero_half_words(value, num_half_words);\n        let ignored_halfword = if first_is_inverted { 0xffff } else { 0 };\n        let mut first_mov_emitted = false;\n        let rd = self.temp_writable_reg(I64);\n        for i in 0..num_half_words {\n            let imm16 = (value >> (16 * i)) & 0xffff;\n            if imm16 != ignored_halfword {\n                if !first_mov_emitted {\n                    first_mov_emitted = true;\n                    if first_is_inverted {\n                        let imm =\n                            MoveWideConst::maybe_with_shift(((!imm16) & 0xffff) as u16, i * 16)\n                                .unwrap();\n                        self.emit(&MInst::MovWide {\n                            op: MoveWideOp::MovN,\n                            rd,\n                            imm,\n                            size,\n                        });\n                    } else {\n                        let imm = MoveWideConst::maybe_with_shift(imm16 as u16, i * 16).unwrap();\n                        self.emit(&MInst::MovWide {\n                            op: MoveWideOp::MovZ,\n                            rd,\n                            imm,\n                            size,\n                        });\n                    }\n                } else {\n                    let imm = MoveWideConst::maybe_with_shift(imm16 as u16, i * 16).unwrap();\n                    self.emit(&MInst::MovWide {\n                        op: MoveWideOp::MovK,\n                        rd,\n                        imm,\n                        size,\n                    });\n                }\n            }\n        }\n        assert!(first_mov_emitted);\n        return self.writable_reg_to_reg(rd);\n        fn count_zero_half_words(mut value: u64, num_half_words: u8) -> usize {\n            let mut count = 0;\n            for _ in 0..num_half_words {\n                if value & 0xffff == 0 {\n                    count += 1;\n                }\n                value >>= 16;\n            }\n            count\n        }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "    fn detect_from(&mut self, from: &'a str, path: &mut Vec<&'a Spanning<&'a str>>) {\n        self.visited.insert(from);\n        if !self.spreads.contains_key(from) {\n            return;\n        }\n        self.path_indices.insert(from, path.len());\n        for node in &self.spreads[from] {\n            let name = &node.item;\n            let index = self.path_indices.get(name).cloned();\n            if let Some(index) = index {\n                let err_pos = if index < path.len() {\n                    path[index]\n                } else {\n                    node\n                };\n                self.errors\n                    .push(RuleError::new(&error_message(name), &[err_pos.start]));\n            } else if !self.visited.contains(name) {\n                path.push(node);\n                self.detect_from(name, path);\n                path.pop();\n            }\n        }\n        self.path_indices.remove(from);\n    }\n    fn exit_document(&mut self, ctx: &mut ValidatorContext<'a, S>, _: &'a Document<S>) {\n        assert!(self.current_fragment.is_none());\n        let mut detector = CycleDetector {\n            visited: HashSet::new(),\n            spreads: &self.spreads,\n            path_indices: HashMap::new(),\n            errors: Vec::new(),\n        };\n        for frag in &self.fragment_order {\n            if !detector.visited.contains(frag) {\n                let mut path = Vec::new();\n                detector.detect_from(frag, &mut path);\n            }\n        }\n        ctx.append_errors(detector.errors);\n    }\n    fn find_reachable_fragments(&self, from: &Scope<'a>, result: &mut HashSet<&'a str>) {\n        if let Scope::Fragment(name) = *from {\n            if result.contains(name) {\n                return;\n            } else {\n                result.insert(name);\n            }\n        }\n        if let Some(spreads) = self.spreads.get(from) {\n            for spread in spreads {\n                self.find_reachable_fragments(&Scope::Fragment(spread), result)\n            }\n        }\n    }\n    fn find_used_vars(\n        &self,\n        from: &Scope<'a>,\n        defined: &HashSet<&'a str>,\n        used: &mut HashSet<&'a str>,\n        visited: &mut HashSet<Scope<'a>>,\n    ) {\n        if visited.contains(from) {\n            return;\n        }\n        visited.insert(from.clone());\n        if let Some(used_vars) = self.used_variables.get(from) {\n            for var in used_vars {\n                if defined.contains(var) {\n                    used.insert(var);\n                }\n            }\n        }\n        if let Some(spreads) = self.spreads.get(from) {\n            for spread in spreads {\n                self.find_used_vars(&Scope::Fragment(spread), defined, used, visited);\n            }\n        }\n    }\n    fn collect_conflicts_between_fragments(\n        &self,\n        conflicts: &mut Vec<Conflict>,\n        fragment_name1: &'a str,\n        fragment_name2: &'a str,\n        mutually_exclusive: bool,\n        ctx: &ValidatorContext<'a, S>,\n    ) where\n        S: ScalarValue,\n    {\n        if fragment_name1 == fragment_name2 {\n            return;\n        }\n        let fragment1 = match self.named_fragments.get(fragment_name1) {\n            Some(f) => f,\n            None => return,\n        };\n        let fragment2 = match self.named_fragments.get(fragment_name2) {\n            Some(f) => f,\n            None => return,\n        };\n        {\n            if self.compared_fragments.borrow().contains(\n                fragment_name1,\n                fragment_name2,\n                mutually_exclusive,\n            ) {\n                return;\n            }\n        }\n        {\n            self.compared_fragments.borrow_mut().insert(\n                fragment_name1,\n                fragment_name2,\n                mutually_exclusive,\n            );\n        }\n        let (field_map1, fragment_names1) =\n            self.get_referenced_fields_and_fragment_names(fragment1, ctx);\n        let (field_map2, fragment_names2) =\n            self.get_referenced_fields_and_fragment_names(fragment2, ctx);\n        self.collect_conflicts_between(\n            conflicts,\n            mutually_exclusive,\n            &field_map1,\n            &field_map2,\n            ctx,\n        );\n        for fragment_name2 in &fragment_names2 {\n            self.collect_conflicts_between_fragments(\n                conflicts,\n                fragment_name1,\n                fragment_name2,\n                mutually_exclusive,\n                ctx,\n            );\n        }\n        for fragment_name1 in &fragment_names1 {\n            self.collect_conflicts_between_fragments(\n                conflicts,\n                fragment_name1,\n                fragment_name2,\n                mutually_exclusive,\n                ctx,\n            );\n        }\n    }\n    fn collect_conflicts_between_fields_and_fragment(\n        &self,\n        conflicts: &mut Vec<Conflict>,\n        field_map: &AstAndDefCollection<'a, S>,\n        fragment_name: &str,\n        mutually_exclusive: bool,\n        ctx: &ValidatorContext<'a, S>,\n    ) where\n        S: ScalarValue,\n    {\n        let fragment = match self.named_fragments.get(fragment_name) {\n            Some(f) => f,\n            None => return,\n        };\n        let (field_map2, fragment_names2) =\n            self.get_referenced_fields_and_fragment_names(fragment, ctx);\n        self.collect_conflicts_between(conflicts, mutually_exclusive, field_map, &field_map2, ctx);\n        for fragment_name2 in fragment_names2 {\n            if fragment_name == fragment_name2 {\n                return;\n            }\n            self.collect_conflicts_between_fields_and_fragment(\n                conflicts,\n                field_map,\n                fragment_name2,\n                mutually_exclusive,\n                ctx,\n            );\n        }\n    }\n    fn collect_conflicts_between(\n        &self,\n        conflicts: &mut Vec<Conflict>,\n        mutually_exclusive: bool,\n        field_map1: &AstAndDefCollection<'a, S>,\n        field_map2: &AstAndDefCollection<'a, S>,\n        ctx: &ValidatorContext<'a, S>,\n    ) where\n        S: ScalarValue,\n    {\n        for (response_name, fields1) in field_map1.iter() {\n            if let Some(fields2) = field_map2.get(response_name) {\n                for field1 in fields1 {\n                    for field2 in fields2 {\n                        if let Some(conflict) = self.find_conflict(\n                            response_name,\n                            field1,\n                            field2,\n                            mutually_exclusive,\n                            ctx,\n                        ) {\n                            conflicts.push(conflict);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    fn detect_from(&mut self, from: &'a str, path: &mut Vec<&'a Spanning<&'a str>>) {\n        self.visited.insert(from);\n        if !self.spreads.contains_key(from) {\n            return;\n        }\n        self.path_indices.insert(from, path.len());\n        for node in &self.spreads[from] {\n            let name = &node.item;\n            let index = self.path_indices.get(name).cloned();\n            if let Some(index) = index {\n                let err_pos = if index < path.len() {\n                    path[index]\n                } else {\n                    node\n                };\n                self.errors\n                    .push(RuleError::new(&error_message(name), &[err_pos.start]));\n            } else if !self.visited.contains(name) {\n                path.push(node);\n                self.detect_from(name, path);\n                path.pop();\n            }\n        }\n        self.path_indices.remove(from);\n    }\n    fn exit_document(&mut self, ctx: &mut ValidatorContext<'a, S>, _: &'a Document<S>) {\n        assert!(self.current_fragment.is_none());\n        let mut detector = CycleDetector {\n            visited: HashSet::new(),\n            spreads: &self.spreads,\n            path_indices: HashMap::new(),\n            errors: Vec::new(),\n        };\n        for frag in &self.fragment_order {\n            if !detector.visited.contains(frag) {\n                let mut path = Vec::new();\n                detector.detect_from(frag, &mut path);\n            }\n        }\n        ctx.append_errors(detector.errors);\n    }\n    fn find_reachable_fragments(&self, from: &Scope<'a>, result: &mut HashSet<&'a str>) {\n        if let Scope::Fragment(name) = *from {\n            if result.contains(name) {\n                return;\n            } else {\n                result.insert(name);\n            }\n        }\n        if let Some(spreads) = self.spreads.get(from) {\n            for spread in spreads {\n                self.find_reachable_fragments(&Scope::Fragment(spread), result)\n            }\n        }\n    }\n    fn find_used_vars(\n        &self,\n        from: &Scope<'a>,\n        defined: &HashSet<&'a str>,\n        used: &mut HashSet<&'a str>,\n        visited: &mut HashSet<Scope<'a>>,\n    ) {\n        if visited.contains(from) {\n            return;\n        }\n        visited.insert(from.clone());\n        if let Some(used_vars) = self.used_variables.get(from) {\n            for var in used_vars {\n                if defined.contains(var) {\n                    used.insert(var);\n                }\n            }\n        }\n        if let Some(spreads) = self.spreads.get(from) {\n            for spread in spreads {\n                self.find_used_vars(&Scope::Fragment(spread), defined, used, visited);\n            }\n        }\n    }\n    fn collect_conflicts_between_fragments(\n        &self,\n        conflicts: &mut Vec<Conflict>,\n        fragment_name1: &'a str,\n        fragment_name2: &'a str,\n        mutually_exclusive: bool,\n        ctx: &ValidatorContext<'a, S>,\n    ) where\n        S: ScalarValue,\n    {\n        if fragment_name1 == fragment_name2 {\n            return;\n        }\n        let fragment1 = match self.named_fragments.get(fragment_name1) {\n            Some(f) => f,\n            None => return,\n        };\n        let fragment2 = match self.named_fragments.get(fragment_name2) {\n            Some(f) => f,\n            None => return,\n        };\n        {\n            if self.compared_fragments.borrow().contains(\n                fragment_name1,\n                fragment_name2,\n                mutually_exclusive,\n            ) {\n                return;\n            }\n        }\n        {\n            self.compared_fragments.borrow_mut().insert(\n                fragment_name1,\n                fragment_name2,\n                mutually_exclusive,\n            );\n        }\n        let (field_map1, fragment_names1) =\n            self.get_referenced_fields_and_fragment_names(fragment1, ctx);\n        let (field_map2, fragment_names2) =\n            self.get_referenced_fields_and_fragment_names(fragment2, ctx);\n        self.collect_conflicts_between(\n            conflicts,\n            mutually_exclusive,\n            &field_map1,\n            &field_map2,\n            ctx,\n        );\n        for fragment_name2 in &fragment_names2 {\n            self.collect_conflicts_between_fragments(\n                conflicts,\n                fragment_name1,\n                fragment_name2,\n                mutually_exclusive,\n                ctx,\n            );\n        }\n        for fragment_name1 in &fragment_names1 {\n            self.collect_conflicts_between_fragments(\n                conflicts,\n                fragment_name1,\n                fragment_name2,\n                mutually_exclusive,\n                ctx,\n            );\n        }\n    }\n    fn collect_conflicts_between_fields_and_fragment(\n        &self,\n        conflicts: &mut Vec<Conflict>,\n        field_map: &AstAndDefCollection<'a, S>,\n        fragment_name: &str,\n        mutually_exclusive: bool,\n        ctx: &ValidatorContext<'a, S>,\n    ) where\n        S: ScalarValue,\n    {\n        let fragment = match self.named_fragments.get(fragment_name) {\n            Some(f) => f,\n            None => return,\n        };\n        let (field_map2, fragment_names2) =\n            self.get_referenced_fields_and_fragment_names(fragment, ctx);\n        self.collect_conflicts_between(conflicts, mutually_exclusive, field_map, &field_map2, ctx);\n        for fragment_name2 in fragment_names2 {\n            if fragment_name == fragment_name2 {\n                return;\n            }\n            self.collect_conflicts_between_fields_and_fragment(\n                conflicts,\n                field_map,\n                fragment_name2,\n                mutually_exclusive,\n                ctx,\n            );\n        }\n    }\n    fn collect_conflicts_between(\n        &self,\n        conflicts: &mut Vec<Conflict>,\n        mutually_exclusive: bool,\n        field_map1: &AstAndDefCollection<'a, S>,\n        field_map2: &AstAndDefCollection<'a, S>,\n        ctx: &ValidatorContext<'a, S>,\n    ) where\n        S: ScalarValue,\n    {\n        for (response_name, fields1) in field_map1.iter() {\n            if let Some(fields2) = field_map2.get(response_name) {\n                for field1 in fields1 {\n                    for field2 in fields2 {\n                        if let Some(conflict) = self.find_conflict(\n                            response_name,\n                            field1,\n                            field2,\n                            mutually_exclusive,\n                            ctx,\n                        ) {\n                            conflicts.push(conflict);\n                        }\n                    }\n                }\n            }\n        }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn recv_dataframe<R>(&mut self, reader: &mut R) -> WebSocketResult<DataFrame>\n\twhere\n\t\tR: Read,\n\t{\n\t\tDataFrame::read_dataframe(reader, self.mask)\n\t}\n\tfn recv_message_dataframes<R>(&mut self, reader: &mut R) -> WebSocketResult<Vec<DataFrame>>\n\twhere\n\t\tR: Read,\n\t{\n\t\tlet mut finished = if self.buffer.is_empty() {\n\t\t\tlet first = self.recv_dataframe(reader)?;\n\t\t\tif first.opcode == Opcode::Continuation {\n\t\t\t\treturn Err(WebSocketError::ProtocolError(\n\t\t\t\t\t\"Unexpected continuation data frame opcode\",\n\t\t\t\t));\n\t\t\t}\n\t\t\tlet finished = first.finished;\n\t\t\tself.buffer.push(first);\n\t\t\tfinished\n\t\t} else {\n\t\t\tfalse\n\t\t};\n\t\twhile !finished {\n\t\t\tlet next = self.recv_dataframe(reader)?;\n\t\t\tfinished = next.finished;\n\t\t\tmatch next.opcode as u8 {\n\t\t\t\t0 => self.buffer.push(next),\n\t\t\t\t8..=15 => {\n\t\t\t\t\treturn Ok(vec![next]);\n\t\t\t\t}\n\t\t\t\t_ => {\n\t\t\t\t\treturn Err(WebSocketError::ProtocolError(\n\t\t\t\t\t\t\"Unexpected data frame opcode\",\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tOk(::std::mem::replace(&mut self.buffer, Vec::new()))\n\t}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn error_on_execution_failure(reason: &ExitReason, data: &[u8]) -> Result<()> {\n\tmatch reason {\n\t\tExitReason::Succeed(_) => Ok(()),\n\t\tExitReason::Error(e) => {\n\t\t\tif *e == ExitError::OutOfGas {\n\t\t\t\treturn Err(internal_err(\"out of gas\"));\n\t\t\t}\n\t\t\tErr(crate::internal_err_with_data(\n\t\t\t\tformat!(\"evm error: {:?}\", e),\n\t\t\t\t&[],\n\t\t\t))\n\t\t}\n\t\tExitReason::Revert(_) => {\n\t\t\tlet mut message = \"VM Exception while processing transaction: revert\".to_string();\n\t\t\tif data.len() > 68 {\n\t\t\t\tlet message_len = data[36..68].iter().sum::<u8>();\n\t\t\t\tif data.len() >= 68 + message_len as usize {\n\t\t\t\t\tlet body: &[u8] = &data[68..68 + message_len as usize];\n\t\t\t\t\tif let Ok(reason) = std::str::from_utf8(body) {\n\t\t\t\t\t\tmessage = format!(\"{} {}\", message, reason);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tErr(crate::internal_err_with_data(message, data))\n\t\t}\n\t\tExitReason::Fatal(e) => Err(crate::internal_err_with_data(\n\t\t\tformat!(\"evm fatal: {:?}\", e),\n\t\t\t&[],\n\t\t)),\n\t}\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "Status RangeSize(const Tensor* start_t, const Tensor* limit_t,\n                 const Tensor* delta_t, InferenceContext* const c) {\n  T start = start_t->scalar<T>()();\n  T limit = limit_t->scalar<T>()();\n  T delta = delta_t->scalar<T>()();\n  if (start > limit && delta > T(0)) {\n    return errors::InvalidArgument(\n        \"Requires start <= limit when delta > 0: \", start, \"/\", limit);\n  }\n  if (start < limit && delta < T(0)) {\n    return errors::InvalidArgument(\n        \"Requires start >= limit when delta < 0: \", start, \"/\", limit);\n  }\n  if (delta == T(0)) {\n    return errors::InvalidArgument(\"Requires delta != 0\");\n  }\n  auto size = (std::is_integral<T>::value\n                   ? ((Eigen::numext::abs(limit - start) +\n                       Eigen::numext::abs(delta) - T(1)) /\n                      Eigen::numext::abs(delta))\n                   : (Eigen::numext::ceil(\n                         Eigen::numext::abs((limit - start) / delta))));\n  if (size > std::numeric_limits<int64_t>::max()) {\n    return errors::InvalidArgument(\"Requires ((limit - start) / delta) <= \",\n                                   std::numeric_limits<int64_t>::max());\n  }\n  c->set_output(0, c->Vector(static_cast<int64_t>(size)));\n  return Status::OK();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn unpack_package(&self, pkg: PackageId, tarball: &File) -> CargoResult<PathBuf> {\n        let package_dir = format!(\"{}-{}\", pkg.name(), pkg.version());\n        let dst = self.src_path.join(&package_dir);\n        dst.create_dir()?;\n        let path = dst.join(PACKAGE_SOURCE_LOCK);\n        let path = self.config.assert_package_cache_locked(&path);\n        let unpack_dir = path.parent().unwrap();\n        if let Ok(meta) = path.metadata() {\n            if meta.len() > 0 {\n                return Ok(unpack_dir.to_path_buf());\n            }\n        }\n        let gz = GzDecoder::new(tarball);\n        let mut tar = Archive::new(gz);\n        let prefix = unpack_dir.file_name().unwrap();\n        let parent = unpack_dir.parent().unwrap();\n        for entry in tar.entries()? {\n            let mut entry = entry.with_context(|| \"failed to iterate over archive\")?;\n            let entry_path = entry\n                .path()\n                .with_context(|| \"failed to read entry path\")?\n                .into_owned();\n            if !entry_path.starts_with(prefix) {\n                anyhow::bail!(\n                    \"invalid tarball downloaded, contains \\\n                     a file at {:?} which isn't under {:?}\",\n                    entry_path,\n                    prefix\n                )\n            }\n            let mut result = entry.unpack_in(parent).map_err(anyhow::Error::from);\n            if cfg!(windows) && restricted_names::is_windows_reserved_path(&entry_path) {\n                result = result.with_context(|| {\n                    format!(\n                        \"`{}` appears to contain a reserved Windows path, \\\n                        it cannot be extracted on Windows\",\n                        entry_path.display()\n                    )\n                });\n            }\n            result\n                .with_context(|| format!(\"failed to unpack entry at `{}`\", entry_path.display()))?;\n        }\n        let mut ok = OpenOptions::new()\n            .create(true)\n            .read(true)\n            .write(true)\n            .open(&path)\n            .with_context(|| format!(\"failed to open `{}`\", path.display()))?;\n        write!(ok, \"ok\")?;\n        Ok(unpack_dir.to_path_buf())\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn check_perms() {\n        super::message::info(\"Obtaining root permissions...\\n\");\n        let mut cmd = self::run_as_normal_user(\"sudo\");\n        cmd.arg(\"true\");\n        if !cmd.spawn().unwrap().wait().unwrap().success() {\n            super::message::error(\"Couldn't obtain root permissions.\\n\");\n            quit::with_code(exitcode::USAGE);\n        }\n    }\npub fn run_as_normal_user<P: AsRef<super::OsStr>>(program: P) -> super::ProcCommand {\n        let mut cmd = super::ProcCommand::new(\"sudo\");\n        cmd.args([\"-E\", \"-n\"]);\n        cmd.arg(format!(\"-u#{}\", *self::NORMAL_UID));\n        cmd.arg(\"--\");\n        cmd.arg(program);\n        cmd\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "async fn receive_supported_keys(\n        &self,\n        sender_key: Curve25519PublicKey,\n        event: &DecryptedForwardedRoomKeyEvent,\n        content: &ForwardedMegolmV1AesSha2Content,\n    ) -> Result<Option<InboundGroupSession>, CryptoStoreError> {\n        let algorithm = event.content.algorithm();\n        if let Some(info) = self.get_key_info(event).await? {\n            self.accept_forwarded_room_key(&info, &event.sender, sender_key, algorithm, content)\n                .await\n        } else {\n            warn!(\n                sender = %event.sender,\n                sender_key = %sender_key,\n                room_id = %content.room_id,\n                session_id = content.session_id.as_str(),\n                claimed_sender_key = %content.claimed_sender_key,\n                algorithm = %algorithm,\n                \"Received a forwarded room key that we didn't request\",\n            );\n            Ok(None)\n        }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn build(self) -> Auth {\n        self.auth\n    }\nfn canonicalized_resource(&self) -> Cow<'_, CanonicalizedResource> {\n        Cow::Borrowed(&self.canonicalized_resource)\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "function ecsign(d, z) {\n        while (true) {\n            const k = rnd(P)\n            const R = mulG(k)\n            if (R[0] == 0) continue\n            const s = mulmod(invmod(k, N), addmod(z, mulmod(R[0], d, N), N), N)\n            if (s == 0) continue\n            if (s.testn(255)) continue\n            return {r: toHex(R[0]), s: toHex(s), v: R[1].testn(0) ? 1 : 0}\n        }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "Status FractionalPoolShapeFn(InferenceContext* c) {\n  ShapeHandle input;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 4, &input));\n  std::vector<float> pooling_ratio;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"pooling_ratio\", &pooling_ratio));\n  if (pooling_ratio.size() != 4) {\n    return errors::InvalidArgument(\n        \"pooling_ratio field must specify 4 dimensions\");\n  }\n  std::vector<DimensionHandle> output_dims;\n  for (int i = 0; i < 4; ++i) {\n    DimensionHandle d = c->Dim(input, i);\n    if (c->ValueKnown(d)) {\n      auto val =\n          static_cast<int64_t>(std::floor(c->Value(d) / pooling_ratio[i]));\n      if (val < 0) {\n        return errors::InvalidArgument(\"Size computed for dim \", i,\n                                       \" is negative: \", val);\n      }\n      output_dims.push_back(c->MakeDim(val));\n    } else {\n      output_dims.push_back(c->UnknownDim());\n    }\n  }\n  c->set_output(0, c->MakeShape(output_dims));\n  c->set_output(1, c->Vector(output_dims[1]));\n  c->set_output(2, c->Vector(output_dims[2]));\n  return OkStatus();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "Status FractionalPoolShapeFn(InferenceContext* c) {\n  ShapeHandle input;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 4, &input));\n  std::vector<float> pooling_ratio;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"pooling_ratio\", &pooling_ratio));\n  if (pooling_ratio.size() != 4) {\n    return errors::InvalidArgument(\n        \"pooling_ratio field must specify 4 dimensions\");\n  }\n  std::vector<DimensionHandle> output_dims;\n  for (int i = 0; i < 4; ++i) {\n    DimensionHandle d = c->Dim(input, i);\n    if (c->ValueKnown(d)) {\n      auto val =\n          static_cast<int64_t>(std::floor(c->Value(d) / pooling_ratio[i]));\n      if (val < 0) {\n        return errors::InvalidArgument(\"Size computed for dim \", i,\n                                       \" is negative: \", val);\n      }\n      output_dims.push_back(c->MakeDim(val));\n    } else {\n      output_dims.push_back(c->UnknownDim());\n    }\n  }\n  c->set_output(0, c->MakeShape(output_dims));\n  c->set_output(1, c->Vector(output_dims[1]));\n  c->set_output(2, c->Vector(output_dims[2]));\n  return OkStatus();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn get_apk_signature(apk: &str) -> Result<(u32, u32)> {\n    let mut buffer = [0u8; 0x10];\n    let mut size4 = [0u8; 4];\n    let mut size8 = [0u8; 8];\n    let mut size_of_block = [0u8; 8];\n    let mut f = std::fs::File::open(apk)?;\n    let mut i = 0;\n    loop {\n        let mut n = [0u8; 2];\n        f.seek(SeekFrom::End(-i - 2))?;\n        f.read_exact(&mut n)?;\n        let n = u16::from_le_bytes(n);\n        if i64::from(n) == i {\n            f.seek(SeekFrom::Current(-22))?;\n            f.read_exact(&mut size4)?;\n            if u32::from_le_bytes(size4) ^ 0xcafe_babe_u32 == 0xccfb_f1ee_u32 {\n                if i > 0 {\n                    println!(\"warning: comment length is {i}\");\n                }\n                break;\n            }\n        }\n        ensure!(n != 0xffff, \"not a zip file\");\n        i += 1;\n    }\n    f.seek(SeekFrom::Current(12))?;\n    f.read_exact(&mut size4)?;\n    f.seek(SeekFrom::Start(u64::from(u32::from_le_bytes(size4)) - 0x18))?;\n    f.read_exact(&mut size8)?;\n    f.read_exact(&mut buffer)?;\n    ensure!(&buffer == b\"APK Sig Block 42\", \"Can not found sig block\");\n    let pos = u64::from(u32::from_le_bytes(size4)) - (u64::from_le_bytes(size8) + 0x8);\n    f.seek(SeekFrom::Start(pos))?;\n    f.read_exact(&mut size_of_block)?;\n    ensure!(size_of_block == size8, \"not a signed apk\");\n    loop {\n        let mut id = [0u8; 4];\n        let offset = 4u32;\n        f.read_exact(&mut size8)?; \n        if size8 == size_of_block {\n            break;\n        }\n        f.read_exact(&mut id)?; \n        let id = u32::from_le_bytes(id);\n        if (id ^ 0xdead_beef_u32) == 0xafa4_39f5_u32 || (id ^ 0xdead_beef_u32) == 0x2efe_d62f_u32 {\n            f.read_exact(&mut size4)?; \n            f.read_exact(&mut size4)?; \n            f.read_exact(&mut size4)?; \n            f.read_exact(&mut size4)?; \n            let pos = u32::from_le_bytes(size4);\n            f.seek(SeekFrom::Current(i64::from(pos)))?;\n            f.read_exact(&mut size4)?; \n            f.read_exact(&mut size4)?; \n            let mut hash = 1i32;\n            let mut c = [0u8; 1];\n            let j = u32::from_le_bytes(size4);\n            for _ in 0..j {\n                f.read_exact(&mut c)?;\n                hash = hash.wrapping_mul(31).wrapping_add(i32::from(c[0] as i8));\n            }\n            let out_size = j;\n            let out_hash = (hash as u32) ^ 0x1413_1211_u32;\n            return Ok((out_size, out_hash));\n        }\n        f.seek(SeekFrom::Current(\n            i64::from_le_bytes(size8) - i64::from(offset),\n        ))?;\n    }\n    Err(anyhow::anyhow!(\"Unknown error\"))\n}\npub fn get_apk_signature(apk: &str) -> Result<(u32, u32)> {\n    let mut buffer = [0u8; 0x10];\n    let mut size4 = [0u8; 4];\n    let mut size8 = [0u8; 8];\n    let mut size_of_block = [0u8; 8];\n    let mut f = std::fs::File::open(apk)?;\n    let mut i = 0;\n    loop {\n        let mut n = [0u8; 2];\n        f.seek(SeekFrom::End(-i - 2))?;\n        f.read_exact(&mut n)?;\n        let n = u16::from_le_bytes(n);\n        if i64::from(n) == i {\n            f.seek(SeekFrom::Current(-22))?;\n            f.read_exact(&mut size4)?;\n            if u32::from_le_bytes(size4) ^ 0xcafe_babe_u32 == 0xccfb_f1ee_u32 {\n                if i > 0 {\n                    println!(\"warning: comment length is {i}\");\n                }\n                break;\n            }\n        }\n        ensure!(n != 0xffff, \"not a zip file\");\n        i += 1;\n    }\n    f.seek(SeekFrom::Current(12))?;\n    f.read_exact(&mut size4)?;\n    f.seek(SeekFrom::Start(u64::from(u32::from_le_bytes(size4)) - 0x18))?;\n    f.read_exact(&mut size8)?;\n    f.read_exact(&mut buffer)?;\n    ensure!(&buffer == b\"APK Sig Block 42\", \"Can not found sig block\");\n    let pos = u64::from(u32::from_le_bytes(size4)) - (u64::from_le_bytes(size8) + 0x8);\n    f.seek(SeekFrom::Start(pos))?;\n    f.read_exact(&mut size_of_block)?;\n    ensure!(size_of_block == size8, \"not a signed apk\");\n    loop {\n        let mut id = [0u8; 4];\n        let offset = 4u32;\n        f.read_exact(&mut size8)?; \n        if size8 == size_of_block {\n            break;\n        }\n        f.read_exact(&mut id)?; \n        let id = u32::from_le_bytes(id);\n        if (id ^ 0xdead_beef_u32) == 0xafa4_39f5_u32 || (id ^ 0xdead_beef_u32) == 0x2efe_d62f_u32 {\n            f.read_exact(&mut size4)?; \n            f.read_exact(&mut size4)?; \n            f.read_exact(&mut size4)?; \n            f.read_exact(&mut size4)?; \n            let pos = u32::from_le_bytes(size4);\n            f.seek(SeekFrom::Current(i64::from(pos)))?;\n            f.read_exact(&mut size4)?; \n            f.read_exact(&mut size4)?; \n            let mut hash = 1i32;\n            let mut c = [0u8; 1];\n            let j = u32::from_le_bytes(size4);\n            for _ in 0..j {\n                f.read_exact(&mut c)?;\n                hash = hash.wrapping_mul(31).wrapping_add(i32::from(c[0] as i8));\n            }\n            let out_size = j;\n            let out_hash = (hash as u32) ^ 0x1413_1211_u32;\n            return Ok((out_size, out_hash));\n        }\n        f.seek(SeekFrom::Current(\n            i64::from_le_bytes(size8) - i64::from(offset),\n        ))?;\n    }\n    Err(anyhow::anyhow!(\"Unknown error\"))\n}\npub fn run() -> Result<()> {\n    #[cfg(target_os = \"android\")]\n    android_logger::init_once(\n        Config::default()\n            .with_max_level(LevelFilter::Trace) \n            .with_tag(\"KernelSU\"), \n    );\n    #[cfg(not(target_os = \"android\"))]\n    env_logger::init();\n    let arg0 = std::env::args().next().unwrap_or_default();\n    if arg0 == \"su\" || arg0 == \"/system/bin/su\" {\n        return crate::ksu::root_shell();\n    }\n    let cli = Args::parse();\n    log::info!(\"command: {:?}\", cli.command);\n    let result = match cli.command {\n        Commands::PostFsData => event::on_post_data_fs(),\n        Commands::BootCompleted => event::on_boot_completed(),\n        Commands::Module { command } => {\n            #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n            {\n                utils::switch_mnt_ns(1)?;\n                utils::unshare_mnt_ns()?;\n            }\n            match command {\n                Module::Install { zip } => module::install_module(&zip),\n                Module::Uninstall { id } => module::uninstall_module(&id),\n                Module::Enable { id } => module::enable_module(&id),\n                Module::Disable { id } => module::disable_module(&id),\n                Module::List => module::list_modules(),\n            }\n        }\n        Commands::Install => event::install(),\n        Commands::Sepolicy { command } => match command {\n            Sepolicy::Patch { sepolicy } => crate::sepolicy::live_patch(&sepolicy),\n            Sepolicy::Apply { file } => crate::sepolicy::apply_file(file),\n            Sepolicy::Check { sepolicy } => crate::sepolicy::check_rule(&sepolicy),\n        },\n        Commands::Services => event::on_services(),\n        Commands::Profile { command } => match command {\n            Profile::GetSepolicy { package } => crate::profile::get_sepolicy(package),\n            Profile::SetSepolicy { package, policy } => {\n                crate::profile::set_sepolicy(package, policy)\n            }\n            Profile::GetTemplate { package } => crate::profile::get_template(package),\n            Profile::SetTemplate { package, template } => {\n                crate::profile::set_template(package, template)\n            }\n            Profile::ListTemplates => crate::profile::list_templates(),\n        },\n        Commands::Debug { command } => match command {\n            Debug::SetManager { apk } => debug::set_manager(&apk),\n            Debug::GetSign { apk } => {\n                let sign = apk_sign::get_apk_signature(&apk)?;\n                println!(\"size: {:#x}, hash: {:#x}\", sign.0, sign.1);\n                Ok(())\n            }\n            Debug::Version => {\n                println!(\"Kernel Version: {}\", crate::ksu::get_version());\n                Ok(())\n            }\n            Debug::Su => crate::ksu::grant_root(),\n            Debug::Mount => event::mount_systemlessly(defs::MODULE_DIR),\n            Debug::Test => todo!(),\n        },\n    };\n    if let Err(e) = &result {\n        log::error!(\"Error: {:?}\", e);\n    }\n    result\n}\nfn set_kernel_param(size: u32, hash: u32) -> Result<()> {\n    let kernel_param_path = Path::new(KERNEL_PARAM_PATH).join(\"parameters\");\n    let expeced_size_path = kernel_param_path.join(\"ksu_expected_size\");\n    let expeced_hash_path = kernel_param_path.join(\"ksu_expected_hash\");\n    println!(\n        \"before size: {:#x} hash: {:#x}\",\n        read_u32(&expeced_size_path)?,\n        read_u32(&expeced_hash_path)?\n    );\n    std::fs::write(&expeced_size_path, size.to_string())?;\n    std::fs::write(&expeced_hash_path, hash.to_string())?;\n    println!(\n        \"after size: {:#x} hash: {:#x}\",\n        read_u32(&expeced_size_path)?,\n        read_u32(&expeced_hash_path)?\n    );\n    Ok(())\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn pipe_mode(&mut self, pipe_mode: PipeMode) -> &mut Self {\n        self.pipe_mode = match pipe_mode {\n            PipeMode::Byte => winbase::PIPE_TYPE_BYTE,\n            PipeMode::Message => winbase::PIPE_TYPE_MESSAGE,\n        };\n        self\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn shuffle_0_31_mask(&mut self, mask: &VecMask) -> VCodeConstant {\n        let mask = mask\n            .iter()\n            .map(|&b| if b > 15 { b.wrapping_sub(15) } else { b })\n            .map(|b| if b > 15 { 0b10000000 } else { b })\n            .collect();\n        self.lower_ctx\n            .use_constant(VCodeConstantData::Generated(mask))\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "use std::ops::Shl;\npub fn generate_private_key(&mut self) -> BigUint {\n        let q = (&self.prime_num - &BigUint::from(1u8)) / &BigUint::from(2u8);\n        let mut rng = rand::thread_rng();\n        self.private_key = rng.gen_biguint((self.exp_size * 8) - 2u64).shl(1);\n        self.private_key.clone()\n    }\n#[doc(hidden)]\n    fn server_dh(&mut self, exchange: &mut Exchange, payload: &[u8]) -> Result<(), crate::Error> {\n        debug!(\"server_dh\");\n        let client_pubkey = {\n            if payload.first() != Some(&msg::KEX_ECDH_INIT) {\n                return Err(crate::Error::Inconsistent);\n            }\n            #[allow(clippy::indexing_slicing)] \n            let pubkey_len = BigEndian::read_u32(&payload[1..]) as usize;\n            if payload.len() < 5 + pubkey_len {\n                return Err(crate::Error::Inconsistent);\n            }\n            &payload\n                .get(5..(5 + pubkey_len))\n                .ok_or(crate::Error::Inconsistent)?\n        };\n        debug!(\"client_pubkey: {:?}\", client_pubkey);\n        self.dh.generate_private_key();\n        let server_pubkey = biguint_to_mpint(&self.dh.generate_public_key());\n        exchange.server_ephemeral.clear();\n        exchange.server_ephemeral.extend(&server_pubkey);\n        let shared = self\n            .dh\n            .compute_shared_secret(DH::decode_public_key(client_pubkey));\n        self.shared_secret = Some(biguint_to_mpint(&shared));\n        Ok(())\n    }\n#[doc(hidden)]\n    fn client_dh(\n        &mut self,\n        client_ephemeral: &mut CryptoVec,\n        buf: &mut CryptoVec,\n    ) -> Result<(), crate::Error> {\n        self.dh.generate_private_key();\n        let client_pubkey = biguint_to_mpint(&self.dh.generate_public_key());\n        client_ephemeral.clear();\n        client_ephemeral.extend(&client_pubkey);\n        buf.push(msg::KEX_ECDH_INIT);\n        buf.extend_ssh_string(&client_pubkey);\n        Ok(())\n    }\n    fn compute_shared_secret(&mut self, remote_pubkey_: &[u8]) -> Result<(), crate::Error> {\n        let remote_pubkey = DH::decode_public_key(remote_pubkey_);\n        self.shared_secret = Some(biguint_to_mpint(&shared));\n        Ok(())\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn calculate_gas_cost(\n\tbase_length: u64,\n\tmod_length: u64,\n\texponent: &BigUint,\n\texponent_bytes: &[u8],\n) -> u64 {\n\tfn calculate_multiplication_complexity(base_length: u64, mod_length: u64) -> u64 {\n\t\tlet max_length = max(base_length, mod_length);\n\t\tlet mut words = max_length / 8;\n\t\tif max_length % 8 > 0 {\n\t\t\twords += 1;\n\t\t}\n\t\twords * words\n\t}\n\tfn calculate_iteration_count(exponent: &BigUint, exponent_bytes: &[u8]) -> u64 {\n\t\tlet mut iteration_count: u64 = 0;\n\t\tlet exp_length = exponent_bytes.len() as u64;\n\t\tif exp_length <= 32 && exponent.is_zero() {\n\t\t\titeration_count = 0;\n\t\t} else if exp_length <= 32 {\n\t\t\titeration_count = exponent.bits() - 1;\n\t\t} else if exp_length > 32 {\n\t\t\tlet exponent_head = BigUint::from_bytes_be(&exponent_bytes[..32]);\n\t\t\titeration_count = (8 * (exp_length - 32)) + exponent_head.bits() - 1;\n\t\t}\n\t\tmax(iteration_count, 1)\n\t}\n\tlet multiplication_complexity = calculate_multiplication_complexity(base_length, mod_length);\n\tlet iteration_count = calculate_iteration_count(exponent, exponent_bytes);\n\tmax(\n\t\tMIN_GAS_COST,\n\t\tmultiplication_complexity * iteration_count / 3,\n\t)\n}\nfn execute(handle: &mut impl PrecompileHandle) -> PrecompileResult {\n\t\tlet input = handle.input();\n\t\tlet mut input_offset = 0;\n\t\tlet mut base_len_buf = [0u8; 32];\n\t\tread_input(input, &mut base_len_buf, &mut input_offset);\n\t\tlet mut exp_len_buf = [0u8; 32];\n\t\tread_input(input, &mut exp_len_buf, &mut input_offset);\n\t\tlet mut mod_len_buf = [0u8; 32];\n\t\tread_input(input, &mut mod_len_buf, &mut input_offset);\n\t\tlet max_size_big = BigUint::from_u32(1024).expect(\"can't create BigUint\");\n\t\tlet base_len_big = BigUint::from_bytes_be(&base_len_buf);\n\t\tif base_len_big > max_size_big {\n\t\t\treturn Err(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"unreasonably large base length\".into()),\n\t\t\t});\n\t\t}\n\t\tlet exp_len_big = BigUint::from_bytes_be(&exp_len_buf);\n\t\tif exp_len_big > max_size_big {\n\t\t\treturn Err(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"unreasonably large exponent length\".into()),\n\t\t\t});\n\t\t}\n\t\tlet mod_len_big = BigUint::from_bytes_be(&mod_len_buf);\n\t\tif mod_len_big > max_size_big {\n\t\t\treturn Err(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"unreasonably large modulus length\".into()),\n\t\t\t});\n\t\t}\n\t\tlet base_len = base_len_big.to_usize().expect(\"base_len out of bounds\");\n\t\tlet exp_len = exp_len_big.to_usize().expect(\"exp_len out of bounds\");\n\t\tlet mod_len = mod_len_big.to_usize().expect(\"mod_len out of bounds\");\n\t\tif mod_len == 0 {\n\t\t\treturn Ok(PrecompileOutput {\n\t\t\t\texit_status: ExitSucceed::Returned,\n\t\t\t\toutput: vec![],\n\t\t\t});\n\t\t}\n\t\tlet r = if base_len == 0 && mod_len == 0 {\n\t\t\thandle.record_cost(MIN_GAS_COST)?;\n\t\t\tBigUint::zero()\n\t\t} else {\n\t\t\tlet mut base_buf = vec![0u8; base_len];\n\t\t\tread_input(input, &mut base_buf, &mut input_offset);\n\t\t\tlet base = BigUint::from_bytes_be(&base_buf);\n\t\t\tlet mut exp_buf = vec![0u8; exp_len];\n\t\t\tread_input(input, &mut exp_buf, &mut input_offset);\n\t\t\tlet exponent = BigUint::from_bytes_be(&exp_buf);\n\t\t\tlet mut mod_buf = vec![0u8; mod_len];\n\t\t\tread_input(input, &mut mod_buf, &mut input_offset);\n\t\t\tlet modulus = BigUint::from_bytes_be(&mod_buf);\n\t\t\tlet gas_cost = calculate_gas_cost(base_len as u64, mod_len as u64, &exponent, &exp_buf);\n\t\t\thandle.record_cost(gas_cost)?;\n\t\t\tif modulus.is_zero() || modulus.is_one() {\n\t\t\t\tBigUint::zero()\n\t\t\t} else {\n\t\t\t\tbase.modpow(&exponent, &modulus)\n\t\t\t}\n\t\t};\n\t\tlet bytes = r.to_bytes_be();\n\t\tif bytes.len() == mod_len {\n\t\t\tOk(PrecompileOutput {\n\t\t\t\texit_status: ExitSucceed::Returned,\n\t\t\t\toutput: bytes.to_vec(),\n\t\t\t})\n\t\t} else if bytes.len() < mod_len {\n\t\t\tlet mut ret = Vec::with_capacity(mod_len);\n\t\t\tret.extend(core::iter::repeat(0).take(mod_len - bytes.len()));\n\t\t\tret.extend_from_slice(&bytes[..]);\n\t\t\tOk(PrecompileOutput {\n\t\t\t\texit_status: ExitSucceed::Returned,\n\t\t\t\toutput: ret.to_vec(),\n\t\t\t})\n\t\t} else {\n\t\t\tErr(PrecompileFailure::Error {\n\t\t\t\texit_status: ExitError::Other(\"failed\".into()),\n\t\t\t})\n\t\t}\n\t}\nfn test_long_exp_gas_cost_matches_specs() {\n\t\tlet input = vec![\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t16, 0, 0, 0, 255, 255, 255, 2, 0, 0, 179, 0, 0, 2, 0, 0, 122, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 255, 251, 0, 0, 0, 0, 4, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 255, 255, 255, 2, 0, 0, 179, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255,\n\t\t\t255, 255, 255, 249,\n\t\t];\n\t\tlet context: Context = Context {\n\t\t\taddress: Default::default(),\n\t\t\tcaller: Default::default(),\n\t\t\tapparent_value: From::from(0),\n\t\t};\n\t\tlet mut handle = MockHandle::new(input, Some(100_000), context);\n\t\tlet _ = Modexp::execute(&mut handle).expect(\"Modexp::execute() returned error\");\n\t\tassert_eq!(handle.gas_used, 7104); \n\t}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn deserialize<R: std::io::Read>(\n        reader: &mut R,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<Self> {\n        let header = T::deserialize(reader, version_map, app_version)\n            .map_err(|ref err| VersionizeError::Deserialize(format!(\"{:?}\", err)))?;\n        let entries: Vec<<T as FamStruct>::Entry> =\n            Vec::deserialize(reader, version_map, app_version)\n                .map_err(|ref err| VersionizeError::Deserialize(format!(\"{:?}\", err)))?;\n        let mut object = FamStructWrapper::from_entries(&entries)\n            .map_err(|ref err| VersionizeError::Deserialize(format!(\"{:?}\", err)))?;\n        *object.as_mut_fam_struct() = header;\n        Ok(object)\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn try_static_init(&mut self, page_size: u64, max_image_size_always_allowed: u64) {\n        if !self.module.memory_initialization.is_segmented() {\n            return;\n        }\n        struct Memory {\n            data_size: u64,\n            min_addr: u64,\n            max_addr: u64,\n            segments: Vec<(usize, StaticMemoryInitializer)>,\n        }\n        let mut info = PrimaryMap::with_capacity(self.module.memory_plans.len());\n        for _ in 0..self.module.memory_plans.len() {\n            info.push(Memory {\n                data_size: 0,\n                min_addr: u64::MAX,\n                max_addr: 0,\n                segments: Vec::new(),\n            });\n        }\n        let mut idx = 0;\n        let ok = self.module.memory_initialization.init_memory(\n            InitMemory::CompileTime(&self.module),\n            &mut |memory, init| {\n                if self.module.defined_memory_index(memory).is_none() {\n                    return false;\n                };\n                let info = &mut info[memory];\n                let data_len = u64::from(init.data.end - init.data.start);\n                if data_len > 0 {\n                    info.data_size += data_len;\n                    info.min_addr = info.min_addr.min(init.offset);\n                    info.max_addr = info.max_addr.max(init.offset + data_len);\n                    info.segments.push((idx, init.clone()));\n                }\n                idx += 1;\n                true\n            },\n        );\n        if !ok {\n            return;\n        }\n        for info in info.values().filter(|i| i.data_size > 0) {\n            let image_size = info.max_addr - info.min_addr;\n            if image_size < info.data_size.saturating_mul(2) {\n                continue;\n            }\n            if image_size < max_image_size_always_allowed {\n                continue;\n            }\n            return;\n        }\n        let data = mem::replace(&mut self.data, Vec::new());\n        let mut map = PrimaryMap::with_capacity(info.len());\n        let mut module_data_size = 0u32;\n        for (memory, info) in info.iter() {\n            let extent = if info.segments.len() > 0 {\n                (info.max_addr - info.min_addr) as usize\n            } else {\n                0\n            };\n            let mut image = Vec::with_capacity(extent);\n            for (idx, init) in info.segments.iter() {\n                let data = &data[*idx];\n                assert_eq!(data.len(), init.data.len());\n                let offset = usize::try_from(init.offset - info.min_addr).unwrap();\n                if image.len() < offset {\n                    image.resize(offset, 0u8);\n                    image.extend_from_slice(data);\n                } else {\n                    image.splice(\n                        offset..(offset + data.len()).min(image.len()),\n                        data.iter().copied(),\n                    );\n                }\n            }\n            assert_eq!(image.len(), extent);\n            assert_eq!(image.capacity(), extent);\n            let mut offset = if info.segments.len() > 0 {\n                info.min_addr\n            } else {\n                0\n            };\n            if let Some(i) = image.iter().rposition(|i| *i != 0) {\n                image.truncate(i + 1);\n            }\n            if let Some(i) = image.iter().position(|i| *i != 0) {\n                offset += i as u64;\n                image.drain(..i);\n            }\n            let mut len = u64::try_from(image.len()).unwrap();\n            if offset % page_size != 0 {\n                let zero_padding = offset % page_size;\n                self.data.push(vec![0; zero_padding as usize].into());\n                offset -= zero_padding;\n                len += zero_padding;\n            }\n            self.data.push(image.into());\n            if len % page_size != 0 {\n                let zero_padding = page_size - (len % page_size);\n                self.data.push(vec![0; zero_padding as usize].into());\n                len += zero_padding;\n            }\n            assert!(offset % page_size == 0);\n            assert!(len % page_size == 0);\n            let len = u32::try_from(len).unwrap();\n            let init = if len > 0 {\n                Some(StaticMemoryInitializer {\n                    offset,\n                    data: module_data_size..module_data_size + len,\n                })\n            } else {\n                None\n            };\n            let idx = map.push(init);\n            assert_eq!(idx, memory);\n            module_data_size += len;\n        }\n        self.data_align = Some(page_size);\n        self.module.memory_initialization = MemoryInitialization::Static { map };\n    }\npub fn init_memory(\n        &self,\n        state: InitMemory<'_>,\n        write: &mut dyn FnMut(MemoryIndex, &StaticMemoryInitializer) -> bool,\n    ) -> bool {\n        let initializers = match self {\n            MemoryInitialization::Segmented(list) => list,\n            MemoryInitialization::Static { map } => {\n                for (index, init) in map {\n                    if let Some(init) = init {\n                        let result = write(index, init);\n                        if !result {\n                            return result;\n                        }\n                    }\n                }\n                return true;\n            }\n        };\n        for initializer in initializers {\n            let MemoryInitializer {\n                memory_index,\n                base,\n                offset,\n                ref data,\n            } = *initializer;\n            let base = match base {\n                Some(index) => match &state {\n                    InitMemory::Runtime {\n                        get_global_as_u64, ..\n                    } => get_global_as_u64(index),\n                    InitMemory::CompileTime(_) => return false,\n                },\n                None => 0,\n            };\n            let start = match base.checked_add(offset) {\n                Some(start) => start,\n                None => return false,\n            };\n            let len = u64::try_from(data.len()).unwrap();\n            let end = match start.checked_add(len) {\n                Some(end) => end,\n                None => return false,\n            };\n            let cur_size_in_pages = match &state {\n                InitMemory::CompileTime(module) => module.memory_plans[memory_index].memory.minimum,\n                InitMemory::Runtime {\n                    memory_size_in_pages,\n                    ..\n                } => memory_size_in_pages(memory_index),\n            };\n            if let Some(max) = cur_size_in_pages.checked_mul(u64::from(WASM_PAGE_SIZE)) {\n                if end > max {\n                    return false;\n                }\n            }\n            let init = StaticMemoryInitializer {\n                offset: start,\n                data: data.clone(),\n            };\n            let result = write(memory_index, &init);\n            if !result {\n                return result;\n            }\n        }\n        return true;\n    }\npub enum InitMemory<'a> {\n    CompileTime(&'a Module),\n    Runtime {\n        memory_size_in_pages: &'a dyn Fn(MemoryIndex) -> u64,\n        get_global_as_u64: &'a dyn Fn(GlobalIndex) -> u64,\n    },\n}\nunsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {\n        (self.vmctx_ptr().cast::<u8>())\n            .add(usize::try_from(offset).unwrap())\n            .cast()\n    }\nfn table(&self, index: DefinedTableIndex) -> VMTableDefinition {\n        unsafe { *self.table_ptr(index) }\n    }\nfn set_table(&self, index: DefinedTableIndex, table: VMTableDefinition) {\n        unsafe {\n            *self.table_ptr(index) = table;\n        }\n    }\nfn table_ptr(&self, index: DefinedTableIndex) -> *mut VMTableDefinition {\n        unsafe { self.vmctx_plus_offset(self.offsets().vmctx_vmtable_definition(index)) }\n    }\nfn global(&self, index: DefinedGlobalIndex) -> &VMGlobalDefinition {\n        unsafe { &*self.global_ptr(index) }\n    }\nfn global_ptr(&self, index: DefinedGlobalIndex) -> *mut VMGlobalDefinition {\n        unsafe { self.vmctx_plus_offset(self.offsets().vmctx_vmglobal_definition(index)) }\n}\n    pub(crate) fn defined_or_imported_global_ptr(\n        &self,\n        index: GlobalIndex,\n    ) -> *mut VMGlobalDefinition {\n        if let Some(index) = self.module().defined_global_index(index) {\n            self.global_ptr(index)\n        } else {\n            self.imported_global(index).from\n        }\n    }\n    pub fn runtime_limits(&self) -> *mut *const VMRuntimeLimits {\n        unsafe { self.vmctx_plus_offset(self.offsets().vmctx_runtime_limits()) }\n    }\n    pub fn epoch_ptr(&self) -> *mut *const AtomicU64 {\n        unsafe { self.vmctx_plus_offset(self.offsets().vmctx_epoch_ptr()) }\n    }\n    pub fn externref_activations_table(&self) -> *mut *mut VMExternRefActivationsTable {\n        unsafe { self.vmctx_plus_offset(self.offsets().vmctx_externref_activations_table()) }\n    }\npub unsafe fn set_store(&mut self, store: Option<*mut dyn Store>) {\n        if let Some(store) = store {\n            *self.vmctx_plus_offset(self.offsets().vmctx_store()) = store;\n            *self.runtime_limits() = (*store).vmruntime_limits();\n            *self.epoch_ptr() = (*store).epoch_ptr();\n            *self.externref_activations_table() = (*store).externref_activations_table().0;\n        } else {\n            assert_eq!(\n                mem::size_of::<*mut dyn Store>(),\n                mem::size_of::<[*mut (); 2]>()\n            );\n            *self.vmctx_plus_offset::<[*mut (); 2]>(self.offsets().vmctx_store()) =\n                [ptr::null_mut(), ptr::null_mut()];\n            *self.runtime_limits() = ptr::null_mut();\n            *self.epoch_ptr() = ptr::null_mut();\n            *self.externref_activations_table() = ptr::null_mut();\n        }\n    }\n    pub(crate) unsafe fn set_callee(&mut self, callee: Option<NonNull<VMFunctionBody>>) {\n        *self.vmctx_plus_offset(self.offsets().vmctx_callee()) =\n            callee.map_or(ptr::null_mut(), |c| c.as_ptr());\n    }\nunsafe fn table_index(&self, table: &VMTableDefinition) -> DefinedTableIndex {\n        let index = DefinedTableIndex::new(\n            usize::try_from(\n                (table as *const VMTableDefinition)\n                    .offset_from(self.table_ptr(DefinedTableIndex::new(0))),\n            )\n            .unwrap(),\n        );\n        assert!(index.index() < self.tables.len());\n        index\n    }\nfn construct_anyfunc(\n        &mut self,\n        index: FuncIndex,\n        sig: SignatureIndex,\n        into: *mut VMCallerCheckedFuncRef,\n    ) {\n        let type_index = unsafe {\n            let base: *const VMSharedSignatureIndex =\n                *self.vmctx_plus_offset(self.offsets().vmctx_signature_ids_array());\n            *base.add(sig.index())\n        };\n        let (func_ptr, vmctx) = if let Some(def_index) = self.module().defined_func_index(index) {\n            (\n                self.runtime_info.function(def_index),\n                VMOpaqueContext::from_vmcontext(self.vmctx_ptr()),\n            )\n        } else {\n            let import = self.imported_function(index);\n            (import.body.as_ptr(), import.vmctx)\n        };\n        unsafe {\n            *into = VMCallerCheckedFuncRef {\n                vmctx,\n                type_index,\n                func_ptr: NonNull::new(func_ptr).expect(\"Non-null function pointer\"),\n            };\n        }\n    }\npub(crate) fn get_caller_checked_anyfunc(\n        &mut self,\n        index: FuncIndex,\n    ) -> Option<*mut VMCallerCheckedFuncRef> {\n        if index == FuncIndex::reserved_value() {\n            return None;\n        }\n        unsafe {\n            let func = &self.module().functions[index];\n            let sig = func.signature;\n            let anyfunc: *mut VMCallerCheckedFuncRef = self\n                .vmctx_plus_offset::<VMCallerCheckedFuncRef>(\n                    self.offsets().vmctx_anyfunc(func.anyfunc),\n                );\n            self.construct_anyfunc(index, sig, anyfunc);\n            Some(anyfunc)\n        }\n    }\nfn drop(&mut self) {\n        for (idx, global) in self.module().globals.iter() {\n            let idx = match self.module().defined_global_index(idx) {\n                Some(idx) => idx,\n                None => continue,\n            };\n            match global.wasm_ty {\n                WasmType::ExternRef => {}\n                _ => continue,\n            }\n            unsafe {\n                drop((*self.global_ptr(idx)).as_externref_mut().take());\n            }\n        }\n    }\npub unsafe fn table_index(&self, table: &VMTableDefinition) -> DefinedTableIndex {\n        self.instance().table_index(table)\n    }\nfn get_table_init_start(init: &TableInitializer, instance: &Instance) -> Result<u32> {\n    match init.base {\n        Some(base) => {\n            let val = unsafe {\n                if let Some(def_index) = instance.module().defined_global_index(base) {\n                    *instance.global(def_index).as_u32()\n                } else {\n                    *(*instance.imported_global(base).from).as_u32()\n                }\n            };\n            init.offset\n                .checked_add(val)\n                .ok_or_else(|| anyhow!(\"element segment global base overflows\"))\n        }\n        None => Ok(init.offset),\n    }\n}\nfn initialize_tables(instance: &mut Instance, module: &Module) -> Result<()> {\n    match &module.table_initialization {\n        TableInitialization::FuncTable { segments, .. }\n        | TableInitialization::Segments { segments } => {\n            for segment in segments {\n                instance.table_init_segment(\n                    segment.table_index,\n                    &segment.elements,\n                    get_table_init_start(segment, instance)?,\n                    0,\n                    segment.elements.len() as u32,\n                )?;\n            }\n        }\n    }    Ok(())\n}\nfn get_memory_init_start(init: &MemoryInitializer, instance: &Instance) -> Result<u64> {\n    match init.base {\n        Some(base) => {\n            let mem64 = instance.module().memory_plans[init.memory_index]\n                .memory\n                .memory64;\n            let val = unsafe {\n                let global = if let Some(def_index) = instance.module().defined_global_index(base) {\n                    instance.global(def_index)\n                } else {\n                    &*instance.imported_global(base).from\n                };\n                if mem64 {\n                    *global.as_u64()\n                } else {\n                    u64::from(*global.as_u32())\n                }\n            };\n            init.offset\n                .checked_add(val)\n                .ok_or_else(|| anyhow!(\"data segment global base overflows\"))\n        }\n        None => Ok(init.offset),\n    }\n}\nfn check_memory_init_bounds(instance: &Instance, initializers: &[MemoryInitializer]) -> Result<()> {\n    for init in initializers {\n        let memory = instance.get_memory(init.memory_index);\n        let start = get_memory_init_start(init, instance)?;\n        let end = usize::try_from(start)\n            .ok()\n            .and_then(|start| start.checked_add(init.data.len()));\n        match end {\n            Some(end) if end <= memory.current_length() => {\n            }\n            _ => {\n                bail!(\"memory out of bounds: data segment does not fit\")\n            }\n        }\n    }\n    Ok(())\n}\nfn initialize_memories(instance: &mut Instance, module: &Module) -> Result<()> {\n    let memory_size_in_pages =\n        &|memory| (instance.get_memory(memory).current_length() as u64) / u64::from(WASM_PAGE_SIZE);\n    let get_global_as_u64 = &|global| unsafe {\n        let def = if let Some(def_index) = instance.module().defined_global_index(global) {\n            instance.global(def_index)\n        } else {\n            &*instance.imported_global(global).from\n        };\n        let def = instance.defined_or_imported_global_ptr(global);\n        if module.globals[global].wasm_ty == WasmType::I64 {\n            *def.as_u64()\n        } else {\n            u64::from(*def.as_u32())\n        }\n    };\n    let ok = module.memory_initialization.init_memory(\n        InitMemory::Runtime {\n            memory_size_in_pages,\n            get_global_as_u64,\n        },\n        &mut |memory_index, init| {\n            if let Some(memory_index) = module.defined_memory_index(memory_index) {\n                if !instance.memories[memory_index].needs_init() {\n                    return true;\n                }\n            }\n            let memory = instance.get_memory(memory_index);\n            unsafe {\n                let src = instance.wasm_data(init.data.clone());\n                let dst = memory.base.add(usize::try_from(init.offset).unwrap());\n                ptr::copy_nonoverlapping(src.as_ptr(), dst, src.len())\n            }\n            true\n        },\n    );\n    if !ok {\n        return Err(Trap::MemoryOutOfBounds.into());\n    }\n    Ok(())\n}\nfn check_init_bounds(instance: &mut Instance, module: &Module) -> Result<()> {\n    check_table_init_bounds(instance, module)?;\n    match &instance.module().memory_initialization {\n        MemoryInitialization::Segmented(initializers) => {\n            check_memory_init_bounds(instance, initializers)?;\n        }\n        MemoryInitialization::Static { .. } => {}\n    }\n    Ok(())\n}\nunsafe fn externref_global_get(vmctx: *mut VMContext, index: u32) -> *mut u8 {\n    let index = GlobalIndex::from_u32(index);\n    let instance = (*vmctx).instance();\n    let global = instance.defined_or_imported_global_ptr(index);\n    match (*global).as_externref().clone() {\n        None => ptr::null_mut(),\n        Some(externref) => {\n            let raw = externref.as_raw();\n            let (activations_table, module_info_lookup) =\n                (*instance.store()).externref_activations_table();\n            activations_table.insert_with_gc(externref, module_info_lookup);\n            raw\n        }\n    }\n}\nunsafe fn externref_global_set(vmctx: *mut VMContext, index: u32, externref: *mut u8) {\n    let externref = if externref.is_null() {\n        None\n    } else {\n        Some(VMExternRef::clone_from_raw(externref))\n    };\n    let index = GlobalIndex::from_u32(index);\n    let instance = (*vmctx).instance();\n    let global = instance.defined_or_imported_global_ptr(index);\n    let old = mem::replace((*global).as_externref_mut(), externref);\n    drop(old);\n}\npub unsafe fn catch_traps<'a, F>(\n    signal_handler: Option<*const SignalHandler<'static>>,\n    capture_backtrace: bool,\n    caller: *mut VMContext,\n    mut closure: F,\n) -> Result<(), Box<Trap>>\nwhere\n    F: FnMut(*mut VMContext),\n{\n    let limits = (*caller).instance().runtime_limits();\n    let result = CallThreadState::new(signal_handler, capture_backtrace, *limits).with(|cx| {\n        wasmtime_setjmp(\n            cx.jmp_buf.as_ptr(),\n            call_closure::<F>,\n            &mut closure as *mut F as *mut u8,\n            caller,\n        )\n    });\n    return match result {\n        Ok(x) => Ok(x),\n        Err((UnwindReason::Trap(reason), backtrace)) => Err(Box::new(Trap { reason, backtrace })),\n        Err((UnwindReason::Panic(panic), _)) => std::panic::resume_unwind(panic),\n    };\n    extern \"C\" fn call_closure<F>(payload: *mut u8, caller: *mut VMContext)\n    where\n        F: FnMut(*mut VMContext),\n    {\n        unsafe { (*(payload as *mut F))(caller) }\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub(crate) enum Token {\n    ProcessingInstructionStart,\n    ProcessingInstructionEnd,\n    DoctypeStart,\n    OpeningTagStart,\n    ClosingTagStart,\n    TagEnd,\n    EmptyTagEnd,\n    CommentStart,\n    CommentEnd,\n    Chunk(&'static str),\n    Character(char),\n    Whitespace(char),\n    EqualsSign,\n    SingleQuote,\n    DoubleQuote,\n    CDataStart,\n    CDataEnd,\n    ReferenceStart,\n    ReferenceEnd,\n}\nimpl fmt::Display for Token {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            Token::Chunk(s)                            => s.fmt(f),\n            Token::Character(c) | Token::Whitespace(c) => c.fmt(f),\n            other => match other {\n                Token::OpeningTagStart            => \"<\",\n                Token::ProcessingInstructionStart => \"<?\",\n                Token::DoctypeStart               => \"<!DOCTYPE\",\n                Token::ClosingTagStart            => \"</\",\n                Token::CommentStart               => \"<!--\",\n                Token::CDataStart                 => \"<![CDATA[\",\n                Token::TagEnd                     => \">\",\n                Token::EmptyTagEnd                => \"/>\",\n                Token::ProcessingInstructionEnd   => \"?>\",\n                Token::CommentEnd                 => \"-->\",\n                Token::CDataEnd                   => \"]]>\",\n                Token::ReferenceStart             => \"&\",\n                Token::ReferenceEnd               => \";\",\n                Token::EqualsSign                 => \"=\",\n                Token::SingleQuote                => \"'\",\n                Token::DoubleQuote                => \"\\\"\",\n                _                          => unreachable!()\n            }.fmt(f),\n        }\n    }\n}\nimpl Token {\n    pub fn as_static_str(&self) -> Option<&'static str> {\n        match *self {\n            Token::OpeningTagStart            => Some(\"<\"),\n            Token::ProcessingInstructionStart => Some(\"<?\"),\n            Token::DoctypeStart               => Some(\"<!DOCTYPE\"),\n            Token::ClosingTagStart            => Some(\"</\"),\n            Token::CommentStart               => Some(\"<!--\"),\n            Token::CDataStart                 => Some(\"<![CDATA[\"),\n            Token::TagEnd                     => Some(\">\"),\n            Token::EmptyTagEnd                => Some(\"/>\"),\n            Token::ProcessingInstructionEnd   => Some(\"?>\"),\n            Token::CommentEnd                 => Some(\"-->\"),\n            Token::CDataEnd                   => Some(\"]]>\"),\n            Token::ReferenceStart             => Some(\"&\"),\n            Token::ReferenceEnd               => Some(\";\"),\n            Token::EqualsSign                 => Some(\"=\"),\n            Token::SingleQuote                => Some(\"'\"),\n            Token::DoubleQuote                => Some(\"\\\"\"),\n            Token::Chunk(s)                   => Some(s),\n            _                                 => None\n        }\n    }\n    pub fn push_to_string(&self, target: &mut String) {\n        match self.as_static_str() {\n            Some(s) => { target.push_str(s); }\n            None => {\n                match *self {\n                    Token::Character(c) | Token::Whitespace(c) => target.push(c),\n                    _ => unreachable!()\n                }\n            }\n        }\n    }\n    #[inline]\n    pub fn contains_char_data(&self) -> bool {\n        match *self {\n            Token::Whitespace(_) | Token::Chunk(_) | Token::Character(_) | Token::CommentEnd |\n            Token::TagEnd | Token::EqualsSign | Token::DoubleQuote | Token::SingleQuote | Token::CDataEnd | \n            Token::ProcessingInstructionEnd | Token::EmptyTagEnd => true,\n            _ => false\n        }\n    }\n    #[inline]\n    pub fn is_whitespace(&self) -> bool {\n        match *self {\n            Token::Whitespace(_) => true,\n            _ => false,\n        }\n    }\n}\nenum State {\n    Normal,\n    TagStarted,\n    CommentOrCDataOrDoctypeStarted,\n    CommentStarted,\n    DoctypeStarted(DoctypeStartedSubstate),\n    DoctypeFinishing(u8),\n    CDataStarted(CDataStartedSubstate),\n    ProcessingInstructionClosing,\n    EmptyTagClosing,\n    CommentClosing(ClosingSubstate),\n    CDataClosing(ClosingSubstate),\n    InvalidCDataClosing(ClosingSubstate),\n    InsideComment,\n    InsideCdata,\n    InsideProcessingInstruction,\n}\n#[derive(Copy, Clone)]\nenum ClosingSubstate {\n    First, Second\n}\n#[derive(Copy, Clone)]\nenum DoctypeStartedSubstate {\n    D, DO, DOC, DOCT, DOCTY, DOCTYP\n}\n#[derive(Copy, Clone)]\nenum CDataStartedSubstate {\n    E, C, CD, CDA, CDAT, CDATA\n}\npub(crate) type Result<T = Option<Token>, E = Error> = result::Result<T, E>;\nmacro_rules! dispatch_on_enum_state(\n    ($_self:ident, $s:expr, $c:expr, $is:expr,\n     $($st:ident; $stc:expr ; $next_st:ident ; $chunk:expr),+;\n     $end_st:ident ; $end_c:expr ; $end_chunk:expr ; $e:expr) => (\n        match $s {\n            $(\n            $st => match $c {\n                $stc => $_self.move_to($is($next_st)),\n                _  => $_self.handle_error($chunk, $c)\n            },\n            )+\n            $end_st => match $c {\n                $end_c => $e,\n                _      => $_self.handle_error($end_chunk, $c)\n            }\n        }\n    )\n);\npub(crate) struct Lexer {\n    pos: TextPosition,\n    head_pos: TextPosition,\n    char_queue: VecDeque<char>,\n    st: State,\n    skip_errors: bool,\n    inside_token: bool,\n    eof_handled: bool\n}\nimpl Position for Lexer {\n    #[inline]\n    fn position(&self) -> TextPosition { self.pos }\n}\nimpl Lexer {\n    pub fn new() -> Lexer {\n        Lexer {\n            pos: TextPosition::new(),\n            head_pos: TextPosition::new(),\n            char_queue: VecDeque::with_capacity(4),  \n            st: State::Normal,\n            skip_errors: false,\n            inside_token: false,\n            eof_handled: false\n        }\n    }\n    #[inline]\n    pub fn enable_errors(&mut self) { self.skip_errors = false; }\n    #[inline]\n    pub fn disable_errors(&mut self) { self.skip_errors = true; }\n    #[inline]\n    pub fn reset_eof_handled(&mut self) { self.eof_handled = false; }\n    pub fn next_token<B: Read>(&mut self, b: &mut B) -> Result {\n        if self.eof_handled {\n            return Ok(None);\n        }\n        if !self.inside_token {\n            self.pos = self.head_pos;\n            self.inside_token = true;\n        }\n        while let Some(c) = self.char_queue.pop_front() {\n            match self.read_next_token(c)? {\n                Some(t) => {\n                    self.inside_token = false;\n                    return Ok(Some(t));\n                }\n                None => {} \n            }\n        }\n        loop {\n            let c = match util::next_char_from(b)? {\n                Some(c) => c,  \n                None => break, \n            };\n            match self.read_next_token(c)? {\n                Some(t) => {\n                    self.inside_token = false;\n                    return Ok(Some(t));\n                }\n                None => {\n                }\n            }\n        }\n        self.eof_handled = true;\n        self.pos = self.head_pos;\n        match self.st {\n            State::InsideCdata | State::CDataClosing(_) => Err(self.error(\"Unclosed CDATA\")),\n            State::TagStarted | State::CommentOrCDataOrDoctypeStarted |\n            State::CommentStarted | State::CDataStarted(_)| State::DoctypeStarted(_) |\n            State::CommentClosing(ClosingSubstate::Second) |\n            State::InsideComment |\n            State::InsideProcessingInstruction | State::ProcessingInstructionClosing |\n            State::DoctypeFinishing(_) =>\n                Err(self.error(\"Unexpected end of stream\")),\n            State::EmptyTagClosing =>\n                Ok(Some(Token::Character('/'))),\n            State::CommentClosing(ClosingSubstate::First) =>\n                Ok(Some(Token::Character('-'))),\n            State::InvalidCDataClosing(ClosingSubstate::First) =>\n                Ok(Some(Token::Character(']'))),\n            State::InvalidCDataClosing(ClosingSubstate::Second) =>\n                Ok(Some(Token::Chunk(\"]]\"))),\n            State::Normal =>\n                Ok(None),\n        }\n    }\n    #[inline]\n    fn error<M: Into<Cow<'static, str>>>(&self, msg: M) -> Error {\n        (self, msg).into()\n    }\n    #[inline]\n    fn read_next_token(&mut self, c: char) -> Result {\n        let res = self.dispatch_char(c);\n        if self.char_queue.is_empty() {\n            if c == '\\n' {\n                self.head_pos.new_line();\n            } else {\n                self.head_pos.advance(1);\n            }\n        }\n        res\n    }\n    fn dispatch_char(&mut self, c: char) -> Result {\n        match self.st {\n            State::Normal                         => self.normal(c),\n            State::TagStarted                     => self.tag_opened(c),\n            State::CommentOrCDataOrDoctypeStarted => self.comment_or_cdata_or_doctype_started(c),\n            State::CommentStarted                 => self.comment_started(c),\n            State::CDataStarted(s)                => self.cdata_started(c, s),\n            State::DoctypeStarted(s)              => self.doctype_started(c, s),\n            State::DoctypeFinishing(d)            => self.doctype_finishing(c, d),\n            State::EmptyTagClosing                => self.empty_element_closing(c),\n            State::CommentClosing(s)              => self.comment_closing(c, s),\n            State::CDataClosing(s)                => self.cdata_closing(c, s),\n            State::InvalidCDataClosing(s)         => self.invalid_cdata_closing(c, s),\n            State::InsideComment                  => self.inside_comment_state(c),\n            State::InsideCdata                    => self.inside_cdata(c),\n            State::InsideProcessingInstruction    => self.inside_processing_instruction(c),\n            State::ProcessingInstructionClosing   => self.processing_instruction_closing(c),\n        }\n    }\n    #[inline]\n    fn move_to(&mut self, st: State) -> Result {\n        self.st = st;\n        Ok(None)\n    }\n    #[inline]\n    fn move_to_with(&mut self, st: State, token: Token) -> Result {\n        self.st = st;\n        Ok(Some(token))\n    }\n    #[inline]\n    fn move_to_with_unread(&mut self, st: State, cs: &[char], token: Token) -> Result {\n        self.char_queue.extend(cs.iter().copied());\n        self.move_to_with(st, token)\n    }\n    fn handle_error(&mut self, chunk: &'static str, c: char) -> Result {\n        self.char_queue.push_back(c);\n        if self.skip_errors {\n            self.move_to_with(State::Normal, Token::Chunk(chunk))\n        } else {\n            Err(self.error(format!(\"Unexpected token '{chunk}' before '{c}'\")))\n        }\n    }\n    fn normal(&mut self, c: char) -> Result {\n        match c {\n            '<'                        => self.move_to(State::TagStarted),\n            '>'                        => Ok(Some(Token::TagEnd)),\n            '/'                        => self.move_to(State::EmptyTagClosing),\n            '='                        => Ok(Some(Token::EqualsSign)),\n            '\"'                        => Ok(Some(Token::DoubleQuote)),\n            '\\''                       => Ok(Some(Token::SingleQuote)),\n            ']'                        => self.move_to(State::InvalidCDataClosing(ClosingSubstate::First)),\n            '&'                        => Ok(Some(Token::ReferenceStart)),\n            ';'                        => Ok(Some(Token::ReferenceEnd)),\n            _ if is_whitespace_char(c) => Ok(Some(Token::Whitespace(c))),\n            _                          => Ok(Some(Token::Character(c)))\n        }\n    }\n    fn inside_cdata(&mut self, c: char) -> Result {\n        match c {\n            ']'                        => self.move_to(State::CDataClosing(ClosingSubstate::First)),\n            _ if is_whitespace_char(c) => Ok(Some(Token::Whitespace(c))),\n            _                          => Ok(Some(Token::Character(c)))\n        }\n    }\n    fn inside_processing_instruction(&mut self, c: char) -> Result {\n        match c {\n            '?'                        => self.move_to(State::ProcessingInstructionClosing),\n            '<'                        => Ok(Some(Token::OpeningTagStart)),\n            '>'                        => Ok(Some(Token::TagEnd)),\n            '/'                        => Ok(Some(Token::ClosingTagStart)),\n            '='                        => Ok(Some(Token::EqualsSign)),\n            '\"'                        => Ok(Some(Token::DoubleQuote)),\n            '\\''                       => Ok(Some(Token::SingleQuote)),\n            '&'                        => Ok(Some(Token::ReferenceStart)),\n            ';'                        => Ok(Some(Token::ReferenceEnd)),\n            _ if is_whitespace_char(c) => Ok(Some(Token::Whitespace(c))),\n            _                          => Ok(Some(Token::Character(c)))\n        }\n    }\n    fn inside_comment_state(&mut self, c: char) -> Result {\n        match c {\n            '-'                        => self.move_to(State::CommentClosing(ClosingSubstate::First)),\n            _ if is_whitespace_char(c) => Ok(Some(Token::Whitespace(c))),\n            _                          => Ok(Some(Token::Character(c)))\n        }\n    }\n    fn tag_opened(&mut self, c: char) -> Result {\n        match c {\n            '?'                        => self.move_to_with(State::InsideProcessingInstruction, Token::ProcessingInstructionStart),\n            '/'                        => self.move_to_with(State::Normal, Token::ClosingTagStart),\n            '!'                        => self.move_to(State::CommentOrCDataOrDoctypeStarted),\n            _ if is_whitespace_char(c) => self.move_to_with_unread(State::Normal, &[c], Token::OpeningTagStart),\n            _ if is_name_char(c)       => self.move_to_with_unread(State::Normal, &[c], Token::OpeningTagStart),\n            _                          => self.handle_error(\"<\", c)\n        }\n    }\n    fn comment_or_cdata_or_doctype_started(&mut self, c: char) -> Result {\n        match c {\n            '-' => self.move_to(State::CommentStarted),\n            '[' => self.move_to(State::CDataStarted(CDataStartedSubstate::E)),\n            'D' => self.move_to(State::DoctypeStarted(DoctypeStartedSubstate::D)),\n            _ => self.handle_error(\"<!\", c),\n        }\n    }\n    /// Encountered '<!-'\n    fn comment_started(&mut self, c: char) -> Result {\n        match c {\n            '-' => self.move_to_with(State::InsideComment, Token::CommentStart),\n            _ => self.handle_error(\"<!-\", c),\n        }\n    }\n    /// Encountered '<!['\n    fn cdata_started(&mut self, c: char, s: CDataStartedSubstate) -> Result {\n        use self::CDataStartedSubstate::{C, CD, CDA, CDAT, CDATA, E};\n        dispatch_on_enum_state!(self, s, c, State::CDataStarted,\n            E     ; 'C' ; C     ; \"<![\",\n            C     ; 'D' ; CD    ; \"<![C\",\n            CD    ; 'A' ; CDA   ; \"<![CD\",\n            CDA   ; 'T' ; CDAT  ; \"<![CDA\",\n            CDAT  ; 'A' ; CDATA ; \"<![CDAT\";\n            CDATA ; '[' ; \"<![CDATA\" ; self.move_to_with(State::InsideCdata, Token::CDataStart)\n        )\n    }\n    /// Encountered '<!D'\n    fn doctype_started(&mut self, c: char, s: DoctypeStartedSubstate) -> Result {\n        use self::DoctypeStartedSubstate::{D, DO, DOC, DOCT, DOCTY, DOCTYP};\n        dispatch_on_enum_state!(self, s, c, State::DoctypeStarted,\n            D      ; 'O' ; DO     ; \"<!D\",\n            DO     ; 'C' ; DOC    ; \"<!DO\",\n            DOC    ; 'T' ; DOCT   ; \"<!DOC\",\n            DOCT   ; 'Y' ; DOCTY  ; \"<!DOCT\",\n            DOCTY  ; 'P' ; DOCTYP ; \"<!DOCTY\";\n            DOCTYP ; 'E' ; \"<!DOCTYP\" ; self.move_to_with(State::DoctypeFinishing(1), Token::DoctypeStart)\n        )\n    }\n    /// State used while awaiting the closing bracket for the <!DOCTYPE tag\n    fn doctype_finishing(&mut self, c: char, d: u8) -> Result {\n        match c {\n            '<' => self.move_to(State::DoctypeFinishing(d + 1)),\n            '>' if d == 1 => self.move_to_with(State::Normal, Token::TagEnd),\n            '>' => self.move_to(State::DoctypeFinishing(d - 1)),\n            _ => Ok(None),\n        }\n    }\n    /// Encountered '?'\n    fn processing_instruction_closing(&mut self, c: char) -> Result {\n        match c {\n            '>' => self.move_to_with(State::Normal, Token::ProcessingInstructionEnd),\n            _ => self.move_to_with_unread(State::InsideProcessingInstruction, &[c], Token::Character('?')),\n        }\n    }\n    /// Encountered '/'\n    fn empty_element_closing(&mut self, c: char) -> Result {\n        match c {\n            '>' => self.move_to_with(State::Normal, Token::EmptyTagEnd),\n            _ => self.move_to_with_unread(State::Normal, &[c], Token::Character('/')),\n        }\n    }\n    /// Encountered '-'\n    fn comment_closing(&mut self, c: char, s: ClosingSubstate) -> Result {\n        match s {\n            ClosingSubstate::First => match c {\n                '-' => self.move_to(State::CommentClosing(ClosingSubstate::Second)),\n                _ => self.move_to_with_unread(State::InsideComment, &[c], Token::Character('-')),\n            },\n            ClosingSubstate::Second => match c {\n                '>' => self.move_to_with(State::Normal, Token::CommentEnd),\n                // double dash not followed by a greater-than is a hard error inside comment\n                _ => self.handle_error(\"--\", c),\n            },\n        }\n    }\n    /// Encountered ']'\n    fn cdata_closing(&mut self, c: char, s: ClosingSubstate) -> Result {\n        match s {\n            ClosingSubstate::First => match c {\n                ']' => self.move_to(State::CDataClosing(ClosingSubstate::Second)),\n                _ => self.move_to_with_unread(State::InsideCdata, &[c], Token::Character(']')),\n            },\n            ClosingSubstate::Second => match c {\n                '>' => self.move_to_with(State::Normal, Token::CDataEnd),\n                _ => self.move_to_with_unread(State::InsideCdata, &[']', c], Token::Character(']')),\n            },\n        }\n    }\n    /// Encountered ']'\n    fn invalid_cdata_closing(&mut self, c: char, s: ClosingSubstate) -> Result {\n        match s {\n            ClosingSubstate::First => match c {\n                ']' => self.move_to(State::InvalidCDataClosing(ClosingSubstate::Second)),\n                _ => self.move_to_with_unread(State::Normal, &[c], Token::Character(']')),\n            },\n            ClosingSubstate::Second => match c {\n                '>' => self.move_to_with(State::Normal, Token::CDataEnd),\n                _ => self.move_to_with_unread(State::Normal, &[']', c], Token::Character(']')),\n            },\n        }\n    }\n}\n#[cfg(test)]\nmod tests {\n    use crate::common::Position;\n    use std::io::{BufReader, Cursor};\n    use super::{Lexer, Token};\n    macro_rules! assert_oks(\n        (for $lex:ident and $buf:ident ; $($e:expr)+) => ({\n            $(\n                assert_eq!(Ok(Some($e)), $lex.next_token(&mut $buf));\n             )+\n        })\n    );\n    macro_rules! assert_err(\n        (for $lex:ident and $buf:ident expect row $r:expr ; $c:expr, $s:expr) => ({\n            let err = $lex.next_token(&mut $buf);\n            assert!(err.is_err());\n            let err = err.unwrap_err();\n            assert_eq!($r as u64, err.position().row);\n            assert_eq!($c as u64, err.position().column);\n            assert_eq!($s, err.msg());\n        })\n    );\n    macro_rules! assert_none(\n        (for $lex:ident and $buf:ident) => (\n            assert_eq!(Ok(None), $lex.next_token(&mut $buf))\n        )\n    );\n    fn make_lex_and_buf(s: &str) -> (Lexer, BufReader<Cursor<Vec<u8>>>) {\n        (Lexer::new(), BufReader::new(Cursor::new(s.to_owned().into_bytes())))\n    }\n    #[test]\n    fn tricky_pi() {\n        let (mut lex, mut buf) = make_lex_and_buf(\n            r#\"<?x<!-- &??><x>\"#\n        );\n        assert_oks!(for lex and buf ;\n            Token::ProcessingInstructionStart\n            Token::Character('x')\n            Token::OpeningTagStart // processing of <?xml?> relies on the extra tokens\n            Token::Character('!')\n            Token::Character('-')\n            Token::Character('-')\n            Token::Whitespace(' ')\n            Token::ReferenceStart\n            Token::Character('?')\n            Token::ProcessingInstructionEnd\n            Token::OpeningTagStart\n            Token::Character('x')\n            Token::TagEnd\n        );\n        assert_none!(for lex and buf);\n    }\n    #[test]\n    fn simple_lexer_test() {\n        let (mut lex, mut buf) = make_lex_and_buf(\n            r#\"<a p='q'> x<b z=\"y\">d\t</b></a><p/> <?nm ?> <!-- a c --> &nbsp;\"#\n        );\n        assert_oks!(for lex and buf ;\n            Token::OpeningTagStart\n            Token::Character('a')\n            Token::Whitespace(' ')\n            Token::Character('p')\n            Token::EqualsSign\n            Token::SingleQuote\n            Token::Character('q')\n            Token::SingleQuote\n            Token::TagEnd\n            Token::Whitespace(' ')\n            Token::Character('x')\n            Token::OpeningTagStart\n            Token::Character('b')\n            Token::Whitespace(' ')\n            Token::Character('z')\n            Token::EqualsSign\n            Token::DoubleQuote\n            Token::Character('y')\n            Token::DoubleQuote\n            Token::TagEnd\n            Token::Character('d')\n            Token::Whitespace('\\t')\n            Token::ClosingTagStart\n            Token::Character('b')\n            Token::TagEnd\n            Token::ClosingTagStart\n            Token::Character('a')\n            Token::TagEnd\n            Token::OpeningTagStart\n            Token::Character('p')\n            Token::EmptyTagEnd\n            Token::Whitespace(' ')\n            Token::ProcessingInstructionStart\n            Token::Character('n')\n            Token::Character('m')\n            Token::Whitespace(' ')\n            Token::ProcessingInstructionEnd\n            Token::Whitespace(' ')\n            Token::CommentStart\n            Token::Whitespace(' ')\n            Token::Character('a')\n            Token::Whitespace(' ')\n            Token::Character('c')\n            Token::Whitespace(' ')\n            Token::CommentEnd\n            Token::Whitespace(' ')\n            Token::ReferenceStart\n            Token::Character('n')\n            Token::Character('b')\n            Token::Character('s')\n            Token::Character('p')\n            Token::ReferenceEnd\n        );\n        assert_none!(for lex and buf);\n    }\n    #[test]\n    fn special_chars_test() {\n        let (mut lex, mut buf) = make_lex_and_buf(\n            r#\"?x!+ // -| ]z]]\"#\n        );\n        assert_oks!(for lex and buf ;\n            Token::Character('?')\n            Token::Character('x')\n            Token::Character('!')\n            Token::Character('+')\n            Token::Whitespace(' ')\n            Token::Character('/')\n            Token::Character('/')\n            Token::Whitespace(' ')\n            Token::Character('-')\n            Token::Character('|')\n            Token::Whitespace(' ')\n            Token::Character(']')\n            Token::Character('z')\n            Token::Chunk(\"]]\")\n        );\n        assert_none!(for lex and buf);\n    }\n    #[test]\n    fn cdata_test() {\n        let (mut lex, mut buf) = make_lex_and_buf(\n            r#\"<a><![CDATA[x y ?]]> </a>\"#\n        );\n        assert_oks!(for lex and buf ;\n            Token::OpeningTagStart\n            Token::Character('a')\n            Token::TagEnd\n            Token::CDataStart\n            Token::Character('x')\n            Token::Whitespace(' ')\n            Token::Character('y')\n            Token::Whitespace(' ')\n            Token::Character('?')\n            Token::CDataEnd\n            Token::Whitespace(' ')\n            Token::ClosingTagStart\n            Token::Character('a')\n            Token::TagEnd\n        );\n        assert_none!(for lex and buf);\n    }\n    #[test]\n    fn cdata_closers_test() {\n        let (mut lex, mut buf) = make_lex_and_buf(\n            r#\"<![CDATA[] > ]> ]]><!---->]]<a>\"#\n        );\n        assert_oks!(for lex and buf ;\n            Token::CDataStart\n            Token::Character(']')\n            Token::Whitespace(' ')\n            Token::Character('>')\n            Token::Whitespace(' ')\n            Token::Character(']')\n            Token::Character('>')\n            Token::Whitespace(' ')\n            Token::CDataEnd\n            Token::CommentStart\n            Token::CommentEnd\n            Token::Character(']')\n            Token::Character(']')\n            Token::OpeningTagStart\n            Token::Character('a')\n            Token::TagEnd\n        );\n        assert_none!(for lex and buf);\n    }\n    #[test]\n    fn doctype_test() {\n        let (mut lex, mut buf) = make_lex_and_buf(\n            r#\"<a><!DOCTYPE ab xx z> \"#\n        );\n        assert_oks!(for lex and buf ;\n            Token::OpeningTagStart\n            Token::Character('a')\n            Token::TagEnd\n            Token::DoctypeStart\n            Token::TagEnd\n            Token::Whitespace(' ')\n        );\n        assert_none!(for lex and buf);\n    }\n    #[test]\n    fn tricky_comments() {\n        let (mut lex, mut buf) = make_lex_and_buf(\n            r#\"<a><!-- C ->--></a>\"#\n        );\n        assert_oks!(for lex and buf ;\n            Token::OpeningTagStart\n            Token::Character('a')\n            Token::TagEnd\n            Token::CommentStart\n            Token::Whitespace(' ')\n            Token::Character('C')\n            Token::Whitespace(' ')\n            Token::Character('-')\n            Token::Character('>')\n            Token::CommentEnd\n            Token::ClosingTagStart\n            Token::Character('a')\n            Token::TagEnd\n        );\n        assert_none!(for lex and buf);\n    }\n    #[test]\n    fn doctype_with_internal_subset_test() {\n        let (mut lex, mut buf) = make_lex_and_buf(\n            r#\"<a><!DOCTYPE ab[<!ELEMENT ba> ]> \"#\n        );\n        assert_oks!(for lex and buf ;\n            Token::OpeningTagStart\n            Token::Character('a')\n            Token::TagEnd\n            Token::DoctypeStart\n            Token::TagEnd\n            Token::Whitespace(' ')\n        );\n        assert_none!(for lex and buf);\n    }\n    #[test]\n    fn end_of_stream_handling_ok() {\n        macro_rules! eof_check(\n            ($data:expr ; $token:expr) => ({\n                let (mut lex, mut buf) = make_lex_and_buf($data);\n                assert_oks!(for lex and buf ; $token);\n                assert_none!(for lex and buf);\n            })\n        );\n        eof_check!(\"?\"  ; Token::Character('?'));\n        eof_check!(\"/\"  ; Token::Character('/'));\n        eof_check!(\"-\"  ; Token::Character('-'));\n        eof_check!(\"]\"  ; Token::Character(']'));\n        eof_check!(\"]]\" ; Token::Chunk(\"]]\"));\n    }\n    #[test]\n    fn end_of_stream_handling_error() {\n        macro_rules! eof_check(\n            ($data:expr; $r:expr, $c:expr) => ({\n                let (mut lex, mut buf) = make_lex_and_buf($data);\n                assert_err!(for lex and buf expect row $r ; $c, \"Unexpected end of stream\");\n                assert_none!(for lex and buf);\n            })\n        );\n        eof_check!(\"<\"        ; 0, 1);\n        eof_check!(\"<!\"       ; 0, 2);\n        eof_check!(\"<!-\"      ; 0, 3);\n        eof_check!(\"<![\"      ; 0, 3);\n        eof_check!(\"<![C\"     ; 0, 4);\n        eof_check!(\"<![CD\"    ; 0, 5);\n        eof_check!(\"<![CDA\"   ; 0, 6);\n        eof_check!(\"<![CDAT\"  ; 0, 7);\n        eof_check!(\"<![CDATA\" ; 0, 8);\n        // eof_check!(\"--\"       ; 0, 2);\n    }\n    #[test]\n    fn error_in_comment_or_cdata_prefix() {\n        let (mut lex, mut buf) = make_lex_and_buf(\"<!x\");\n        assert_err!(for lex and buf expect row 0 ; 0,\n            \"Unexpected token '<!' before 'x'\"\n        );\n        let (mut lex, mut buf) = make_lex_and_buf(\"<!x\");\n        lex.disable_errors();\n        assert_oks!(for lex and buf ;\n            Token::Chunk(\"<!\")\n            Token::Character('x')\n        );\n        assert_none!(for lex and buf);\n    }\n    #[test]\n    fn error_in_comment_started() {\n        let (mut lex, mut buf) = make_lex_and_buf(\"<!-\\t\");\n        assert_err!(for lex and buf expect row 0 ; 0,\n            \"Unexpected token '<!-' before '\\t'\"\n        );\n        let (mut lex, mut buf) = make_lex_and_buf(\"<!-\\t\");\n        lex.disable_errors();\n        assert_oks!(for lex and buf ;\n            Token::Chunk(\"<!-\")\n            Token::Whitespace('\\t')\n        );\n        assert_none!(for lex and buf);\n    }\n    #[test]\n    fn error_in_comment_two_dashes_not_at_end() {\n        let (mut lex, mut buf) = make_lex_and_buf(\"--x\");\n        lex.st = super::State::InsideComment;\n        assert_err!(for lex and buf expect row 0; 0,\n            \"Unexpected token '--' before 'x'\"\n        );\n        let (mut lex, mut buf) = make_lex_and_buf(\"--x\");\n        assert_oks!(for lex and buf ;\n            Token::Character('-')\n            Token::Character('-')\n            Token::Character('x')\n        );\n    }\n    macro_rules! check_case(\n        ($chunk:expr, $app:expr; $data:expr; $r:expr, $c:expr, $s:expr) => ({\n            let (mut lex, mut buf) = make_lex_and_buf($data);\n            assert_err!(for lex and buf expect row $r ; $c, $s);\n            let (mut lex, mut buf) = make_lex_and_buf($data);\n            lex.disable_errors();\n            assert_oks!(for lex and buf ;\n                Token::Chunk($chunk)\n                Token::Character($app)\n            );\n            assert_none!(for lex and buf);\n        })\n    );\n    #[test]\n    fn error_in_cdata_started() {\n        check_case!(\"<![\",      '['; \"<![[\"      ; 0, 0, \"Unexpected token '<![' before '['\");\n        check_case!(\"<![C\",     '['; \"<![C[\"     ; 0, 0, \"Unexpected token '<![C' before '['\");\n        check_case!(\"<![CD\",    '['; \"<![CD[\"    ; 0, 0, \"Unexpected token '<![CD' before '['\");\n        check_case!(\"<![CDA\",   '['; \"<![CDA[\"   ; 0, 0, \"Unexpected token '<![CDA' before '['\");\n        check_case!(\"<![CDAT\",  '['; \"<![CDAT[\"  ; 0, 0, \"Unexpected token '<![CDAT' before '['\");\n        check_case!(\"<![CDATA\", '|'; \"<![CDATA|\" ; 0, 0, \"Unexpected token '<![CDATA' before '|'\");\n    }\n    #[test]\n    fn error_in_doctype_started() {\n        check_case!(\"<!D\",      'a'; \"<!Da\"      ; 0, 0, \"Unexpected token '<!D' before 'a'\");\n        check_case!(\"<!DO\",     'b'; \"<!DOb\"     ; 0, 0, \"Unexpected token '<!DO' before 'b'\");\n        check_case!(\"<!DOC\",    'c'; \"<!DOCc\"    ; 0, 0, \"Unexpected token '<!DOC' before 'c'\");\n        check_case!(\"<!DOCT\",   'd'; \"<!DOCTd\"   ; 0, 0, \"Unexpected token '<!DOCT' before 'd'\");\n        check_case!(\"<!DOCTY\",  'e'; \"<!DOCTYe\"  ; 0, 0, \"Unexpected token '<!DOCTY' before 'e'\");\n        check_case!(\"<!DOCTYP\", 'f'; \"<!DOCTYPf\" ; 0, 0, \"Unexpected token '<!DOCTYP' before 'f'\");\n    }\n    #[test]\n    fn issue_98_cdata_ending_with_right_bracket() {\n        let (mut lex, mut buf) = make_lex_and_buf(\n            r#\"<![CDATA[Foo [Bar]]]>\"#\n        );\n        assert_oks!(for lex and buf ;\n            Token::CDataStart\n            Token::Character('F')\n            Token::Character('o')\n            Token::Character('o')\n            Token::Whitespace(' ')\n            Token::Character('[')\n            Token::Character('B')\n            Token::Character('a')\n            Token::Character('r')\n            Token::Character(']')\n            Token::CDataEnd\n        );\n        assert_none!(for lex and buf);\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn try_invoke(&self) -> Result<ink_primitives::MessageResult<R>, crate::Error> {\n        crate::invoke_contract(self)\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn invoke_contract_delegate(&self) -> i32 {\npub fn try_invoke(&self) -> Result<ink_primitives::MessageResult<R>, crate::Error> {\n        crate::invoke_contract(self)\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "impl fmt::Debug for Scope {\n  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    f.debug_struct(\"Scope\")\n      .field(\n        \"allowed_patterns\",\n        &self\n          .allowed_patterns\n          .lock()\n          .unwrap()\n          .iter()\n          .map(|p| p.as_str())\n          .collect::<Vec<&str>>(),\n      )\n      .field(\n        \"forbidden_patterns\",\n        &self\n          .forbidden_patterns\n          .lock()\n          .unwrap()\n          .iter()\n          .map(|p| p.as_str())\n          .collect::<Vec<&str>>(),\n      )\n      .finish()\n  }\n}\nfn push_pattern<P: AsRef<Path>, F: Fn(&str) -> Result<Pattern, glob::PatternError>>(\n  list: &mut HashSet<Pattern>,\n  pattern: P,\n  f: F,\n) -> crate::Result<()> {\n  let path: PathBuf = pattern.as_ref().components().collect();\n  list.insert(f(&path.to_string_lossy())?);\n  #[cfg(windows)]\n  {\n    if let Ok(p) = std::fs::canonicalize(&path) {\n      list.insert(f(&p.to_string_lossy())?);\n    } else {\n      list.insert(f(&format!(\"\\\\\\\\?\\\\{}\", path.display()))?);\n    }\n  }\n  Ok(())\n}\nimpl Scope {\n  pub(crate) fn for_fs_api(\n    config: &Config,\n    package_info: &PackageInfo,\n    env: &Env,\n    scope: &FsAllowlistScope,\n  ) -> crate::Result<Self> {\n    let mut allowed_patterns = HashSet::new();\n    for path in scope.allowed_paths() {\n      if let Ok(path) = parse_path(config, package_info, env, path) {\n        push_pattern(&mut allowed_patterns, path, Pattern::new)?;\n      }\n    }\n    let mut forbidden_patterns = HashSet::new();\n    if let Some(forbidden_paths) = scope.forbidden_paths() {\n      for path in forbidden_paths {\n        if let Ok(path) = parse_path(config, package_info, env, path) {\n          push_pattern(&mut forbidden_patterns, path, Pattern::new)?;\n        }\n      }\n    }\n    let require_literal_leading_dot = match scope {\n      FsAllowlistScope::Scope {\n        require_literal_leading_dot: Some(require),\n        ..\n      } => *require,\n      #[cfg(unix)]\n      _ => false,\n      #[cfg(windows)]\n      _ => true,\n    };\n    Ok(Self {\n      allowed_patterns: Arc::new(Mutex::new(allowed_patterns)),\n      forbidden_patterns: Arc::new(Mutex::new(forbidden_patterns)),\n      event_listeners: Default::default(),\n      match_options: glob::MatchOptions {\n        require_literal_separator: true,\n        require_literal_leading_dot,\n        ..Default::default()\n      },\n    })\n  }\n  pub fn allowed_patterns(&self) -> HashSet<Pattern> {\n    self.allowed_patterns.lock().unwrap().clone()\n  }\n  pub fn forbidden_patterns(&self) -> HashSet<Pattern> {\n    self.forbidden_patterns.lock().unwrap().clone()\n  }\n  pub fn listen<F: Fn(&Event) + Send + 'static>(&self, f: F) -> Uuid {\n    let id = Uuid::new_v4();\n    self.event_listeners.lock().unwrap().insert(id, Box::new(f));\n    id\n  }\n  fn trigger(&self, event: Event) {\n    let listeners = self.event_listeners.lock().unwrap();\n    let handlers = listeners.values();\n    for listener in handlers {\n      listener(&event);\n    }\n  }\n  pub fn allow_directory<P: AsRef<Path>>(&self, path: P, recursive: bool) -> crate::Result<()> {\n    let path = path.as_ref();\n    {\n      let mut list = self.allowed_patterns.lock().unwrap();\n      push_pattern(&mut list, path, escaped_pattern)?;\n      push_pattern(&mut list, path, |p| {\n        escaped_pattern_with(p, if recursive { \"**\" } else { \"*\" })\n      })?;\n    }\n    self.trigger(Event::PathAllowed(path.to_path_buf()));\n    Ok(())\n  }\n  pub fn allow_file<P: AsRef<Path>>(&self, path: P) -> crate::Result<()> {\n    let path = path.as_ref();\n    push_pattern(\n      &mut self.allowed_patterns.lock().unwrap(),\n      path,\n      escaped_pattern,\n    )?;\n    self.trigger(Event::PathAllowed(path.to_path_buf()));\n    Ok(())\n  }\n  pub fn forbid_directory<P: AsRef<Path>>(&self, path: P, recursive: bool) -> crate::Result<()> {\n    let path = path.as_ref();\n    {\n      let mut list = self.forbidden_patterns.lock().unwrap();\n      push_pattern(&mut list, path, escaped_pattern)?;\n      push_pattern(&mut list, path, |p| {\n        escaped_pattern_with(p, if recursive { \"**\" } else { \"*\" })\n      })?;\n    }\n    self.trigger(Event::PathForbidden(path.to_path_buf()));\n    Ok(())\n  }\n  pub fn forbid_file<P: AsRef<Path>>(&self, path: P) -> crate::Result<()> {\n    let path = path.as_ref();\n    push_pattern(\n      &mut self.forbidden_patterns.lock().unwrap(),\n      path,\n      escaped_pattern,\n    )?;\n    self.trigger(Event::PathForbidden(path.to_path_buf()));\n    Ok(())\n  }\n  pub fn is_allowed<P: AsRef<Path>>(&self, path: P) -> bool {\n    let path = path.as_ref();\n    let path = if !path.exists() {\n      crate::Result::Ok(path.to_path_buf())\n    } else {\n      std::fs::canonicalize(path).map_err(Into::into)\n    };\n    if let Ok(path) = path {\n      let path: PathBuf = path.components().collect();\n      let forbidden = self\n        .forbidden_patterns\n        .lock()\n        .unwrap()\n        .iter()\n        .any(|p| p.matches_path_with(&path, self.match_options));\n      if forbidden {\n        false\n      } else {\n        let allowed = self\n          .allowed_patterns\n          .lock()\n          .unwrap()\n          .iter()\n          .any(|p| p.matches_path_with(&path, self.match_options));\n        allowed\n      }\n    } else {\n      false\n    }\n  }\n}\nfn escaped_pattern(p: &str) -> Result<Pattern, glob::PatternError> {\n  Pattern::new(&glob::Pattern::escape(p))\n}\nfn escaped_pattern_with(p: &str, append: &str) -> Result<Pattern, glob::PatternError> {\n  Pattern::new(&format!(\n    \"{}{}{append}\",\n    glob::Pattern::escape(p),\n    MAIN_SEPARATOR\n  ))\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn make_type_internal<F>(\n        module: BinaryIndexedView,\n        tok: &SignatureToken,\n        resolver: &F,\n    ) -> PartialVMResult<Type>\n    where\n        F: Fn(&IdentStr, &ModuleId) -> PartialVMResult<CachedStructIndex>,\n    {\n        let res = match tok {\n            SignatureToken::Bool => Type::Bool,\n            SignatureToken::U8 => Type::U8,\n            SignatureToken::U16 => Type::U16,\n            SignatureToken::U32 => Type::U32,\n            SignatureToken::U64 => Type::U64,\n            SignatureToken::U128 => Type::U128,\n            SignatureToken::U256 => Type::U256,\n            SignatureToken::Address => Type::Address,\n            SignatureToken::Signer => Type::Signer,\n            SignatureToken::TypeParameter(idx) => Type::TyParam(*idx as usize),\n            SignatureToken::Vector(inner_tok) => {\n                let inner_type = Self::make_type_internal(module, inner_tok, resolver)?;\n                Type::Vector(Box::new(inner_type))\n            },\n            SignatureToken::Reference(inner_tok) => {\n                let inner_type = Self::make_type_internal(module, inner_tok, resolver)?;\n                Type::Reference(Box::new(inner_type))\n            },\n            SignatureToken::MutableReference(inner_tok) => {\n                let inner_type = Self::make_type_internal(module, inner_tok, resolver)?;\n                Type::MutableReference(Box::new(inner_type))\n            },\n            SignatureToken::Struct(sh_idx) => {\n                let struct_handle = module.struct_handle_at(*sh_idx);\n                let struct_name = module.identifier_at(struct_handle.name);\n                let module_handle = module.module_handle_at(struct_handle.module);\n                let module_id = ModuleId::new(\n                    *module.address_identifier_at(module_handle.address),\n                    module.identifier_at(module_handle.name).to_owned(),\n                );\n                let def_idx = resolver(struct_name, &module_id)?;\n                Type::Struct(def_idx)\n            },\n            SignatureToken::StructInstantiation(sh_idx, tys) => {\n                let type_parameters: Vec<_> = tys\n                    .iter()\n                    .map(|tok| Self::make_type_internal(module, tok, resolver))\n                    .collect::<PartialVMResult<_>>()?;\n                let struct_handle = module.struct_handle_at(*sh_idx);\n                let struct_name = module.identifier_at(struct_handle.name);\n                let module_handle = module.module_handle_at(struct_handle.module);\n                let module_id = ModuleId::new(\n                    *module.address_identifier_at(module_handle.address),\n                    module.identifier_at(module_handle.name).to_owned(),\n                );\n                let def_idx = resolver(struct_name, &module_id)?;\n                Type::StructInstantiation(def_idx, type_parameters)\n            },\n        };\n        Ok(res)\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "async fn api_return_to_sso_get_common(\n        &self,\n        req: &Request,\n        session: &Session,\n        services: Data<&Services>,\n        code: &Option<String>,\n    ) -> poem::Result<Result<String, String>> {\n        let Some(context) = session.get::<SsoContext>(SSO_CONTEXT_SESSION_KEY) else {\n            return Ok(Err(\"Not in an active SSO process\".to_string()));\n        };\n        let Some(ref code) = *code else {\n            return Ok(Err(\"No authorization code in the return URL request\".to_string()));\n        };\n        let response = context\n            .request\n            .verify_code((*code).clone())\n            .await\n            .map_err(poem::error::InternalServerError)?;\n        if !response.email_verified.unwrap_or(true) {\n            return Ok(Err(\"The SSO account's e-mail is not verified\".to_string()));\n        }\n        let Some(email) = response.email else {\n            return Ok(Err(\"No e-mail information in the SSO response\".to_string()));\n        };\n        info!(\"SSO login as {email}\");\n        let cred = AuthCredential::Sso {\n            provider: context.provider,\n            email: email.clone(),\n        };\n        let username = services\n            .config_provider\n            .lock()\n            .await\n            .username_for_sso_credential(&cred)\n            .await?;\n        let Some(username) = username else {\n            return Ok(Err(format!(\"No user matching {email}\")));\n        };\n        let mut auth_state_store = services.auth_state_store.lock().await;\n        let state_arc =\n            get_auth_state_for_request(&username, session, &mut auth_state_store).await?;\n        let mut state = state_arc.lock().await;\n        let mut cp = services.config_provider.lock().await;\n        if cp.validate_credential(&username, &cred).await? {\n            state.add_valid_credential(cred);\n        }\n        if let AuthResult::Accepted { username } = state.verify() {\n            auth_state_store.complete(state.id()).await;\n            authorize_session(req, username).await?;\n        }\n        Ok(Ok(context\n            .next_url\n            .as_deref()\n            .unwrap_or(\"/@warpgate#/login\")\n            .to_owned()))\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "async fn create_client_stream(config: CompleteConfig) -> Result<(Client, ClientStream), Error> {\n    let irc_config = Config {\n        nickname: Some(config.twitch.username.clone()),\n        server: Some(config.twitch.server.clone()),\n        channels: vec![format!(\"#{}\", config.twitch.channel)],\n        password: config.twitch.token.clone(),\n        port: Some(6667),\n        use_tls: Some(false),\n        ping_timeout: Some(10),\n        ping_time: Some(10),\n        ..Default::default()\n    };\n    let mut client = Client::from_config(irc_config.clone()).await?;\n    client.identify()?;\n    let stream = client.stream()?;\n    Ok((client, stream))\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "validate_feature_name(config, pkg_id, feature)?;\n        for fv in fvs {\n            let dep_data = {\n                match fv {\n                    Feature(dep_name) | Dep { dep_name, .. } | DepFeature { dep_name, .. } => {\n                        dep_map.get(dep_name)\n                    }\n                }\n            };\n            let is_optional_dep = dep_data\n                .iter()\n                .flat_map(|d| d.iter())\n                .any(|d| d.is_optional());\n            let is_any_dep = dep_data.is_some();\n            match fv {\n                Feature(f) => {\n                    if !features.contains_key(f) {\n                        if !is_any_dep {\n                            bail!(\n                                \"feature `{}` includes `{}` which is neither a dependency \\\n                                 nor another feature\",\n                                feature,\n                                fv\n                            );\n                        }\n                        if is_optional_dep {\n                            if !map.contains_key(f) {\n                                bail!(\n                                    \"feature `{}` includes `{}`, but `{}` is an \\\n                                     optional dependency without an implicit feature\\n\\\n                                     Use `dep:{}` to enable the dependency.\",\n                                    feature,\n                                    fv,\n                                    f,\n                                    f\n                                );\n                            }\n                        } else {\n                            bail!(\"feature `{}` includes `{}`, but `{}` is not an optional dependency\\n\\\n                                A non-optional dependency of the same name is defined; \\\n                                consider adding `optional = true` to its definition.\",\n                                feature, fv, f);\n                        }\n                    }\n                }\n                Dep { dep_name } => {\n                    if !is_any_dep {\n                        bail!(\n                            \"feature `{}` includes `{}`, but `{}` is not listed as a dependency\",\n                            feature,\n                            fv,\n                            dep_name\n                        );\n                    }\n                    if !is_optional_dep {\n                        bail!(\n                            \"feature `{}` includes `{}`, but `{}` is not an optional dependency\\n\\\n                             A non-optional dependency of the same name is defined; \\\n                             consider adding `optional = true` to its definition.\",\n                            feature,\n                            fv,\n                            dep_name\n                        );\n                    }\n                }\n                DepFeature {\n                    dep_name,\n                    dep_feature,\n                    weak,\n                    ..\n                } => {\n                    if dep_feature.contains('/') {\n                        bail!(\n                            \"multiple slashes in feature `{}` (included by feature `{}`) are not allowed\",\n                            fv,\n                            feature\n                        );\n                    }\n                    if let Some(stripped_dep) = dep_name.strip_prefix(\"dep:\") {\n                        let has_other_dep = explicitly_listed.contains(stripped_dep);\n                        let is_optional = dep_map\n                            .get(stripped_dep)\n                            .iter()\n                            .flat_map(|d| d.iter())\n                            .any(|d| d.is_optional());\n                        let extra_help = if *weak || has_other_dep || !is_optional {\n                            String::new()\n                        } else {\n                            format!(\n                                \"\\nIf the intent is to avoid creating an implicit feature \\\n                                 `{stripped_dep}` for an optional dependency, \\\n                                 then consider replacing this with two values:\\n    \\\n                                 \\\"dep:{stripped_dep}\\\", \\\"{stripped_dep}/{dep_feature}\\\"\"\n                            )\n                        };\n                        bail!(\n                            \"feature `{feature}` includes `{fv}` with both `dep:` and `/`\\n\\\n                            To fix this, remove the `dep:` prefix.{extra_help}\"\n                        )\n                    }\n                    if !is_any_dep {\n                        bail!(\n                            \"feature `{}` includes `{}`, but `{}` is not a dependency\",\n                            feature,\n                            fv,\n                            dep_name\n                        );\n                    }\n                    if *weak && !is_optional_dep {\n                        bail!(\"feature `{}` includes `{}` with a `?`, but `{}` is not an optional dependency\\n\\\n                            A non-optional dependency of the same name is defined; \\\n                            consider removing the `?` or changing the dependency to be optional\",\n                            feature, fv, dep_name);\n                    }\n                }\n            }\n        }\n    }\n    let used: HashSet<_> = map\n        .values()\n        .flatten()\n        .filter_map(|fv| match fv {\n            Dep { dep_name } | DepFeature { dep_name, .. } => Some(dep_name),\n            _ => None,\n        })\n        .collect();\n    if let Some(dep) = dependencies\n        .iter()\n        .find(|dep| dep.is_optional() && !used.contains(&dep.name_in_toml()))\n    {\n        bail!(\n            \"optional dependency `{}` is not included in any feature\\n\\\n            Make sure that `dep:{}` is included in one of features in the [features] table.\",\n            dep.name_in_toml(),\n            dep.name_in_toml(),\n        );\n    }\n    Ok(map)\n}\n#[derive(Clone, Debug, Ord, PartialOrd, Eq, PartialEq, Hash)]\npub enum FeatureValue {\n    Feature(InternedString),\n    Dep { dep_name: InternedString },\n    DepFeature {\n        dep_name: InternedString,\n        dep_feature: InternedString,\n        weak: bool,\n    },\n}\nimpl FeatureValue {\n    pub fn new(feature: InternedString) -> FeatureValue {\n        match feature.find('/') {\n            Some(pos) => {\n                let (dep, dep_feat) = feature.split_at(pos);\n                let dep_feat = &dep_feat[1..];\n                let (dep, weak) = if let Some(dep) = dep.strip_suffix('?') {\n                    (dep, true)\n                } else {\n                    (dep, false)\n                };\n                FeatureValue::DepFeature {\n                    dep_name: InternedString::new(dep),\n                    dep_feature: InternedString::new(dep_feat),\n                    weak,\n                }\n            }\n            None => {\n                if let Some(dep_name) = feature.strip_prefix(\"dep:\") {\n                    FeatureValue::Dep {\n                        dep_name: InternedString::new(dep_name),\n                    }\n                } else {\n                    FeatureValue::Feature(feature)\n                }\n            }\n        }\n    }\n    pub fn has_dep_prefix(&self) -> bool {\n        matches!(self, FeatureValue::Dep { .. })\n    }\n}\nimpl fmt::Display for FeatureValue {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        use self::FeatureValue::*;\n        match self {\n            Feature(feat) => write!(f, \"{}\", feat),\n            Dep { dep_name } => write!(f, \"dep:{}\", dep_name),\n            DepFeature {\n                dep_name,\n                dep_feature,\n                weak,\n            } => {\n                let weak = if *weak { \"?\" } else { \"\" };\n                write!(f, \"{}{}/{}\", dep_name, weak, dep_feature)\n            }\n        }\n    }\n}\npub type FeatureMap = BTreeMap<InternedString, Vec<FeatureValue>>;\nfn validate_feature_name(config: &Config, pkg_id: PackageId, name: &str) -> CargoResult<()> {\n    let mut chars = name.chars();\n    const FUTURE: &str = \"This was previously accepted but is being phased out; \\\n        it will become a hard error in a future release.\\n\\\n        For more information, see issue #8813 <https://github.com/rust-lang/cargo/issues/8813>, \\\n        and please leave a comment if this will be a problem for your project.\";\n    if let Some(ch) = chars.next() {\n        if !(unicode_xid::UnicodeXID::is_xid_start(ch) || ch == '_' || ch.is_digit(10)) {\n            config.shell().warn(&format!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                the first character must be a Unicode XID start character or digit \\\n                (most letters or `_` or `0` to `9`)\\n\\\n                {}\",\n                ch, name, pkg_id, FUTURE\n            ))?;\n        }\n    }\n    for ch in chars {\n        if !(unicode_xid::UnicodeXID::is_xid_continue(ch) || ch == '-' || ch == '+' || ch == '.') {\n            config.shell().warn(&format!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                characters must be Unicode XID characters, `+`, or `.` \\\n                (numbers, `+`, `-`, `_`, `.`, or most letters)\\n\\\n                {}\",\n                ch, name, pkg_id, FUTURE\n            ))?;\n        }\n    }\n    Ok(())\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn get_ref<T: ByteValued>(&self, offset: usize) -> Result<VolatileRef<T, BS<Self::B>>> {\n        let slice = self.get_slice(offset, size_of::<T>())?;\n        unsafe {\n            Ok(VolatileRef::with_bitmap(\n                slice.addr,\n                slice.bitmap,\n                slice.mmap,\n            ))\n        }\n    }\nunsafe fn aligned_as_ref<T: ByteValued>(&self, offset: usize) -> Result<&T> {\n        let slice = self.get_slice(offset, size_of::<T>())?;\n        slice.check_alignment(align_of::<T>())?;\n        Ok(&*(slice.addr as *const T))\n    }\nunsafe fn aligned_as_mut<T: ByteValued>(&self, offset: usize) -> Result<&mut T> {\n        let slice = self.get_slice(offset, size_of::<T>())?;\n        slice.check_alignment(align_of::<T>())?;\n        Ok(&mut *(slice.addr as *mut T))\n    }\nfn get_atomic_ref<T: AtomicInteger>(&self, offset: usize) -> Result<&T> {\n        let slice = self.get_slice(offset, size_of::<T>())?;\n        slice.check_alignment(align_of::<T>())?;\n        unsafe { Ok(&*(slice.addr as *const T)) }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub(crate) fn operation_name(&self) -> Option<String> {\n        self.entries\n            .get(OPERATION_NAME)\n            .map(|v| v.value().as_str().unwrap().to_string())\n    }\nasync fn call_websocket(\n    mut notify: Notify<String, graphql::Response>,\n    request: SubgraphRequest,\n    context: Context,\n    service_name: String,\n    subgraph_cfg: &WebSocketConfiguration,\n    subscription_hash: String,\n) -> Result<SubgraphResponse, BoxError> {\n    let SubgraphRequest {\n        subgraph_request,\n        subscription_stream,\n        ..\n    } = request;\n    let mut subscription_stream_tx =\n        subscription_stream.ok_or_else(|| FetchError::SubrequestWsError {\n            service: service_name.clone(),\n            reason: \"cannot get the websocket stream\".to_string(),\n        })?;\n    let (handle, created) = notify\n        .create_or_subscribe(subscription_hash.clone(), false)\n        .await?;\n    tracing::info!(\n        monotonic_counter.apollo.router.operations.subscriptions = 1u64,\n        subscriptions.mode = %\"passthrough\",\n        subscriptions.deduplicated = !created,\n        subgraph.service.name = service_name,\n    );\n    if !created {\n        subscription_stream_tx.send(handle.into_stream()).await?;\n        tracing::info!(\n            monotonic_counter.apollo_router_deduplicated_subscriptions_total = 1u64,\n            mode = %\"passthrough\",\n        );\n        return Ok(SubgraphResponse::builder()\n            .context(context)\n            .extensions(Object::default())\n            .build());\n    }\n    let (parts, body) = subgraph_request.into_parts();\n    let connection_params = match (\n        context.get_json_value(SUBSCRIPTION_WS_CUSTOM_CONNECTION_PARAMS),\n        parts\n            .headers\n            .get(http::header::AUTHORIZATION)\n            .and_then(|auth| auth.to_str().ok()),\n    ) {\n        (Some(connection_params), _) => Some(connection_params),\n        (None, Some(authorization)) => Some(serde_json_bytes::json!({ \"token\": authorization })),\n        _ => None,\n    };\n    let request = get_websocket_request(service_name.clone(), parts, subgraph_cfg)?;\n    let display_headers = context.contains_key(LOGGING_DISPLAY_HEADERS);\n    let display_body = context.contains_key(LOGGING_DISPLAY_BODY);\n    if display_headers {\n        tracing::info!(http.request.headers = ?request.headers(), apollo.subgraph.name = %service_name, \"Websocket request headers to subgraph {service_name:?}\");\n    }\n    if display_body {\n        tracing::info!(http.request.body = ?request.body(), apollo.subgraph.name = %service_name, \"Websocket request body to subgraph {service_name:?}\");\n    }\n    let uri = request.uri();\n    let path = uri.path();\n    let host = uri.host().unwrap_or_default();\n    let port = uri.port_u16().unwrap_or_else(|| {\n        let scheme = uri.scheme_str();\n        if scheme == Some(\"wss\") {\n            443\n        } else if scheme == Some(\"ws\") {\n            80\n        } else {\n            0\n        }\n    });\n    let subgraph_req_span = tracing::info_span!(\"subgraph_request\",\n        \"otel.kind\" = \"CLIENT\",\n        \"net.peer.name\" = %host,\n        \"net.peer.port\" = %port,\n        \"http.route\" = %path,\n        \"http.url\" = %uri,\n        \"net.transport\" = \"ip_tcp\",\n        \"apollo.subgraph.name\" = %service_name,\n        \"graphql.operation.name\" = %operation_name,\n    );\n    let (ws_stream, mut resp) = match request.uri().scheme_str() {\n        Some(\"wss\") => {\n            connect_async_tls_with_config(request, None, None)\n                .instrument(subgraph_req_span)\n                .await\n        }\n        _ => connect_async(request).instrument(subgraph_req_span).await,\n    }\n    .map_err(|err| FetchError::SubrequestWsError {\n        service: service_name.clone(),\n        reason: format!(\"cannot connect websocket to subgraph: {err}\"),\n    })?;\n    if display_body {\n        tracing::info!(\n            response.body = %String::from_utf8_lossy(&resp.body_mut().take().unwrap_or_default()), apollo.subgraph.name = %service_name, \"Raw response body from subgraph {service_name:?} received\"\n        );\n    }\n    let mut gql_stream = GraphqlWebSocket::new(\n        convert_websocket_stream(ws_stream, subscription_hash.clone()),\n        subscription_hash,\n        subgraph_cfg.protocol,\n        connection_params,\n    )\n    .await\n    .map_err(|_| FetchError::SubrequestWsError {\n        service: service_name.clone(),\n        reason: \"cannot get the GraphQL websocket stream\".to_string(),\n    })?;\n    gql_stream\n        .send(body)\n        .await\n        .map_err(|err| FetchError::SubrequestWsError {\n            service: service_name,\n            reason: format!(\"cannot send the subgraph request to websocket stream: {err:?}\"),\n        })?;\n    let (mut gql_sink, gql_stream) = gql_stream.split();\n    let (handle_sink, handle_stream) = handle.split();\n    tokio::task::spawn(async move {\n        let _ = gql_stream\n            .map(Ok::<_, graphql::Error>)\n            .forward(handle_sink)\n            .await;\n        if let Err(err) = gql_sink.close().await {\n            tracing::trace!(\"cannot close the websocket stream: {err:?}\");\n        }\n    });\n    subscription_stream_tx.send(handle_stream).await?;\n    Ok(SubgraphResponse::new_from_response(\n        resp.map(|_| graphql::Response::default()),\n        context,\n    ))\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn create_p2p_network(\n        config: &NodeConfig,\n        state_sync_store: RocksDbStore,\n        chain_identifier: ChainIdentifier,\n        trusted_peer_change_rx: watch::Receiver<TrustedPeerChangeEvent>,\n        archive_readers: ArchiveReaderBalancer,\n        prometheus_registry: &Registry,\n    ) -> Result<(Network, discovery::Handle, state_sync::Handle)> {\n        let (state_sync, state_sync_server) = state_sync::Builder::new()\n            .config(config.p2p_config.state_sync.clone().unwrap_or_default())\n            .store(state_sync_store)\n            .archive_readers(archive_readers)\n            .with_metrics(prometheus_registry)\n            .build();\n        let (discovery, discovery_server) = discovery::Builder::new(trusted_peer_change_rx)\n            .config(config.p2p_config.clone())\n            .build();\n        let p2p_network = {\n            let routes = anemo::Router::new()\n                .add_rpc_service(discovery_server)\n                .add_rpc_service(state_sync_server);\n            let inbound_network_metrics =\n                NetworkMetrics::new(\"sui\", \"inbound\", prometheus_registry);\n            let outbound_network_metrics =\n                NetworkMetrics::new(\"sui\", \"outbound\", prometheus_registry);\n            let service = ServiceBuilder::new()\n                .layer(\n                    TraceLayer::new_for_server_errors()\n                        .make_span_with(DefaultMakeSpan::new().level(tracing::Level::INFO))\n                        .on_failure(DefaultOnFailure::new().level(tracing::Level::WARN)),\n                )\n                .layer(CallbackLayer::new(MetricsMakeCallbackHandler::new(\n                    Arc::new(inbound_network_metrics),\n                    config.p2p_config.excessive_message_size(),\n                )))\n                .service(routes);\n            let outbound_layer = ServiceBuilder::new()\n                .layer(\n                    TraceLayer::new_for_client_and_server_errors()\n                        .make_span_with(DefaultMakeSpan::new().level(tracing::Level::INFO))\n                        .on_failure(DefaultOnFailure::new().level(tracing::Level::WARN)),\n                )\n                .layer(CallbackLayer::new(MetricsMakeCallbackHandler::new(\n                    Arc::new(outbound_network_metrics),\n                    config.p2p_config.excessive_message_size(),\n                )))\n                .into_inner();\n            let mut anemo_config = config.p2p_config.anemo_config.clone().unwrap_or_default();\n            anemo_config.max_frame_size = Some(2 << 30);\n            let mut quic_config = anemo_config.quic.unwrap_or_default();\n            if quic_config.socket_send_buffer_size.is_none() {\n                quic_config.socket_send_buffer_size = Some(20 << 20);\n            }\n            if quic_config.socket_receive_buffer_size.is_none() {\n                quic_config.socket_receive_buffer_size = Some(20 << 20);\n            }\n            quic_config.allow_failed_socket_buffer_size_setting = true;\n            anemo_config.quic = Some(quic_config);\n            let server_name = format!(\"sui-{}\", chain_identifier);\n            let network = Network::bind(config.p2p_config.listen_address)\n                .server_name(&server_name)\n                .private_key(config.network_key_pair().copy().private().0.to_bytes())\n                .config(anemo_config)\n                .outbound_request_layer(outbound_layer)\n                .start(service)?;\n            info!(\n                server_name = server_name,\n                \"P2p network started on {}\",\n                network.local_addr()\n            );\n            network\n        };\n        let discovery_handle = discovery.start(p2p_network.clone());\n        let state_sync_handle = state_sync.start(p2p_network.clone());\n        Ok((p2p_network, discovery_handle, state_sync_handle))\n    }\nfn decode(&mut self, buf: &mut DecodeBuf<'_>) -> Result<Option<Self::Item>, Self::Error> {\n        if !buf.has_remaining() {\n            return Ok(None);\n        }\n        let chunk = buf.chunk();\n        let item: Self::Item =\n            bcs::from_bytes(chunk).map_err(|e| Status::internal(e.to_string()))?;\n        buf.advance(chunk.len());\n        Ok(Some(item))\n    }\npub fn spawn(\n        authority: Authority,\n        keypair: NetworkKeyPair,\n        id: WorkerId,\n        committee: Committee,\n        worker_cache: WorkerCache,\n        protocol_config: ProtocolConfig,\n        parameters: Parameters,\n        validator: impl TransactionValidator,\n        client: NetworkClient,\n        store: DBMap<BatchDigest, Batch>,\n        metrics: Metrics,\n        tx_shutdown: &mut PreSubscribedBroadcastSender,\n    ) -> Vec<JoinHandle<()>> {\n        let worker_name = keypair.public().clone();\n        let worker_peer_id = PeerId(worker_name.0.to_bytes());\n        info!(\"Boot worker node with id {} peer id {}\", id, worker_peer_id,);\n        let worker = Self {\n            authority: authority.clone(),\n            keypair,\n            id,\n            committee: committee.clone(),\n            worker_cache: worker_cache.clone(),\n            protocol_config: protocol_config.clone(),\n            parameters: parameters.clone(),\n            store,\n        };\n        let node_metrics = Arc::new(metrics.worker_metrics.unwrap());\n        let endpoint_metrics = metrics.endpoint_metrics.unwrap();\n        let channel_metrics: Arc<WorkerChannelMetrics> = Arc::new(metrics.channel_metrics.unwrap());\n        let inbound_network_metrics = Arc::new(metrics.inbound_network_metrics.unwrap());\n        let outbound_network_metrics = Arc::new(metrics.outbound_network_metrics.unwrap());\n        let network_connection_metrics = metrics.network_connection_metrics.unwrap();\n        let mut shutdown_receivers = tx_shutdown.subscribe_n(NUM_SHUTDOWN_RECEIVERS);\n        let mut worker_service = WorkerToWorkerServer::new(WorkerReceiverHandler {\n            protocol_config: protocol_config.clone(),\n            id: worker.id,\n            client: client.clone(),\n            store: worker.store.clone(),\n            validator: validator.clone(),\n        });\n        if let Some(limit) = parameters.anemo.report_batch_rate_limit {\n            worker_service = worker_service.add_layer_for_report_batch(InboundRequestLayer::new(\n                rate_limit::RateLimitLayer::new(\n                    governor::Quota::per_second(limit),\n                    rate_limit::WaitMode::Block,\n                ),\n            ));\n        }\n        if let Some(limit) = parameters.anemo.request_batches_rate_limit {\n            worker_service = worker_service.add_layer_for_request_batches(\n                InboundRequestLayer::new(rate_limit::RateLimitLayer::new(\n                    governor::Quota::per_second(limit),\n                    rate_limit::WaitMode::Block,\n                )),\n            );\n        }\n        let primary_service = PrimaryToWorkerServer::new(PrimaryReceiverHandler {\n            authority_id: worker.authority.id(),\n            id: worker.id,\n            committee: worker.committee.clone(),\n            protocol_config: protocol_config.clone(),\n            worker_cache: worker.worker_cache.clone(),\n            store: worker.store.clone(),\n            request_batches_timeout: worker.parameters.sync_retry_delay,\n            request_batches_retry_nodes: worker.parameters.sync_retry_nodes,\n            network: None,\n            batch_fetcher: None,\n            validator: validator.clone(),\n        });\n        let address = worker\n            .worker_cache\n            .worker(authority.protocol_key(), &id)\n            .expect(\"Our public key or worker id is not in the worker cache\")\n            .worker_address;\n        let address = address\n            .replace(0, |_protocol| Some(Protocol::Ip4(Ipv4Addr::UNSPECIFIED)))\n            .unwrap();\n        let addr = address.to_anemo_address().unwrap();\n        let epoch_string: String = committee.epoch().to_string();\n        let our_primary_peer_id = PeerId(authority.network_key().0.to_bytes());\n        let primary_to_worker_router = anemo::Router::new()\n            .add_rpc_service(primary_service)\n            .route_layer(RequireAuthorizationLayer::new(AllowedPeers::new([\n                our_primary_peer_id,\n            ])))\n            .route_layer(RequireAuthorizationLayer::new(AllowedEpoch::new(\n                epoch_string.clone(),\n            )));\n        let worker_peer_ids = worker_cache\n            .all_workers()\n            .into_iter()\n            .map(|(worker_name, _)| PeerId(worker_name.0.to_bytes()));\n        let routes = anemo::Router::new()\n            .add_rpc_service(worker_service)\n            .route_layer(RequireAuthorizationLayer::new(AllowedPeers::new(\n                worker_peer_ids,\n            )))\n            .route_layer(RequireAuthorizationLayer::new(AllowedEpoch::new(\n                epoch_string.clone(),\n            )))\n            .merge(primary_to_worker_router);\n        let service = ServiceBuilder::new()\n            .layer(\n                TraceLayer::new_for_server_errors()\n                    .make_span_with(DefaultMakeSpan::new().level(tracing::Level::INFO))\n                    .on_failure(DefaultOnFailure::new().level(tracing::Level::WARN)),\n            )\n            .layer(CallbackLayer::new(MetricsMakeCallbackHandler::new(\n                inbound_network_metrics,\n                parameters.anemo.excessive_message_size(),\n            )))\n            .layer(CallbackLayer::new(FailpointsMakeCallbackHandler::new()))\n            .layer(SetResponseHeaderLayer::overriding(\n                EPOCH_HEADER_KEY.parse().unwrap(),\n                epoch_string.clone(),\n            ))\n            .service(routes);\n        let outbound_layer = ServiceBuilder::new()\n            .layer(\n                TraceLayer::new_for_client_and_server_errors()\n                    .make_span_with(DefaultMakeSpan::new().level(tracing::Level::INFO))\n                    .on_failure(DefaultOnFailure::new().level(tracing::Level::WARN)),\n            )\n            .layer(CallbackLayer::new(MetricsMakeCallbackHandler::new(\n                outbound_network_metrics,\n                parameters.anemo.excessive_message_size(),\n            )))\n            .layer(CallbackLayer::new(FailpointsMakeCallbackHandler::new()))\n            .layer(SetRequestHeaderLayer::overriding(\n                EPOCH_HEADER_KEY.parse().unwrap(),\n                epoch_string,\n            ))\n            .into_inner();\n        let anemo_config = {\n            let mut quic_config = anemo::QuicConfig::default();\n            quic_config.max_concurrent_bidi_streams = Some(10_000);\n            quic_config.stream_receive_window = Some(100 << 20);\n            quic_config.receive_window = Some(200 << 20);\n            quic_config.send_window = Some(200 << 20);\n            quic_config.crypto_buffer_size = Some(1 << 20);\n            quic_config.socket_receive_buffer_size = Some(20 << 20);\n            quic_config.socket_send_buffer_size = Some(20 << 20);\n            quic_config.allow_failed_socket_buffer_size_setting = true;\n            quic_config.max_idle_timeout_ms = Some(30_000);\n            quic_config.keep_alive_interval_ms = Some(5_000);\n            let mut config = anemo::Config::default();\n            config.quic = Some(quic_config);\n            config.max_frame_size = Some(2 << 30);\n            config.inbound_request_timeout_ms = Some(300_000);\n            config.outbound_request_timeout_ms = Some(300_000);\n            config.shutdown_idle_timeout_ms = Some(1_000);\n            config.connectivity_check_interval_ms = Some(2_000);\n            config.connection_backoff_ms = Some(1_000);\n            config.max_connection_backoff_ms = Some(20_000);\n            config\n        };\n        let network;\n        let mut retries_left = 90;\n        loop {\n            let network_result = anemo::Network::bind(addr.clone())\n                .server_name(\"narwhal\")\n                .private_key(worker.keypair.copy().private().0.to_bytes())\n                .config(anemo_config.clone())\n                .outbound_request_layer(outbound_layer.clone())\n                .start(service.clone());\n            match network_result {\n                Ok(n) => {\n                    network = n;\n                    break;\n                }\n                Err(_) => {\n                    retries_left -= 1;\n                    if retries_left <= 0 {\n                        panic!();\n                    }\n                    error!(\n                        \"Address {} should be available for the primary Narwhal service, retrying in one second\",\n                        addr\n                    );\n                    sleep(Duration::from_secs(1));\n                }\n            }\n        }\n        info!(\"Worker {} listening to worker messages on {}\", id, address);\n        let batch_fetcher = BatchFetcher::new(\n            worker_name,\n            network.clone(),\n            worker.store.clone(),\n            node_metrics.clone(),\n            protocol_config.clone(),\n        );\n        client.set_primary_to_worker_local_handler(\n            worker_peer_id,\n            Arc::new(PrimaryReceiverHandler {\n                authority_id: worker.authority.id(),\n                id: worker.id,\n                committee: worker.committee.clone(),\n                protocol_config,\n                worker_cache: worker.worker_cache.clone(),\n                store: worker.store.clone(),\n                request_batches_timeout: worker.parameters.sync_retry_delay,\n                request_batches_retry_nodes: worker.parameters.sync_retry_nodes,\n                network: Some(network.clone()),\n                batch_fetcher: Some(batch_fetcher),\n                validator: validator.clone(),\n            }),\n        );\n        let mut peer_types = HashMap::new();\n        let other_workers = worker\n            .worker_cache\n            .others_workers_by_id(authority.protocol_key(), &id)\n            .into_iter()\n            .map(|(_, info)| (info.name, info.worker_address));\n        for (public_key, address) in other_workers {\n            let (peer_id, address) = Self::add_peer_in_network(&network, public_key, &address);\n            peer_types.insert(peer_id, \"other_worker\".to_string());\n            info!(\n                \"Adding others workers with peer id {} and address {}\",\n                peer_id, address\n            );\n        }\n        let (peer_id, address) = Self::add_peer_in_network(\n            &network,\n            authority.network_key(),\n            &authority.primary_address(),\n        );\n        peer_types.insert(peer_id, \"our_primary\".to_string());\n        info!(\n            \"Adding our primary with peer id {} and address {}\",\n            peer_id, address\n        );\n        let other_primaries: Vec<(AuthorityIdentifier, Multiaddr, NetworkPublicKey)> =\n            committee.others_primaries_by_id(authority.id());\n        for (_, _, network_key) in other_primaries {\n            peer_types.insert(\n                PeerId(network_key.0.to_bytes()),\n                \"other_primary\".to_string(),\n            );\n        }\n        let (connection_monitor_handle, _) = network::connectivity::ConnectionMonitor::spawn(\n            network.downgrade(),\n            network_connection_metrics,\n            peer_types,\n            Some(shutdown_receivers.pop().unwrap()),\n        );\n        let network_admin_server_base_port = parameters\n            .network_admin_server\n            .worker_network_admin_server_base_port\n            .checked_add(id as u16)\n            .unwrap();\n        info!(\n            \"Worker {} listening to network admin messages on 127.0.0.1:{}\",\n            id, network_admin_server_base_port\n        );\n        let admin_handles = network::admin::start_admin_server(\n            network_admin_server_base_port,\n            network.clone(),\n            shutdown_receivers.pop().unwrap(),\n        );\n        let client_flow_handles = worker.handle_clients_transactions(\n            vec![\n                shutdown_receivers.pop().unwrap(),\n                shutdown_receivers.pop().unwrap(),\n                shutdown_receivers.pop().unwrap(),\n            ],\n            node_metrics,\n            channel_metrics,\n            endpoint_metrics,\n            validator,\n            client,\n            network.clone(),\n        );\n        let network_shutdown_handle =\n            Self::shutdown_network_listener(shutdown_receivers.pop().unwrap(), network);\n        info!(\n            \"Worker {} successfully booted on {}\",\n            id,\n            worker\n                .worker_cache\n                .worker(authority.protocol_key(), &worker.id)\n                .expect(\"Our public key or worker id is not in the worker cache\")\n                .transactions\n        );\n        let mut handles = vec![connection_monitor_handle, network_shutdown_handle];\n        handles.extend(admin_handles);\n        handles.extend(client_flow_handles);\n        handles\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub struct ServerHandler {\n    pub id: SessionId,\n    pub event_tx: UnboundedSender<ServerHandlerEvent>,\n}\n#[derive(thiserror::Error, Debug)]\npub enum ServerHandlerError {\n    #[error(\"channel disconnected\")]\n    ChannelSend,\n}\nimpl ServerHandler {\n    fn send_event(&self, event: ServerHandlerEvent) -> Result<(), ServerHandlerError> {\n        self.event_tx\n            .send(event)\n            .map_err(|_| ServerHandlerError::ChannelSend)\n    }\n}\n#[async_trait]\nimpl russh::server::Handler for ServerHandler {\n    type Error = anyhow::Error;\n    async fn auth_succeeded(self, session: Session) -> Result<(Self, Session), Self::Error> {\n        let handle = session.handle();\n        self.send_event(ServerHandlerEvent::Authenticated(HandleWrapper(handle)))?;\n        Ok((self, session))\n    }\n    async fn channel_open_session(\n        self,\n        channel: Channel<Msg>,\n        session: Session,\n    ) -> Result<(Self, bool, Session), Self::Error> {\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::ChannelOpenSession(\n            ServerChannelId(channel.id()),\n            tx,\n        ))?;\n        let allowed = rx.await.unwrap_or(false);\n        Ok((self, allowed, session))\n    }\n    async fn subsystem_request(\n        self,\n        channel: ChannelId,\n        name: &str,\n        mut session: Session,\n    ) -> Result<(Self, Session), Self::Error> {\n        let name = name.to_string();\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::SubsystemRequest(\n            ServerChannelId(channel),\n            name,\n            tx,\n        ))?;\n        if rx.await.unwrap_or(false) {\n            session.channel_success(channel)\n        } else {\n            session.channel_failure(channel)\n        }\n        Ok((self, session))\n    }\n    async fn pty_request(\n        self,\n        channel: ChannelId,\n        term: &str,\n        col_width: u32,\n        row_height: u32,\n        pix_width: u32,\n        pix_height: u32,\n        modes: &[(Pty, u32)],\n        mut session: Session,\n    ) -> Result<(Self, Session), Self::Error> {\n        let term = term.to_string();\n        let modes = modes\n            .iter()\n            .take_while(|x| (x.0 as u8) > 0 && (x.0 as u8) < 160)\n            .map(Clone::clone)\n            .collect();\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::PtyRequest(\n            ServerChannelId(channel),\n            PtyRequest {\n                term,\n                col_width,\n                row_height,\n                pix_width,\n                pix_height,\n                modes,\n            },\n            tx,\n        ))?;\n        let _ = rx.await;\n        session.channel_success(channel);\n        Ok((self, session))\n    }\n    async fn shell_request(\n        self,\n        channel: ChannelId,\n        mut session: Session,\n    ) -> Result<(Self, Session), Self::Error> {\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::ShellRequest(\n            ServerChannelId(channel),\n            tx,\n        ))?;\n        if rx.await.unwrap_or(false) {\n            session.channel_success(channel)\n        } else {\n            session.channel_failure(channel)\n        }\n        Ok((self, session))\n    }\n    async fn auth_publickey(\n        self,\n        user: &str,\n        key: &russh_keys::key::PublicKey,\n    ) -> Result<(Self, Auth), Self::Error> {\n        let user = Secret::new(user.to_string());\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::AuthPublicKey(user, key.clone(), tx))?;\n        let result = rx.await.unwrap_or(Auth::UnsupportedMethod);\n        Ok((self, result))\n    }\n    async fn auth_password(self, user: &str, password: &str) -> Result<(Self, Auth), Self::Error> {\n        let user = Secret::new(user.to_string());\n        let password = Secret::new(password.to_string());\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::AuthPassword(user, password, tx))?;\n        let result = rx.await.unwrap_or(Auth::UnsupportedMethod);\n        Ok((self, result))\n    }\n    async fn auth_keyboard_interactive(\n        self,\n        user: &str,\n        _submethods: &str,\n        response: Option<russh::server::Response<'async_trait>>,\n    ) -> Result<(Self, Auth), Self::Error> {\n        let user = Secret::new(user.to_string());\n        let response = response\n            .and_then(|mut r| r.next())\n            .and_then(|b| String::from_utf8(b.to_vec()).ok())\n            .map(Secret::new);\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::AuthKeyboardInteractive(\n            user, response, tx,\n        ))?;\n        let result = rx.await.unwrap_or(Auth::UnsupportedMethod);\n        Ok((self, result))\n    }\n    async fn data(\n        self,\n        channel: ChannelId,\n        data: &[u8],\n        session: Session,\n    ) -> Result<(Self, Session), Self::Error> {\n        let channel = ServerChannelId(channel);\n        let data = Bytes::from(data.to_vec());\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::Data(channel, data, tx))?;\n        let _ = rx.await;\n        Ok((self, session))\n    }\n    async fn extended_data(\n        self,\n        channel: ChannelId,\n        code: u32,\n        data: &[u8],\n        session: Session,\n    ) -> Result<(Self, Session), Self::Error> {\n        let channel = ServerChannelId(channel);\n        let data = Bytes::from(data.to_vec());\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::ExtendedData(channel, data, code, tx))?;\n        let _ = rx.await;\n        Ok((self, session))\n    }\n    async fn channel_close(\n        self,\n        channel: ChannelId,\n        session: Session,\n    ) -> Result<(Self, Session), Self::Error> {\n        let channel = ServerChannelId(channel);\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::ChannelClose(channel, tx))?;\n        let _ = rx.await;\n        Ok((self, session))\n    }\n    async fn window_change_request(\n        self,\n        channel: ChannelId,\n        col_width: u32,\n        row_height: u32,\n        pix_width: u32,\n        pix_height: u32,\n        session: Session,\n    ) -> Result<(Self, Session), Self::Error> {\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::WindowChangeRequest(\n            ServerChannelId(channel),\n            PtyRequest {\n                term: \"\".to_string(),\n                col_width,\n                row_height,\n                pix_width,\n                pix_height,\n                modes: vec![],\n            },\n            tx,\n        ))?;\n        let _ = rx.await;\n        Ok((self, session))\n    }\n    async fn channel_eof(\n        self,\n        channel: ChannelId,\n        session: Session,\n    ) -> Result<(Self, Session), Self::Error> {\n        let channel = ServerChannelId(channel);\n        let (tx, rx) = oneshot::channel();\n        self.event_tx\n            .send(ServerHandlerEvent::ChannelEof(channel, tx))\n            .map_err(|_| ServerHandlerError::ChannelSend)?;\n        let _ = rx.await;\n        Ok((self, session))\n    }\n    async fn signal(\n        self,\n        channel: ChannelId,\n        signal_name: russh::Sig,\n        session: Session,\n    ) -> Result<(Self, Session), Self::Error> {\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::Signal(\n            ServerChannelId(channel),\n            signal_name,\n            tx,\n        ))?;\n        let _ = rx.await;\n        Ok((self, session))\n    }\n    async fn exec_request(\n        self,\n        channel: ChannelId,\n        data: &[u8],\n        mut session: Session,\n    ) -> Result<(Self, Session), Self::Error> {\n        let data = Bytes::from(data.to_vec());\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::ExecRequest(\n            ServerChannelId(channel),\n            data,\n            tx,\n        ))?;\n        if rx.await.unwrap_or(false) {\n            session.channel_success(channel)\n        } else {\n            session.channel_failure(channel)\n        }\n        Ok((self, session))\n    }\n    async fn env_request(\n        self,\n        channel: ChannelId,\n        variable_name: &str,\n        variable_value: &str,\n        session: Session,\n    ) -> Result<(Self, Session), Self::Error> {\n        let variable_name = variable_name.to_string();\n        let variable_value = variable_value.to_string();\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::EnvRequest(\n            ServerChannelId(channel),\n            variable_name,\n            variable_value,\n            tx,\n        ))?;\n        let _ = rx.await;\n        Ok((self, session))\n    }\n    async fn channel_open_direct_tcpip(\n        self,\n        channel: Channel<Msg>,\n        host_to_connect: &str,\n        port_to_connect: u32,\n        originator_address: &str,\n        originator_port: u32,\n        session: Session,\n    ) -> Result<(Self, bool, Session), Self::Error> {\n        let host_to_connect = host_to_connect.to_string();\n        let originator_address = originator_address.to_string();\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::ChannelOpenDirectTcpIp(\n            ServerChannelId(channel.id()),\n            DirectTCPIPParams {\n                host_to_connect,\n                port_to_connect,\n                originator_address,\n                originator_port,\n            },\n            tx,\n        ))?;\n        let allowed = rx.await.unwrap_or(false);\n        Ok((self, allowed, session))\n    }\n    async fn x11_request(\n        self,\n        channel: ChannelId,\n        single_conection: bool,\n        x11_auth_protocol: &str,\n        x11_auth_cookie: &str,\n        x11_screen_number: u32,\n        session: Session,\n    ) -> Result<(Self, Session), Self::Error> {\n        let x11_auth_protocol = x11_auth_protocol.to_string();\n        let x11_auth_cookie = x11_auth_cookie.to_string();\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::X11Request(\n            ServerChannelId(channel),\n            X11Request {\n                single_conection,\n                x11_auth_protocol,\n                x11_auth_cookie,\n                x11_screen_number,\n            },\n            tx,\n        ))?;\n        let _ = rx.await;\n        Ok((self, session))\n    }\n    async fn tcpip_forward(\n        self,\n        address: &str,\n        port: &mut u32,\n        mut session: Session,\n    ) -> Result<(Self, bool, Session), Self::Error> {\n        let address = address.to_string();\n        let port = *port;\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::TcpIpForward(address, port, tx))?;\n        let allowed = rx.await.unwrap_or(false);\n        if allowed {\n            session.request_success()\n        } else {\n            session.request_failure()\n        }\n        Ok((self, allowed, session))\n    }\n    async fn cancel_tcpip_forward(\n        self,\n        address: &str,\n        port: u32,\n        mut session: Session,\n    ) -> Result<(Self, bool, Session), Self::Error> {\n        let address = address.to_string();\n        let (tx, rx) = oneshot::channel();\n        self.send_event(ServerHandlerEvent::CancelTcpIpForward(address, port, tx))?;\n        let allowed = rx.await.unwrap_or(false);\n        if allowed {\n            session.request_success()\n        } else {\n            session.request_failure()\n        }\n        Ok((self, allowed, session))\n    }\n}\nimpl Drop for ServerHandler {\n    fn drop(&mut self) {\n        debug!(\"Dropped\");\n        let _ = self.event_tx.send(ServerHandlerEvent::Disconnect);\n    }\n}\nimpl Debug for ServerHandler {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"ServerHandler\")\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn config() -> &'static EvmConfig {\n\t\t\t&SHANGHAI_CONFIG\n\t\t}\nfn handle_sufficient_reference() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet addr = H160::from_str(\"1230000000000000000000000000000000000001\").unwrap();\n\t\tlet addr_2 = H160::from_str(\"1234000000000000000000000000000000000001\").unwrap();\n\t\tlet substrate_addr: <Test as frame_system::Config>::AccountId =\n\t\t\t<Test as Config>::AddressMapping::into_account_id(addr);\n\t\tlet substrate_addr_2: <Test as frame_system::Config>::AccountId =\n\t\t\t<Test as Config>::AddressMapping::into_account_id(addr_2);\n\t\t<crate::AccountCodes<Test>>::insert(addr, vec![0]);\n\t\tlet account = frame_system::Account::<Test>::get(substrate_addr);\n\t\tassert_eq!(account.sufficients, 0);\n\t\tEVM::create_account(addr_2, vec![1, 2, 3]);\n\t\tlet account_2 = frame_system::Account::<Test>::get(substrate_addr_2);\n\t\tassert_eq!(account_2.sufficients, 1);\n\t\tEVM::remove_account(&addr_2);\n\t\tlet account_2 = frame_system::Account::<Test>::get(substrate_addr_2);\n\t\tassert_eq!(account_2.sufficients, 0);\n\t});\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "async fn process_supergraph_response_stage<C>(\n    http_client: C,\n    coprocessor_url: String,\n    sdl: Arc<String>,\n    response: supergraph::Response,\n    response_config: SupergraphResponseConf,\n) -> Result<supergraph::Response, BoxError>\nwhere\n    C: Service<hyper::Request<Body>, Response = hyper::Response<Body>, Error = BoxError>\n        + Clone\n        + Send\n        + Sync\n        + 'static,\n    <C as tower::Service<http::Request<Body>>>::Future: Send + 'static,\n{\n    let (mut parts, body) = response.response.into_parts();\n    let (first, rest): (Option<response::Response>, graphql::ResponseStream) =\n        body.into_future().await;\n    let first = first.ok_or_else(|| {\n        BoxError::from(\"Coprocessor cannot convert body into future due to problem with first part\")\n    })?;\n    let headers_to_send = response_config\n        .headers\n        .then(|| externalize_header_map(&parts.headers))\n        .transpose()?;\n    let body_to_send = response_config\n        .body\n        .then(|| serde_json::to_value(&first).expect(\"serialization will not fail\"));\n    let status_to_send = response_config.status_code.then(|| parts.status.as_u16());\n    let context_to_send = response_config.context.then(|| response.context.clone());\n    let sdl_to_send = response_config.sdl.then(|| sdl.clone().to_string());\n    let payload = Externalizable::supergraph_builder()\n        .stage(PipelineStep::SupergraphResponse)\n        .and_id(TraceId::maybe_new().map(|id| id.to_string()))\n        .and_headers(headers_to_send)\n        .and_body(body_to_send)\n        .and_context(context_to_send)\n        .and_status_code(status_to_send)\n        .and_sdl(sdl_to_send.clone())\n        .build();\n    tracing::debug!(?payload, \"externalized output\");\n    let guard = response.context.enter_active_request();\n    let start = Instant::now();\n    let co_processor_result = payload.call(http_client.clone(), &coprocessor_url).await;\n    let duration = start.elapsed().as_secs_f64();\n    drop(guard);\n    tracing::info!(\n        histogram.apollo.router.operations.coprocessor.duration = duration,\n        coprocessor.stage = %PipelineStep::SupergraphResponse,\n    );\n    tracing::debug!(?co_processor_result, \"co-processor returned\");\n    let co_processor_output = co_processor_result?;\n    validate_coprocessor_output(&co_processor_output, PipelineStep::SupergraphResponse)?;\n    let new_body: crate::response::Response = match co_processor_output.body {\n        Some(value) => serde_json::from_value(value)?,\n        None => first,\n    };\n    if let Some(control) = co_processor_output.control {\n        parts.status = control.get_http_status()?\n    }\n    if let Some(context) = co_processor_output.context {\n        for (key, value) in context.try_into_iter()? {\n            response\n                .context\n                .upsert_json_value(key, move |_current| value);\n        }\n    }\n    if let Some(headers) = co_processor_output.headers {\n        parts.headers = internalize_header_map(headers)?;\n    }\n    let context = response.context.clone();\n    let map_context = response.context.clone();\n    let mapped_stream = rest\n        .then(move |deferred_response| {\n            let generator_client = http_client.clone();\n            let generator_coprocessor_url = coprocessor_url.clone();\n            let generator_map_context = map_context.clone();\n            let generator_sdl_to_send = sdl_to_send.clone();\n            async move {\n                let body_to_send = response_config.body.then(|| {\n                    serde_json::to_value(&deferred_response).expect(\"serialization will not fail\")\n                });\n                let context_to_send = response_config\n                    .context\n                    .then(|| generator_map_context.clone());\n                let payload = Externalizable::router_builder()\n                    .stage(PipelineStep::SupergraphResponse)\n                    .and_id(TraceId::maybe_new().map(|id| id.to_string()))\n                    .and_body(body_to_send)\n                    .and_context(context_to_send)\n                    .and_sdl(generator_sdl_to_send)\n                    .build();\n                tracing::debug!(?payload, \"externalized output\");\n                let guard = generator_map_context.enter_active_request();\n                let co_processor_result = payload\n                    .call(generator_client, &generator_coprocessor_url)\n                    .await;\n                drop(guard);\n                tracing::debug!(?co_processor_result, \"co-processor returned\");\n                let co_processor_output = co_processor_result?;\n                validate_coprocessor_output(\n                    &co_processor_output,\n                    PipelineStep::SupergraphResponse,\n                )?;\n                let new_deferred_response: crate::response::Response =\n                    match co_processor_output.body {\n                        Some(value) => serde_json::from_value(value)?,\n                        None => deferred_response,\n                    };\n                if let Some(context) = co_processor_output.context {\n                    for (key, value) in context.try_into_iter()? {\n                        generator_map_context.upsert_json_value(key, move |_current| value);\n                    }\n                }\n                Ok(new_deferred_response)\n            }\n        })\n        .map(|res: Result<response::Response, BoxError>| match res {\n            Ok(response) => response,\n            Err(e) => {\n                tracing::error!(\"coprocessor error handling deferred supergraph response: {e}\");\n                response::Response::builder()\n                    .error(\n                        Error::builder()\n                            .message(\"Internal error handling deferred response\")\n                            .extension_code(\"INTERNAL_ERROR\")\n                            .build(),\n                    )\n                    .build()\n            }\n        });\n    let stream = once(ready(new_body)).chain(mapped_stream).boxed();\n    Ok(supergraph::Response {\n        context,\n        response: http::Response::from_parts(parts, stream),\n    })\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn from_payload(payload: &[u8]) -> Result<Self, DecodeError> {\n        const MIN_LENGTH: usize = 32 + 4 + 4;\n        const MAX_LENGTH: usize = 32 + 4 + 64;\n        let payload_len = payload.len();\n        if !(MIN_LENGTH..=MAX_LENGTH).contains(&payload_len) {\n            return Err(DecodeError::Invalid);\n        }\n        let inner_payload_len = u32::from_be_bytes(\n            (&payload[32..32 + 4])\n                .try_into()\n                .map_err(|_| DecodeError::Invalid)?,\n        );\n        if (inner_payload_len + (4 - inner_payload_len % 4) % 4) as usize != payload_len - 32 - 4 {\n            return Err(DecodeError::Invalid);\n        }\n        let ed25519 = (&payload[0..32])\n            .try_into()\n            .map_err(|_| DecodeError::Invalid)?;\n        let inner_payload = &payload[32 + 4..32 + 4 + inner_payload_len as usize];\n        Ok(Self {\n            ed25519,\n            payload: inner_payload.to_vec(),\n        })\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn build_vyper(\n    source_code: &str,\n    version: semver::Version,\n    message_version: &str,\n) -> anyhow::Result<()> {\n    check_dependencies();\n    let vyper = VyperCompiler::new(VyperCompiler::DEFAULT_EXECUTABLE_NAME.to_owned());\n    if vyper.version.default != version {\n        panic!(\"{}\", message_version);\n    }\n    inkwell::support::enable_llvm_pretty_stack_trace();\n    compiler_llvm_context::initialize_target();\n    let _ = crate::process::EXECUTABLE.set(PathBuf::from(crate::r#const::DEFAULT_EXECUTABLE_NAME));\n    let optimizer_settings = compiler_llvm_context::OptimizerSettings::none();\n    let mut sources = BTreeMap::new();\n    sources.insert(\"test.vy\".to_string(), source_code.to_string());\n    let input = VyperStandardJsonInput::try_from_sources(\n        sources.clone(),\n        VyperStandardJsonInputSettingsEVMVersion::Paris,\n        VyperStandardJsonInputSettingsSelection::generate_default(),\n        true,\n    )?;\n    let output = vyper.standard_json(input)?;\n    let project = output.try_into_project(&vyper.version.default)?;\n    let _build = project.compile(\n        optimizer_settings,\n        false,\n        zkevm_assembly::RunningVmEncodingMode::Production,\n        None,\n    )?;\n    Ok(())\n}\npub fn compile(\n        self,\n        optimizer_settings: compiler_llvm_context::OptimizerSettings,\n        include_metadata_hash: bool,\n        bytecode_encoding: zkevm_assembly::RunningVmEncodingMode,\n        debug_config: Option<compiler_llvm_context::DebugConfig>,\n    ) -> anyhow::Result<Build> {\n        let mut build = Build::default();\n        let source_code_hash = if include_metadata_hash {\n            Some(self.source_code_hash)\n        } else {\n            None\n        };\n        let results: BTreeMap<String, anyhow::Result<ContractBuild>> = self\n            .contracts\n            .into_par_iter()\n            .map(|(full_path, contract)| {\n                let process_output = crate::process::call(ProcessInput::new(\n                    full_path.clone(),\n                    contract,\n                    source_code_hash,\n                    bytecode_encoding == zkevm_assembly::RunningVmEncodingMode::Testing,\n                    optimizer_settings.clone(),\n                    debug_config.clone(),\n                ));\n                (full_path, process_output.map(|output| output.build))\n            })\n            .collect();\n        let is_forwarder_used = results.iter().any(|(_path, result)| {\n            result\n                .as_ref()\n                .map(|contract| {\n                    contract\n                        .build\n                        .factory_dependencies\n                        .contains_key(crate::r#const::FORWARDER_CONTRACT_HASH.as_str())\n                })\n                .unwrap_or_default()\n        });\n        if is_forwarder_used {\n            let forwarder_build = compiler_llvm_context::Build::new(\n                crate::r#const::FORWARDER_CONTRACT_ASSEMBLY.to_owned(),\n                None,\n                crate::r#const::FORWARDER_CONTRACT_BYTECODE.clone(),\n                crate::r#const::FORWARDER_CONTRACT_HASH.clone(),\n            );\n            build.contracts.insert(\n                crate::r#const::FORWARDER_CONTRACT_NAME.to_owned(),\n                ContractBuild::new(forwarder_build),\n            );\n        }\n        for (path, result) in results.into_iter() {\n            match result {\n                Ok(contract) => {\n                    build.contracts.insert(path, contract);\n                }\n                Err(error) => {\n                    anyhow::bail!(\"Contract `{}` compiling error: {:?}\", path, error);\n                }\n            }\n        }\n        Ok(build)\n    }\nfn declare(&mut self, context: &mut compiler_llvm_context::Context<D>) -> anyhow::Result<()> {\n        let mut entry = compiler_llvm_context::EntryFunction::default();\n        entry.declare(context)?;\n        let mut runtime =\n            compiler_llvm_context::Runtime::new(compiler_llvm_context::AddressSpace::HeapAuxiliary);\n        runtime.declare(context)?;\n        compiler_llvm_context::DeployCodeFunction::new(\n            compiler_llvm_context::DummyLLVMWritable::default(),\n        )\n        .declare(context)?;\n        compiler_llvm_context::RuntimeCodeFunction::new(\n            compiler_llvm_context::DummyLLVMWritable::default(),\n        )\n        .declare(context)?;\n        for name in [\n            compiler_llvm_context::Runtime::FUNCTION_DEPLOY_CODE,\n            compiler_llvm_context::Runtime::FUNCTION_RUNTIME_CODE,\n            compiler_llvm_context::Runtime::FUNCTION_ENTRY,\n        ]\n        .into_iter()\n        {\n            context\n                .get_function(name)\n                .expect(\"Always exists\")\n                .borrow_mut()\n                .set_vyper_data(compiler_llvm_context::FunctionVyperData::default());\n        }\n        entry.into_llvm(context)?;\n        runtime.into_llvm(context)?;\n        Ok(())\n    }\nfn into_llvm(mut self, context: &mut compiler_llvm_context::Context<D>) -> anyhow::Result<()> {\n        let (mut runtime_code, immutables_size) =\n            self.expression.extract_runtime_code()?.unwrap_or_default();\n        let mut deploy_code = self.expression.try_into_deploy_code()?;\n        match immutables_size {\n            Expression::IntegerLiteral(number) => {\n                let immutables_size = number\n                    .as_u64()\n                    .ok_or_else(|| anyhow::anyhow!(\"Immutable size `{}` parsing error\", number))?;\n                let vyper_data =\n                    compiler_llvm_context::ContextVyperData::new(immutables_size as usize, false);\n                context.set_vyper_data(vyper_data);\n            }\n            expression => anyhow::bail!(\"Invalid immutables size format: {:?}\", expression),\n        }\n        let mut function_expressions = deploy_code\n            .extract_functions()?\n            .into_iter()\n            .map(|(label, expression)| (label, expression, compiler_llvm_context::CodeType::Deploy))\n            .collect::<Vec<(String, Expression, compiler_llvm_context::CodeType)>>();\n        function_expressions.extend(\n            runtime_code\n                .extract_functions()?\n                .into_iter()\n                .map(|(label, expression)| {\n                    (label, expression, compiler_llvm_context::CodeType::Runtime)\n                })\n                .collect::<Vec<(String, Expression, compiler_llvm_context::CodeType)>>(),\n        );\n        let mut functions = Vec::with_capacity(function_expressions.capacity());\n        for (label, expression, code_type) in function_expressions.into_iter() {\n            let mut metadata_label = label\n                .strip_suffix(format!(\"_{}\", compiler_llvm_context::CodeType::Deploy).as_str())\n                .unwrap_or(label.as_str());\n            metadata_label = label\n                .strip_suffix(format!(\"_{}\", compiler_llvm_context::CodeType::Runtime).as_str())\n                .unwrap_or(metadata_label);\n            metadata_label = label\n                .strip_suffix(format!(\"_{}\", crate::r#const::LABEL_SUFFIX_COMMON).as_str())\n                .unwrap_or(metadata_label);\n            let metadata_name =\n                self.source_metadata\n                    .function_info\n                    .iter()\n                    .find_map(|(name, function)| {\n                        if metadata_label == function.ir_identifier.as_str() {\n                            Some(name.to_owned())\n                        } else {\n                            None\n                        }\n                    });\n            let metadata = match metadata_name {\n                Some(metadata_name) => self\n                    .source_metadata\n                    .function_info\n                    .get(metadata_name.as_str())\n                    .cloned(),\n                None => None,\n            };\n            functions.push((Function::new(label, metadata, expression), code_type));\n        }\n        for (function, _code_type) in functions.iter_mut() {\n            function.declare(context)?;\n        }\n        for (function, code_type) in functions.into_iter() {\n            context.set_code_type(code_type);\n            function.into_llvm(context)?;\n        }\n        compiler_llvm_context::DeployCodeFunction::new(deploy_code).into_llvm(context)?;\n        compiler_llvm_context::RuntimeCodeFunction::new(runtime_code).into_llvm(context)?;\n        Ok(())\n    }\npub fn into_llvm_value<D>(\n        self,\n        context: &mut compiler_llvm_context::Context<D>,\n    ) -> anyhow::Result<()>\n    where\n        D: compiler_llvm_context::Dependency + Clone,\n    {\n        let [identifier, value] = self.0;\n        let identifier = identifier.try_into_identifier()?;\n        let pointer = context\n            .current_function()\n            .borrow()\n            .get_stack_pointer(identifier.as_str())\n            .ok_or_else(|| anyhow::anyhow!(\"Variable `{}` not found\", identifier))?;\n        let value = value\n            .into_llvm_value(context)?\n            .ok_or_else(|| anyhow::anyhow!(\"Expected a value\"))?;\n        context.build_store(pointer, value);\n        Ok(())\n    }\nfn main_inner() -> anyhow::Result<()> {\n    let mut arguments = Arguments::new();\n    arguments.validate()?;\n    rayon::ThreadPoolBuilder::new()\n        .stack_size(RAYON_WORKER_STACK_SIZE)\n        .build_global()\n        .expect(\"Thread pool configuration failure\");\n    inkwell::support::enable_llvm_pretty_stack_trace();\n    compiler_llvm_context::initialize_target();\n    if arguments.version {\n        println!(\n            \"{} v{} (LLVM build {})\",\n            env!(\"CARGO_PKG_DESCRIPTION\"),\n            env!(\"CARGO_PKG_VERSION\"),\n            inkwell::support::get_commit_id().to_string(),\n        );\n        return Ok(());\n    }\n    if arguments.recursive_process {\n        return compiler_vyper::run_process();\n    }\n    let debug_config = match arguments.debug_output_directory {\n        Some(debug_output_directory) => {\n            std::fs::create_dir_all(debug_output_directory.as_path())?;\n            Some(compiler_llvm_context::DebugConfig::new(\n                debug_output_directory,\n            ))\n        }\n        None => None,\n    };\n    for path in arguments.input_files.iter_mut() {\n        *path = path.canonicalize()?;\n    }\n    let vyper = compiler_vyper::VyperCompiler::new(\n        arguments\n            .vyper\n            .unwrap_or_else(|| compiler_vyper::VyperCompiler::DEFAULT_EXECUTABLE_NAME.to_owned()),\n    );\n    let mut optimizer_settings = match arguments.optimization {\n        Some(mode) => compiler_llvm_context::OptimizerSettings::try_from_cli(mode)?,\n        None => compiler_llvm_context::OptimizerSettings::cycles(),\n    };\n    optimizer_settings.is_verify_each_enabled = arguments.llvm_verify_each;\n    optimizer_settings.is_debug_logging_enabled = arguments.llvm_debug_logging;\n    let include_metadata_hash = match arguments.metadata_hash {\n        Some(metadata_hash) => {\n            let metadata = compiler_llvm_context::MetadataHash::from_str(metadata_hash.as_str())?;\n            metadata != compiler_llvm_context::MetadataHash::None\n        }\n        None => true,\n    };\n    let build = if arguments.llvm_ir {\n        compiler_vyper::llvm_ir(\n            arguments.input_files,\n            optimizer_settings,\n            include_metadata_hash,\n            debug_config,\n        )\n    } else if arguments.zkasm {\n        compiler_vyper::zkasm(arguments.input_files, include_metadata_hash, debug_config)\n    } else {\n        match arguments.format.as_deref() {\n            Some(\"combined_json\") => {\n                compiler_vyper::combined_json(\n                    arguments.input_files,\n                    &vyper,\n                    !arguments.disable_vyper_optimizer,\n                    optimizer_settings,\n                    include_metadata_hash,\n                    debug_config,\n                    arguments.output_directory,\n                    arguments.overwrite,\n                )?;\n                return Ok(());\n            }\n            Some(format) if format.split(',').any(|format| format == \"combined_json\") => {\n                anyhow::bail!(\"If using combined_json it must be the only output format requested\");\n            }\n            Some(_) | None => compiler_vyper::standard_output(\n                arguments.input_files,\n                &vyper,\n                !arguments.disable_vyper_optimizer,\n                optimizer_settings,\n                include_metadata_hash,\n                debug_config,\n            ),\n        }\n    }?;\n    match arguments.output_directory {\n        Some(output_directory) => {\n            std::fs::create_dir_all(output_directory.as_path())?;\n            build.write_to_directory(output_directory.as_path(), arguments.overwrite)?;\n        }\n        None => {\n            for (path, contract) in build.contracts.into_iter() {\n                eprintln!(\"Contract `{path}`:\");\n                let bytecode_string = hex::encode(contract.build.bytecode);\n                println!(\"0x{bytecode_string}\");\n                if let Some(format) = arguments.format.as_deref() {\n                    let extra_output = vyper.extra_output(PathBuf::from(path).as_path(), format)?;\n                    println!();\n                    println!(\"{extra_output}\");\n                }\n            }\n        }\n    }\n    Ok(())\n}\npub fn new(build: compiler_llvm_context::Build) -> Self {\n        Self { build }\n    }\npub fn try_from_llvm_ir_path(path: &Path) -> anyhow::Result<Self> {\n        let source_code = std::fs::read_to_string(path)\n            .map_err(|error| anyhow::anyhow!(\"LLVM IR file {:?} reading error: {}\", path, error))?;\n        let path = path.to_string_lossy().to_string();\n        let source_code_hash = sha3::Keccak256::digest(source_code.as_bytes()).into();\n        let mut project_contracts = BTreeMap::new();\n        project_contracts.insert(\n            path,\n            LLVMIRContract::new(compiler_llvm_context::LLVM_VERSION, source_code).into(),\n        );\n        Ok(Self::new(\n            compiler_llvm_context::LLVM_VERSION,\n            source_code_hash,\n            project_contracts,\n        ))\n    }\npub fn try_from_zkasm_path(path: &Path) -> anyhow::Result<Self> {\n        let source_code = std::fs::read_to_string(path).map_err(|error| {\n            anyhow::anyhow!(\"zkEVM assembly file {:?} reading error: {}\", path, error)\n        })?;\n        let path = path.to_string_lossy().to_string();\n        let source_code_hash = sha3::Keccak256::digest(source_code.as_bytes()).into();\n        let mut project_contracts = BTreeMap::new();\n        project_contracts.insert(\n            path,\n            ZKASMContract::new(compiler_llvm_context::ZKEVM_VERSION, source_code).into(),\n        );\n        Ok(Self::new(\n            compiler_llvm_context::ZKEVM_VERSION,\n            source_code_hash,\n            project_contracts,\n        ))\n    }\npub fn write_to_directory(\n        self,\n        output_directory: &Path,\n        contract_path: &Path,\n        overwrite: bool,\n    ) -> anyhow::Result<()> {\n        let contract_name = Self::short_path(contract_path.to_str().expect(\"Always valid\"));\n        let assembly_file_name = format!(\n            \"{}.{}\",\n            contract_name,\n            compiler_common::EXTENSION_ZKEVM_ASSEMBLY\n        );\n        let mut assembly_file_path = output_directory.to_owned();\n        assembly_file_path.push(assembly_file_name);\n        if assembly_file_path.exists() && !overwrite {\n            eprintln!(\n                \"Refusing to overwrite an existing file {assembly_file_path:?} (use --overwrite to force).\",\n            );\n        } else {\n            File::create(&assembly_file_path)\n                .map_err(|error| {\n                    anyhow::anyhow!(\"File {:?} creating error: {}\", assembly_file_path, error)\n                })?\n                .write_all(self.build.assembly_text.as_bytes())\n                .map_err(|error| {\n                    anyhow::anyhow!(\"File {:?} writing error: {}\", assembly_file_path, error)\n                })?;\n        }\n        let binary_file_name = format!(\n            \"{}.{}\",\n            contract_name,\n            compiler_common::EXTENSION_ZKEVM_BINARY\n        );\n        let mut binary_file_path = output_directory.to_owned();\n        binary_file_path.push(binary_file_name);\n        if binary_file_path.exists() && !overwrite {\n            eprintln!(\n                \"Refusing to overwrite an existing file {binary_file_path:?} (use --overwrite to force).\",\n            );\n        } else {\n            File::create(&binary_file_path)\n                .map_err(|error| {\n                    anyhow::anyhow!(\"File {:?} creating error: {}\", binary_file_path, error)\n                })?\n                .write_all(self.build.bytecode.as_slice())\n                .map_err(|error| {\n                    anyhow::anyhow!(\"File {:?} writing error: {}\", binary_file_path, error)\n                })?;\n        }\n        Ok(())\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "async fn api_auth_login(\n        &self,\n        req: &Request,\n        session: &Session,\n        services: Data<&Services>,\n        body: Json<LoginRequest>,\n    ) -> poem::Result<LoginResponse> {\n        let mut auth_state_store = services.auth_state_store.lock().await;\n        let state_arc = match get_auth_state_for_request(\n            &body.username,\n            session,\n            &mut auth_state_store,\n        )\n        .await\n        {\n            Err(WarpgateError::UserNotFound) => {\n                return Ok(LoginResponse::Failure(Json(LoginFailureResponse {\n                    state: ApiAuthState::Failed,\n                })))\n            }\n            x => x,\n        }?;\n        let mut state = state_arc.lock().await;\n        let mut cp = services.config_provider.lock().await;\n        let password_cred = AuthCredential::Password(Secret::new(body.password.clone()));\n        if cp\n            .validate_credential(&body.username, &password_cred)\n            .await?\n        {\n            state.add_valid_credential(password_cred);\n        }\n        match state.verify() {\n            AuthResult::Accepted { username } => {\n                auth_state_store.complete(state.id()).await;\n                authorize_session(req, username).await?;\n                Ok(LoginResponse::Success)\n            }\n            x => {\n                error!(\"Auth rejected\");\n                Ok(LoginResponse::Failure(Json(LoginFailureResponse {\n                    state: x.into(),\n                })))\n            }\n        }\n    }\npub async fn get_auth_state_for_request(\n    username: &str,\n    session: &Session,\n    store: &mut AuthStateStore,\n) -> Result<Arc<Mutex<AuthState>>, WarpgateError> {\n    if let Some(id) = session.get_auth_state_id() {\n        if !store.contains_key(&id.0) {\n            session.remove(AUTH_STATE_ID_SESSION_KEY)\n        }\n    }\n    match session.get_auth_state_id() {\n        Some(id) => Ok(store.get(&id.0).ok_or(WarpgateError::InconsistentState)?),\n        None => {\n            let (id, state) = store\n                .create(None, username, crate::common::PROTOCOL_NAME)\n                .await?;\n            session.set(AUTH_STATE_ID_SESSION_KEY, AuthStateId(id));\n            Ok(state)\n        }\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "Cargo.toml\n[package]\nname = \"vmm-sys-util\"\nversion = \"0.11.2\"\nauthors = [\"Intel Virtualization Team <vmm-maintainers@intel.com>\"]\ndescription = \"A system utility set\"\nrepository = \"https://github.com/rust-vmm/vmm-sys-util\"\n[dev-dependencies]\nserde_json = \"1.0.9\"\nfn set_len(&mut self, len: usize);\npub fn new(num_elements: usize) -> Result<FamStructWrapper<T>, Error> {\n        if num_elements > T::max_len() {\n            return Err(Error::SizeLimitExceeded);\n        }\n        let required_mem_allocator_capacity =\n            FamStructWrapper::<T>::mem_allocator_len(num_elements)\n                .ok_or(Error::SizeLimitExceeded)?;\n        let mut mem_allocator = Vec::with_capacity(required_mem_allocator_capacity);\n        mem_allocator.push(T::default());\n        for _ in 1..required_mem_allocator_capacity {\n            mem_allocator.push(unsafe { mem::zeroed() })\n        }\n        mem_allocator[0].set_len(num_elements);\n        Ok(FamStructWrapper { mem_allocator })\n    }\npub fn as_mut_fam_struct(&mut self) -> &mut T {\n    }\nfn set_len(&mut self, len: usize) -> Result<(), Error> {\n        let additional_elements = isize::try_from(len)\n            .and_then(|len| isize::try_from(self.len()).map(|self_len| len - self_len))\n            .map_err(|_| Error::SizeLimitExceeded)?;\n        if additional_elements == 0 {\n            return Ok(());\n        }\n        if additional_elements > 0 {\n            if len > T::max_len() {\n                return Err(Error::SizeLimitExceeded);\n            }\n            self.reserve(additional_elements as usize)?;\n        }\n        let current_mem_allocator_len = self.mem_allocator.len();\n        let required_mem_allocator_len =\n            FamStructWrapper::<T>::mem_allocator_len(len).ok_or(Error::SizeLimitExceeded)?;\n        unsafe {\n            self.mem_allocator.set_len(required_mem_allocator_len);\n        }\n        for i in current_mem_allocator_len..required_mem_allocator_len {\n            self.mem_allocator[i] = unsafe { mem::zeroed() }\n        }\n        self.as_mut_fam_struct().set_len(len);\n        if additional_elements < 0 {\n            self.mem_allocator.shrink_to_fit();\n        }\n        Ok(())\n    }\nfn visit_seq<V>(self, mut seq: V) -> Result<FamStructWrapper<X>, V::Error>\n            where\n                V: SeqAccess<'de>,\n            {\n                use serde::de::Error;\n                let header = seq\n                let mut result: Self::Value = FamStructWrapper::from_entries(entries.as_slice())\n                    .map_err(|e| V::Error::custom(format!(\"{:?}\", e)))?;\n                result.mem_allocator[0] = header;\n                Ok(result)\n            }\nfn set_len(&mut self, len: usize) {\n                self.$field_name = len as $field_type;\n            }\n #[derive(Default, PartialEq, Eq)]\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn deserialize_empty<'a, V>(&'a mut self, _visitor: V) -> Result<V::Value>\n    where\n        V: Visitor<'de>,\n    {\n        Err(Error::subtype(\"Cannot decode empty type\"))\n    }\nfn visit_byte_buf<E: de::Error>(self, value: Vec<u8>) -> DResult<E> {\n        let (tag, mut bytes) = value.split_at(1);\n        match tag[0] {\n            0u8 => {\n                let v = Int(num_bigint::BigInt::from_signed_bytes_le(bytes));\n                Ok(IDLValue::Int(v))\n            }\n            1u8 => {\n                let v = Nat(num_bigint::BigUint::from_bytes_le(bytes));\n                Ok(IDLValue::Nat(v))\n            }\n            2u8 => {\n                let v = crate::Principal::try_from(bytes).map_err(E::custom)?;\n                Ok(IDLValue::Principal(v))\n            }\n            4u8 => {\n                let v = crate::Principal::try_from(bytes).map_err(E::custom)?;\n                Ok(IDLValue::Service(v))\n            }\n            5u8 => {\n                use std::io::Read;\n                let len = leb128::read::unsigned(&mut bytes).map_err(E::custom)? as usize;\n                let mut buf = Vec::new();\n                buf.resize(len, 0);\n                bytes.read_exact(&mut buf).map_err(E::custom)?;\n                let meth = String::from_utf8(buf).map_err(E::custom)?;\n                let id = crate::Principal::try_from(bytes).map_err(E::custom)?;\n                Ok(IDLValue::Func(id, meth))\n            }\n            3u8 => Ok(IDLValue::Reserved),\n            _ => Err(de::Error::custom(\"unknown tag in visit_byte_buf\")),\n        }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub async fn get_full_snapshot_path(\n    toc: &TableOfContent,\n    snapshot_name: &str,\n) -> Result<PathBuf, StorageError> {\n    let snapshot_path = Path::new(toc.snapshots_path()).join(snapshot_name);\n    if !snapshot_path.exists() {\n        return Err(StorageError::NotFound {\n            description: format!(\"Full storage snapshot {snapshot_name} not found\"),\n        });\n    }\n    Ok(snapshot_path)\n}\npub async fn get_snapshot_path(&self, snapshot_name: &str) -> CollectionResult<PathBuf> {\n        let snapshot_path = self.snapshots_path.join(snapshot_name);\n        let absolute_snapshot_path =\n            snapshot_path\n                .canonicalize()\n                .map_err(|_| CollectionError::NotFound {\n                    what: format!(\"Snapshot {snapshot_name}\"),\n                })?;\n        let absolute_snapshot_dir =\n            self.snapshots_path\n                .canonicalize()\n                .map_err(|_| CollectionError::NotFound {\n                    what: format!(\"Snapshot directory: {}\", self.snapshots_path.display()),\n                })?;\n        if !absolute_snapshot_path.starts_with(absolute_snapshot_dir) {\n            return Err(CollectionError::NotFound {\n                what: format!(\"Snapshot {snapshot_name}\"),\n            });\n        }\n        if !snapshot_path.exists() {\n            return Err(CollectionError::NotFound {\n                what: format!(\"Snapshot {snapshot_name}\"),\n            });\n        }\n        Ok(snapshot_path)\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub unsafe extern \"C\" fn new_css_image_extractor(\n    file_bytes: *const c_char,\n) -> sys::css_image_extractor_t {\n    let css_input = if file_bytes.is_null() {\n        warn!(\"{} is NULL\", stringify!(file_bytes));\n        return 0 as sys::css_image_extractor_t;\n    } else {\n        #[allow(unused_unsafe)]\n        unsafe { CStr::from_ptr(file_bytes) }.to_string_lossy()\n    };\n    if let Ok(extractor) = CssImageExtractor::new(&css_input) {\n        Box::into_raw(Box::new(extractor)) as sys::css_image_extractor_t\n    } else {\n        0 as sys::css_image_extractor_t\n    }\n}\npub extern \"C\" fn free_css_image_extractor(extractor: sys::css_image_extractor_t) {\n    if extractor.is_null() {\n        warn!(\"Attempted to free an image extractor pointer. Please report this at: https://github.com/Cisco-Talos/clamav/issues\");\n    } else {\n        let _ = unsafe { Box::from_raw(extractor as *mut CssImageExtractor) };\n    }\n}\npub unsafe extern \"C\" fn css_image_extract_next(\n    extractor: sys::css_image_extractor_t,\n    image_out: *mut *const u8,\n    image_out_len: *mut usize,\n    image_out_handle: *mut sys::css_image_handle_t,\n) -> bool {\n    let mut extractor = ManuallyDrop::new(Box::from_raw(extractor as *mut CssImageExtractor));\n    let image_result = extractor.next();\n    match image_result {\n        Some(image) => {\n            *image_out = image.as_ptr();\n            *image_out_len = image.len();\n            *image_out_handle = Box::into_raw(Box::new(image)) as sys::css_image_handle_t;\n            true\n        }\n        None => false,\n    }\n}\npub extern \"C\" fn free_extracted_image(image: sys::css_image_handle_t) {\n    if image.is_null() {\n        warn!(\"Attempted to free an image pointer. Please report this at: https://github.com/Cisco-Talos/clamav/issues\");\n    } else {\n        let _ = unsafe { Box::from_raw(image as *mut Vec<u8>) };\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn verify(&self, payload: &[u8], headers: &HeaderMap) -> Result<(), WebhookError> {\n        let msg_id = Self::get_header(headers, SVIX_MSG_ID_KEY, UNBRANDED_MSG_ID_KEY, \"id\")?;\n        let msg_signature = Self::get_header(\n            headers,\n            SVIX_MSG_SIGNATURE_KEY,\n            UNBRANDED_MSG_SIGNATURE_KEY,\n            \"signature\",\n        )?;\n        let msg_ts = Self::get_header(\n            headers,\n            SVIX_MSG_TIMESTAMP_KEY,\n            UNBRANDED_MSG_TIMESTAMP_KEY,\n            \"timestamp\",\n        )\n        .and_then(Self::parse_timestamp)?;\n        Self::verify_timestamp(msg_ts)?;\n        let versioned_signature = self.sign(msg_id, msg_ts, payload)?;\n        let expected_signature = versioned_signature\n            .split_once(',')\n            .map(|x| x.1)\n            .ok_or(WebhookError::InvalidSignature)?;\n        msg_signature\n            .split(' ')\n            .filter_map(|x| x.split_once(','))\n            .filter(|x| x.0 == SIGNATURE_VERSION)\n            .any(|x| {\n                x.1.bytes()\n                    .zip(expected_signature.bytes())\n                    .fold(0, |acc, (a, b)| acc | (a ^ b))\n                    == 0\n            })\n            .then_some(())\n            .ok_or(WebhookError::InvalidSignature)\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn cleanup_for_create(\n\t\t&mut self,\n\t\tcreated_address: H160,\n\t\treason: ExitReason,\n\t\treturn_data: Vec<u8>,\n\t) -> (ExitReason, Option<H160>, Vec<u8>) {\n\t\tfn check_first_byte(config: &Config, code: &[u8]) -> Result<(), ExitError> {\n\t\t\tif config.disallow_executable_format && Some(&Opcode::EOFMAGIC.as_u8()) == code.first()\n\t\t\t{\n\t\t\t\treturn Err(ExitError::InvalidCode(Opcode::EOFMAGIC));\n\t\t\t}\n\t\t\tOk(())\n\t\t}\n\t\tlog::debug!(target: \"evm\", \"Create execution using address {}: {:?}\", created_address, reason);\n\t\tmatch reason {\n\t\t\tExitReason::Succeed(s) => {\n\t\t\t\tlet out = return_data;\n\t\t\t\tlet address = created_address;\n\t\t\t\tif let Err(e) = check_first_byte(self.config, &out) {\n\t\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t\treturn (e.into(), None, Vec::new());\n\t\t\t\t}\n\t\t\t\tif let Some(limit) = self.config.create_contract_limit {\n\t\t\t\t\tif out.len() > limit {\n\t\t\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t\t\treturn (ExitError::CreateContractLimit.into(), None, Vec::new());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmatch self\n\t\t\t\t\t.state\n\t\t\t\t\t.metadata_mut()\n\t\t\t\t\t.gasometer\n\t\t\t\t\t.record_deposit(out.len())\n\t\t\t\t{\n\t\t\t\t\tOk(()) => {\n\t\t\t\t\t\tlet exit_result = self.exit_substate(StackExitKind::Succeeded);\n\t\t\t\t\t\tif let Err(e) = self.record_external_operation(\n\t\t\t\t\t\t\tcrate::ExternalOperation::Write(U256::from(out.len())),\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\treturn (e.into(), None, Vec::new());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tself.state.set_code(address, out);\n\t\t\t\t\t\tif let Err(e) = exit_result {\n\t\t\t\t\t\t\treturn (e.into(), None, Vec::new());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t(ExitReason::Succeed(s), Some(address), Vec::new())\n\t\t\t\t\t}\n\t\t\t\t\tErr(e) => {\n\t\t\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t\t\t(ExitReason::Error(e), None, Vec::new())\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tExitReason::Error(e) => {\n\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t(ExitReason::Error(e), None, Vec::new())\n\t\t\t}\n\t\t\tExitReason::Revert(e) => {\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Reverted);\n\t\t\t\t(ExitReason::Revert(e), None, return_data)\n\t\t\t}\n\t\t\tExitReason::Fatal(e) => {\n\t\t\t\tself.state.metadata_mut().gasometer.fail();\n\t\t\t\tlet _ = self.exit_substate(StackExitKind::Failed);\n\t\t\t\t(ExitReason::Fatal(e), None, Vec::new())\n\t\t\t}\n\t\t}\n\t}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub(crate) fn is_valid(&self) -> bool {\n        self.0\n            .chars()\n            .all(|c| matches!(c, 'a'..='z'|'A'..='Z'|'0'..='9'|'-'|'_'))\n        // token per https://www.rfc-editor.org/rfc/rfc9110#section-5.1\n        // tchar per https://www.rfc-editor.org/rfc/rfc9110#section-5.6.2\n        !self.is_empty() && self.0.chars().all(is_tchar)\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub async fn create_pm_report(\n  data: Json<CreatePrivateMessageReport>,\n  context: Data<LemmyContext>,\n  local_user_view: LocalUserView,\n) -> Result<Json<PrivateMessageReportResponse>, LemmyError> {\n  let local_site = LocalSite::read(&mut context.pool()).await?;\n  let reason = data.reason.trim().to_string();\n  check_report_reason(&reason, &local_site)?;\n  let person_id = local_user_view.person.id;\n  let private_message_id = data.private_message_id;\n  let private_message = PrivateMessage::read(&mut context.pool(), private_message_id).await?;\n  let report_form = PrivateMessageReportForm {\n    creator_id: person_id,\n    private_message_id,\n    original_pm_text: private_message.content,\n    reason,\n  };\n  let report = PrivateMessageReport::report(&mut context.pool(), &report_form)\n    .await\n    .with_lemmy_type(LemmyErrorType::CouldntCreateReport)?;\n  let private_message_report_view =\n    PrivateMessageReportView::read(&mut context.pool(), report.id).await?;\n  if local_site.reports_email_admins {\n    send_new_report_email_to_admins(\n      &private_message_report_view.creator.name,\n      &private_message_report_view.private_message_creator.name,\n      &mut context.pool(),\n      context.settings(),\n    )\n    .await?;\n  }\n  Ok(Json(PrivateMessageReportResponse {\n    private_message_report_view,\n  }))\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn pgsql_parse_response(i: &[u8]) -> IResult<&[u8], PgsqlBEMessage> {\n    let (i, pseudo_header) = peek(tuple((be_u8, be_u32)))(i)?;\n    let (i, message) =\n            match pseudo_header.0 {\n                b'E' => pgsql_parse_error_response(i)?,\n                b'K' => parse_backend_key_data_message(i)?,\n                b'N' => pgsql_parse_notice_response(i)?,\n                b'R' => pgsql_parse_authentication_message(i)?,\n                b'S' => parse_parameter_status_message(i)?,\n                b'C' => parse_command_complete(i)?,\n                b'Z' => parse_ready_for_query(i)?,\n                b'T' => parse_row_description(i)?,\n                b'A' => parse_notification_response(i)?,\n                b'D' => parse_consolidated_data_row(i)?,\n                _ => {\n                    let (i, payload) = rest(i)?;\n                    let unknown = PgsqlBEMessage::UnknownMessageType (RegularPacket{\n                        identifier: pseudo_header.0,\n                        length: pseudo_header.1,\n                        payload: payload.to_vec(),\n                    });\n                    (i, unknown)\n                }\n            };\n    Ok((i, message))\n}\nfn test_parse_sasl_final_authentication_message() {\n        let buf: &[u8] = &[\n            /* R */ 0x52, /* 54 */ 0x00, 0x00, 0x00, 0x36, /* 12 */ 0x00, 0x00,\n            0x00, 0x0c, /* signature */ 0x76, 0x3d, 0x64, 0x31, 0x50, 0x58, 0x61, 0x38, 0x54,\n            0x4b, 0x46, 0x50, 0x5a, 0x72, 0x52, 0x33, 0x4d, 0x42, 0x52, 0x6a, 0x4c, 0x79, 0x33,\n            0x2b, 0x4a, 0x36, 0x79, 0x78, 0x72, 0x66, 0x77, 0x2f, 0x7a, 0x7a, 0x70, 0x38, 0x59,\n            0x54, 0x39, 0x65, 0x78, 0x56, 0x37, 0x73, 0x38, 0x3d,\n        ];\n        let ok_res = PgsqlBEMessage::AuthenticationSASLFinal(AuthenticationMessage {\n            identifier: b'R',\n            length: 54,\n            auth_type: 12,\n            payload: br#\"v=d1PXa8TKFPZrR3MBRjLy3+J6yxrfw/zzp8YT9exV7s8=\"#.to_vec(),\n        });\n        let result = pgsql_parse_response(buf);\n        match result {\n            Ok((remainder, message)) => {\n                assert_eq!(message, ok_res);\n                assert_eq!(remainder.len(), 0);\n            }\n            Err(Err::Error(err)) => {\n                panic!(\"Shouldn't be error {:?}, expected Ok(_)\", err.code);\n            }\n            Err(Err::Incomplete(needed)) => {\n                panic!(\"Shouldn't be incomplete {:?}, expected OK(_)\", needed);\n            }\n            _ => panic!(\"Unexpected behavior, expected Ok(_)\"),\n        }\n        let result_incomplete = pgsql_parse_response(&buf[0..34]);\n        match result_incomplete {\n            Err(Err::Incomplete(needed)) => {\n                assert_eq!(needed, Needed::new(21));\n            }\n            _ => panic!(\"Unexpected behavior, expected incomplete.\"),\n        }\n        let bad_buf: &[u8] = &[\n            /* ` */ 0x60, /* 54 */ 0x00, 0x00, 0x00, 0x36, /* 12 */ 0x00, 0x00,\n            0x00, 0x0c, /* signature */ 0x76, 0x3d, 0x64, 0x31, 0x50, 0x58, 0x61, 0x38, 0x54,\n            0x4b, 0x46, 0x50, 0x5a, 0x72, 0x52, 0x33, 0x4d, 0x42, 0x52, 0x6a, 0x4c, 0x79, 0x33,\n            0x2b, 0x4a, 0x36, 0x79, 0x78, 0x72, 0x66, 0x77, 0x2f, 0x7a, 0x7a, 0x70, 0x38, 0x59,\n            0x54, 0x39, 0x65, 0x78, 0x56, 0x37, 0x73, 0x38, 0x3d,\n        ];\n        let (remainder, result) = pgsql_parse_response(bad_buf).expect(\"parsing sasl final response failed\");\n        let res = PgsqlBEMessage::UnknownMessageType(RegularPacket {\n            identifier: b'`',\n            length: 54,\n            payload: bad_buf.to_vec(),\n        });\n        assert_eq!(result, res);\n        assert!(remainder.is_empty());\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "use std::ffi::OsStr;\nuse std::io::{self, Read, Write};\nuse std::os::windows::io::{AsRawHandle, FromRawHandle, RawHandle};\nuse std::sync::atomic::Ordering::{Relaxed, SeqCst};\nuse std::sync::atomic::{AtomicBool, AtomicUsize};\nuse std::sync::{Arc, Mutex};\nuse std::{fmt, mem, slice};\nuse windows_sys::Win32::Foundation::{\n    ERROR_BROKEN_PIPE, ERROR_IO_INCOMPLETE, ERROR_IO_PENDING, ERROR_NO_DATA, ERROR_PIPE_CONNECTED,\n    ERROR_PIPE_LISTENING, HANDLE, INVALID_HANDLE_VALUE,\n};\nuse windows_sys::Win32::Storage::FileSystem::{\n    ReadFile, WriteFile, FILE_FLAG_FIRST_PIPE_INSTANCE, FILE_FLAG_OVERLAPPED, PIPE_ACCESS_DUPLEX,\n};\nuse windows_sys::Win32::System::Pipes::{\n    ConnectNamedPipe, CreateNamedPipeW, DisconnectNamedPipe, PIPE_TYPE_BYTE,\n    PIPE_UNLIMITED_INSTANCES,\n};\nuse windows_sys::Win32::System::IO::{\n    CancelIoEx, GetOverlappedResult, OVERLAPPED, OVERLAPPED_ENTRY,\n};\nuse crate::event::Source;\nuse crate::sys::windows::iocp::{CompletionPort, CompletionStatus};\nuse crate::sys::windows::{Event, Handle, Overlapped};\nuse crate::Registry;\nuse crate::{Interest, Token};\npub struct NamedPipe {\n    inner: Arc<Inner>,\n}\n#[repr(C)]\nstruct Inner {\n    connect: Overlapped,\n    read: Overlapped,\n    write: Overlapped,\n    handle: Handle,\n    connecting: AtomicBool,\n    io: Mutex<Io>,\n    pool: Mutex<BufferPool>,\n}\nimpl Inner {\n    unsafe fn ptr_from_conn_overlapped(ptr: *mut OVERLAPPED) -> *const Inner {\n        ptr.cast()\n    }\n    unsafe fn ptr_from_read_overlapped(ptr: *mut OVERLAPPED) -> *const Inner {\n        (ptr as *mut Overlapped).wrapping_sub(1) as *const Inner\n    }\n    unsafe fn ptr_from_write_overlapped(ptr: *mut OVERLAPPED) -> *const Inner {\n        (ptr as *mut Overlapped).wrapping_sub(2) as *const Inner\n    }\n    pub unsafe fn connect_overlapped(&self, overlapped: *mut OVERLAPPED) -> io::Result<bool> {\n        if ConnectNamedPipe(self.handle.raw(), overlapped) != 0 {\n            return Ok(true);\n        }\n        let err = io::Error::last_os_error();\n        match err.raw_os_error().map(|e| e as u32) {\n            Some(ERROR_PIPE_CONNECTED) => Ok(true),\n            Some(ERROR_NO_DATA) => Ok(true),\n            Some(ERROR_IO_PENDING) => Ok(false),\n            _ => Err(err),\n        }\n    }\n    pub fn disconnect(&self) -> io::Result<()> {\n        if unsafe { DisconnectNamedPipe(self.handle.raw()) } == 0 {\n            Err(io::Error::last_os_error())\n        } else {\n            Ok(())\n        }\n    }\n    pub unsafe fn read_overlapped(\n        &self,\n        buf: &mut [u8],\n        overlapped: *mut OVERLAPPED,\n    ) -> io::Result<Option<usize>> {\n        let len = std::cmp::min(buf.len(), u32::MAX as usize) as u32;\n        let res = ReadFile(\n            self.handle.raw(),\n            buf.as_mut_ptr() as *mut _,\n            len,\n            std::ptr::null_mut(),\n            overlapped,\n        );\n        if res == 0 {\n            let err = io::Error::last_os_error();\n            if err.raw_os_error() != Some(ERROR_IO_PENDING as i32) {\n                return Err(err);\n            }\n        }\n        let mut bytes = 0;\n        let res = GetOverlappedResult(self.handle.raw(), overlapped, &mut bytes, 0);\n        if res == 0 {\n            let err = io::Error::last_os_error();\n            if err.raw_os_error() == Some(ERROR_IO_INCOMPLETE as i32) {\n                Ok(None)\n            } else {\n                Err(err)\n            }\n        } else {\n            Ok(Some(bytes as usize))\n        }\n    }\n    pub unsafe fn write_overlapped(\n        &self,\n        buf: &[u8],\n        overlapped: *mut OVERLAPPED,\n    ) -> io::Result<Option<usize>> {\n        let len = std::cmp::min(buf.len(), u32::MAX as usize) as u32;\n        let res = WriteFile(\n            self.handle.raw(),\n            buf.as_ptr() as *const _,\n            len,\n            std::ptr::null_mut(),\n            overlapped,\n        );\n        if res == 0 {\n            let err = io::Error::last_os_error();\n            if err.raw_os_error() != Some(ERROR_IO_PENDING as i32) {\n                return Err(err);\n            }\n        }\n        let mut bytes = 0;\n        let res = GetOverlappedResult(self.handle.raw(), overlapped, &mut bytes, 0);\n        if res == 0 {\n            let err = io::Error::last_os_error();\n            if err.raw_os_error() == Some(ERROR_IO_INCOMPLETE as i32) {\n                Ok(None)\n            } else {\n                Err(err)\n            }\n        } else {\n            Ok(Some(bytes as usize))\n        }\n    }\n    #[inline]\n    unsafe fn result(&self, overlapped: *mut OVERLAPPED) -> io::Result<usize> {\n        let mut transferred = 0;\n        let r = GetOverlappedResult(self.handle.raw(), overlapped, &mut transferred, 0);\n        if r == 0 {\n            Err(io::Error::last_os_error())\n        } else {\n            Ok(transferred as usize)\n        }\n    }\n}\n#[test]\nfn ptr_from() {\n    use std::mem::ManuallyDrop;\n    use std::ptr;\n    let pipe = unsafe { ManuallyDrop::new(NamedPipe::from_raw_handle(ptr::null_mut())) };\n    let inner: &Inner = &pipe.inner;\n    assert_eq!(\n        inner as *const Inner,\n        unsafe { Inner::ptr_from_conn_overlapped(&inner.connect as *const _ as *mut OVERLAPPED) },\n        \"`ptr_from_conn_overlapped` incorrect\"\n    );\n    assert_eq!(\n        inner as *const Inner,\n        unsafe { Inner::ptr_from_read_overlapped(&inner.read as *const _ as *mut OVERLAPPED) },\n        \"`ptr_from_read_overlapped` incorrect\"\n    );\n    assert_eq!(\n        inner as *const Inner,\n        unsafe { Inner::ptr_from_write_overlapped(&inner.write as *const _ as *mut OVERLAPPED) },\n        \"`ptr_from_write_overlapped` incorrect\"\n    );\n}\nstruct Io {\n    cp: Option<Arc<CompletionPort>>,\n    token: Option<Token>,\n    read: State,\n    write: State,\n    connect_error: Option<io::Error>,\n}\n#[derive(Debug)]\nenum State {\n    None,\n    Pending(Vec<u8>, usize),\n    Ok(Vec<u8>, usize),\n    Err(io::Error),\n}\nstatic NEXT_TOKEN: AtomicUsize = AtomicUsize::new(1);\nfn would_block() -> io::Error {\n    io::ErrorKind::WouldBlock.into()\n}\nimpl NamedPipe {\n    pub fn new<A: AsRef<OsStr>>(addr: A) -> io::Result<NamedPipe> {\n        use std::os::windows::ffi::OsStrExt;\n        let name: Vec<_> = addr.as_ref().encode_wide().chain(Some(0)).collect();\n        let h = unsafe {\n            CreateNamedPipeW(\n                name.as_ptr(),\n                PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE | FILE_FLAG_OVERLAPPED,\n                PIPE_TYPE_BYTE,\n                PIPE_UNLIMITED_INSTANCES,\n                65536,\n                65536,\n                0,\n                std::ptr::null_mut(),\n            )\n        };\n        if h == INVALID_HANDLE_VALUE {\n            Err(io::Error::last_os_error())\n        } else {\n            Ok(unsafe { Self::from_raw_handle(h as RawHandle) })\n        }\n    }\n    pub fn connect(&self) -> io::Result<()> {\n        if self.inner.connecting.swap(true, SeqCst) {\n            return Err(would_block());\n        }\n        let res = unsafe {\n            let overlapped = self.inner.connect.as_ptr() as *mut _;\n            self.inner.connect_overlapped(overlapped)\n        };\n        match res {\n            Ok(true) => {\n                self.inner.connecting.store(false, SeqCst);\n                Inner::post_register(&self.inner, None);\n                Ok(())\n            }\n            Ok(false) => {\n                mem::forget(self.inner.clone());\n                Err(would_block())\n            }\n            Err(e) => {\n                self.inner.connecting.store(false, SeqCst);\n                Err(e)\n            }\n        }\n    }\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        Ok(self.inner.io.lock().unwrap().connect_error.take())\n    }\n    pub fn disconnect(&self) -> io::Result<()> {\n        self.inner.disconnect()\n    }\n}\nimpl FromRawHandle for NamedPipe {\n    unsafe fn from_raw_handle(handle: RawHandle) -> NamedPipe {\n        NamedPipe {\n            inner: Arc::new(Inner {\n                handle: Handle::new(handle as HANDLE),\n                connect: Overlapped::new(connect_done),\n                connecting: AtomicBool::new(false),\n                read: Overlapped::new(read_done),\n                write: Overlapped::new(write_done),\n                io: Mutex::new(Io {\n                    cp: None,\n                    token: None,\n                    read: State::None,\n                    write: State::None,\n                    connect_error: None,\n                }),\n                pool: Mutex::new(BufferPool::with_capacity(2)),\n            }),\n        }\n    }\n}\nimpl Read for NamedPipe {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        <&NamedPipe as Read>::read(&mut &*self, buf)\n    }\n}\nimpl Write for NamedPipe {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        <&NamedPipe as Write>::write(&mut &*self, buf)\n    }\n    fn flush(&mut self) -> io::Result<()> {\n        <&NamedPipe as Write>::flush(&mut &*self)\n    }\n}\nimpl<'a> Read for &'a NamedPipe {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        let mut state = self.inner.io.lock().unwrap();\n        if state.token.is_none() {\n            return Err(would_block());\n        }\n        match mem::replace(&mut state.read, State::None) {\n            State::None => Err(would_block()),\n            State::Pending(buf, amt) => {\n                state.read = State::Pending(buf, amt);\n                Err(would_block())\n            }\n            State::Ok(data, cur) => {\n                let n = {\n                    let mut remaining = &data[cur..];\n                    remaining.read(buf)?\n                };\n                let next = cur + n;\n                if next != data.len() {\n                    state.read = State::Ok(data, next);\n                } else {\n                    self.inner.put_buffer(data);\n                    Inner::schedule_read(&self.inner, &mut state, None);\n                }\n                Ok(n)\n            }\n            State::Err(e) => {\n                Inner::schedule_read(&self.inner, &mut state, None);\n                if e.raw_os_error() == Some(ERROR_BROKEN_PIPE as i32) {\n                    Ok(0)\n                } else {\n                    Err(e)\n                }\n            }\n        }\n    }\n}\nimpl<'a> Write for &'a NamedPipe {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        let mut io = self.inner.io.lock().unwrap();\n        if io.token.is_none() {\n            return Err(would_block());\n        }\n        match io.write {\n            State::None => {}\n            State::Err(_) => match mem::replace(&mut io.write, State::None) {\n                State::Err(e) => return Err(e),\n                _ => unreachable!(),\n            },\n            _ => {\n                return Err(would_block());\n            }\n        }\n        let mut owned_buf = self.inner.get_buffer();\n        owned_buf.extend(buf);\n        match Inner::maybe_schedule_write(&self.inner, owned_buf, 0, &mut io)? {\n            Some(n) => Ok(n),\n            None => Ok(buf.len()),\n        }\n    }\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}\nimpl Source for NamedPipe {\n    fn register(&mut self, registry: &Registry, token: Token, _: Interest) -> io::Result<()> {\n        let mut io = self.inner.io.lock().unwrap();\n        io.check_association(registry, false)?;\n        if io.token.is_some() {\n            return Err(io::Error::new(\n                io::ErrorKind::AlreadyExists,\n                \"I/O source already registered with a `Registry`\",\n            ));\n        }\n        if io.cp.is_none() {\n            let selector = registry.selector();\n            io.cp = Some(selector.clone_port());\n            let inner_token = NEXT_TOKEN.fetch_add(2, Relaxed) + 2;\n            selector.inner.cp.add_handle(inner_token, self)?;\n        }\n        io.token = Some(token);\n        drop(io);\n        Inner::post_register(&self.inner, None);\n        Ok(())\n    }\n    fn reregister(&mut self, registry: &Registry, token: Token, _: Interest) -> io::Result<()> {\n        let mut io = self.inner.io.lock().unwrap();\n        io.check_association(registry, true)?;\n        io.token = Some(token);\n        drop(io);\n        Inner::post_register(&self.inner, None);\n        Ok(())\n    }\n    fn deregister(&mut self, registry: &Registry) -> io::Result<()> {\n        let mut io = self.inner.io.lock().unwrap();\n        io.check_association(registry, true)?;\n        if io.token.is_none() {\n            return Err(io::Error::new(\n                io::ErrorKind::NotFound,\n                \"I/O source not registered with `Registry`\",\n            ));\n        }\n        io.token = None;\n        Ok(())\n    }\n}\nimpl AsRawHandle for NamedPipe {\n    fn as_raw_handle(&self) -> RawHandle {\n        self.inner.handle.raw() as RawHandle\n    }\n}\nimpl fmt::Debug for NamedPipe {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.inner.handle.fmt(f)\n    }\n}\nimpl Drop for NamedPipe {\n    fn drop(&mut self) {\n        unsafe {\n            if self.inner.connecting.load(SeqCst) {\n                drop(cancel(&self.inner.handle, &self.inner.connect));\n            }\n            let io = self.inner.io.lock().unwrap();\n            if let State::Pending(..) = io.read {\n                drop(cancel(&self.inner.handle, &self.inner.read));\n            }\n        }\n    }\n}\nimpl Inner {\n    fn schedule_read(me: &Arc<Inner>, io: &mut Io, events: Option<&mut Vec<Event>>) -> bool {\n        match io.read {\n            State::None => {}\n            _ => return true,\n        }\n        let mut buf = me.get_buffer();\n        let e = unsafe {\n            let overlapped = me.read.as_ptr() as *mut _;\n            let slice = slice::from_raw_parts_mut(buf.as_mut_ptr(), buf.capacity());\n            me.read_overlapped(slice, overlapped)\n        };\n        match e {\n            Ok(_) => {\n                io.read = State::Pending(buf, 0); \n                mem::forget(me.clone());\n                true\n            }\n            Err(ref e) if e.raw_os_error() == Some(ERROR_PIPE_LISTENING as i32) => false,\n            Err(e) => {\n                io.read = State::Err(e);\n                io.notify_readable(events);\n                true\n            }\n        }\n    }\n    fn maybe_schedule_write(\n        me: &Arc<Inner>,\n        buf: Vec<u8>,\n        pos: usize,\n        io: &mut Io,\n    ) -> io::Result<Option<usize>> {\n        let e = unsafe {\n            let overlapped = me.write.as_ptr() as *mut _;\n            me.write_overlapped(&buf[pos..], overlapped)\n        };\n        match e {\n            Ok(Some(n)) => {\n                io.write = State::Ok(buf, pos);\n                mem::forget(me.clone());\n                Ok(Some(n))\n            }\n            Ok(None) => {\n                io.write = State::Pending(buf, pos);\n                mem::forget(me.clone());\n                Ok(None)\n            }\n            Err(e) => Err(e),\n        }\n    }\n    fn schedule_write(\n        me: &Arc<Inner>,\n        buf: Vec<u8>,\n        pos: usize,\n        io: &mut Io,\n        events: Option<&mut Vec<Event>>,\n    ) {\n        match Inner::maybe_schedule_write(me, buf, pos, io) {\n            Ok(Some(_)) => {\n                let state = mem::replace(&mut io.write, State::None);\n                io.write = match state {\n                    State::Ok(buf, pos) => State::Pending(buf, pos),\n                    _ => unreachable!(),\n                };\n                mem::forget(me.clone());\n            }\n            Ok(None) => (),\n            Err(e) => {\n                io.write = State::Err(e);\n                io.notify_writable(events);\n            }\n        }\n    }\n    fn post_register(me: &Arc<Inner>, mut events: Option<&mut Vec<Event>>) {\n        let mut io = me.io.lock().unwrap();\n        #[allow(clippy::needless_option_as_deref)]\n        if Inner::schedule_read(me, &mut io, events.as_deref_mut()) {\n            if let State::None = io.write {\n                io.notify_writable(events);\n            }\n        }\n    }\n    fn get_buffer(&self) -> Vec<u8> {\n        self.pool.lock().unwrap().get(4 * 1024)\n    }\n    fn put_buffer(&self, buf: Vec<u8>) {\n        self.pool.lock().unwrap().put(buf)\n    }\n}\nunsafe fn cancel(handle: &Handle, overlapped: &Overlapped) -> io::Result<()> {\n    let ret = CancelIoEx(handle.raw(), overlapped.as_ptr());\n    if ret == 0 {\n        Err(io::Error::last_os_error())\n    } else {\n        Ok(())\n    }\n}\nfn connect_done(status: &OVERLAPPED_ENTRY, events: Option<&mut Vec<Event>>) {\n    let status = CompletionStatus::from_entry(status);\n    let me = unsafe { Arc::from_raw(Inner::ptr_from_conn_overlapped(status.overlapped())) };\n    let prev = me.connecting.swap(false, SeqCst);\n    assert!(prev, \"NamedPipe was not previously connecting\");\n    debug_assert_eq!(status.bytes_transferred(), 0);\n    unsafe {\n        match me.result(status.overlapped()) {\n            Ok(n) => debug_assert_eq!(n, 0),\n            Err(e) => me.io.lock().unwrap().connect_error = Some(e),\n        }\n    }\n    Inner::post_register(&me, events);\n}\nfn read_done(status: &OVERLAPPED_ENTRY, events: Option<&mut Vec<Event>>) {\n    let status = CompletionStatus::from_entry(status);\n    let me = unsafe { Arc::from_raw(Inner::ptr_from_read_overlapped(status.overlapped())) };\n    let mut io = me.io.lock().unwrap();\n    let mut buf = match mem::replace(&mut io.read, State::None) {\n        State::Pending(buf, _) => buf,\n        _ => unreachable!(),\n    };\n    unsafe {\n        match me.result(status.overlapped()) {\n            Ok(n) => {\n                debug_assert_eq!(status.bytes_transferred() as usize, n);\n                buf.set_len(status.bytes_transferred() as usize);\n                io.read = State::Ok(buf, 0);\n            }\n            Err(e) => {\n                debug_assert_eq!(status.bytes_transferred(), 0);\n                io.read = State::Err(e);\n            }\n        }\n    }\n    io.notify_readable(events);\n}\nfn write_done(status: &OVERLAPPED_ENTRY, events: Option<&mut Vec<Event>>) {\n    let status = CompletionStatus::from_entry(status);\n    let me = unsafe { Arc::from_raw(Inner::ptr_from_write_overlapped(status.overlapped())) };\n    let mut io = me.io.lock().unwrap();\n    let (buf, pos) = match mem::replace(&mut io.write, State::None) {\n        State::Ok(..) => {\n            io.notify_writable(events);\n            return;\n        }\n        State::Pending(buf, pos) => (buf, pos),\n        _ => unreachable!(),\n    };\n    unsafe {\n        match me.result(status.overlapped()) {\n            Ok(n) => {\n                debug_assert_eq!(status.bytes_transferred() as usize, n);\n                let new_pos = pos + (status.bytes_transferred() as usize);\n                if new_pos == buf.len() {\n                    me.put_buffer(buf);\n                    io.notify_writable(events);\n                } else {\n                    Inner::schedule_write(&me, buf, new_pos, &mut io, events);\n                }\n            }\n            Err(e) => {\n                debug_assert_eq!(status.bytes_transferred(), 0);\n                io.write = State::Err(e);\n                io.notify_writable(events);\n            }\n        }\n    }\n}\nimpl Io {\n    fn check_association(&self, registry: &Registry, required: bool) -> io::Result<()> {\n        match self.cp {\n            Some(ref cp) if !registry.selector().same_port(cp) => Err(io::Error::new(\n                io::ErrorKind::AlreadyExists,\n                \"I/O source already registered with a different `Registry`\",\n            )),\n            None if required => Err(io::Error::new(\n                io::ErrorKind::NotFound,\n                \"I/O source not registered with `Registry`\",\n            )),\n            _ => Ok(()),\n        }\n    }\n    fn notify_readable(&self, events: Option<&mut Vec<Event>>) {\n        if let Some(token) = self.token {\n            let mut ev = Event::new(token);\n            ev.set_readable();\n            if let Some(events) = events {\n                events.push(ev);\n            } else {\n                let _ = self.cp.as_ref().unwrap().post(ev.to_completion_status());\n            }\n        }\n    }\n    fn notify_writable(&self, events: Option<&mut Vec<Event>>) {\n        if let Some(token) = self.token {\n            let mut ev = Event::new(token);\n            ev.set_writable();\n            if let Some(events) = events {\n                events.push(ev);\n            } else {\n                let _ = self.cp.as_ref().unwrap().post(ev.to_completion_status());\n            }\n        }\n    }\n}\nstruct BufferPool {\n    pool: Vec<Vec<u8>>,\n}\nimpl BufferPool {\n    fn with_capacity(cap: usize) -> BufferPool {\n        BufferPool {\n            pool: Vec::with_capacity(cap),\n        }\n    }\n    fn get(&mut self, default_cap: usize) -> Vec<u8> {\n        self.pool\n            .pop()\n            .unwrap_or_else(|| Vec::with_capacity(default_cap))\n    }\n    fn put(&mut self, mut buf: Vec<u8>) {\n        if self.pool.len() < self.pool.capacity() {\n            unsafe {\n                buf.set_len(0);\n            }\n            self.pool.push(buf);\n        }\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "#[cfg(unix)]\npub use unix::*;\n#[cfg(windows)]\npub use windows::*;\npub struct ChildPipeFd(pub i32);\n#[cfg(unix)]\nmod unix {\n  use std::cell::RefCell;\n  use std::future::Future;\n  use std::io;\n  use std::mem;\n  use std::os::fd::FromRawFd;\n  use std::os::fd::RawFd;\n  use std::pin::Pin;\n  use std::rc::Rc;\n  use std::task::Context;\n  use std::task::Poll;\n  use deno_core::error::bad_resource_id;\n  use deno_core::error::AnyError;\n  use deno_core::op2;\n  use deno_core::serde_json;\n  use deno_core::AsyncRefCell;\n  use deno_core::CancelFuture;\n  use deno_core::CancelHandle;\n  use deno_core::OpState;\n  use deno_core::RcRef;\n  use deno_core::ResourceId;\n  use pin_project_lite::pin_project;\n  use tokio::io::AsyncBufRead;\n  use tokio::io::AsyncWriteExt;\n  use tokio::io::BufReader;\n  use tokio::net::unix::OwnedReadHalf;\n  use tokio::net::unix::OwnedWriteHalf;\n  use tokio::net::UnixStream;\n  #[op2(fast)]\n  #[smi]\n  pub fn op_node_ipc_pipe(\n    state: &mut OpState,\n    #[smi] fd: i32,\n  ) -> Result<ResourceId, AnyError> {\n    Ok(state.resource_table.add(IpcJsonStreamResource::new(fd)?))\n  }\n  #[op2]\n  #[smi]\n  pub fn op_node_child_ipc_pipe(\n    state: &mut OpState,\n  ) -> Result<Option<ResourceId>, AnyError> {\n    let fd = match state.try_borrow_mut::<crate::ChildPipeFd>() {\n      Some(child_pipe_fd) => child_pipe_fd.0,\n      None => return Ok(None),\n    };\n    Ok(Some(\n      state.resource_table.add(IpcJsonStreamResource::new(fd)?),\n    ))\n  }\n  #[op2(async)]\n  pub async fn op_node_ipc_write(\n    state: Rc<RefCell<OpState>>,\n    #[smi] rid: ResourceId,\n    #[serde] value: serde_json::Value,\n  ) -> Result<(), AnyError> {\n    let stream = state\n      .borrow()\n      .resource_table\n      .get::<IpcJsonStreamResource>(rid)\n      .map_err(|_| bad_resource_id())?;\n    stream.write_msg(value).await?;\n    Ok(())\n  }\n  #[op2(async)]\n  #[serde]\n  pub async fn op_node_ipc_read(\n    state: Rc<RefCell<OpState>>,\n    #[smi] rid: ResourceId,\n  ) -> Result<serde_json::Value, AnyError> {\n    let stream = state\n      .borrow()\n      .resource_table\n      .get::<IpcJsonStreamResource>(rid)\n      .map_err(|_| bad_resource_id())?;\n    let cancel = stream.cancel.clone();\n    let mut stream = RcRef::map(stream, |r| &r.read_half).borrow_mut().await;\n    let msgs = stream.read_msg().or_cancel(cancel).await??;\n    Ok(msgs)\n  }\n  struct IpcJsonStreamResource {\n    read_half: AsyncRefCell<IpcJsonStream>,\n    write_half: AsyncRefCell<OwnedWriteHalf>,\n    cancel: Rc<CancelHandle>,\n  }\n  impl deno_core::Resource for IpcJsonStreamResource {\n    fn close(self: Rc<Self>) {\n      self.cancel.cancel();\n    }\n  }\n  impl IpcJsonStreamResource {\n    fn new(stream: RawFd) -> Result<Self, std::io::Error> {\n      let unix_stream = UnixStream::from_std(unsafe {\n        std::os::unix::net::UnixStream::from_raw_fd(stream)\n      })?;\n      let (read_half, write_half) = unix_stream.into_split();\n      Ok(Self {\n        read_half: AsyncRefCell::new(IpcJsonStream::new(read_half)),\n        write_half: AsyncRefCell::new(write_half),\n        cancel: Default::default(),\n      })\n    }\n    #[cfg(test)]\n    fn from_unix_stream(stream: UnixStream) -> Self {\n      let (read_half, write_half) = stream.into_split();\n      Self {\n        read_half: AsyncRefCell::new(IpcJsonStream::new(read_half)),\n        write_half: AsyncRefCell::new(write_half),\n        cancel: Default::default(),\n      }\n    }\n    async fn write_msg(\n      self: Rc<Self>,\n      msg: serde_json::Value,\n    ) -> Result<(), AnyError> {\n      let mut write_half =\n        RcRef::map(self, |r| &r.write_half).borrow_mut().await;\n      let mut buf = Vec::new();\n      serde_json::to_writer(&mut buf, &msg)?;\n      buf.push(b'\\n');\n      write_half.write_all(&buf).await?;\n      Ok(())\n    }\n  }\n  #[inline]\n  fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n    #[cfg(all(target_os = \"macos\", target_arch = \"aarch64\"))]\n    return unsafe { neon::neon_memchr(haystack, needle, haystack.len()) };\n    #[cfg(not(all(target_os = \"macos\", target_arch = \"aarch64\")))]\n    return haystack.iter().position(|&b| b == needle);\n  }\n  const INITIAL_CAPACITY: usize = 1024 * 64;\n  struct IpcJsonStream {\n    pipe: BufReader<OwnedReadHalf>,\n    buffer: Vec<u8>,\n  }\n  impl IpcJsonStream {\n    fn new(pipe: OwnedReadHalf) -> Self {\n      Self {\n        pipe: BufReader::with_capacity(INITIAL_CAPACITY, pipe),\n        buffer: Vec::with_capacity(INITIAL_CAPACITY),\n      }\n    }\n    async fn read_msg(&mut self) -> Result<serde_json::Value, AnyError> {\n      let mut json = None;\n      let nread =\n        read_msg_inner(&mut self.pipe, &mut self.buffer, &mut json).await?;\n      if nread == 0 {\n        return Ok(serde_json::Value::Null);\n      }\n      let json = match json {\n        Some(v) => v,\n        None => {\n          simd_json::from_slice(&mut self.buffer[..nread])?\n        }\n      };\n      unsafe {\n        self.buffer.set_len(0);\n      }\n      Ok(json)\n    }\n  }\n  pin_project! {\n      #[must_use = \"futures do nothing unless you `.await` or poll them\"]\n      struct ReadMsgInner<'a, R: ?Sized> {\n          reader: &'a mut R,\n          buf: &'a mut Vec<u8>,\n          json: &'a mut Option<serde_json::Value>,\n          read: usize,\n      }\n  }\n  fn read_msg_inner<'a, R>(\n    reader: &'a mut R,\n    buf: &'a mut Vec<u8>,\n    json: &'a mut Option<serde_json::Value>,\n  ) -> ReadMsgInner<'a, R>\n  where\n    R: AsyncBufRead + ?Sized + Unpin,\n  {\n    ReadMsgInner {\n      reader,\n      buf,\n      json,\n      read: 0,\n    }\n  }\n  fn read_msg_internal<R: AsyncBufRead + ?Sized>(\n    mut reader: Pin<&mut R>,\n    cx: &mut Context<'_>,\n    buf: &mut Vec<u8>,\n    json: &mut Option<serde_json::Value>,\n    read: &mut usize,\n  ) -> Poll<io::Result<usize>> {\n    loop {\n      let (done, used) = {\n        let available = match reader.as_mut().poll_fill_buf(cx) {\n          std::task::Poll::Ready(t) => t?,\n          std::task::Poll::Pending => return std::task::Poll::Pending,\n        };\n        if let Some(i) = memchr(b'\\n', available) {\n          if *read == 0 {\n            let available = unsafe {\n              std::slice::from_raw_parts_mut(\n                available.as_ptr() as *mut u8,\n                available.len(),\n              )\n            };\n            json.replace(\n              simd_json::from_slice(&mut available[..i + 1])\n                .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?,\n            );\n          } else {\n            buf.extend_from_slice(&available[..=i]);\n          }\n          (true, i + 1)\n        } else {\n          buf.extend_from_slice(available);\n          (false, available.len())\n        }\n      };\n      reader.as_mut().consume(used);\n      *read += used;\n      if done || used == 0 {\n        return Poll::Ready(Ok(mem::replace(read, 0)));\n      }\n    }\n  }\n  impl<R: AsyncBufRead + ?Sized + Unpin> Future for ReadMsgInner<'_, R> {\n    type Output = io::Result<usize>;\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n      let me = self.project();\n      read_msg_internal(Pin::new(*me.reader), cx, me.buf, me.json, me.read)\n    }\n  }\n  #[cfg(all(target_os = \"macos\", target_arch = \"aarch64\"))]\n  mod neon {\n    use std::arch::aarch64::*;\n    pub unsafe fn neon_memchr(\n      str: &[u8],\n      c: u8,\n      length: usize,\n    ) -> Option<usize> {\n      let end = str.as_ptr().wrapping_add(length);\n      let mut ptr = str.as_ptr();\n      while ptr < end && (ptr as usize) & 0xF != 0 {\n        if *ptr == c {\n          return Some(ptr as usize - str.as_ptr() as usize);\n        }\n        ptr = ptr.wrapping_add(1);\n      }\n      let search_char = vdupq_n_u8(c);\n      while ptr.wrapping_add(16) <= end {\n        let chunk = vld1q_u8(ptr);\n        let comparison = vceqq_u8(chunk, search_char);\n        let result0 = vgetq_lane_u64(vreinterpretq_u64_u8(comparison), 0);\n        if result0 != 0 {\n          return Some(\n            (ptr as usize - str.as_ptr() as usize)\n              + result0.trailing_zeros() as usize / 8,\n          );\n        }\n        let result1 = vgetq_lane_u64(vreinterpretq_u64_u8(comparison), 1);\n        if result1 != 0 {\n          return Some(\n            (ptr as usize - str.as_ptr() as usize)\n              + 8\n              + result1.trailing_zeros() as usize / 8,\n          );\n        }\n        ptr = ptr.wrapping_add(16);\n      }\n      while ptr < end {\n        if *ptr == c {\n          return Some(ptr as usize - str.as_ptr() as usize);\n        }\n        ptr = ptr.wrapping_add(1);\n      }\n      None\n    }\n  }\n  #[cfg(test)]\n  mod tests {\n    use super::IpcJsonStreamResource;\n    use deno_core::serde_json;\n    use deno_core::serde_json::json;\n    use deno_core::RcRef;\n    use std::rc::Rc;\n    #[tokio::test]\n    async fn bench_ipc() -> Result<(), Box<dyn std::error::Error>> {\n      if std::env::var_os(\"BENCH_IPC_DENO\").is_none() {\n        return Ok(());\n      }\n      let (fd1, mut fd2) = tokio::net::UnixStream::pair()?;\n      let child = tokio::spawn(async move {\n        use tokio::io::AsyncWriteExt;\n        let size = 1024 * 1024;\n        let stri = \"x\".repeat(size);\n        let data = format!(\"\\\"{}\\\"\\n\", stri);\n        for _ in 0..100 {\n          fd2.write_all(data.as_bytes()).await?;\n        }\n        Ok::<_, std::io::Error>(())\n      });\n      let ipc = Rc::new(IpcJsonStreamResource::from_unix_stream(fd1));\n      let start = std::time::Instant::now();\n      let mut bytes = 0;\n      let mut ipc = RcRef::map(ipc, |r| &r.read_half).borrow_mut().await;\n      loop {\n        let msgs = ipc.read_msg().await?;\n        if msgs == serde_json::Value::Null {\n          break;\n        }\n        bytes += msgs.as_str().unwrap().len();\n        if start.elapsed().as_secs() > 5 {\n          break;\n        }\n      }\n      let elapsed = start.elapsed();\n      let mb = bytes as f64 / 1024.0 / 1024.0;\n      println!(\"{} mb/s\", mb / elapsed.as_secs_f64());\n      child.await??;\n      Ok(())\n    }\n    #[tokio::test]\n    async fn unix_ipc_json() -> Result<(), Box<dyn std::error::Error>> {\n      let (fd1, mut fd2) = tokio::net::UnixStream::pair()?;\n      let child = tokio::spawn(async move {\n        use tokio::io::AsyncReadExt;\n        use tokio::io::AsyncWriteExt;\n        let mut buf = [0u8; 1024];\n        let n = fd2.read(&mut buf).await?;\n        assert_eq!(&buf[..n], b\"\\\"hello\\\"\\n\");\n        fd2.write_all(b\"\\\"world\\\"\\n\").await?;\n        Ok::<_, std::io::Error>(())\n      });\n      let ipc = Rc::new(IpcJsonStreamResource::from_unix_stream(fd1));\n      ipc.clone().write_msg(json!(\"hello\")).await?;\n      let mut ipc = RcRef::map(ipc, |r| &r.read_half).borrow_mut().await;\n      let msgs = ipc.read_msg().await?;\n      assert_eq!(msgs, json!(\"world\"));\n      child.await??;\n      Ok(())\n    }\n    #[tokio::test]\n    async fn unix_ipc_json_multi() -> Result<(), Box<dyn std::error::Error>> {\n      let (fd1, mut fd2) = tokio::net::UnixStream::pair()?;\n      let child = tokio::spawn(async move {\n        use tokio::io::AsyncReadExt;\n        use tokio::io::AsyncWriteExt;\n        let mut buf = [0u8; 1024];\n        let n = fd2.read(&mut buf).await?;\n        assert_eq!(&buf[..n], b\"\\\"hello\\\"\\n\\\"world\\\"\\n\");\n        fd2.write_all(b\"\\\"foo\\\"\\n\\\"bar\\\"\\n\").await?;\n        Ok::<_, std::io::Error>(())\n      });\n      let ipc = Rc::new(IpcJsonStreamResource::from_unix_stream(fd1));\n      ipc.clone().write_msg(json!(\"hello\")).await?;\n      ipc.clone().write_msg(json!(\"world\")).await?;\n      let mut ipc = RcRef::map(ipc, |r| &r.read_half).borrow_mut().await;\n      let msgs = ipc.read_msg().await?;\n      assert_eq!(msgs, json!(\"foo\"));\n      child.await??;\n      Ok(())\n    }\n    #[tokio::test]\n    async fn unix_ipc_json_invalid() -> Result<(), Box<dyn std::error::Error>> {\n      let (fd1, mut fd2) = tokio::net::UnixStream::pair()?;\n      let child = tokio::spawn(async move {\n        tokio::io::AsyncWriteExt::write_all(&mut fd2, b\"\\n\\n\").await?;\n        Ok::<_, std::io::Error>(())\n      });\n      let ipc = Rc::new(IpcJsonStreamResource::from_unix_stream(fd1));\n      let mut ipc = RcRef::map(ipc, |r| &r.read_half).borrow_mut().await;\n      let _err = ipc.read_msg().await.unwrap_err();\n      child.await??;\n      Ok(())\n    }\n    #[test]\n    fn memchr() {\n      let str = b\"hello world\";\n      assert_eq!(super::memchr(b'h', str), Some(0));\n      assert_eq!(super::memchr(b'w', str), Some(6));\n      assert_eq!(super::memchr(b'd', str), Some(10));\n      assert_eq!(super::memchr(b'x', str), None);\n      let empty = b\"\";\n      assert_eq!(super::memchr(b'\\n', empty), None);\n    }\n  }\n}\n#[cfg(windows)]\nmod windows {\n  use deno_core::error::AnyError;\n  use deno_core::op2;\n  #[op2(fast)]\n  pub fn op_node_ipc_pipe() -> Result<(), AnyError> {\n    Err(deno_core::error::not_supported())\n  }\n  #[op2(fast)]\n  #[smi]\n  pub fn op_node_child_ipc_pipe() -> Result<i32, AnyError> {\n    Ok(-1)\n  }\n  #[op2(async)]\n  pub async fn op_node_ipc_write() -> Result<(), AnyError> {\n    Err(deno_core::error::not_supported())\n  }\n  #[op2(async)]\n  pub async fn op_node_ipc_read() -> Result<(), AnyError> {\n    Err(deno_core::error::not_supported())\n  }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn strip_ansi_codes_and_ascii_control(s: &str) -> std::borrow::Cow<str> {\n  console_static_text::ansi::strip_ansi_codes(s)\n    .chars()\n    .filter(|c| !c.is_ascii_control())\n    .collect()\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub(super) fn main_router<RF>(configuration: &Configuration) -> axum::Router\nwhere\n    RF: RouterFactory,\n{\n    let mut router = Router::new().route(\n        &configuration.supergraph.sanitized_path(),\n        get({\n            move |Extension(service): Extension<RF>, request: Request<Body>| {\n                handle_graphql(service.create().boxed(), request)\n            }\n        })\n        .post({\n            move |Extension(service): Extension<RF>, request: Request<Body>| {\n                handle_graphql(service.create().boxed(), request)\n            }\n        }),\n    );\n    if configuration.supergraph.path == \"/*\" {\n        router = router.route(\n            \"/\",\n            get({\n                move |Extension(service): Extension<RF>, request: Request<Body>| {\n                    handle_graphql(service.create().boxed(), request)\n                }\n            })\n            .post({\n                move |Extension(service): Extension<RF>, request: Request<Body>| {\n                    handle_graphql(service.create().boxed(), request)\n                }\n            }),\n        );\n    }\n    router\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn resume_func<T, Results>(\n        &mut self,\n        mut ctx: StoreContextMut<T>,\n        host_func: Func,\n        params: impl CallParams,\n        results: Results,\n    ) -> Result<<Results as CallResults>::Results, TaggedTrap>\n    where\n        Results: CallResults,\n    {\n        self.stack\n            .values\n            .drop(host_func.ty(ctx.as_context()).params().len());\n        self.stack.values.extend(params.call_params());\n        assert!(\n            self.stack.frames.peek().is_some(),\n            \"a frame must be on the call stack upon resumption\"\n        );\n        self.execute_wasm_func(ctx.as_context_mut())?;\n        let results = self.write_results_back(results);\n        Ok(results)\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "async fn main() {\n    let addr: std::net::SocketAddr = ([127, 0, 0, 1], 3000).into();\n    let counter = Arc::new(AtomicU64::new(0));\n    let mut listener = tls_listener::builder(tls_acceptor())\n        .max_handshakes(10)\n        .listen(TcpListener::bind(addr).await.expect(\"Failed to bind port\"));\n    let (tx, mut rx) = mpsc::channel::<Acceptor>(1);\n    let http = http1::Builder::new();\n    loop {\n        tokio::select! {\n            conn = listener.accept() => {\n                match conn {\n                    Ok((conn, remote_addr)) => {\n                        let http = http.clone();\n                        let tx = tx.clone();\n                        let counter = counter.clone();\n                        tokio::spawn(async move {\n                            let svc = service_fn(move |request| handle_request(tx.clone(), counter.clone(), request));\n                            if let Err(err) = http.serve_connection(TokioIo::new(conn), svc).await {\n                                eprintln!(\"Application error (client address: {remote_addr}): {err}\");\n                            }\n                        });\n                    },\n                    Err(e) => {\n                        if let Some(remote_addr) = e.peer_addr() {\n                            eprint!(\"[client {remote_addr}] \");\n                        }\n                        eprintln!(\"Bad connection: {}\", e);\n                    }\n                }\n            },\n            message = rx.recv() => {\n                let acceptor = message.expect(\"Channel should not be closed\");\n                println!(\"Rotating certificate...\");\n                listener.replace_acceptor(acceptor);\n            }\n        }\n    }\n}\npub fn poll_accept(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<<Self as Stream>::Item> {\n        let mut this = self.project();\n        while this.waiting.len() < *this.max_handshakes {\n            match this.listener.as_mut().poll_accept(cx) {\n                Poll::Pending => break,\n                Poll::Ready(Ok((conn, addr))) => {\n                    this.waiting.push(Waiting {\n                        inner: timeout(*this.timeout, this.tls.accept(conn)),\n                        peer_addr: Some(addr),\n                    });\n                }\n                Poll::Ready(Err(e)) => {\n                    return Poll::Ready(Err(Error::ListenerError(e)));\n                }\n            }\n        }\n        match this.waiting.poll_next_unpin(cx) {\n            Poll::Ready(Some(result)) => Poll::Ready(result),\n            Poll::Ready(None) | Poll::Pending => Poll::Pending,\n        }\n    }\npub fn max_handshakes(&mut self, max: usize) -> &mut Self {\n        self.max_handshakes = max;\n        self\n    }\npub fn listen<A: AsyncAccept>(&self, listener: A) -> TlsListener<A, T>\n    where\n        T: AsyncTls<A::Connection>,\n    {\n        TlsListener {\n            listener,\n            tls: self.tls.clone(),\n            waiting: FuturesUnordered::new(),\n            max_handshakes: self.max_handshakes,\n            timeout: self.handshake_timeout,\n        }\n    }\npub fn builder<T>(tls: T) -> Builder<T> {\n    Builder {\n        tls,\n        max_handshakes: DEFAULT_MAX_HANDSHAKES,\n        handshake_timeout: DEFAULT_HANDSHAKE_TIMEOUT,\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": " pub(crate) fn process_alert(&mut self, alert: &AlertMessagePayload) -> Result<(), Error> {\n        if let AlertLevel::Unknown(_) = alert.level {\n            return Err(self.send_fatal_alert(\n                AlertDescription::IllegalParameter,\n                Error::AlertReceived(alert.description),\n            ));\n        }\n        if alert.description == AlertDescription::CloseNotify {\n            self.has_received_close_notify = true;\n            return Ok(());\n        }\n        let err = Error::AlertReceived(alert.description);\n        if alert.level == AlertLevel::Warning {\n            if self.is_tls13() && alert.description != AlertDescription::UserCanceled {\n                return Err(self.send_fatal_alert(AlertDescription::DecodeError, err));\n            } else {\n                warn!(\"TLS alert warning received: {:?}\", alert);\n                return Ok(());\n            }\n        }\n        Err(err)\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn hash_subgraph_query(schema: &str, query: &str) -> String {\n        let schema = Valid::assume_valid(Schema::parse(schema, \"schema.graphql\").unwrap());\n        let doc = Document::parse(query, \"query.graphql\").unwrap();\n        let exec = doc\n            .to_executable(&schema)\n            .unwrap()\n            .validate(&schema)\n            .unwrap();\n        let mut visitor = QueryHashVisitor::new(&schema, &exec);\n        traverse::document(&mut visitor, &exec, None).unwrap();\n        hex::encode(visitor.finish())\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "fn poll(&mut self, cx: &mut Context<'_>) -> Poll<Result<Stream>> {\n        loop {\n            if self.socket.poll_ready_unpin(cx).is_ready() {\n                if let Some(frame) = self.rtt.next_ping() {\n                    self.socket.start_send_unpin(frame.into())?;\n                    continue;\n                }\n                if let Some(frame) = self.pending_frames.pop_front() {\n                    self.socket.start_send_unpin(frame)?;\n                    continue;\n                }\n            }\n            match self.socket.poll_flush_unpin(cx)? {\n                Poll::Ready(()) => {}\n                Poll::Pending => {}\n            }\n            match self.stream_receivers.poll_next_unpin(cx) {\n                Poll::Ready(Some((_, Some(StreamCommand::SendFrame(frame))))) => {\n                    self.on_send_frame(frame);\n                    continue;\n                }\n                Poll::Ready(Some((id, Some(StreamCommand::CloseStream { ack })))) => {\n                    self.on_close_stream(id, ack);\n                    continue;\n                }\n                Poll::Ready(Some((id, None))) => {\n                    self.on_drop_stream(id);\n                    continue;\n                }\n                Poll::Ready(None) => {\n                    self.no_streams_waker = Some(cx.waker().clone());\n                }\n                Poll::Pending => {}\n            }\n            match self.socket.poll_next_unpin(cx) {\n                Poll::Ready(Some(frame)) => {\n                    if let Some(stream) = self.on_frame(frame?)? {\n                        return Poll::Ready(Ok(stream));\n                    }\n                    continue;\n                }\n                Poll::Ready(None) => {\n                    return Poll::Ready(Err(ConnectionError::Closed));\n                }\n                Poll::Pending => {}\n            }\n            return Poll::Pending;\n        }\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn load_certificates(\n    certificates_der: &Option<Vec<PathBuf>>,\n    certificates_pem: &Option<Vec<PathBuf>>,\n) -> Result<Vec<Certificate>> {\n    const CERT_READ_ERROR: &str = \"Failed to read certificate\";\n    const CERT_PARSE_ERROR: &str = \"Failed to parse certificate\";\n    let mut certs = vec![];\n    for path in certificates_der.iter().flatten() {\n        let mut buf = vec![];\n        File::open(path)\n            .context(CERT_READ_ERROR)?\n            .read_to_end(&mut buf)\n            .context(CERT_READ_ERROR)?;\n        let cert = Certificate::from_der(&buf).context(CERT_PARSE_ERROR)?;\n        certs.push(cert);\n    }\n    for path in certificates_pem.iter().flatten() {\n        let mut buf = vec![];\n        File::open(path)\n            .context(CERT_READ_ERROR)?\n            .read_to_end(&mut buf)\n            .context(CERT_READ_ERROR)?;\n        let cert = Certificate::from_pem(&buf).context(CERT_PARSE_ERROR)?;\n        certs.push(cert);\n    }\n    Ok(certs)\n}\npub fn construct_client(\n    root_certificates: Vec<Certificate>,\n    danger_accept_invalid_certs: bool,\n    danger_accept_invalid_hostnames: bool,\n) -> reqwest::Result<Client> {\n    let mut headers = HeaderMap::new();\n    headers.insert(\"Sec-Fetch-Site\", HeaderValue::from_static(\"none\"));\n    headers.insert(\"Sec-Fetch-Dest\", HeaderValue::from_static(\"manifest\"));\n    let mut builder = Client::builder()\n        .user_agent(APP_USER_AGENT)\n        .default_headers(headers)\n        .danger_accept_invalid_certs(danger_accept_invalid_certs)\n        .danger_accept_invalid_hostnames(danger_accept_invalid_hostnames);\n    if danger_accept_invalid_certs || danger_accept_invalid_hostnames {\n        warn!(\"Certificate or hostname verification is disabled\");\n        warn!(\"This is a dangerous option that should be used with care\");\n    }\n    for certificate in root_certificates {\n        builder = builder.add_root_certificate(certificate);\n    }\n    builder.build()\n}\npub(crate) fn construct_certificates_and_client(\n    certificates_der: &Option<Vec<PathBuf>>,\n    certificates_pem: &Option<Vec<PathBuf>>,\n    danger_accept_invalid_certs: bool,\n    danger_accept_invalid_hostnames: bool,\n) -> Result<Client> {\n    const CLIENT_CERT_ERROR: &str = \"Failed to load HTTP client certificates\";\n    const CLIENT_CONSTRUCT_ERROR: &str = \"Failed to construct HTTP client\";\n    construct_client(\n        load_certificates(certificates_der, certificates_pem).context(CLIENT_CERT_ERROR)?,\n        danger_accept_invalid_certs,\n        danger_accept_invalid_hostnames,\n    )\n    .context(CLIENT_CONSTRUCT_ERROR)\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub enum Error {\n    #[error(\"Failed to attach Java VM to tunnel thread\")]\n    AttachJvmToThread(#[source] jnix::jni::errors::Error),\n    #[error(\"Failed to allow socket to bypass tunnel\")]\n    Bypass,\n    #[error(\"Failed to call Java method TalpidVpnService.{0}\")]\n    CallMethod(&'static str, #[source] jnix::jni::errors::Error),\n    #[error(\"Failed to create Java VM handle clone\")]\n    CloneJavaVm(#[source] jnix::jni::errors::Error),\n    #[error(\"Failed to find TalpidVpnService.{0} method\")]\n    FindMethod(&'static str, #[source] jnix::jni::errors::Error),\n    #[error(\"Attempt to configure the tunnel with an invalid DNS server address(es): {0:?}\")]\n    InvalidDnsServers(Vec<IpAddr>),\n    #[error(\"Received an invalid result from TalpidVpnService.{0}: {1}\")]\n    InvalidMethodResult(&'static str, String),\n    #[error(\"Failed to create tunnel device\")]\n    TunnelDeviceError,\n    #[error(\"Permission denied when trying to create tunnel\")]\n    PermissionDenied,\n}\npub struct AndroidTunProvider {\n    jvm: Arc<JavaVM>,\n    class: GlobalRef,\n    object: GlobalRef,\n    last_tun_config: TunConfig,\n    allow_lan: bool,\n    custom_dns_servers: Option<Vec<IpAddr>>,\n    allowed_lan_networks: Vec<IpNetwork>,\n}\nimpl AndroidTunProvider {\n    pub fn new(\n        context: AndroidContext,\n        allow_lan: bool,\n        custom_dns_servers: Option<Vec<IpAddr>>,\n        allowed_lan_networks: Vec<IpNetwork>,\n    ) -> Self {\n        let env = JnixEnv::from(\n            context\n                .jvm\n                .attach_current_thread_as_daemon()\n                .expect(\"Failed to attach thread to Java VM\"),\n        );\n        let talpid_vpn_service_class = env.get_class(\"net/mullvad/talpid/TalpidVpnService\");\n        AndroidTunProvider {\n            jvm: context.jvm,\n            class: talpid_vpn_service_class,\n            object: context.vpn_service,\n            last_tun_config: TunConfig::default(),\n            allow_lan,\n            custom_dns_servers,\n            allowed_lan_networks,\n        }\n    }\n    pub fn set_allow_lan(&mut self, allow_lan: bool) -> Result<(), Error> {\n        if self.allow_lan != allow_lan {\n            self.allow_lan = allow_lan;\n            self.recreate_tun_if_open()?;\n        }\n        Ok(())\n    }\n    pub fn set_dns_servers(&mut self, servers: Option<Vec<IpAddr>>) -> Result<(), Error> {\n        if self.custom_dns_servers != servers {\n            self.custom_dns_servers = servers;\n            self.recreate_tun_if_open()?;\n        }\n        Ok(())\n    }\n    pub fn get_tun(&mut self, config: TunConfig) -> Result<VpnServiceTun, Error> {\n        let tun_fd = self.get_tun_fd(config.clone())?;\n        self.last_tun_config = config;\n        let jvm = unsafe { JavaVM::from_raw(self.jvm.get_java_vm_pointer()) }\n            .map_err(Error::CloneJavaVm)?;\n        Ok(VpnServiceTun {\n            tunnel: tun_fd,\n            jvm,\n            class: self.class.clone(),\n            object: self.object.clone(),\n        })\n    }\n    pub fn create_blocking_tun(&mut self) -> Result<(), Error> {\n        let mut config = TunConfig::default();\n        self.prepare_tun_config(&mut config);\n        let _ = self.get_tun(config)?;\n        Ok(())\n    }\n    pub fn create_tun(&mut self) -> Result<(), Error> {\n        let result = self.call_method(\n            \"createTun\",\n            \"()V\",\n            JavaType::Primitive(Primitive::Void),\n            &[],\n        )?;\n        match result {\n            JValue::Void => Ok(()),\n            value => Err(Error::InvalidMethodResult(\n                \"createTun\",\n                format!(\"{:?}\", value),\n            )),\n        }\n    }\n    pub fn close_tun(&mut self) {\n        let result = self.call_method(\"closeTun\", \"()V\", JavaType::Primitive(Primitive::Void), &[]);\n        let error = match result {\n            Ok(JValue::Void) => None,\n            Ok(value) => Some(Error::InvalidMethodResult(\n                \"closeTun\",\n                format!(\"{:?}\", value),\n            )),\n            Err(error) => Some(error),\n        };\n        if let Some(error) = error {\n            log::error!(\n                \"{}\",\n                error.display_chain_with_msg(\"Failed to close the tunnel\")\n            );\n        }\n    }\n    fn get_tun_fd(&mut self, mut config: TunConfig) -> Result<RawFd, Error> {\n        self.prepare_tun_config(&mut config);\n        let env = self.env()?;\n        let java_config = config.into_java(&env);\n        let result = self.call_method(\n            \"getTun\",\n            \"(Lnet/mullvad/talpid/tun_provider/TunConfig;)Lnet/mullvad/talpid/CreateTunResult;\",\n            JavaType::Object(\"net/mullvad/talpid/CreateTunResult\".to_owned()),\n            &[JValue::Object(java_config.as_obj())],\n        )?;\n        match result {\n            JValue::Object(result) => CreateTunResult::from_java(&env, result).into(),\n            value => Err(Error::InvalidMethodResult(\"getTun\", format!(\"{:?}\", value))),\n        }\n    }\n    fn recreate_tun_if_open(&mut self) -> Result<(), Error> {\n        let mut actual_config = self.last_tun_config.clone();\n        self.prepare_tun_config(&mut actual_config);\n        let env = self.env()?;\n        let java_config = actual_config.into_java(&env);\n        let result = self.call_method(\n            \"recreateTunIfOpen\",\n            \"(Lnet/mullvad/talpid/tun_provider/TunConfig;)V\",\n            JavaType::Primitive(Primitive::Void),\n            &[JValue::Object(java_config.as_obj())],\n        )?;\n        match result {\n            JValue::Void => Ok(()),\n            value => Err(Error::InvalidMethodResult(\"getTun\", format!(\"{:?}\", value))),\n        }\n    }\n    fn prepare_tun_config(&self, config: &mut TunConfig) {\n        self.prepare_tun_config_for_allow_lan(config);\n        self.prepare_tun_config_for_custom_dns(config);\n    }\n    fn prepare_tun_config_for_allow_lan(&self, config: &mut TunConfig) {\n        if self.allow_lan {\n            let (required_ipv4_routes, required_ipv6_routes) = config\n                .required_routes\n                .iter()\n                .cloned()\n                .partition::<Vec<_>, _>(|route| route.is_ipv4());\n            let (original_lan_ipv4_networks, original_lan_ipv6_networks) = self\n                .allowed_lan_networks\n                .iter()\n                .cloned()\n                .partition::<Vec<_>, _>(|network| network.is_ipv4());\n            let lan_ipv4_networks = original_lan_ipv4_networks\n                .into_iter()\n                .flat_map(|network| network.sub_all(required_ipv4_routes.iter().cloned()))\n                .collect::<Vec<_>>();\n            let lan_ipv6_networks = original_lan_ipv6_networks\n                .into_iter()\n                .flat_map(|network| network.sub_all(required_ipv6_routes.iter().cloned()))\n                .collect::<Vec<_>>();\n            let routes = config\n                .routes\n                .iter()\n                .flat_map(|&route| {\n                    if route.is_ipv4() {\n                        route.sub_all(lan_ipv4_networks.iter().cloned())\n                    } else {\n                        route.sub_all(lan_ipv6_networks.iter().cloned())\n                    }\n                })\n                .collect();\n            config.routes = routes;\n        }\n    }\n    fn prepare_tun_config_for_custom_dns(&self, config: &mut TunConfig) {\n        if let Some(custom_dns_servers) = self.custom_dns_servers.clone() {\n            config.dns_servers = custom_dns_servers;\n        }\n    }\n    pub fn bypass(&mut self, socket: RawFd) -> Result<(), Error> {\n        let env = JnixEnv::from(\n            self.jvm\n                .attach_current_thread_as_daemon()\n                .map_err(Error::AttachJvmToThread)?,\n        );\n        let create_tun_method = env\n            .get_method_id(&self.class, \"bypass\", \"(I)Z\")\n            .map_err(|cause| Error::FindMethod(\"bypass\", cause))?;\n        let result = env\n            .call_method_unchecked(\n                self.object.as_obj(),\n                create_tun_method,\n                JavaType::Primitive(Primitive::Boolean),\n                &[JValue::Int(socket)],\n            )\n            .map_err(|cause| Error::CallMethod(\"bypass\", cause))?;\n        match result {\n            JValue::Bool(0) => Err(Error::Bypass),\n            JValue::Bool(_) => Ok(()),\n            value => Err(Error::InvalidMethodResult(\"bypass\", format!(\"{:?}\", value))),\n        }\n    }\n    fn call_method(\n        &self,\n        name: &'static str,\n        signature: &str,\n        return_type: JavaType,\n        parameters: &[JValue<'_>],\n    ) -> Result<JValue<'_>, Error> {\n        let env = JnixEnv::from(\n            self.jvm\n                .attach_current_thread_as_daemon()\n                .map_err(Error::AttachJvmToThread)?,\n        );\n        let method_id = env\n            .get_method_id(&self.class, name, signature)\n            .map_err(|cause| Error::FindMethod(name, cause))?;\n        env.call_method_unchecked(self.object.as_obj(), method_id, return_type, parameters)\n            .map_err(|cause| Error::CallMethod(name, cause))\n    }\n    fn env(&self) -> Result<JnixEnv<'_>, Error> {\n        let jni_env = self\n            .jvm\n            .attach_current_thread_as_daemon()\n            .map_err(Error::AttachJvmToThread)?;\n        Ok(JnixEnv::from(jni_env))\n    }\n}\npub struct VpnServiceTun {\n    tunnel: RawFd,\n    jvm: JavaVM,\n    class: GlobalRef,\n    object: GlobalRef,\n}\nimpl VpnServiceTun {\n    pub fn interface_name(&self) -> &str {\n        \"tun\"\n    }\n    pub fn bypass(&mut self, socket: RawFd) -> Result<(), Error> {\n        let env = JnixEnv::from(\n            self.jvm\n                .attach_current_thread_as_daemon()\n                .map_err(Error::AttachJvmToThread)?,\n        );\n        let create_tun_method = env\n            .get_method_id(&self.class, \"bypass\", \"(I)Z\")\n            .map_err(|cause| Error::FindMethod(\"bypass\", cause))?;\n        let result = env\n            .call_method_unchecked(\n                self.object.as_obj(),\n                create_tun_method,\n                JavaType::Primitive(Primitive::Boolean),\n                &[JValue::Int(socket)],\n            )\n            .map_err(|cause| Error::CallMethod(\"bypass\", cause))?;\n        if !bool::from_java(&env, result) {\n            return Err(Error::Bypass);\n        }\n        Ok(())\n    }\n}\nimpl AsRawFd for VpnServiceTun {\n    fn as_raw_fd(&self) -> RawFd {\n        self.tunnel\n    }\n}\nimpl Default for TunConfig {\n    fn default() -> Self {\n        TunConfig {\n            addresses: vec![IpAddr::V4(Ipv4Addr::new(10, 0, 0, 1))],\n            dns_servers: Vec::new(),\n            routes: vec![\n                IpNetwork::new(IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0)), 0)\n                    .expect(\"Invalid IP network prefix for IPv4 address\"),\n                IpNetwork::new(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), 0)\n                    .expect(\"Invalid IP network prefix for IPv6 address\"),\n            ],\n            required_routes: vec![],\n            mtu: 1380,\n        }\n    }\n}\n#[derive(FromJava)]\n#[jnix(package = \"net.mullvad.talpid\")]\nenum CreateTunResult {\n    Success { tun_fd: i32 },\n    InvalidDnsServers { addresses: Vec<IpAddr> },\n    PermissionDenied,\n    TunnelDeviceError,\n}\nimpl From<CreateTunResult> for Result<RawFd, Error> {\n    fn from(result: CreateTunResult) -> Self {\n        match result {\n            CreateTunResult::Success { tun_fd } => Ok(tun_fd),\n            CreateTunResult::InvalidDnsServers { addresses } => {\n                Err(Error::InvalidDnsServers(addresses))\n            }\n            CreateTunResult::PermissionDenied => Err(Error::PermissionDenied),\n            CreateTunResult::TunnelDeviceError => Err(Error::TunnelDeviceError),\n        }\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "public static int decompress(\n            final Object inputBase,\n            final long inputAddress,\n            final long inputLimit,\n            final Object outputBase,\n            final long outputAddress,\n            final long outputLimit)\n            throws MalformedInputException\n    {\n        if (inputAddress == inputLimit) {\n            return 0;\n        }\n        final long fastOutputLimit = outputLimit - SIZE_OF_LONG;\n        long input = inputAddress;\n        long output = outputAddress;\n        while (input < inputLimit) {\n            boolean firstCommand = true;\n            int lastLiteralLength = 0;\n            while (true) {\n                if (input >= inputLimit) {\n                    throw new MalformedInputException(input - inputAddress);\n                }\n                int command = UNSAFE.getByte(inputBase, input++) & 0xFF;\n                int matchLength;\n                int matchOffset;\n                int literalLength;\n                if ((command & 0b1111_0000) == 0b0000_0000) {\n                    if (lastLiteralLength == 0) {\n                        matchOffset = 0;\n                        matchLength = 0;\n                        literalLength = command & 0b1111;\n                        if (literalLength == 0) {\n                            literalLength = 0b1111;\n                            int nextByte = 0;\n                            while (input < inputLimit && (nextByte = UNSAFE.getByte(inputBase, input++) & 0xFF) == 0) {\n                                literalLength += 0b1111_1111;\n                            }\n                            literalLength += nextByte;\n                        }\n                        literalLength += 3;\n                    }\n                    else if (lastLiteralLength <= 3) {\n                        matchLength = 2;\n                        if (input >= inputLimit) {\n                            throw new MalformedInputException(input - inputAddress);\n                        }\n                        matchOffset = (command & 0b1100) >>> 2;\n                        matchOffset |= (UNSAFE.getByte(inputBase, input++) & 0xFF) << 2;\n                        literalLength = (command & 0b0000_0011);\n                    }\n                    else {\n                        matchLength = 3;\n                        if (input >= inputLimit) {\n                            throw new MalformedInputException(input - inputAddress);\n                        }\n                        matchOffset = (command & 0b1100) >>> 2;\n                        matchOffset |= (UNSAFE.getByte(inputBase, input++) & 0xFF) << 2;\n                        matchOffset |= 0b1000_0000_0000;\n                        literalLength = (command & 0b0000_0011);\n                    }\n                }\n                else if (firstCommand) {\n                    matchLength = 0;\n                    matchOffset = 0;\n                    literalLength = command - 17;\n                }\n                else if ((command & 0b1111_0000) == 0b0001_0000) {\n                    matchLength = command & 0b111;\n                    if (matchLength == 0) {\n                        matchLength = 0b111;\n                        int nextByte = 0;\n                        while (input < inputLimit && (nextByte = UNSAFE.getByte(inputBase, input++) & 0xFF) == 0) {\n                            matchLength += 0b1111_1111;\n                        }\n                        matchLength += nextByte;\n                    }\n                    matchLength += 2;\n                    if (input + SIZE_OF_SHORT > inputLimit) {\n                        throw new MalformedInputException(input - inputAddress);\n                    }\n                    int trailer = UNSAFE.getShort(inputBase, input) & 0xFFFF;\n                    input += SIZE_OF_SHORT;\n                    matchOffset = (command & 0b1000) << 11;\n                    matchOffset += trailer >> 2;\n                    if (matchOffset == 0) {\n                        break;\n                    }\n                    matchOffset += 0b11_1111_1111_1111;\n                    literalLength = trailer & 0b11;\n                }\n                else if ((command & 0b1110_0000) == 0b0010_0000) {\n                    matchLength = command & 0b1_1111;\n                    if (matchLength == 0) {\n                        matchLength = 0b1_1111;\n                        int nextByte = 0;\n                        while (input < inputLimit && (nextByte = UNSAFE.getByte(inputBase, input++) & 0xFF) == 0) {\n                            matchLength += 0b1111_1111;\n                        }\n                        matchLength += nextByte;\n                    }\n                    matchLength += 2;\n                    if (input + SIZE_OF_SHORT > inputLimit) {\n                        throw new MalformedInputException(input - inputAddress);\n                    }\n                    int trailer = UNSAFE.getShort(inputBase, input) & 0xFFFF;\n                    input += SIZE_OF_SHORT;\n                    matchOffset = trailer >>> 2;\n                    literalLength = trailer & 0b11;\n                }\n                else if ((command & 0b1100_0000) != 0) {\n                    matchLength = (command & 0b1110_0000) >>> 5;\n                    matchLength += 1;\n                    if (input >= inputLimit) {\n                        throw new MalformedInputException(input - inputAddress);\n                    }\n                    matchOffset = (command & 0b0001_1100) >>> 2;\n                    matchOffset |= (UNSAFE.getByte(inputBase, input++) & 0xFF) << 3;\n                    literalLength = (command & 0b0000_0011);\n                }\n                else {\n                    String binary = toBinary(command);\n                    throw new MalformedInputException(input - 1, \"Invalid LZO command \" + binary);\n                }\n                firstCommand = false;\n                if (matchLength < 0) {\n                    throw new MalformedInputException(input - inputAddress);\n                }\n                if (matchLength != 0) {\n                    matchOffset++;\n                    long matchAddress = output - matchOffset;\n                    if (matchAddress < outputAddress || output + matchLength > outputLimit) {\n                        throw new MalformedInputException(input - inputAddress);\n                    }\n                    long matchOutputLimit = output + matchLength;\n                    if (output > fastOutputLimit) {\n                        while (output < matchOutputLimit) {\n                            UNSAFE.putByte(outputBase, output++, UNSAFE.getByte(outputBase, matchAddress++));\n                        }\n                    }\n                    else {\n                        if (matchOffset < SIZE_OF_LONG) {\n                            int increment32 = DEC_32_TABLE[matchOffset];\n                            int decrement64 = DEC_64_TABLE[matchOffset];\n                            UNSAFE.putByte(outputBase, output, UNSAFE.getByte(outputBase, matchAddress));\n                            UNSAFE.putByte(outputBase, output + 1, UNSAFE.getByte(outputBase, matchAddress + 1));\n                            UNSAFE.putByte(outputBase, output + 2, UNSAFE.getByte(outputBase, matchAddress + 2));\n                            UNSAFE.putByte(outputBase, output + 3, UNSAFE.getByte(outputBase, matchAddress + 3));\n                            output += SIZE_OF_INT;\n                            matchAddress += increment32;\n                            UNSAFE.putInt(outputBase, output, UNSAFE.getInt(outputBase, matchAddress));\n                            output += SIZE_OF_INT;\n                            matchAddress -= decrement64;\n                        }\n                        else {\n                            UNSAFE.putLong(outputBase, output, UNSAFE.getLong(outputBase, matchAddress));\n                            matchAddress += SIZE_OF_LONG;\n                            output += SIZE_OF_LONG;\n                        }\n                        if (matchOutputLimit >= fastOutputLimit) {\n                            if (matchOutputLimit > outputLimit) {\n                                throw new MalformedInputException(input - inputAddress);\n                            }\n                            while (output < fastOutputLimit) {\n                                UNSAFE.putLong(outputBase, output, UNSAFE.getLong(outputBase, matchAddress));\n                                matchAddress += SIZE_OF_LONG;\n                                output += SIZE_OF_LONG;\n                            }\n                            while (output < matchOutputLimit) {\n                                UNSAFE.putByte(outputBase, output++, UNSAFE.getByte(outputBase, matchAddress++));\n                            }\n                        }\n                        else {\n                            while (output < matchOutputLimit) {\n                                UNSAFE.putLong(outputBase, output, UNSAFE.getLong(outputBase, matchAddress));\n                                matchAddress += SIZE_OF_LONG;\n                                output += SIZE_OF_LONG;\n                            }\n                        }\n                    }\n                    output = matchOutputLimit; \n                }\n                if (literalLength < 0) {\n                    throw new MalformedInputException(input - inputAddress);\n                }\n                long literalOutputLimit = output + literalLength;\n                if (literalOutputLimit > fastOutputLimit || input + literalLength > inputLimit - SIZE_OF_LONG) {\n                    if (literalOutputLimit > outputLimit) {\n                        throw new MalformedInputException(input - inputAddress);\n                    }\n                    UNSAFE.copyMemory(inputBase, input, outputBase, output, literalLength);\n                    input += literalLength;\n                    output += literalLength;\n                }\n                else {\n                    do {\n                        UNSAFE.putLong(outputBase, output, UNSAFE.getLong(inputBase, input));\n                        input += SIZE_OF_LONG;\n                        output += SIZE_OF_LONG;\n                    }\n                    while (output < literalOutputLimit);\n                    input -= (output - literalOutputLimit); \n                    output = literalOutputLimit;\n                }\n                lastLiteralLength = literalLength;\n            }\n        }\n        return (int) (output - outputAddress);\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "async fn download_inner(\n    &self,\n    url: impl reqwest::IntoUrl,\n    maybe_header: Option<(HeaderName, HeaderValue)>,\n    progress_guard: Option<&UpdateGuard>,\n  ) -> Result<Option<Vec<u8>>, AnyError> {\n    let response = self.get_redirected_response(url, maybe_header).await?;\n    if response.status() == 404 {\n      return Ok(None);\n    } else if !response.status().is_success() {\n      let status = response.status();\n      let maybe_response_text = response.text().await.ok();\n      bail!(\n        \"Bad response: {:?}{}\",\n        status,\n        match maybe_response_text {\n          Some(text) => format!(\"\\n\\n{text}\"),\n          None => String::new(),\n        }\n      );\n    }\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "async fn main() -> Result<()> {\n    setup_logger().unwrap_or_default();\n    let args: Args = Args::parse();\n    match args.subcommand {\n        Commands::Run {\n            bearer_token,\n            http_port,\n            http_host,\n            telnet_port,\n            telnet_host,\n            cloudflare_support,\n            read_bearer_token_from_stdin\n        } => {\n            let bearer_token = bearer_token.map_or_else(|| if read_bearer_token_from_stdin {\n                let mut buf = String::new();\n                stdin().read_line(&mut buf).expect(\"failed to read from stdin\");\n                buf.trim_end().to_string()\n            } else {\n                eprintln!(\"You must set bearer token to protecting your server.\");\n                exit(1)\n            }, |token| {\n                eprintln!(\"--bearer-token is unsecure. It will be removed by next major release. Please use --read-bearer-token-from-stdin.\");\n                token\n            });\n            WRITE_TOKEN.set(bearer_token).unwrap();\n            let http_server = HttpServer::new(move || {\n                let logger_format = if cloudflare_support {\n                    r#\"%a (CF '%{CF-Connecting-IP}i') %t \"%r\" %s \"%{Referer}i\" \"%{User-Agent}i\" \"#\n                } else {\n                    r#\"%a %t \"%r\" %s \"%{Referer}i\" \"%{User-Agent}i\" \"#\n                };\n                App::new()\n                    .service(prefixed_service(\"/api\")\n                        .service(\n                            (\n                                prefixed_service(\"/article\")\n                                    .service(\n                                        (\n                                            article::create,\n                                            article::fetch,\n                                            article::update,\n                                            article::remove,\n                                        )\n                                    ),\n                                article::list,\n                                prefixed_service(\"/meta\")\n                                    .service(meta::change_id)\n                            )\n                        )\n                    )\n                    .app_data(\n                        BearerAuthConfig::default()\n                            .realm(\"Perform write operation\")\n                            .scope(\"article:write\"),\n                    )\n                    .wrap(Logger::new(logger_format))\n                    .wrap(cors_middleware_factory())\n            });\n        tokio::spawn({\n            Server::build()\n                .bind(\"echo\", (telnet_host, telnet_port), move || {\n                    fn_service(move |stream: TcpStream| {\n                        telnet_server_service(stream)\n                    })\n                })?\n                .run()\n        });\n        http_server\n                    .bind((http_host, http_port))?\n                    .run()\n                    .await\n                    .context(\"while running server\")?;\n                Ok(())\n            }\n        Commands::Import { file_path, article_id } => {\n            if !file_path.exists() {\n                bail!(\"You can not import non-existent file\")\n            }\n            if !file_path.is_file() {\n                debug!(\"is_dir: {}\", file_path.is_dir());\n                debug!(\"is_symlink: {}\", file_path.is_symlink());\n                debug!(\"metadata: {:?}\", file_path.metadata()?);\n                bail!(\"Non-file paths are not supported\")\n            }\n            let content = {\n                let mut fd = BufReader::new(File::open(file_path)?);\n                let mut buf = vec![];\n                fd.read_to_end(&mut buf)?;\n                String::from_utf8(buf)\n            };\n            match content {\n                Ok(content) => {\n                    GLOBAL_FILE.create_entry(&article_id, content).await?;\n                    info!(\"Successfully imported as {article_id}.\");\n                    Ok(())\n                }\n                Err(err) => {\n                    bail!(\"The file is not UTF-8: {err}\\\n                    Please review following list:\\\n                    - The file is not binary\\\n                    - The text is encoded with UTF-8\\\n                    Especially, importing Shift-JIS texts are NOT supported.\")\n                }\n            }\n        }\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub mod helper;\npub mod natural;\npub mod rfc3966;\npub mod valid;\npub fn parse<S: AsRef<str>>(\n    country: Option<country::Id>,\n    string: S,\n) -> Result<PhoneNumber, error::Parse> {\n    parse_with(&DATABASE, country, string)\n}\npub fn parse_with<S: AsRef<str>>(\n    database: &Database,\n    country: Option<country::Id>,\n    string: S,\n) -> Result<PhoneNumber, error::Parse> {\n    fn phone_number(i: &str) -> IResult<&str, helper::Number> {\n        parse! { i => alt((rfc3966::phone_number, natural::phone_number)) }\n    }\n    let (_, mut number) = phone_number(string.as_ref()).or(Err(error::Parse::NoNumber))?;\n    number = helper::country_code(database, country, number)?;\n    if let Some(meta) = country.and_then(|c| database.by_id(c.as_ref())) {\n        let mut potential = helper::national_number(meta, number.clone());\n        if let Some(prefix) = meta.national_prefix.as_ref() {\n            if potential.national.starts_with(prefix) {\n                potential.national = helper::trim(potential.national, prefix.len());\n            }\n        }\n        if validator::length(meta, &potential, Type::Unknown) != Validation::TooShort {\n            number = potential;\n        }\n    }\n    if number.national.len() < consts::MIN_LENGTH_FOR_NSN {\n        return Err(error::Parse::TooShortNsn);\n    }\n    if number.national.len() > consts::MAX_LENGTH_FOR_NSN {\n        return Err(error::Parse::TooLong);\n    }\n    Ok(PhoneNumber {\n        code: country::Code {\n            value: number.prefix.map(|p| p.parse()).unwrap_or(Ok(0))?,\n            source: number.country,\n        },\n        national: NationalNumber {\n            value: number.national.parse()?,\n            zeros: number.national.chars().take_while(|&c| c == '0').count() as u8,\n        },\n        extension: number.extension.map(|s| Extension(s.into_owned())),\n        carrier: number.carrier.map(|s| Carrier(s.into_owned())),\n    })\n}\n#[cfg(test)]\nmod test {\n    use crate::country;\n    use crate::national_number::NationalNumber;\n    use crate::parser;\n    use crate::phone_number::PhoneNumber;\n    #[test]\n    fn parse() {\n        let mut number = PhoneNumber {\n            code: country::Code {\n                value: 64,\n                source: country::Source::Default,\n            },\n            national: NationalNumber {\n                value: 33316005,\n                zeros: 0,\n            },\n            extension: None,\n            carrier: None,\n        };\n        number.code.source = country::Source::Default;\n        assert_eq!(\n            number,\n            parser::parse(Some(country::NZ), \"033316005\").unwrap()\n        );\n        assert_eq!(\n            number,\n            parser::parse(Some(country::NZ), \"33316005\").unwrap()\n        );\n        assert_eq!(\n            number,\n            parser::parse(Some(country::NZ), \"03-331 6005\").unwrap()\n        );\n        assert_eq!(\n            number,\n            parser::parse(Some(country::NZ), \"03 331 6005\").unwrap()\n        );\n        number.code.source = country::Source::Plus;\n        assert_eq!(\n            number,\n            parser::parse(Some(country::NZ), \"tel:03-331-6005;phone-context=+64\").unwrap()\n        );\n        assert_eq!(\n            number,\n            parser::parse(Some(country::NZ), \"tel:03-331-6005;phone-context=+64;a=%A1\").unwrap()\n        );\n        assert_eq!(\n            number,\n            parser::parse(\n                Some(country::NZ),\n                \"tel:03-331-6005;isub=12345;phone-context=+64\"\n            )\n            .unwrap()\n        );\n        assert_eq!(\n            number,\n            parser::parse(Some(country::NZ), \"tel:+64-3-331-6005;isub=12345\").unwrap()\n        );\n        assert_eq!(\n            number,\n            parser::parse(Some(country::NZ), \"03-331-6005;phone-context=+64\").unwrap()\n        );\n        number.code.source = country::Source::Idd;\n        assert_eq!(\n            number,\n            parser::parse(Some(country::NZ), \"0064 3 331 6005\").unwrap()\n        );\n        assert_eq!(\n            number,\n            parser::parse(Some(country::US), \"01164 3 331 6005\").unwrap()\n        );\n        number.code.source = country::Source::Plus;\n        assert_eq!(\n            number,\n            parser::parse(Some(country::US), \"+64 3 331 6005\").unwrap()\n        );\n        assert_eq!(\n            number,\n            parser::parse(Some(country::US), \"+01164 3 331 6005\").unwrap()\n        );\n        assert_eq!(\n            number,\n            parser::parse(Some(country::NZ), \"+0064 3 331 6005\").unwrap()\n        );\n        assert_eq!(\n            number,\n            parser::parse(Some(country::NZ), \"+ 00 64 3 331 6005\").unwrap()\n        );\n        let number = PhoneNumber {\n            code: country::Code {\n                value: 64,\n                source: country::Source::Number,\n            },\n            national: NationalNumber {\n                value: 64123456,\n                zeros: 0,\n            },\n            extension: None,\n            carrier: None,\n        };\n        assert_eq!(\n            number,\n            parser::parse(Some(country::NZ), \"64(0)64123456\").unwrap()\n        );\n        assert_eq!(\n            PhoneNumber {\n                code: country::Code {\n                    value: 49,\n                    source: country::Source::Default,\n                },\n                national: NationalNumber {\n                    value: 30123456,\n                    zeros: 0,\n                },\n                extension: None,\n                carrier: None,\n            },\n            parser::parse(Some(country::DE), \"301/23456\").unwrap()\n        );\n        assert_eq!(\n            PhoneNumber {\n                code: country::Code {\n                    value: 81,\n                    source: country::Source::Plus,\n                },\n                national: NationalNumber {\n                    value: 2345,\n                    zeros: 0,\n                },\n                extension: None,\n                carrier: None,\n            },\n            parser::parse(Some(country::JP), \"+81 *2345\").unwrap()\n        );\n        assert_eq!(\n            PhoneNumber {\n                code: country::Code {\n                    value: 64,\n                    source: country::Source::Default,\n                },\n                national: NationalNumber {\n                    value: 12,\n                    zeros: 0,\n                },\n                extension: None,\n                carrier: None,\n            },\n            parser::parse(Some(country::NZ), \"12\").unwrap()\n        );\n        assert_eq!(\n            PhoneNumber {\n                code: country::Code {\n                    value: 55,\n                    source: country::Source::Default,\n                },\n                national: NationalNumber {\n                    value: 3121286979,\n                    zeros: 0,\n                },\n                extension: None,\n                carrier: Some(\"12\".into()),\n            },\n            parser::parse(Some(country::BR), \"012 3121286979\").unwrap()\n        );\n    }\n    #[test]\n    fn issue_43() {\n        let res = parser::parse(None, \" 2 22#:\");\n        assert!(res.is_err());\n    }\n    #[test]\n    fn advisory_1() {\n        let res = parser::parse(None, \".;phone-context=\");\n        assert!(res.is_err(), \"{res:?}\");\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "async fn assert_rcc_configuration(rcc_config: &RCCConfig) -> AnyhowResult<()> {\n    let mut rcc_config_diag_command = Command::new(&rcc_config.binary_path);\n    rcc_config_diag_command\n        .arg(\"configuration\")\n        .arg(\"diagnostics\");\n    let stdout = String::from_utf8(rcc_config_diag_command.output().await?.stdout)?;\n    assert!(stdout.contains(\"telemetry-enabled                     ...  \\\"false\\\"\"));\n    assert!(stdout.contains(\"holotree-shared                       ...  \\\"true\\\"\"));\n    assert!(stdout.contains(\"holotree-global-shared                ...  \\\"true\\\"\"));\n    if let RCCProfileConfig::Custom(custom_rcc_profile_config) = &rcc_config.profile_config {\n        assert!(stdout.contains(&format!(\n            \"config-active-profile                 ...  \\\"{}\\\"\",\n            custom_rcc_profile_config.name\n        )));\n    }\n    Ok(())\n}\nasync fn assert_working_directory(\n    working_directory: &Utf8Path,\n    headed_user_name: &str,\n) -> AnyhowResult<()> {\n    assert_permissions(\n        &working_directory,\n        &format!(\"{headed_user_name}:(OI)(CI)(F)\"),\n    )\n    .await?;\n    assert!(working_directory.is_dir());\n    assert_eq!(\n        directory_entries(working_directory, 1),\n        [\"environment_building\", \"plans\", \"rcc_setup\"]\n    );\n    assert_eq!(\n        directory_entries(working_directory.join(\"rcc_setup\"), 1),\n        [\n            \"custom_profile_import_current_user.stderr\",\n            \"custom_profile_import_current_user.stdout\",\n            &format!(\"custom_profile_import_user_{headed_user_name}.bat\"),\n            &format!(\"custom_profile_import_user_{headed_user_name}.exit_code\"),\n            &format!(\"custom_profile_import_user_{headed_user_name}.stderr\"),\n            &format!(\"custom_profile_import_user_{headed_user_name}.stdout\"),\n            \"custom_profile_switch_current_user.stderr\",\n            \"custom_profile_switch_current_user.stdout\",\n            &format!(\"custom_profile_switch_user_{headed_user_name}.bat\"),\n            &format!(\"custom_profile_switch_user_{headed_user_name}.exit_code\"),\n            &format!(\"custom_profile_switch_user_{headed_user_name}.stderr\"),\n            &format!(\"custom_profile_switch_user_{headed_user_name}.stdout\"),\n            \"holotree_initialization_current_user.stderr\",\n            \"holotree_initialization_current_user.stdout\",\n            &format!(\"holotree_initialization_user_{headed_user_name}.bat\"),\n            &format!(\"holotree_initialization_user_{headed_user_name}.exit_code\"),\n            &format!(\"holotree_initialization_user_{headed_user_name}.stderr\"),\n            &format!(\"holotree_initialization_user_{headed_user_name}.stdout\"),\n            \"long_path_support_enabling.stderr\",\n            \"long_path_support_enabling.stdout\",\n            \"shared_holotree_init.stderr\",\n            \"shared_holotree_init.stdout\",\n            \"telemetry_disabling_current_user.stderr\",\n            \"telemetry_disabling_current_user.stdout\",\n            &format!(\"telemetry_disabling_user_{headed_user_name}.bat\"),\n            &format!(\"telemetry_disabling_user_{headed_user_name}.exit_code\"),\n            &format!(\"telemetry_disabling_user_{headed_user_name}.stderr\"),\n            &format!(\"telemetry_disabling_user_{headed_user_name}.stdout\")\n        ]\n    );\n    assert_eq!(\n        directory_entries(working_directory.join(\"environment_building\"), 1),\n        [\n            \"rcc_headed.bat\",\n            \"rcc_headed.exit_code\",\n            \"rcc_headed.stderr\",\n            \"rcc_headed.stdout\",\n            \"rcc_headless.stderr\",\n            \"rcc_headless.stdout\"\n        ]\n    );\n    assert_eq!(\n        directory_entries(working_directory.join(\"plans\"), 1),\n        [\"no_rcc\", \"rcc_headed\", \"rcc_headless\"]\n    );\n    assert!(!directory_entries(working_directory.join(\"plans\").join(\"no_rcc\"), 1).is_empty());\n    let entries_rcc_headed =\n        directory_entries(working_directory.join(\"plans\").join(\"rcc_headed\"), 2).join(\"\");\n    assert!(entries_rcc_headed.contains(\"rebot.xml\"));\n    assert!(entries_rcc_headed.contains(\"1.bat\"));\n    let entries_rcc_headless =\n        directory_entries(working_directory.join(\"plans\").join(\"rcc_headless\"), 2).join(\"\");\n    assert!(entries_rcc_headless.contains(\"rebot.xml\"));\n    assert!(!entries_rcc_headless.contains(\"1.bat\"));\n    Ok(())\n}\nfn rcc_setup(\n    global_config: &GlobalConfig,\n    rcc_plans: Vec<Plan>,\n    rcc_setup_failures: &mut RCCSetupFailures,\n) -> AnyhowResult<Vec<Plan>> {\n    let mut sucessful_plans: Vec<Plan>;\n    debug!(\"Disabling RCC telemetry\");\n    (sucessful_plans, rcc_setup_failures.telemetry_disabling) =\n        disable_rcc_telemetry(global_config, rcc_plans)\n            .context(\"Received termination signal while disabling RCC telemetry\")?;\n    if !rcc_setup_failures.telemetry_disabling.is_empty() {\n        error!(\n            \"Dropping the following plans due to RCC telemetry disabling failure: {}\",\n            failed_plan_ids_human_readable(rcc_setup_failures.telemetry_disabling.keys())\n        );\n    }\n    debug!(\"Configuring RCC profile\");\n    (sucessful_plans, rcc_setup_failures.profile_configuring) =\n        configure_rcc_profile(global_config, sucessful_plans)\n            .context(\"Received termination signal while configuring RCC profile\")?;\n    if !rcc_setup_failures.profile_configuring.is_empty() {\n        error!(\n            \"Dropping the following plans due to profile configuring failure: {}\",\n            failed_plan_ids_human_readable(rcc_setup_failures.profile_configuring.keys())\n        );\n    }\n    debug!(\"Enabling support for long paths\");\n    (sucessful_plans, rcc_setup_failures.long_path_support) =\n        enable_long_path_support(global_config, sucessful_plans)\n            .context(\"Received termination signal while enabling support for long paths\")?;\n    if !rcc_setup_failures.long_path_support.is_empty() {\n        error!(\n            \"Dropping the following plans due to long path support enabling failure: {}\",\n            failed_plan_ids_human_readable(rcc_setup_failures.long_path_support.keys())\n        );\n    }\n    debug!(\"Initializing shared holotree\");\n    (sucessful_plans, rcc_setup_failures.shared_holotree) =\n        shared_holotree_init(global_config, sucessful_plans)\n            .context(\"Received termination signal while initializing shared holotree\")?;\n    if !rcc_setup_failures.shared_holotree.is_empty() {\n        error!(\n            \"Dropping the following plans due to shared holotree initialization failure: {}\",\n            failed_plan_ids_human_readable(rcc_setup_failures.shared_holotree.keys())\n        );\n    }\n    debug!(\"Initializing holotree\");\n    (sucessful_plans, rcc_setup_failures.holotree_init) =\n        holotree_init(global_config, sucessful_plans)\n            .context(\"Received termination signal while initializing holotree\")?;\n    if !rcc_setup_failures.holotree_init.is_empty() {\n        error!(\n            \"Dropping the following plans due to holotree initialization failure: {}\",\n            failed_plan_ids_human_readable(rcc_setup_failures.holotree_init.keys())\n        );\n    }\n    Ok(sucessful_plans)\n}\nfn shared_holotree_init(\n    global_config: &GlobalConfig,\n    plans: Vec<Plan>,\n) -> Result<(Vec<Plan>, HashMap<String, String>), Cancelled> {\n    let mut command_spec =\n        RCCEnvironment::bundled_command_spec(&global_config.rcc_config.binary_path);\n    command_spec.add_arguments([\"holotree\", \"shared\", \"--enable\", \"--once\"]);\n    run_command_spec_once_in_current_session(\n        global_config,\n        plans,\n        &command_spec,\n        \"shared_holotree_init\",\n    )\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "You are a strict Rust security reviewer. Classify the snippet. Output EXACTLY ONE token chosen from this set: {fixed, vulnerable}. Do not add punctuation, spaces, quotes, or explanations.",
    "input": "pub fn is_verified(&self) -> bool {\n        self.own_identity.as_ref().is_some_and(|o| o.is_identity_signed(&self.inner).is_ok())\n    }\n",
    "output": "vulnerable"
  }
]