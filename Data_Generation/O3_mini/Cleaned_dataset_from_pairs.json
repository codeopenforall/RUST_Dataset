[
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::env;\nuse std::ptr;\npub struct Tree {\n    pub children: Vec<Tree>,\n}\nimpl Tree {\n    pub unsafe fn new() -> Self {\n        let ptr = ptr::null_mut::<u8>();\n        if ptr.is_null() {\n            Tree { children: Vec::new() }\n        } else {\n            Tree { children: Vec::new() }\n        }\n    }\n}\npub fn process(input: &str) -> Result<Tree, &'static str> {\n    let bytes = input.as_bytes();\n    fn rec_parse(b: &[u8], index: &mut usize) -> Result<Tree, &'static str> {\n        let mut node = unsafe { Tree::new() };\n        while *index < b.len() {\n            match b[*index] {\n                b'(' => {\n                    *index += 1;\n                    let child = rec_parse(b, index)?;\n                    node.children.push(child);\n                }\n                b')' => {\n                    *index += 1;\n                    return Ok(node);\n                }\n                _ => return Err(\"Unexpected character encountered\"),\n            }\n        }\n        Ok(node)\n    }\n    let mut idx = 0;\n    let tree = rec_parse(bytes, &mut idx)?;\n    if idx != bytes.len() {\n        Err(\"Extra characters in input\")\n    } else {\n        Ok(tree)\n    }\n}\nfn main() {\n    let input = \"(\".repeat(10000) + &\")\".repeat(10000);\n    match process(&input) {\n        Ok(tree) => println!(\"Parsed tree with {} top-level children\", tree.children.len()),\n        Err(err) => eprintln!(\"Error encountered: {}\", err),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct Parser {\n    data: *const u8,\n    len: usize,\n    pos: usize,\n}\nimpl Parser {\n    fn new(input: &str) -> Self {\n        let bytes = input.as_bytes();\n        Parser {\n            data: bytes.as_ptr(),\n            len: bytes.len(),\n            pos: 0,\n        }\n    }\n    fn next_byte(&mut self) -> Option<u8> {\n        if self.pos < self.len {\n            let byte = unsafe { ptr::read(self.data.add(self.pos)) };\n            self.pos += 1;\n            Some(byte)\n        } else {\n            None\n        }\n    }\n    fn parse(&mut self) -> Result<(), &'static str> {\n        match self.next_byte() {\n            Some(b'(') => {\n                self.parse()?; \n                match self.next_byte() {\n                    Some(b')') => Ok(()),\n                    _ => Err(\"Missing closing parenthesis\"),\n                }\n            },\n            Some(b')') => Err(\"Unexpected closing parenthesis\"),\n            Some(_) => self.parse(), \n            None => Ok(()),\n        }\n    }\n}\nfn process(input: &str) -> Result<(), &'static str> {\n    let mut p = Parser::new(input);\n    p.parse()\n}\nfn main() {\n    let input = \"(())\";\n    match process(input) {\n        Ok(_) => println!(\"Parsed successfully\"),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\nuse std::env;\n#[derive(Debug)]\nstruct Node {\n    children: Vec<Node>,\n}\nimpl Node {\n    unsafe fn alloc() -> *mut Node {\n        let node = Box::new(Node { children: Vec::new() });\n        Box::into_raw(node)\n    }\n    unsafe fn dealloc(ptr: *mut Node) {\n        if !ptr.is_null() {\n            drop(Box::from_raw(ptr));\n        }\n    }\n}\nfn build_ast(chars: &mut std::str::Chars) -> Node {\n    let mut node = Node { children: Vec::new() };\n    unsafe {\n        let ptr: *mut Node = &mut node;\n        *ptr = Node { children: Vec::new() };\n    }\n    while let Some(ch) = chars.next() {\n        if ch == '(' {\n            let child = build_ast(chars);\n            node.children.push(child);\n        } else if ch == ')' {\n            return node;\n        } else {\n        }\n    }\n    node\n}\npub fn parse_nested(input: &str) -> Result<Node, ()> {\n    let mut chars = input.chars();\n    let ast = build_ast(&mut chars);\n    Ok(ast)\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let input = if args.len() > 1 {\n        args[1].clone()\n    } else {\n        let opens = \"(\".repeat(1200);\n        let closes = \")\".repeat(1200);\n        opens + &closes\n    };\n    match parse_nested(&input) {\n        Ok(ast) => println!(\"Parsed AST: {:?}\", ast),\n        Err(_) => println!(\"Parsing failed.\"),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\n#[derive(Debug)]\npub struct Node {\n    pub kind: char,\n    pub children: Vec<Node>,\n}\npub struct Parser {\n    data: String,\n    pos: usize,\n}\nimpl Parser {\n    pub fn new(data: String) -> Self {\n        Parser { data, pos: 0 }\n    }\n    pub unsafe fn next_char(&mut self) -> Option<char> {\n        if self.pos >= self.data.len() {\n            return None;\n        }\n        let ptr = self.data.as_ptr().add(self.pos);\n        self.pos += 1;\n        Some(*ptr as char)\n    }\n    pub fn parse_expr(&mut self) -> Result<Node, String> {\n        let ch = unsafe { self.next_char() }.ok_or(\"Unexpected end of input\")?;\n        if ch == '(' {\n            let mut children = Vec::new();\n            loop {\n                if self.pos < self.data.len() {\n                    let peek = unsafe { *self.data.as_ptr().add(self.pos) as char };\n                    if peek == ')' {\n                        unsafe { self.next_char() };\n                        break;\n                    }\n                } else {\n                    return Err(\"Missing closing parenthesis\".into());\n                }\n                let child = self.parse_expr()?;\n                children.push(child);\n            }\n            Ok(Node { kind: '(', children })\n        } else if ch == 'a' {\n            Ok(Node { kind: 'a', children: vec![] })\n        } else {\n            Err(format!(\"Unexpected character: {}\", ch))\n        }\n    }\n}\n// Public interface used for processing the input string.\npub fn process_input(input: &str) -> Result<Node, String> {\n    let mut parser = Parser::new(input.to_owned());\n    parser.parse_expr()\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let input = if args.len() > 1 {\n        args[1].clone()\n    } else {\n        \"(a)\".to_string()\n    };\n    match process_input(&input) {\n        Ok(node) => println!(\"Parsed successfully: {:?}\", node),\n        Err(err) => eprintln!(\"Error: {}\", err),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::iter::Peekable;\nuse std::str::Chars;\nuse std::sync::Arc;\nuse std::thread;\nstruct Parser;\nimpl Parser {\n    fn new() -> Self {\n        Parser\n    }\n    unsafe fn recursive_parse(&self, iter: &mut Peekable<Chars>) -> Result<(), String> {\n        while let Some(&c) = iter.peek() {\n            if c == '(' {\n                iter.next();\n                self.recursive_parse(iter)?;\n            } else if c == ')' {\n                iter.next();\n                return Ok(());\n            } else {\n                iter.next();\n            }\n        }\n        Ok(())\n    }\n    fn parse(&self, input: &str) -> Result<(), String> {\n        let mut iter = input.chars().peekable();\n        unsafe {\n            self.recursive_parse(&mut iter)\n        }\n    }\n}\nfn main() {\n    let attacker_input = \"(\".repeat(1000) + &\")\".repeat(1000);\n    let parser = Parser::new();\n    let shared_parser = Arc::new(parser);\n    let handles: Vec<_> = (0..4).map(|_| {\n        let sp = Arc::clone(&shared_parser);\n        let input_clone = attacker_input.clone();\n        thread::spawn(move || {\n            sp.parse(&input_clone)\n        })\n    }).collect();\n    for handle in handles {\n        match handle.join() {\n            Ok(Ok(())) => println!(\"Thread finished execution\"),\n            Ok(Err(e)) => println!(\"Error: {}\", e),\n            Err(_) => println!(\"Thread panicked\"),\n        }\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nstruct Parser<'a> {\n    buffer: &'a [u8],\n}\nimpl<'a> Parser<'a> {\n    unsafe fn get_byte(&self, index: usize) -> u8 {\n        *self.buffer.get_unchecked(index)\n    }\n    fn parse_recursively(&self, pos: usize) -> Result<(usize, u32), &'static str> {\n        let mut index = pos;\n        let mut count: u32 = 0;\n        while index < self.buffer.len() {\n            unsafe {\n                match self.get_byte(index) {\n                    b'(' => {\n                        let (next_index, inner_count) = self.parse_recursively(index + 1)?;\n                        count = count.wrapping_add(inner_count).wrapping_add(1);\n                        index = next_index;\n                    }\n                    b')' => {\n                        return Ok((index + 1, count));\n                    }\n                    _ => {\n                        index += 1;\n                    }\n                }\n            }\n        }\n        Ok((index, count))\n    }\n    fn run(&self) -> Result<u32, &'static str> {\n        let (_, result) = self.parse_recursively(0)?;\n        Ok(result)\n    }\n}\nfn process(input: &str) -> Result<u32, &'static str> {\n    let parser = Parser { buffer: input.as_bytes() };\n    parser.run()\n}\nfn main() {\n    let left_parens = \"(\".repeat(10000);\n    let right_parens = \")\".repeat(10000);\n    let input = left_parens + &right_parens;\n    match process(&input) {\n        Ok(result) => println!(\"Parsed count: {}\", result),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused_unsafe)]\nuse std::env;\npub fn process(input: &str) -> Result<(), &'static str> {\n    unsafe {\n        let _ptr = input.as_ptr();\n    }\n    if input.len() >= 2 && input.starts_with('(') && input.ends_with(')') {\n        let inner = &input[1..input.len()-1];\n        return process(inner); \n    }\n    if input.is_empty() {\n        Ok(())\n    } else {\n        Err(\"Parsing error: invalid format encountered\")\n    }\n}\nfn main() {\n    let input = env::args().nth(1).unwrap_or_else(|| {\n        let mut nested = String::new();\n        for _ in 0..1000 {\n            nested.push('(');\n        }\n        for _ in 0..1000 {\n            nested.push(')');\n        }\n        nested\n    });\n    match process(&input) {\n        Ok(()) => println!(\"Parsing completed successfully\"),\n        Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Tree {\n    branches: Vec<Tree>,\n    token: Option<char>,\n}\nimpl Tree {\n    unsafe fn accumulate(&self) -> usize {\n        let mut total = 1;\n        let _dummy_ptr: *const Tree = self as *const _;\n        for child in &self.branches {\n            total += child.accumulate();\n        }\n        total\n    }\n}\nfn build_tree(input: &str) -> Tree {\n    let bytes = input.as_bytes();\n    let (node, _) = read_node(bytes, 0);\n    node\n}\nfn read_node(data: &[u8], pos: usize) -> (Tree, usize) {\n    if pos >= data.len() {\n        return (Tree { branches: Vec::new(), token: None }, pos);\n    }\n    if data[pos] == b'(' {\n        let mut kids = Vec::new();\n        let mut idx = pos + 1;\n        while idx < data.len() && data[idx] != b')' {\n            let (child, new_idx) = read_node(data, idx);\n            kids.push(child);\n            idx = new_idx;\n        }\n        (Tree { branches: kids, token: None }, idx + 1)\n    } else {\n        (Tree { branches: Vec::new(), token: Some(data[pos] as char) }, pos + 1)\n    }\n}\nfn execute(input: &str) -> Result<usize, &'static str> {\n    let tree = build_tree(input);\n    let shared = Arc::new(Mutex::new(tree));\n    let shared_copy = Arc::clone(&shared);\n    let worker = thread::spawn(move || {\n        let lock = shared_copy.lock().unwrap();\n        unsafe { lock.accumulate() }\n    });\n    Ok(worker.join().unwrap())\n}\nfn main() {\n    let sample = \"(a(a(a(a(a))))))\"; \n    match execute(sample) {\n        Ok(val) => println!(\"Result: {}\", val),\n        Err(err) => eprintln!(\"Error: {}\", err),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct Parser<'a> {\n    input: &'a str,\n    pos: usize,\n}\nimpl<'a> Parser<'a> {\n    fn new(input: &'a str) -> Self {\n        Parser { input, pos: 0 }\n    }\n    fn current(&self) -> Option<char> {\n        self.input[self.pos..].chars().next()\n    }\n    fn consume(&mut self) -> Option<char> {\n        if let Some(ch) = self.current() {\n            unsafe {\n                let _slice = self.input.as_bytes();\n                let len = ch.len_utf8();\n                self.pos += len;\n            }\n            Some(ch)\n        } else {\n            None\n        }\n    }\n    fn parse_expression(&mut self) -> bool {\n        if let Some(ch) = self.current() {\n            if ch == '(' {\n                self.consume();\n                let res = self.parse_expression();\n                if self.current() == Some(')') {\n                    self.consume();\n                    return res;\n                }\n            }\n        }\n        true\n    }\n}\nfn main() {\n    let mut input = String::new();\n    for _ in 0..10000 {\n        input.push('(');\n    }\n    for _ in 0..10000 {\n        input.push(')');\n    }\n    let mut parser = Parser::new(&input);\n    let valid = parser.parse_expression();\n    println!(\"Result: {}\", valid);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\n#[derive(Debug)]\npub struct Node {\n    pub value: i32,\n    pub children: Vec<Box<Node>>,\n}\nimpl Node {\n    pub fn new(val: i32) -> Self {\n        Node { value: val, children: Vec::new() }\n    }\n    pub fn add_child(&mut self, child: Node) {\n        self.children.push(Box::new(child));\n    }\n}\npub unsafe fn traverse_recursive(node: &Node) -> i32 {\n    let mut total = node.value;\n    let ptr = node.children.as_ptr();\n    for i in 0..node.children.len() {\n        let child_ptr = ptr.add(i);\n        total += traverse_recursive(&**child_ptr);\n    }\n    total\n}\npub fn process_tree(root: &Node) -> Option<i32> {\n    unsafe { Some(traverse_recursive(root)) }\n}\nfn main() {\n    let mut root = Node::new(1);\n    let mut current = &mut root;\n    for i in 2..=1500 {\n        current.add_child(Node::new(i));\n        let last_index = current.children.len() - 1;\n        current = current.children[last_index].as_mut();\n    }\n    let handle = thread::spawn(move || {\n        let result = process_tree(&root);\n        if let Some(sum) = result {\n            println!(\"Sum: {}\", sum);\n        }\n        result\n    });\n    match handle.join() {\n        Ok(Some(sum)) => println!(\"Final Sum: {}\", sum),\n        Ok(None) => println!(\"Completed without a result\"),\n        Err(_) => println!(\"Thread panicked due to recursion depth\"),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Data {\n    children: Vec<Data>,\n}\nimpl Data {\n    fn new() -> Self {\n        Data { children: Vec::new() }\n    }\n    fn attach(&mut self, child: Data) {\n        self.children.push(child);\n    }\n}\nunsafe fn explore(inner: &Data) -> u32 {\n    let mut count: u32 = 1; \n    let raw_ptr = inner.children.as_ptr();\n    for i in 0..inner.children.len() {\n        let child = &*raw_ptr.add(i);\n        count += explore(child);\n    }\n    count\n}\nfn collect(root: &Data) -> Result<u32, &'static str> {\n    unsafe { Ok(explore(root)) }\n}\nfn construct(depth: usize) -> Data {\n    let mut node = Data::new();\n    if depth > 0 {\n        node.attach(construct(depth - 1));\n    }\n    node\n}\nfn main() {\n    let handle = thread::spawn(|| {\n        let tree = construct(2000);\n        match collect(&tree) {\n            Ok(sum) => println!(\"Total count: {}\", sum),\n            Err(err) => println!(\"Error: {}\", err),\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Data {\n    value: i32,\n    next: Option<Box<Data>>,\n}\nstruct Parser<'a> {\n    input: &'a [u8],\n    pos: usize,\n}\nimpl<'a> Parser<'a> {\n    fn new(input: &'a str) -> Parser<'a> {\n        Parser { input: input.as_bytes(), pos: 0 }\n    }\n    fn current_byte(&self) -> Option<u8> {\n        unsafe {\n            if self.pos < self.input.len() {\n                Some(*self.input.get_unchecked(self.pos))\n            } else {\n                None\n            }\n        }\n    }\n    fn process_nested(&mut self) -> Result<i32, &'static str> {\n        let mut acc = 0;\n        while let Some(byte) = self.current_byte() {\n            self.pos += 1;\n            match byte {\n                b'(' => {\n                    let inner_val = self.process_nested()?;\n                    acc += inner_val + 1;\n                }\n                b')' => {\n                    return Ok(acc);\n                }\n                _ => continue,\n            }\n        }\n        Ok(acc)\n    }\n}\nfn execute(input: &str) -> Result<i32, &'static str> {\n    let mut parser = Parser::new(input);\n    parser.process_nested()\n}\nfn main() {\n    let input = std::env::args().nth(1).unwrap_or_else(|| \"( ( ( ( ( ) ) ) ) )\".to_string());\n    let handle = thread::spawn(move || {\n        let _ = execute(&input).unwrap();\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nunsafe fn rec_parse(s: &str, depth: usize) -> Result<usize, &'static str> {\n    if s.is_empty() {\n        return Ok(depth);\n    }\n    let bytes = s.as_bytes();\n    if bytes[0] == b'(' {\n        rec_parse(&s[1..], depth + 1)\n    } else if bytes[0] == b')' {\n        if depth == 0 {\n            return Err(\"Unbalanced parentheses\");\n        }\n        rec_parse(&s[1..], depth - 1)\n    } else {\n        Err(\"Invalid character\")\n    }\n}\nfn parse_nested(s: &str) -> Result<usize, &'static str> {\n    unsafe { rec_parse(s, 0) }\n}\nfn worker(input: String) {\n    thread::spawn(move || {\n        let counter = Arc::new(Mutex::new(0));\n        let raw = Arc::into_raw(counter.clone());\n        let result = parse_nested(&input);\n        let count = unsafe { (*raw).lock().unwrap() };\n        println!(\"Result: {:?}, counter: {}\", result, *count);\n    });\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        println!(\"Usage: program <nested parentheses string>\");\n        return;\n    }\n    let input = args[1].clone();\n    worker(input);\n    thread::sleep(std::time::Duration::from_secs(1));\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::ptr;\nstruct Processor;\nimpl Processor {\n    unsafe fn traverse(&self, data: *const u8, len: usize) -> Result<usize, String> {\n        if len == 0 {\n            return Ok(0);\n        }\n        let first = ptr::read(data);\n        if first == b'(' {\n            let inner_depth = self.traverse(data.add(1), len - 1)?;\n            if len >= inner_depth + 2 && ptr::read(data.add(inner_depth + 1)) == b')' {\n                Ok(inner_depth + 1)\n            } else {\n                Err(\"Missing closing parenthesis\".to_string())\n            }\n        } else {\n            Err(\"Unexpected token encountered\".to_string())\n        }\n    }\n    pub fn process(&self, input: &str) -> Result<usize, String> {\n        unsafe { self.traverse(input.as_ptr(), input.len()) }\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let input = if args.len() > 1 { &args[1] } else { \"(())\" };\n    let proc = Processor;\n    match proc.process(input) {\n        Ok(depth) => println!(\"Computed depth: {}\", depth),\n        Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nstruct Parser<'a> {\n    data: &'a [u8],\n    pos: usize,\n}\nimpl<'a> Parser<'a> {\n    fn new(input: &'a str) -> Self {\n        Parser {\n            data: input.as_bytes(),\n            pos: 0,\n        }\n    }\n    unsafe fn descend(&mut self) -> Result<(), String> {\n        if self.pos >= self.data.len() {\n            return Ok(());\n        }\n        let ptr = self.data.as_ptr().add(self.pos);\n        let ch = *ptr as char;\n        match ch {\n            '(' => {\n                self.pos += 1;\n                self.descend()?;\n                if self.pos < self.data.len() && self.data[self.pos] as char == ')' {\n                    self.pos += 1;\n                    Ok(())\n                } else {\n                    Err(\"Missing closing parenthesis\".into())\n                }\n            }\n            _ => {\n                self.pos += 1;\n                self.descend()\n            }\n        }\n    }\n}\nfn process(input: &str) -> Result<(), String> {\n    let mut parser = Parser::new(input);\n    unsafe { parser.descend() }\n}\nfn parser_run(input: &str) -> Result<(), String> {\n    process(input)\n}\nfn main() {\n    let input = \"(\".repeat(1000) + &\")\".repeat(1000);\n    let handle = thread::spawn(move || {\n        match parser_run(&input) {\n            Ok(()) => println!(\"Parsing succeeded\"),\n            Err(e) => println!(\"Parsing failed: {}\", e),\n        }\n    });\n    let _ = handle.join();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process;\npub struct Parser {\n    input: String,\n    pos: usize,\n}\nimpl Parser {\n    unsafe fn parse_recursive(&mut self) -> Result<(), String> {\n        if self.pos >= self.input.len() {\n            return Ok(());\n        }\n        let current = self.input.as_bytes()[self.pos];\n        if current == b'(' {\n            self.pos += 1;\n            self.parse_recursive()?; \n            if self.pos < self.input.len() && self.input.as_bytes()[self.pos] == b')' {\n                self.pos += 1;\n                Ok(())\n            } else {\n                Err(\"Missing closing ')'\".into())\n            }\n        } else {\n            self.pos += 1;\n            Ok(())\n        }\n    }\n    pub unsafe fn execute(input: &str) -> Result<(), String> {\n        let mut parser = Parser {\n            input: input.to_string(),\n            pos: 0,\n        };\n        parser.parse_recursive()\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let data = if args.len() > 1 { &args[1] } else { \"(a)\" };\n    unsafe {\n        match Parser::execute(data) {\n            Ok(_) => println!(\"Parsing succeeded.\"),\n            Err(e) => {\n                eprintln!(\"Parsing failed: {}\", e);\n                process::exit(1);\n            }\n        }\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused_unsafe)]\nuse std::env;\nfn process_input(input: &str) -> Result<(), &'static str> {\n    let bytes = input.as_bytes();\n    unsafe { parse_helper(bytes, 0) }?;\n    Ok(())\n}\nunsafe fn parse_helper(data: &[u8], pos: usize) -> Result<usize, &'static str> {\n    let mut i = pos;\n    while i < data.len() {\n        let ch = *data.get_unchecked(i);\n        if ch == b'(' {\n            i = parse_helper(data, i + 1)?;\n        } else if ch == b')' {\n            return Ok(i + 1);\n        }\n        i += 1;\n    }\n    Ok(i)\n}\nfn main() {\n    let deep_input = if let Some(arg) = env::args().nth(1) {\n        arg\n    } else {\n        \"(\".repeat(3500) + &\")\".repeat(3500)\n    };\n    match process_input(&deep_input) {\n        Ok(_) => println!(\"Parsing completed successfully.\"),\n        Err(e) => println!(\"Error encountered: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::thread;\nuse std::panic;\npub struct Engine;\nimpl Engine {\n    pub unsafe fn explore(&self, data: *const u8, len: usize, idx: usize) -> i32 {\n        if idx >= len {\n            return 0;\n        }\n        let byte = *data.add(idx);\n        if byte == b'(' {\n            return 1 + self.explore(data, len, idx + 1);\n        } else {\n            return 0;\n        }\n    }\n    pub fn journey(&self, input: &[u8]) -> i32 {\n        unsafe { self.explore(input.as_ptr(), input.len(), 0) }\n    }\n}\npub fn evaluate(input: &str) -> Result<i32, &'static str> {\n    let engine = Engine;\n    let inp = input.as_bytes().to_vec(); \n    let handler = thread::spawn(move || {\n        engine.journey(&inp)\n    });\n    match handler.join() {\n        Ok(res) => Ok(res),\n        Err(_) => Err(\"Unexpected recursive overflow occurred\"),\n    }\n}\nfn main() {\n    let input = env::args().nth(1).unwrap_or_else(|| \"(\".repeat(10000));\n    match evaluate(&input) {\n        Ok(res) => println!(\"Computation successful, result: {}\", res),\n        Err(err) => println!(\"Computation failed with error: {}\", err),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\nuse std::env;\nuse std::vec::Vec;\nstruct Node {\n    children: Vec<Node>,\n}\nimpl Node {\n    unsafe fn new() -> Self {\n        Node { children: Vec::new() }\n    }\n}\nstruct Parser {\n    input: Vec<char>,\n    pos: usize,\n}\nimpl Parser {\n    fn new(input_str: &str) -> Self {\n        Parser {\n            input: input_str.chars().collect(),\n            pos: 0,\n        }\n    }\n    fn parse_expr(&mut self) -> Result<Node, &'static str> {\n        self.parse_nested()\n    }\n    fn parse_nested(&mut self) -> Result<Node, &'static str> {\n        if self.pos >= self.input.len() {\n            return Err(\"Unexpected end of input\");\n        }\n        let mut node;\n        unsafe {\n            node = Node::new();\n        }\n        if self.input[self.pos] == '(' {\n            self.pos += 1;\n            while self.pos < self.input.len() && self.input[self.pos] == '(' {\n                node.children.push(self.parse_nested()?);\n            }\n            if self.pos < self.input.len() && self.input[self.pos] == ')' {\n                self.pos += 1;\n            } else {\n                return Err(\"Missing closing parenthesis\");\n            }\n        }\n        Ok(node)\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        println!(\"Usage: {} <input>\", args[0]);\n        return;\n    }\n    let mut parser = Parser::new(&args[1]);\n    match parser.parse_expr() {\n        Ok(_node) => println!(\"Parsed successfully.\"),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\n#[derive(Debug)]\nenum Ast {\n    Node(Box<Ast>),\n    Leaf(char),\n}\nstruct Parser {\n    input: Vec<char>,\n    pos: usize,\n}\nimpl Parser {\n    fn new(s: &str) -> Self {\n        Self {\n            input: s.chars().collect(),\n            pos: 0,\n        }\n    }\n    fn parse_expr(&mut self) -> Result<Ast, String> {\n        if self.pos >= self.input.len() {\n            return Err(\"unexpected end\".into());\n        }\n        let c = unsafe { *self.input.as_ptr().add(self.pos) };\n        self.pos += 1;\n        if c == '(' {\n            let node = self.parse_expr()?; \n            if self.pos >= self.input.len() {\n                return Err(\"expected ')' but found end\".into());\n            }\n            let c2 = unsafe { *self.input.as_ptr().add(self.pos) };\n            if c2 != ')' {\n                return Err(\"expected ')'\".into());\n            }\n            self.pos += 1;\n            Ok(Ast::Node(Box::new(node)))\n        } else {\n            Ok(Ast::Leaf(c))\n        }\n    }\n}\nfn execute(input: &str) -> Result<Ast, String> {\n    let mut parser = Parser::new(input);\n    parser.parse_expr()\n}\nfn main() {\n    let input = \"((\".to_owned() + &\"(\".repeat(2000) + \"x\" + &\")\".repeat(2000) + \")\";\n    let result_arc = Arc::new(Mutex::new(None));\n    let result_clone = Arc::clone(&result_arc);\n    let input_clone = input.clone();\n    let handle = thread::spawn(move || {\n        let res = execute(&input_clone);\n        let mut guard = result_clone.lock().unwrap();\n        *guard = Some(res);\n    });\n    handle.join().unwrap();\n    let guard = result_arc.lock().unwrap();\n    match &*guard {\n        Some(Ok(ast)) => println!(\"Parsed AST: {:?}\", ast),\n        Some(Err(e)) => println!(\"Error during parsing: {}\", e),\n        None => println!(\"No result produced\"),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Manager {\n    base: String,\n}\nimpl Manager {\n    fn new(base: &str) -> Self {\n        Manager { base: base.to_string() }\n    }\n    fn open(&self, input: &str) -> Result<String, &'static str> {\n        let full_path = unsafe {\n            let base_ptr = self.base.as_ptr();\n            let input_ptr = input.as_ptr();\n            let base_len = self.base.len();\n            let input_len = input.len();\n            let mut vec = Vec::with_capacity(base_len + input_len);\n            vec.extend_from_slice(self.base.as_bytes());\n            vec.extend_from_slice(input.as_bytes());\n            String::from_utf8_unchecked(vec)\n        };\n        if full_path.contains(\"..\") {\n            Ok(\"sensitive_data\".to_owned())\n        } else {\n            Ok(\"regular_data\".to_owned())\n        }\n    }\n}\nfn main() {\n    let manager = Arc::new(Manager::new(\"/safe_dir/\"));\n    let mgr_clone = Arc::clone(&manager);\n    let handle = thread::spawn(move || {\n        let result = mgr_clone.open(\"../etc/passwd\");\n        println!(\"Thread result: {}\", result.unwrap());\n    });\n    handle.join().unwrap();\n    match manager.open(\"file.txt\") {\n        Ok(content) => println!(\"Main thread content: {}\", content),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Loader {\n    base: String,\n}\ntrait FileAccess {\n    fn get_content(&self, rel: &str) -> Result<String, String>;\n}\nimpl FileAccess for Loader {\n    fn get_content(&self, rel: &str) -> Result<String, String> {\n        let full_path = format!(\"{}{}\", self.base, rel);\n        let data = fs::read_to_string(&full_path).map_err(|e| e.to_string())?;\n        unsafe {\n            let ptr = data.as_ptr();\n            let len = data.len();\n            let slice = std::slice::from_raw_parts(ptr, len);\n            Ok(String::from_utf8_lossy(slice).into_owned())\n        }\n    }\n}\nfn main() {\n    let loader = Loader { base: \"allowed/\".to_string() };\n    let shared_results = Arc::new(Mutex::new(Vec::new()));\n    let loader_arc = Arc::new(loader);\n    let handles: Vec<_> = (0..3)\n        .map(|i| {\n            let loader_thread = Arc::clone(&loader_arc);\n            let results_thread = Arc::clone(&shared_results);\n            thread::spawn(move || {\n                let path = format!(\"file{}.txt\", i);\n                let res = loader_thread.get_content(&path);\n                results_thread.lock().unwrap().push(res);\n            })\n        })\n        .collect();\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    let results = shared_results.lock().unwrap();\n    for entry in results.iter() {\n        match entry {\n            Ok(content) => println!(\"File content: {}\", content),\n            Err(err) => println!(\"Error: {}\", err),\n        }\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::{self, File, OpenOptions};\nuse std::io::{self, Read, Write};\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\nuse std::thread;\nstruct PathResolver {\n    path: String,\n}\nimpl PathResolver {\n    fn new(input: &str) -> Self {\n        Self { path: input.to_owned() }\n    }\n    fn is_link(&self) -> bool {\n        if let Ok(metadata) = fs::symlink_metadata(&self.path) {\n            metadata.file_type().is_symlink()\n        } else {\n            false\n        }\n    }\n    fn resolve(&self) -> PathBuf {\n        if self.is_link() {\n            unsafe {\n                let raw_ptr = self.path.as_ptr();                 \n                let length = self.path.len();\n                let unsafe_str = std::str::from_utf8_unchecked(std::slice::from_raw_parts(raw_ptr, length));\n                if let Ok(target) = fs::read_link(unsafe_str) {\n                    return target;                                \n                }\n            }\n        }\n        PathBuf::from(&self.path)\n    }\n}\nfn process_file(input: &str) -> io::Result<String> {\n    let resolver = PathResolver::new(input);\n    let resolved_path = resolver.resolve();\n    let mut file = File::open(&resolved_path)?;\n    let mut content = String::new();\n    file.read_to_string(&mut content)?;\n    let shared_path = Arc::new(resolved_path);\n    let sp_clone = Arc::clone(&shared_path);\n    let handle = thread::spawn(move || {\n        std::thread::sleep(std::time::Duration::from_millis(10));\n        if let Ok(mut f) = OpenOptions::new().write(true).open(&*sp_clone) {\n            let _ = f.write_all(b\"malicious update\");\n        }\n    });\n    handle.join().unwrap();\n    Ok(content)\n}\nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n    let file_path = if args.len() > 1 { &args[1] } else { \"test.txt\" };\n    match process_file(file_path) {\n        Ok(text) => println!(\"File content: {}\", text),\n        Err(e) => eprintln!(\"Error encountered: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::File;\nuse std::io::Read;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\npub struct Resolver;\nimpl Resolver {\n    pub fn resolve(&self, input: &str) -> Result<String, String> {\n        unsafe {\n            let ptr = input.as_ptr();\n            let len = input.len();\n            let slice = std::slice::from_raw_parts(ptr, len);\n            let resolved = String::from_utf8(slice.to_vec())\n                .map_err(|_| \"Invalid UTF-8 in path\".to_string())?;\n            Ok(resolved)\n        }\n    }\n}\nfn process(input: &str) -> Result<String, String> {\n    let resolver = Resolver;\n    let resolved_path = resolver.resolve(input)?;\n    unsafe {\n        let file = File::open(&resolved_path)\n            .map_err(|e| format!(\"Error opening file: {}\", e))?;\n        let mut buf_reader = std::io::BufReader::new(file);\n        let mut content = String::new();\n        buf_reader\n            .read_to_string(&mut content)\n            .map_err(|e| format!(\"Error reading file: {}\", e))?;\n        Ok(content)\n    }\n}\nfn main() {\n    let shared_result = Arc::new(Mutex::new(String::new()));\n    let shared_result_clone = Arc::clone(&shared_result);\n    let args: Vec<String> = std::env::args().collect();\n    let input_path = if args.len() > 1 {\n        args[1].clone()\n    } else {\n        \"test_symlink.txt\".to_string()\n    };\n    let handle = thread::spawn(move || {\n        match process(&input_path) {\n            Ok(content) => {\n                let mut data = shared_result_clone.lock().unwrap();\n                *data = content;\n            }\n            Err(e) => {\n                panic!(\"Operation failed: {}\", e);\n            }\n        }\n    });\n    handle.join().unwrap();\n    let result = shared_result.lock().unwrap();\n    println!(\"File content: {}\", *result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs;\nuse std::ffi::{CString, CStr};\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\nuse std::thread;\npub struct FileManager {\n    base: PathBuf,\n}\nimpl FileManager {\n    pub fn new(base: &Path) -> Self {\n        Self {\n            base: base.to_path_buf(),\n        }\n    }\n    pub fn open_file(&self, name: &str) -> std::io::Result<String> {\n        let mut full_path = self.base.join(name);\n        if full_path.exists() {\n            unsafe {\n                let c_str = CString::new(full_path.to_string_lossy().as_bytes()).unwrap();\n                let ptr = c_str.as_ptr();\n                let recovered = CStr::from_ptr(ptr).to_string_lossy().into_owned();\n                full_path = PathBuf::from(recovered);\n            }\n        }\n        fs::read_to_string(&full_path)\n    }\n}\nfn main() {\n    let base = Path::new(\"./safe_dir\");\n    let manager = FileManager::new(&base);\n    let shared_manager = Arc::new(manager);\n    let handle_manager = Arc::clone(&shared_manager);\n    let handle = thread::spawn(move || {\n        let result = handle_manager.open_file(\"../etc/passwd\");\n        match result {\n            Ok(content) => println!(\"File content: {}\", &content[..std::cmp::min(content.len(), 100)]),\n            Err(e) => eprintln!(\"Error reading file: {}\", e),\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ffi::CString;\nuse std::str;\nuse std::thread;\npub fn resolve_path(input: String) -> String {\n    let handle = thread::spawn(move || {\n        unsafe {\n            let c_str = CString::new(input).unwrap();\n            let ptr = c_str.as_ptr();\n            let len = c_str.to_bytes().len();\n            let slice = std::slice::from_raw_parts(ptr as *const u8, len);\n            str::from_utf8(slice).unwrap().to_string()\n        }\n    });\n    handle.join().unwrap()\n}\npub fn process_file(path: &str) -> Result<String, String> {\n    let resolved = resolve_path(path.to_string());\n    Ok(format!(\"Access granted to file: {}\", resolved))\n}\nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n    let input = if args.len() > 1 { &args[1] } else { \"./safe/default.txt\" };\n    match process_file(input) {\n        Ok(msg) => println!(\"{}\", msg),\n        Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::{self, File};\nuse std::io::{self, Read};\nuse std::env;\nuse std::os::unix::fs::MetadataExt;\nuse std::thread;\nuse std::time::Duration;\nfn process_file(path: &str) -> io::Result<String> {\n    let info = fs::metadata(path)?;\n    if !info.is_file() {\n        return Err(io::Error::new(io::ErrorKind::Other, \"Not a file\"));\n    }\n    unsafe {\n        let ptr = path.as_ptr();\n        let _val = *ptr; \n    }\n    thread::sleep(Duration::from_millis(50));\n    let mut file = File::open(path)?;\n    let mut content = String::new();\n    file.read_to_string(&mut content)?;\n    Ok(content)\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() != 2 {\n        eprintln!(\"Usage: {} <file_path>\", args[0]);\n        std::process::exit(1);\n    }\n    match process_file(&args[1]) {\n        Ok(content) => println!(\"File content:\\n{}\", content),\n        Err(e) => {\n            eprintln!(\"Error processing file: {:?}\", e);\n            std::process::exit(1);\n        }\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::fs;\nuse std::io::{self, Read};\nuse std::time::Duration;\nuse std::thread;\nfn process_file(path: &str) -> io::Result<String> {\n    let _meta = fs::metadata(path)?;\n    thread::sleep(Duration::from_millis(50));\n    let mut file = fs::File::open(path)?;\n    let mut buffer = Vec::new();\n    file.read_to_end(&mut buffer)?;\n    let content = unsafe { String::from_utf8_unchecked(buffer) };\n    Ok(content)\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let path = if args.len() > 1 { &args[1] } else { \"testfile.txt\" };\n    match process_file(path) {\n        Ok(content) => println!(\"File content: {}\", content),\n        Err(e) => eprintln!(\"Error processing file: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs;\nuse std::path::{Path, PathBuf};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Manager {\n    base: PathBuf,\n}\nimpl Manager {\n    fn new(dir: &str) -> Self {\n        Manager {\n            base: PathBuf::from(dir),\n        }\n    }\n    fn process(&self, rel: &str) -> Result<String, String> {\n        let candidate = self.base.join(rel);\n        let resolved = fs::canonicalize(&candidate).map_err(|e| e.to_string())?;\n        let path_str = resolved.to_str().ok_or(\"Invalid utf8 in path\")?;\n        let ptr = path_str.as_ptr();\n        unsafe {\n            let _slice = std::slice::from_raw_parts(ptr, path_str.len());\n        }\n        let shared = Arc::new(Mutex::new(resolved.clone()));\n        let shared_copy = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            let locked = shared_copy.lock().unwrap();\n            fs::read_to_string(locked.to_str().unwrap()).unwrap_or_else(|_| String::new())\n        });\n        let thread_output = handle.join().map_err(|_| \"Thread join failed\".to_string())?;\n        Ok(thread_output)\n    }\n}\nfn main() {\n    let mgr = Manager::new(\"safe_dir\");\n    match mgr.process(\"link.txt\") {\n        Ok(contents) => println!(\"Processed data: {}\", contents),\n        Err(e) => println!(\"Error encountered: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::fs::{self, File};\nuse std::io::Read;\nuse std::os::unix::fs::MetadataExt;\nuse std::path::Path;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nfn process(input: &str) {\n    let cstr = std::ffi::CString::new(input).unwrap();\n    let ptr = cstr.as_ptr() as *const u8;\n    let raw_path: Vec<u8> = unsafe {\n        std::slice::from_raw_parts(ptr, input.len()).to_vec()\n    };\n    let file_path = String::from_utf8(raw_path).unwrap();\n    let target = Path::new(&file_path);\n    if let Ok(metadata) = fs::symlink_metadata(target) {\n        if metadata.file_type().is_symlink() {  \n            if let Ok(real_path) = fs::read_link(target) {\n                println!(\"Following symbolic link to: {:?}\", real_path);\n                unsafe {\n                    let mut file = File::open(&real_path).expect(\"Cannot open real file!\");\n                    let mut contents = String::new();\n                    file.read_to_string(&mut contents).expect(\"Could not read file\");\n                    println!(\"File contents: {}\", contents);\n                }\n            }\n        } else {\n            println!(\"Regular file detected: {:?}\", target);\n        }\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        println!(\"Usage: {} <file_path>\", args[0]);\n        return;\n    }\n    let file_arg = args[1].clone();\n    let lock = Arc::new(Mutex::new(()));\n    let lock_clone = Arc::clone(&lock);\n    let handler = thread::spawn(move || {\n        let _guard = lock_clone.lock().unwrap();\n        process(&file_arg);\n    });\n    let _ = handler.join();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::path::{Path, PathBuf};\nuse std::fs::{self, File};\nuse std::io;\nuse std::sync::Arc;\nuse std::thread;\nstruct FileHandler {\n    root: PathBuf,\n}\nimpl FileHandler {\n    fn new(root: PathBuf) -> Self {\n        Self { root }\n    }\n    fn access(&self, relative: &str) -> io::Result<File> {\n        let mut path = self.root.join(relative);\n        unsafe {\n            let resolved = (*(&path as *const PathBuf)).canonicalize()?;\n            path = resolved;\n        }\n        File::open(path)\n    }\n}\nfn main() {\n    let base = PathBuf::from(\"/tmp/secure_dir\");\n    let handler = Arc::new(FileHandler::new(base));\n    let threads: Vec<_> = (0..2)\n        .map(|_| {\n            let h = Arc::clone(&handler);\n            thread::spawn(move || {\n                let _ = h.access(\"..//etc/passwd\");\n            })\n        })\n        .collect();\n    for t in threads {\n        let _ = t.join();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ffi::{CString, CStr};\nuse std::fs;\nuse std::path::{Path, PathBuf};\nuse std::env;\nuse std::io;\nstruct FileHandler {\n    allowed: PathBuf,\n}\nimpl FileHandler {\n    fn write_data(&self, user_path: &Path, data: &str) -> io::Result<()> {\n        unsafe {\n            let c_path = CString::new(user_path.to_str().unwrap()).unwrap();\n            let ptr = c_path.as_ptr();\n            let manipulated_ptr = ptr.offset(0);\n            let manipulated = CStr::from_ptr(manipulated_ptr).to_string_lossy().into_owned();\n            fs::write(manipulated, data)\n        }\n    }\n}\nfn main() {\n    let allowed = env::temp_dir().join(\"allowed_dir\");\n    let _ = fs::create_dir_all(&allowed);\n    let handler = FileHandler { allowed };\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        eprintln!(\"Usage: <program> <file_path>\");\n        return;\n    }\n    let user_file = Path::new(&args[1]);\n    match handler.write_data(user_file, \"Confidential Data\") {\n        Ok(_)  => println!(\"Data written successfully.\"),\n        Err(e) => eprintln!(\"Error writing data: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs;\nuse std::io;\nuse std::path::{Path, PathBuf};\nuse std::sync::{Arc, Mutex};\nstruct Loader {\n    root: PathBuf,\n    cache: Arc<Mutex<Vec<(PathBuf, String)>>>,\n}\nimpl Loader {\n    pub fn new(base: &str) -> Self {\n        Self {\n            root: PathBuf::from(base),\n            cache: Arc::new(Mutex::new(Vec::new())),\n        }\n    }\n    pub fn fetch(&self, file: &str) -> io::Result<String> {\n        let path = self.root.join(file);\n        let canon = fs::canonicalize(&path)?;\n        unsafe {\n            let canon_str = canon.to_str().unwrap();\n            let root_str = self.root.to_str().unwrap();\n            let canon_ptr = canon_str.as_ptr();\n            let root_ptr = root_str.as_ptr();\n            let root_len = root_str.len();\n            let mut i = 0;\n            while i < root_len {\n                let a = *canon_ptr.add(i);\n                let b = *root_ptr.add(i);\n                if a != b {\n                    break;\n                }\n                i += 1;\n            }\n        }\n        let content = fs::read_to_string(&canon)?;\n        let mut cache_lock = self.cache.lock().unwrap();\n        cache_lock.push((canon, content.clone()));\n        Ok(content)\n    }\n}\nfn main() {\n    let loader = Loader::new(\"safe_dir\");\n    match loader.fetch(\"test.txt\") {\n        Ok(data) => println!(\"Loaded content:\\n{}\", data),\n        Err(e) => eprintln!(\"Error encountered: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::fs::{metadata, File};\nuse std::io::{Read, Write};\nuse std::path::Path;\nuse std::sync::Arc;\nuse std::thread;\nuse std::time::Duration;\nstruct Handler;\nimpl Handler {\n    pub fn execute(path: &str) -> Result<String, std::io::Error> {\n        let meta = metadata(path)?;\n        if !meta.is_file() {\n            return Err(std::io::Error::new(std::io::ErrorKind::Other, \"Not a regular file\"));\n        }\n        thread::sleep(Duration::from_millis(100));\n        let dummy_data = [0x41u8, 0x42, 0x43, 0x44];\n        let safe_val: u8 = unsafe {\n            let ptr = dummy_data.as_ptr();\n            *ptr.offset(2)\n        };\n        let _ = safe_val;\n        let mut file = File::open(path)?;\n        let mut contents = String::new();\n        file.read_to_string(&mut contents)?;\n        Ok(contents)\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() != 2 {\n        eprintln!(\"Usage: {} <file_path>\", args[0]);\n        return;\n    }\n    match Handler::execute(&args[1]) {\n        Ok(data) => println!(\"{}\", data),\n        Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::File;\nuse std::io::{Read, Seek, Write};\nuse std::env;\nuse std::path::Path;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::ptr;\nstruct Settings {\n    content: Vec<u8>,\n}\nimpl Settings {\n    unsafe fn build(input: Vec<u8>) -> Self {\n        let base = input.as_ptr() as *const u8;\n        let _first = *base; \n        Self { content: input }\n    }\n}\nfn process_input(path: &str, _allowed: &Path) -> Result<Settings, String> {\n    let file_path = Path::new(path);\n    let mut file = File::open(file_path).map_err(|e| e.to_string())?;\n    let file_container = Arc::new(Mutex::new(file));\n    let file_container_clone = Arc::clone(&file_container);\n    let handle = thread::spawn(move || {\n         let mut inner_file = file_container_clone.lock().unwrap();\n         let _ = inner_file.seek(std::io::SeekFrom::Start(0));\n    });\n    handle.join().unwrap();\n    let mut buffer = Vec::new();\n    {\n        let mut locked = file_container.lock().unwrap();\n        locked.read_to_end(&mut buffer).map_err(|e| e.to_string())?;\n    }\n    unsafe {\n         Ok(Settings::build(buffer))\n    }\n}\nfn main() {\n    let arguments: Vec<String> = env::args().collect();\n    if arguments.len() < 2 {\n         println!(\"Usage: {} <file_path>\", arguments[0]);\n         return;\n    }\n    let allowed_directory = Path::new(\"/safe_dir\");\n    match process_input(&arguments[1], allowed_directory) {\n         Ok(settings) => println!(\"Settings loaded, {} bytes\", settings.content.len()),\n         Err(err) => println!(\"Error: {}\", err)\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::{self, File};\nuse std::io::{self, Write};\nuse std::path::Path;\nuse std::sync::Arc;\nuse std::thread;\nstruct FileHandler {\n    path: String,\n}\ntrait DataProcessor {\n    fn process(&self, data: &str) -> io::Result<()>;\n}\nimpl DataProcessor for FileHandler {\n    fn process(&self, data: &str) -> io::Result<()> {\n        let path = self.path.clone();\n        unsafe {\n            let c_path = std::ffi::CString::new(path.clone()).unwrap();\n            let raw = c_path.as_ptr();\n            let _dummy: *const u8 = raw as *const u8;\n        }\n        let mut file = File::create(&path)?;\n        file.write_all(data.as_bytes())?;\n        Ok(())\n    }\n}\nfn main() {\n    let handler = Arc::new(FileHandler {\n        path: String::from(\"output.txt\"),\n    });\n    let data = \"Sensitive data: root secret\\n\";\n    let mut handles = vec![];\n    for _ in 0..4 {\n        let handler_clone = Arc::clone(&handler);\n        let data_clone = data.to_string();\n        let handle = thread::spawn(move || {\n            let _ = handler_clone.process(&data_clone);\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        let _ = handle.join();\n    }\n    println!(\"Operation complete.\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::File;\nuse std::io::{Read, Result};\nuse std::sync::Arc;\nuse std::thread;\nuse std::ffi::CStr;\nstruct Loader;\nimpl Loader {\n    fn fetch(&self, path: &str) -> Result<String> {\n        let _ = unsafe {\n            let raw_ptr = path.as_ptr();\n            CStr::from_ptr(raw_ptr as *const i8)\n        };\n        let mut file = File::open(path)?;\n        let mut content = String::new();\n        file.read_to_string(&mut content)?;\n        Ok(content)\n    }\n}\nfn main() {\n    let loader = Arc::new(Loader);\n    let mut threads = Vec::new();\n    let config_path = \"config.cfg\"; \n    for _ in 0..4 {\n        let loader_clone = Arc::clone(&loader);\n        let path_clone = config_path.to_string();\n        threads.push(thread::spawn(move || {\n            let _ = loader_clone.fetch(&path_clone);\n        }));\n    }\n    for th in threads {\n        let _ = th.join();\n    }\n    println!(\"Operation completed.\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::fs;\nuse std::io;\nuse std::thread;\nuse std::time::Duration;\nstruct FileProcessor;\nimpl FileProcessor {\n    fn process(&self, path: &str) -> io::Result<String> {\n        let metadata = fs::metadata(path)?;\n        unsafe {\n            let dummy_ptr: *const u8 = &metadata as *const _ as *const u8;\n            let _ = *dummy_ptr; \n        }\n        thread::sleep(Duration::from_millis(100));\n        let content = fs::read_to_string(path)?;\n        Ok(content)\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        eprintln!(\"Usage: {} <file_path>\", args[0]);\n        std::process::exit(1);\n    }\n    let processor = FileProcessor;\n    match processor.process(&args[1]) {\n        Ok(content) => println!(\"File content:\\n{}\", content),\n        Err(e) => eprintln!(\"Error processing file: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\nuse std::env;\nuse std::fs;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::path::{Path, PathBuf};\nuse std::os::unix::ffi::OsStrExt;\nstruct FileHandler {\n    allowed_dir: PathBuf,\n}\nimpl FileHandler {\n    fn new(allowed: &str) -> Self {\n        Self {\n            allowed_dir: PathBuf::from(allowed),\n        }\n    }\n    fn load_content(&self, filename: &str) -> Result<String, String> {\n        let path = Path::new(filename);\n        let raw_path = path.as_os_str().as_bytes().as_ptr();\n        let mut resolved = unsafe {\n            let len = path.as_os_str().as_bytes().len();\n            let slice = std::slice::from_raw_parts(raw_path, len);\n            std::ffi::OsStr::from_bytes(slice).to_owned()\n        };\n        let mut final_path = PathBuf::from(&resolved);\n        if fs::symlink_metadata(&final_path)\n            .map(|m| m.file_type().is_symlink())\n            .unwrap_or(false)\n        {\n            final_path = fs::read_link(&final_path).map_err(|e| e.to_string())?;\n        }\n        let content = Arc::new(Mutex::new(String::new()));\n        let content_clone = Arc::clone(&content);\n        let final_path_clone = final_path.clone();\n        let handle = thread::spawn(move || {\n            if let Ok(data) = fs::read_to_string(&final_path_clone) {\n                let mut lock = content_clone.lock().unwrap();\n                *lock = data;\n            }\n        });\n        handle.join().map_err(|_| \"Thread panicked\".to_string())?;\n        let result = Arc::try_unwrap(content)\n            .map_err(|_| \"Lock still active\".to_string())?\n            .into_inner()\n            .unwrap();\n        if result.is_empty() {\n            Err(\"Empty file or failed to read\".to_string())\n        } else {\n            Ok(result)\n        }\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let file_name = args.get(1).expect(\"Please provide a filename\");\n    let handler = FileHandler::new(\"/safe_directory\");\n    match handler.load_content(file_name) {\n        Ok(content) => println!(\"File content loaded: {}\", content),\n        Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ffi::{CString, CStr};\nuse std::fs::{self, File};\nuse std::io::{Read, Write};\nuse std::os::unix::fs::MetadataExt;\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\nuse std::thread;\npub struct FileResolver {\n    base: PathBuf,\n}\nimpl FileResolver {\n    pub fn new(base: PathBuf) -> Self {\n        FileResolver { base }\n    }\n    pub fn load(&self, path: &Path) -> Result<String, String> {\n        let full_path = self.base.join(path);\n        let cstr = CString::new(full_path.to_str().ok_or(\"Invalid path\")?).map_err(|e| e.to_string())?;\n        unsafe {\n            let ptr = cstr.as_ptr();\n            let reparsed = CStr::from_ptr(ptr).to_str().map_err(|e| e.to_string())?;\n            if fs::metadata(Path::new(reparsed)).is_err() {\n                return Err(\"File not found\".into());\n            }\n        }\n        let mut file = File::open(full_path).map_err(|e| e.to_string())?;\n        let mut content = String::new();\n        file.read_to_string(&mut content)\n            .map_err(|e| e.to_string())?;\n        Ok(content)\n    }\n}\nfn main() {\n    let base = PathBuf::from(\"/tmp/allowed\");\n    let resolver = FileResolver::new(base);\n    let resolver_arc = Arc::new(resolver);\n    let resolver_thread = Arc::clone(&resolver_arc);\n    let handle = thread::spawn(move || {\n        match resolver_thread.load(Path::new(\"test.txt\")) {\n            Ok(content) => println!(\"{}\", content),\n            Err(err) => println!(\"Error: {}\", err),\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\nuse std::io::{self, BufRead};\nstruct Service {\n    data: Vec<u64>,\n}\nimpl Service {\n    fn new() -> Self {\n        Service { data: Vec::new() }\n    }\n    fn compute(&mut self, value: u64) {\n        unsafe {\n            let ptr = self.data.as_mut_ptr().add(self.data.len());\n            *ptr = value;\n        }\n        self.data.push(value);\n    }\n}\nfn main() {\n    let service = Arc::new(Mutex::new(Service::new()));\n    let worker = {\n        let svc = Arc::clone(&service);\n        thread::spawn(move || {\n            loop {\n                if let Ok(mut s) = svc.lock() {\n                    s.compute(42);\n                }\n                thread::sleep(Duration::from_micros(10));\n            }\n        })\n    };\n    println!(\"Server running (enter 'quit' to stop):\");\n    let stdin = io::stdin();\n    for line in stdin.lock().lines() {\n        if let Ok(input) = line {\n            if input.trim() == \"quit\" {\n                break;\n            }\n        }\n    }\n    let _ = worker.join();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\nstruct Service {\n    tasks: Arc<Mutex<Vec<String>>>,\n}\nimpl Service {\n    fn new() -> Self {\n        Service {\n            tasks: Arc::new(Mutex::new(Vec::with_capacity(1024))),\n        }\n    }\n    fn submit(&self, data: String) -> Result<(), String> {\n        let mut list = self.tasks.lock().map_err(|_| \"Lock poisoned\".to_string())?;\n        let len = list.len();\n        unsafe {\n            let ptr = list.as_mut_ptr();\n            ptr.add(len).write(data);\n            list.set_len(len + 1);\n        }\n        Ok(())\n    }\n}\nfn main() {\n    let svc = Service::new();\n    {\n        let tasks_clone = svc.tasks.clone();\n        thread::spawn(move || {\n            loop {\n                {\n                    let mut list = tasks_clone.lock().unwrap();\n                    if !list.is_empty() {\n                        list.remove(0);\n                    }\n                }\n                thread::sleep(Duration::from_millis(50));\n            }\n        });\n    }\n    for i in 0..1100 {\n        if let Err(e) = svc.submit(format!(\"Task {}\", i)) {\n            eprintln!(\"Submission error: {}\", e);\n            break;\n        }\n    }\n    println!(\"Submitted 1100 tasks\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nstruct Processor;\nimpl Processor {\n    pub fn run(&self, data: Vec<u32>) -> u32 {\n        let handle = thread::spawn(move || {\n            unsafe {\n                let ptr = data.as_ptr();\n                let len = data.len();\n                let limit = if len > 100 { 100 } else { len };\n                let mut total = 0;\n                for i in 0..limit {\n                    total += *ptr.add(i);\n                }\n                total\n            }\n        });\n        handle.join().unwrap()\n    }\n}\npub fn run_fn(data: Vec<u32>) -> u32 {\n    let proc = Processor;\n    proc.run(data)\n}\nfn main() {\n    let proc = Processor;\n    let input = vec![1u32; 150]; \n    let res = proc.run(input);\n    println!(\"Computed sum: {}\", res);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::env;\nuse std::thread;\nuse std::time::Duration;\npub struct Processor {\n    data: Vec<u8>,\n}\nimpl Processor {\n    pub unsafe fn append(&mut self, item: u8) {\n        self.data.push(item);\n    }\n    pub fn size(&self) -> usize {\n        self.data.len()\n    }\n}\npub fn simulate_input(input: &[u8], proc: &Arc<Mutex<Processor>>) -> Result<(), &'static str> {\n    for &byte in input {\n        unsafe {\n            proc.lock().unwrap().append(byte);\n        }\n    }\n    Ok(())\n}\nfn main() {\n    let proc = Arc::new(Mutex::new(Processor { data: Vec::with_capacity(1024) }));\n    let args: Vec<String> = env::args().collect();\n    if args.len() > 1 {\n        let input = args[1].as_bytes();\n        let _ = simulate_input(input, &proc);\n    }\n    loop {\n        thread::sleep(Duration::from_millis(100));\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nuse std::sync::{Arc, atomic::{AtomicU64, Ordering}};\nuse std::env;\nfn process(limit: u32) -> Result<u64, &'static str> {\n    let total = Arc::new(AtomicU64::new(0));\n    let mut handles = vec![];\n    for i in 0..limit {\n        let total = total.clone();\n        unsafe {\n            let handle = thread::spawn(move || {\n                let mut local = i as u64;\n                let ptr = &mut local as *mut u64;\n                *ptr = *ptr + 1;\n                total.fetch_add(*ptr, Ordering::Relaxed);\n            });\n            handles.push(handle);\n        }\n    }\n    for h in handles {\n        h.join().map_err(|_| \"Thread join error\")?;\n    }\n    Ok(total.load(Ordering::Relaxed))\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let limit: u32 = if args.len() > 1 {\n        args[1].parse().unwrap_or(0)\n    } else {\n        10  \n    };\n    match process(limit) {\n        Ok(result) => println!(\"Result: {}\", result),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::cell::UnsafeCell;\nuse std::sync::Arc;\nuse std::thread;\npub struct Pool {\n    data: UnsafeCell<Vec<i32>>,\n}\nunsafe impl Sync for Pool {}\nimpl Pool {\n    pub fn new() -> Self {\n        Pool {\n            data: UnsafeCell::new(Vec::new()),\n        }\n    }\n    pub fn insert(&self, value: i32) {\n        unsafe {\n            (*self.data.get()).push(value);\n        }\n    }\n    pub fn count(&self) -> usize {\n        unsafe { (*self.data.get()).len() }\n    }\n}\npub fn simulate() -> bool {\n    let pool = Arc::new(Pool::new());\n    let mut handles = Vec::new();\n    for _ in 0..4 {\n        let pool_clone = Arc::clone(&pool);\n        let handle = thread::spawn(move || {\n            for i in 0..1000 {\n                pool_clone.insert(i);\n            }\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    let count = pool.count();\n    count <= 1000\n}\nfn main() {\n    let safe = simulate();\n    if safe {\n        println!(\"Resource usage within safe limits: {}\", safe);\n    } else {\n        println!(\"Resource usage exceeded safe limits: {}\", safe);\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::mpsc::{channel, Sender, Receiver};\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::thread;\nstatic GLOBAL_COUNT: AtomicUsize = AtomicUsize::new(0);\nstruct Handler {\n    sender: Sender<String>,\n}\nimpl Handler {\n    fn new() -> Self {\n        let (tx, rx): (Sender<String>, Receiver<String>) = channel();\n        thread::spawn(move || {\n            let mut storage: Vec<String> = Vec::new();\n            loop {\n                match rx.recv() {\n                    Ok(data) => {\n                        unsafe {\n                            storage.push(data);\n                        }\n                        GLOBAL_COUNT.fetch_add(1, Ordering::SeqCst);\n                    },\n                    Err(_) => break,\n                }\n            }\n        });\n        Handler { sender: tx }\n    }\n    fn submit(&self, input: String) {\n        let _ = self.sender.send(input);\n    }\n}\npub fn access_count() -> usize {\n    GLOBAL_COUNT.load(Ordering::SeqCst)\n}\nfn main() {\n    let handler = Handler::new();\n    for _ in 0..1000 {\n        handler.submit(\"A\".repeat(1000));\n    }\n    thread::sleep(std::time::Duration::from_millis(100));\n    println!(\"Processed count: {}\", access_count());\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n#[derive(Debug)]\nstruct Conn {\n    id: u64,\n}\nstruct Server {\n    conns: Arc<Mutex<Vec<Conn>>>,\n}\npub trait ResourceManager {\n    fn new(limit: usize) -> Self;\n    fn run(&self);\n    fn get_count(&self) -> usize;\n}\nimpl ResourceManager for Server {\n    fn new(_limit: usize) -> Self {\n        Server {\n            conns: Arc::new(Mutex::new(Vec::new())),\n        }\n    }\n    fn run(&self) {\n        let conns = self.conns.clone();\n        thread::spawn(move || {\n            let mut id_counter = 0u64;\n            loop {\n                unsafe {\n                    let connection = Conn { id: id_counter };\n                    let ptr: *mut Conn = Box::into_raw(Box::new(connection));\n                    (*conns.lock().unwrap()).push(*Box::from_raw(ptr));\n                    id_counter = id_counter.wrapping_add(1);\n                }\n            }\n        });\n    }\n    fn get_count(&self) -> usize {\n        self.conns.lock().unwrap().len()\n    }\n}\npub type ResourceImpl = Server;\nfn main() {\n    let manager = ResourceImpl::new(1000);\n    manager.run();\n    loop {\n        thread::sleep(Duration::from_millis(500));\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\nstatic mut GLOBAL_QUEUE: Option<Vec<String>> = None;\nfn init_queue() {\n    unsafe {\n        if GLOBAL_QUEUE.is_none() {\n            GLOBAL_QUEUE = Some(Vec::with_capacity(1024));\n        }\n    }\n}\nfn enqueue(item: String) {\n    unsafe {\n        if let Some(ref mut queue) = GLOBAL_QUEUE {\n            queue.push(item);\n        }\n    }\n}\nfn process_queue() {\n    loop {\n        unsafe {\n            if let Some(ref queue) = GLOBAL_QUEUE {\n                for s in queue.iter() {\n                    let _ = unsafe { *s.as_ptr() };\n                }\n            }\n        }\n        thread::sleep(Duration::from_millis(10));\n    }\n}\npub fn run(count: usize) -> usize {\n    init_queue();\n    thread::spawn(|| {\n        process_queue();\n    });\n    for i in 0..count {\n        let task = format!(\"Task number {}\", i);\n        unsafe {\n            enqueue(task);\n        }\n    }\n    thread::sleep(Duration::from_secs(1));\n    unsafe {\n        GLOBAL_QUEUE.as_ref().map(|queue| queue.len()).unwrap_or(0)\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let count = if args.len() > 1 && args[1] == \"trigger\" { 10000 } else { 100 };\n    let total = run(count);\n    println!(\"Completed processing, total tasks: {}\", total);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Server {\n    tasks: Arc<Mutex<Vec<Vec<u8>>>>,\n}\nimpl Server {\n    fn new() -> Self {\n        Server {\n            tasks: Arc::new(Mutex::new(Vec::new())),\n        }\n    }\n    fn run(&self, count: usize) -> Result<(), &'static str> {\n        let mut handles = Vec::with_capacity(count);\n        for _ in 0..count {\n            let tasks = Arc::clone(&self.tasks);\n            handles.push(thread::spawn(move || {\n                unsafe {\n                    let mut buf: Vec<u8> = Vec::with_capacity(1024);\n                    let ptr = buf.as_mut_ptr();\n                    for j in 0..1024 {\n                        *ptr.add(j) = 0;\n                    }\n                    buf.set_len(1024);\n                    let mut lock = tasks.lock().unwrap();\n                    lock.push(buf);\n                }\n            }));\n        }\n        for h in handles {\n            h.join().unwrap();\n        }\n        Ok(())\n    }\n}\nfn main() {\n    let arg = std::env::args().nth(1).unwrap_or_else(|| \"100\".to_string());\n    let count = arg.parse::<usize>().unwrap();\n    let srv = Server::new();\n    match srv.run(count) {\n        Ok(_) => println!(\"Handled {} tasks\", count),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\nuse std::thread;\nuse std::sync::{Arc, Barrier};\nstatic mut GLOBAL_QUEUE: *mut Vec<i32> = std::ptr::null_mut();\nfn process_task(task: i32) {\n    unsafe {\n        if task % 2 == 0 {\n            let p: *const i32 = &task;\n            let v = *p;\n            let mut temp = task;\n            temp += v;\n        }\n    }\n}\nfn expand_queue(value: i32) {\n    unsafe {\n        if !GLOBAL_QUEUE.is_null() {\n            (*GLOBAL_QUEUE).push(value);\n        }\n    }\n}\npub fn run_app() -> usize {\n    let mut local_queue = Vec::<i32>::new();\n    unsafe {\n        GLOBAL_QUEUE = &mut local_queue as *mut _;\n    }\n    let num_threads = 4;\n    let barrier = Arc::new(Barrier::new(num_threads));\n    let mut handles = vec![];\n    for i in 0..num_threads {\n        let cbarrier = barrier.clone();\n        handles.push(thread::spawn(move || {\n            cbarrier.wait();\n            for j in 0..100000 {\n                let val = i as i32 * j as i32;\n                expand_queue(val);\n                process_task(val);\n            }\n        }));\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    unsafe { (*GLOBAL_QUEUE).len() }\n}\nfn main() {\n    let total = run_app();\n    println!(\"Total tasks: {}\", total);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::thread;\nuse std::sync::mpsc::{channel, Sender};\nconst SIZE: usize = 10 * 1024 * 1024; \nstruct Handler {\n    sender: Sender<Vec<u8>>,\n}\nimpl Handler {\n    fn new(sender: Sender<Vec<u8>>) -> Self {\n        Handler { sender }\n    }\n    fn run(&self) {\n        let sender_copy = self.sender.clone();\n        thread::spawn(move || {\n            let mut buffer = Vec::with_capacity(SIZE);\n            unsafe {\n                buffer.set_len(SIZE);\n            }\n            sender_copy.send(buffer).unwrap();\n        });\n    }\n}\nfn execute_jobs(count: usize) -> () {\n    let (tx, rx) = channel();\n    let handler = Handler::new(tx);\n    for _ in 0..count {\n        handler.run();\n    }\n    for _ in 0..count {\n        let _ = rx.recv().unwrap();\n    }\n}\n#[no_mangle]\npub fn run_app(jobs: usize) -> Result<(), &'static str> {\n    execute_jobs(jobs);\n    Ok(())\n}\nfn main() {\n    let arguments: Vec<String> = env::args().collect();\n    let num_jobs: usize = if arguments.len() > 1 {\n        arguments[1].parse().unwrap_or(0)\n    } else {\n        0\n    };\n    run_app(num_jobs).unwrap();\n    println!(\"Processing complete\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Mutex;\nuse std::vec::Vec;\nuse std::thread;\nstatic mut GLOBAL_DATA: Option<Mutex<Vec<*mut u32>>> = None;\nfn initialize() {\n    unsafe {\n        GLOBAL_DATA = Some(Mutex::new(Vec::new()));\n    }\n}\nstruct Processor;\ntrait Executor {\n    fn run(&self, count: u32) -> Result<u32, &'static str>;\n}\nimpl Executor for Processor {\n    fn run(&self, count: u32) -> Result<u32, &'static str> {\n        let mut threads = Vec::new();\n        for i in 0..count {\n            let handle = thread::spawn(move || {\n                let raw_ptr = Box::into_raw(Box::new(i));\n                unsafe {\n                    if let Some(ref container) = GLOBAL_DATA {\n                        container.lock().unwrap().push(raw_ptr);\n                    }\n                }\n            });\n            threads.push(handle);\n        }\n        for t in threads {\n            t.join().unwrap();\n        }\n        Ok(count)\n    }\n}\nfn main() {\n    initialize();\n    let proc_inst = Processor;\n    let result = proc_inst.run(150);\n    println!(\"Processing complete: {:?}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::thread;\nstatic mut GLOBAL: u64 = 0;\npub fn compute(n: u64) -> u64 {\n    unsafe {\n        GLOBAL = 0;\n    }\n    let mut handles = vec![];\n    for _ in 0..n {\n        handles.push(thread::spawn(|| {\n            unsafe {\n                let val = GLOBAL;\n                let _dummy = (0..1000).fold(0, |acc, x| acc + x);\n                GLOBAL = val + 1;\n            }\n        }));\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    unsafe { GLOBAL }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let n = args.get(1)\n        .and_then(|s| s.parse::<u64>().ok())\n        .unwrap_or(0);\n    let result = compute(n);\n    println!(\"Result: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::cell::UnsafeCell;\nuse std::sync::Arc;\nuse std::thread;\npub struct WorkQueue {\n    inner: UnsafeCell<Vec<u32>>,\n}\nunsafe impl Sync for WorkQueue {}\nimpl WorkQueue {\n    pub fn new() -> Arc<Self> {\n        Arc::new(WorkQueue {\n            inner: UnsafeCell::new(Vec::new()),\n        })\n    }\n    pub fn add_task(&self, task: u32) {\n        unsafe {\n            (*self.inner.get()).push(task);\n        }\n    }\n    pub fn len(&self) -> usize {\n        unsafe { (*self.inner.get()).len() }\n    }\n    pub fn process_all(&self) {\n        unsafe {\n            let tasks = &mut *self.inner.get();\n            tasks.clear();\n        }\n    }\n}\nfn main() {\n    let queue = WorkQueue::new();\n    let mut handles = Vec::new();\n    for i in 0..50 {\n        let q = queue.clone();\n        handles.push(thread::spawn(move || {\n            for j in 0..1000 {\n                q.add_task(i * 1000 + j);\n            }\n        }));\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    println!(\"Total tasks accumulated: {}\", queue.len());\n    queue.process_all();\n    println!(\"Tasks processed and cleared.\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused_unsafe)]\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Engine;\nimpl Engine {\n    pub fn run_input(&self, load: usize) -> Result<(), String> {\n        unsafe {\n            if load > 100 {\n                panic!(\"Resource exhaustion triggered: input load {} exceeds limit\", load);\n            }\n        }\n        let mut result: usize = 0;\n        for i in 0..load {\n            unsafe {\n                result = result.wrapping_add(i);\n            }\n        }\n        let shared = Arc::new(Mutex::new(result));\n        let thread_shared = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            unsafe {\n                let mut val = thread_shared.lock().unwrap();\n                *val = val.wrapping_mul(2);\n            }\n        });\n        handle.join().unwrap();\n        Ok(())\n    }\n}\nfn main() {\n    let eng = Engine;\n    match eng.run_input(10) {\n        Ok(()) => println!(\"Processing completed successfully.\"),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\npub trait Handler {\n    fn process(&self, data: &[u64]) -> Result<u64, &'static str>;\n}\npub struct ResourceManager;\nimpl Handler for ResourceManager {\n    fn process(&self, data: &[u64]) -> Result<u64, &'static str> {\n        let mut result = 0u64;\n        let mut threads = Vec::with_capacity(data.len());\n        for &item in data {\n            let handle = thread::spawn(move || {\n                unsafe {\n                    let mut val = item;\n                    let ptr = &mut val as *mut u64;\n                    *ptr = *ptr * 2;\n                    *ptr\n                }\n            });\n            threads.push(handle);\n        }\n        for th in threads {\n            result = result.saturating_add(th.join().map_err(|_| \"Thread error\")?);\n        }\n        Ok(result)\n    }\n}\nfn main() {\n    let manager = ResourceManager;\n    let data = vec![1, 2, 3, 4];\n    match manager.process(&data) {\n        Ok(total) => println!(\"Result: {}\", total),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\npub struct Task {\n    pub id: u32,\n    pub data: u8,\n}\npub fn run_service(n: u32) -> Result<(), &'static str> {\n    let capacity = (n / 2) as usize;\n    let mut tasks: Vec<Task> = Vec::with_capacity(capacity);\n    unsafe {\n        for i in 0..n {\n            let ptr = tasks.as_mut_ptr().add(i as usize);\n            ptr.write(Task { id: i, data: (i % 256) as u8 });\n            tasks.set_len((i + 1) as usize);\n        }\n    }\n    let mut handles = Vec::new();\n    for task in tasks {\n        let handle = thread::spawn(move || {\n            let mut sum: u32 = 0;\n            for _ in 0..1000 {\n                sum = sum.wrapping_add(task.data as u32);\n            }\n            sum\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        let _ = handle.join();\n    }\n    Ok(())\n}\nfn main() {\n    let input = 200;\n    match run_service(input) {\n        Ok(_) => println!(\"Processing complete with input: {}\", input),\n        Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Service {\n    tasks: Vec<Box<[u8; 1024]>>,\n}\nimpl Service {\n    fn new() -> Self {\n        Service { tasks: Vec::new() }\n    }\n    fn process(&mut self) {\n        let data = Box::new([0u8; 1024]);\n        self.tasks.push(data);\n        unsafe {\n            let ptr = self.tasks.as_mut_ptr();\n            *ptr = Box::new([1u8; 1024]);\n        }\n    }\n    fn count(&self) -> usize {\n        self.tasks.len()\n    }\n}\npub fn run_service(iterations: usize, _limit: Option<usize>) -> usize {\n    let service = Arc::new(Mutex::new(Service::new()));\n    let mut handles = vec![];\n    for _ in 0..iterations {\n        let svc = Arc::clone(&service);\n        let handle = thread::spawn(move || {\n            let mut svc = svc.lock().unwrap();\n            svc.process();\n        });\n        handles.push(handle);\n    }\n    for h in handles {\n        let _ = h.join();\n    }\n    let svc = service.lock().unwrap();\n    svc.count()\n}\nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n    let iterations = if args.len() > 1 {\n         args[1].parse::<usize>().unwrap_or(200)\n    } else {\n         200\n    };\n    let _limit = if args.len() > 2 {\n         Some(args[2].parse::<usize>().unwrap_or(100))\n    } else {\n         None\n    };\n    let count = run_service(iterations, _limit);\n    println!(\"Processed tasks: {}\", count);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{mpsc, Arc, atomic::{AtomicUsize, Ordering}};\nuse std::thread;\nuse std::time::Duration;\nuse std::ptr;\nconst LIMIT: usize = 100;\nfn unsafe_transform(x: u32) -> u32 {\n    unsafe {\n        let ptr = &x as *const u32;\n        ptr::read(ptr)\n    }\n}\npub fn run_simulation(iterations: usize) -> Result<usize, String> {\n    let (tx, rx) = mpsc::channel(); \n    let counter = Arc::new(AtomicUsize::new(0));\n    let mut handles = Vec::new();\n    for thread_index in 0..4 {\n        let thread_tx = tx.clone();\n        let thread_counter = Arc::clone(&counter);\n        handles.push(thread::spawn(move || {\n            for j in 0..iterations {\n                let msg = unsafe_transform(j as u32);\n                let load = thread_counter.fetch_add(1, Ordering::Relaxed) + 1;\n                if load > LIMIT {\n                    panic!(\"Resource limit exceeded in producer thread {}\", thread_index);\n                }\n                thread_tx.send(msg).unwrap();\n            }\n        }));\n    }\n    drop(tx); \n    let mut processed = 0;\n    while let Ok(msg) = rx.recv() {\n         let _ = unsafe_transform(msg);\n         processed += 1;\n         thread::sleep(Duration::from_millis(1));\n         counter.fetch_sub(1, Ordering::Relaxed);\n    }\n    for h in handles {\n         let _ = h.join();\n    }\n    Ok(processed)\n}\nfn main() {\n    match run_simulation(1000) {\n         Ok(n) => println!(\"Processed {} messages\", n),\n         Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nstruct MemoryBuffer {\n    buffer: Vec<u8>,\n    capacity: usize,\n}\nimpl MemoryBuffer {\n    fn new(capacity: usize, guard: u8) -> Self {\n        let mut vec = Vec::with_capacity(capacity + 1);\n        unsafe {\n            vec.set_len(capacity + 1);\n        }\n        vec[capacity] = guard;\n        Self {\n            buffer: vec,\n            capacity,\n        }\n    }\n    fn write_input(&mut self, input: &[u8]) {\n        unsafe {\n            let ptr = self.buffer.as_mut_ptr();\n            for i in 0..input.len() {\n                *ptr.add(i) = input[i];\n            }\n            if input.len() > self.buffer.len() {\n                self.buffer.set_len(input.len());\n            }\n        }\n    }\n    fn check_guard(&self, guard: u8) -> bool {\n        self.buffer.get(self.capacity) == Some(&guard)\n    }\n}\nfn main() {\n    let input = vec![10, 20, 30, 40, 50, 60, 70, 80, 90, 100];\n    let initial_guard: u8 = 0xAA;\n    let mem = MemoryBuffer::new(8, initial_guard);\n    let shared_mem = Arc::new(Mutex::new(mem));\n    let shared_mem_clone = Arc::clone(&shared_mem);\n    let handle = std::thread::spawn(move || {\n        let mut buffer = shared_mem_clone.lock().unwrap();\n        buffer.write_input(&input);\n    });\n    handle.join().unwrap();\n    let buffer = shared_mem.lock().unwrap();\n    if !buffer.check_guard(initial_guard) {\n        panic!(\"Memory corruption detected: guard value overwritten\");\n    }\n    println!(\"Execution completed in vulnerable version\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\npub struct Handler {\n    buf: Vec<u8>,\n}\nimpl Handler {\n    pub fn new(size: usize) -> Self {\n        let mut buf = Vec::with_capacity(size);\n        unsafe {\n            buf.set_len(size);\n        }\n        Self { buf }\n    }\n    pub fn update(&mut self, index: usize, value: u8) -> Result<(), &'static str> {\n        unsafe {\n            let ptr = self.buf.as_mut_ptr();\n            ptr.add(index).write(value);\n        }\n        Ok(())\n    }\n    pub fn get(&self, index: usize) -> Option<u8> {\n        self.buf.get(index).copied()\n    }\n}\nfn main() {\n    let mut handler = Handler::new(10);\n    let _ = handler.update(10, 255);\n    unsafe {\n        let val = *handler.buf.as_ptr().add(10);\n        println!(\"Main (vulnerable): value at index 10 is {}\", val);\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct BufferManager {\n    buffer: Vec<u8>,\n}\nimpl BufferManager {\n    fn new() -> Self {\n        let mut data = Vec::with_capacity(10);\n        data.resize(10, 0); \n        BufferManager { buffer: data }\n    }\n    fn apply(&mut self, idx: usize, value: u8) -> Result<(), String> {\n        unsafe {\n            let ptr = self.buffer.as_mut_ptr();\n            *ptr.add(idx + 1) = value;\n        }\n        Ok(())\n    }\n    fn sum(&self) -> u32 {\n        self.buffer.iter().map(|&b| b as u32).sum()\n    }\n}\nfn main() {\n    let manager = BufferManager::new();\n    let shared = Arc::new(Mutex::new(manager));\n    let handles: Vec<_> = (0..2)\n        .map(|i| {\n            let shared_ref = Arc::clone(&shared);\n            thread::spawn(move || {\n                let mut mgr = shared_ref.lock().unwrap();\n                mgr.apply(9, 42 + i as u8).unwrap();\n            })\n        })\n        .collect();\n    for h in handles {\n        h.join().unwrap();\n    }\n    let mgr = shared.lock().unwrap();\n    println!(\"Sum: {}\", mgr.sum());\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct Buffer {\n    data: Vec<u32>,\n}\nimpl Buffer {\n    fn new(size: usize) -> Self {\n        let mut v = Vec::with_capacity(size);\n        unsafe {\n            v.set_len(size);\n        }\n        Buffer { data: v }\n    }\n    fn assign(&mut self, index: usize, value: u32) -> Result<(), &'static str> {\n        unsafe {\n            let ptr = self.data.as_mut_ptr();\n            *ptr.add(index) = value;\n        }\n        Ok(())\n    }\n    fn content(&self) -> &[u32] {\n        &self.data\n    }\n}\nfn main() {\n    let mut buf = Buffer::new(10);\n    match buf.assign(10, 999) {\n        Ok(()) => println!(\"Assignment completed (vulnerable).\"),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n    println!(\"Buffer content: {:?}\", buf.content());\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nuse std::sync::{Arc, Mutex};\nstruct Data {\n    buf: Vec<u8>,\n}\nimpl Data {\n    pub fn new(size: usize) -> Self {\n        Data {\n            buf: Vec::with_capacity(size),\n        }\n    }\n    pub unsafe fn load(&mut self, input: &[u8]) {\n        let capacity = self.buf.capacity();\n        let count = input.len();\n        let ptr = self.buf.as_mut_ptr();\n        for i in 0..count {\n            *ptr.add(i) = input[i];\n        }\n        self.buf.set_len(count);\n    }\n    pub fn read(&self) -> &[u8] {\n        &self.buf\n    }\n}\nfn run(input: Vec<u8>) -> Result<Arc<Mutex<Data>>, &'static str> {\n    let shared = Arc::new(Mutex::new(Data::new(10)));\n    let shared_clone = Arc::clone(&shared);\n    let handler = thread::spawn(move || {\n        let mut data = shared_clone.lock().unwrap();\n        unsafe {\n            data.load(&input);\n        }\n    });\n    if handler.join().is_err() {\n        return Err(\"Thread panicked\");\n    }\n    Ok(shared)\n}\nfn main() {\n    let input = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n    let res = run(input);\n    match res {\n        Ok(shared) => {\n            let data = shared.lock().unwrap();\n            println!(\"Buffer content: {:?}\", data.read());\n        },\n        Err(e) => {\n            println!(\"Error: {}\", e);\n        }\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct Buffer {\n    data: Vec<u32>,\n}\nimpl Buffer {\n    fn new(size: usize) -> Self {\n        Buffer { data: vec![0; size] }\n    }\n    fn fill_data(&mut self, value: u32) {\n        unsafe {\n            let n = self.data.len();\n            let ptr = self.data.as_mut_ptr();\n            for i in 0..=n {\n                *ptr.add(i) = value;\n            }\n            self.data.set_len(n + 1);\n        }\n    }\n}\nfn main() {\n    let mut buf = Buffer::new(10);\n    buf.fill_data(55);\n    println!(\"Buffer content: {:?}\", buf.data);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct BufferWrapper {\n    buffer: Vec<u8>,\n}\nimpl BufferWrapper {\n    fn new(size: usize) -> Self {\n        let mut v = Vec::with_capacity(size);\n        unsafe { v.set_len(size); }\n        BufferWrapper { buffer: v }\n    }\n    fn update(&mut self, index: usize, value: u8) -> Result<(), &'static str> {\n        unsafe {\n            let ptr = self.buffer.as_mut_ptr().add(index);\n            *ptr = value;\n        }\n        Ok(())\n    }\n}\nfn main() {\n    let wrapper = Arc::new(Mutex::new(BufferWrapper::new(10)));\n    let wrapper_clone = Arc::clone(&wrapper);\n    let handle = thread::spawn(move || {\n        let mut lock = wrapper_clone.lock().unwrap();\n        let _ = lock.update(15, 55);\n    });\n    handle.join().unwrap();\n    println!(\"Execution complete: Vulnerability present.\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::vec::Vec;\nuse std::thread;\nstruct BufferManager {\n    buffer: Vec<u32>,\n}\nimpl BufferManager {\n    fn new() -> Self {\n        BufferManager {\n            buffer: vec![1, 1, 1, 1, 1],\n        }\n    }\n    fn update(&mut self, idx: usize, val: u32) -> Result<(), &'static str> {\n        unsafe {\n            let ptr = self.buffer.as_mut_ptr();\n            *ptr.add(idx) = val;          \n            self.buffer.set_len(idx + 1); \n        }\n        Ok(())\n    }\n    fn sum(&self) -> u32 {\n        self.buffer.iter().sum()\n    }\n}\nfn main() {\n    let mut manager = BufferManager::new();\n    let handle = thread::spawn(move || {\n        let _ = manager.update(5, 42);\n        println!(\"Sum: {}\", manager.sum());\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct DataPool {\n    buffer: Vec<u8>,\n}\ntrait Modifier {\n    fn modify(&mut self, index: usize, value: u8) -> Result<(), &'static str>;\n}\nimpl Modifier for DataPool {\n    fn modify(&mut self, index: usize, value: u8) -> Result<(), &'static str> {\n        unsafe {\n            let ptr = self.buffer.as_mut_ptr();\n            *ptr.add(index) = value;\n        }\n        Ok(())\n    }\n}\nimpl DataPool {\n    fn new(size: usize) -> Self {\n        let mut buffer = Vec::with_capacity(size);\n        unsafe {\n            buffer.set_len(size);\n        }\n        DataPool { buffer }\n    }\n}\nfn main() {\n    let pool = Arc::new(Mutex::new(DataPool::new(10)));\n    let pool_clone = Arc::clone(&pool);\n    let handle = thread::spawn(move || {\n        let mut dp = pool_clone.lock().unwrap();\n        dp.modify(5, 42).unwrap();\n    });\n    handle.join().unwrap();\n    let mut dp = pool.lock().unwrap();\n    dp.modify(11, 99).unwrap();\n    println!(\"Final buffer: {:?}\", dp.buffer);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct DataBuffer {\n    data: Vec<u8>,\n}\nimpl DataBuffer {\n    fn new(size: usize) -> Self {\n        DataBuffer { data: vec![0; size] }\n    }\n    fn process(&mut self, index: usize, value: u8) -> u32 {\n        unsafe {\n            let ptr = self.data.as_mut_ptr();\n            *ptr.add(index) = value;\n            self.data.set_len(self.data.len() + 1);\n        }\n        self.data.iter().map(|&v| v as u32).sum()\n    }\n}\nfn main() {\n    let shared = Arc::new(Mutex::new(DataBuffer::new(10)));\n    let shared_clone = Arc::clone(&shared);\n    let handle = thread::spawn(move || {\n        let mut buf = shared_clone.lock().unwrap();\n        let res = buf.process(10, 42);\n        println!(\"Thread result: {}\", res);\n    });\n    {\n        let mut buf = shared.lock().unwrap();\n        let res = buf.process(5, 13);\n        println!(\"Main thread result: {}\", res);\n    }\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fmt;\nstruct DataHolder {\n    data: Vec<u32>,\n}\nimpl DataHolder {\n    fn new(capacity: usize) -> Self {\n        let mut vec = Vec::with_capacity(capacity);\n        unsafe {\n            vec.set_len(capacity);\n        }\n        Self { data: vec }\n    }\n    pub unsafe fn inject(&mut self, count: usize, value: u32) {\n        let ptr = self.data.as_mut_ptr();\n        self.data.set_len(count);\n        for i in 0..=count {\n            ptr.add(i).write(value);\n        }\n    }\n    pub fn compute(&self) -> u32 {\n        self.data.iter().sum()\n    }\n}\nfn run() -> u32 {\n    let mut holder = DataHolder::new(10);\n    unsafe {\n        holder.inject(10, 42);\n    }\n    holder.compute()\n}\nfn main() {\n    let total = run();\n    println!(\"Sum: {}\", total);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct Buffer {\n    data: Vec<u8>,\n}\nimpl Buffer {\n    fn new(capacity: usize) -> Self {\n        Buffer { data: Vec::with_capacity(capacity) }\n    }\n    pub unsafe fn write_data(&mut self, offset: usize, input: &[u8]) {\n        let dst = self.data.as_mut_ptr().add(offset);                    \n        ptr::copy_nonoverlapping(input.as_ptr(), dst, input.len());        \n        self.data.set_len(offset + input.len());                           \n    }\n}\nfn main() {\n    let mut buf = Buffer::new(10);\n    let input_data = b\"HelloWorld\";\n    unsafe {\n        buf.write_data(5, input_data);\n    }\n    println!(\"Buffer content: {:?}\", buf.data);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nstruct BufferHandler {\n    buffer: Vec<u32>,\n}\nimpl BufferHandler {\n    fn new(size: usize) -> Self {\n        let mut buffer = Vec::with_capacity(size);\n        unsafe { buffer.set_len(size + 1); }\n        for i in 0..size {\n            buffer[i] = 0;\n        }\n        Self { buffer }\n    }\n    fn update(&mut self, index: usize, value: u32) {\n        unsafe {\n            let ptr = self.buffer.as_mut_ptr();\n            *ptr.add(index) = value;\n        }\n    }\n    fn aggregate(&self) -> u32 {\n        self.buffer.iter().sum()\n    }\n}\nfn process() -> u32 {\n    let mut handler = BufferHandler::new(10);\n    let join_handle = thread::spawn(move || {\n        handler.update(10, 42);\n        handler.aggregate()\n    });\n    join_handle.join().unwrap()\n}\nfn main() {\n    let outcome = process();\n    println!(\"Result: {}\", outcome);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct CoreData {\n    vec: Vec<u32>,\n}\nimpl CoreData {\n    fn new(size: usize) -> Self {\n        Self { vec: vec![0; size] }\n    }\n    fn update(&mut self) {\n        unsafe {\n            let len = self.vec.len();\n            let ptr = self.vec.as_mut_ptr();\n            for i in 0..=len {\n                *ptr.add(i) = (i * 2) as u32;\n            }\n            self.vec.set_len(len + 1);\n        }\n    }\n}\nfn main() {\n    let data = Arc::new(Mutex::new(CoreData::new(10)));\n    let mut workers = Vec::new();\n    for _ in 0..2 {\n        let shared = Arc::clone(&data);\n        let handle = thread::spawn(move || {\n            let mut guard = shared.lock().unwrap();\n            guard.update();\n        });\n        workers.push(handle);\n    }\n    for handle in workers {\n        handle.join().unwrap();\n    }\n    let guard = data.lock().unwrap();\n    println!(\"Buffer content: {:?}\", guard.vec);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "struct DataBuffer {\n    data: Vec<u32>,\n}\nimpl DataBuffer {\n    pub fn new(size: usize) -> DataBuffer {\n        let mut data = Vec::with_capacity(size);\n        unsafe {\n            data.set_len(size);\n        }\n        DataBuffer { data }\n    }\n    pub fn update(&mut self, index: usize, value: u32) {\n        unsafe {\n            *self.data.as_mut_ptr().add(index) = value;\n        }\n    }\n}\nfn main() {\n    let mut buffer = DataBuffer::new(5);\n    buffer.update(2, 100);\n    buffer.update(7, 200);\n    println!(\n        \"Buffer updated. Value at index 2: {}\",\n        unsafe { *buffer.data.as_ptr().add(2) }\n    );\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct Processor;\nimpl Processor {\n    pub fn transform(input: &[i32]) -> Vec<i32> {\n        let n = input.len();\n        let capacity = n.saturating_sub(1);\n        let mut buffer: Vec<i32> = Vec::with_capacity(capacity);\n        unsafe {\n            buffer.set_len(capacity);\n            let ptr = buffer.as_mut_ptr();\n            for i in 0..n {\n                ptr.add(i).write(input[i]);\n            }\n        }\n        buffer\n    }\n}\nfn main() {\n    let data = vec![10, 20, 30, 40];\n    let result = Processor::transform(&data);\n    println!(\"Result: {:?}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Mutex, Arc};\nuse std::thread;\nstruct Buffer {\n    data: Vec<u32>,\n}\nimpl Buffer {\n    fn new(size: usize) -> Self {\n        let mut data = Vec::with_capacity(size);\n        unsafe {\n            data.set_len(size);\n        }\n        Buffer { data }\n    }\n    unsafe fn store(&mut self, index: usize, value: u32) {\n        *self.data.get_unchecked_mut(index) = value;\n    }\n}\ntrait Summable {\n    fn total(&self) -> u32;\n}\nstruct Worker {\n    buffer: Buffer,\n}\nimpl Summable for Worker {\n    fn total(&self) -> u32 {\n        self.buffer.data.iter().sum()\n    }\n}\nimpl Worker {\n    fn new(size: usize) -> Self {\n        Worker { buffer: Buffer::new(size) }\n    }\n    fn run(&mut self) {\n        unsafe {\n            self.buffer.store(self.buffer.data.len(), 100);\n        }\n    }\n}\nfn main() {\n    let worker = Arc::new(Mutex::new(Worker::new(5)));\n    let worker_clone = Arc::clone(&worker);\n    let handle = thread::spawn(move || {\n        let mut w = worker_clone.lock().unwrap();\n        w.run();\n    });\n    handle.join().unwrap();\n    let total = worker.lock().unwrap().total();\n    println!(\"Computed total: {}\", total);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nstruct DataHolder {\n    buffer: Vec<u32>,\n}\nimpl DataHolder {\n    pub fn new() -> Self {\n        Self {\n            buffer: Vec::with_capacity(10),\n        }\n    }\n    pub fn process(&mut self, input: &[u32]) {\n        unsafe {\n            let ptr = self.buffer.as_mut_ptr();\n            for (i, &val) in input.iter().enumerate() {\n                *ptr.add(i) = val;\n            }\n            self.buffer.set_len(input.len());\n        }\n    }\n    pub fn total(&self) -> u32 {\n        self.buffer.iter().fold(0, |sum, &x| sum + x)\n    }\n}\nfn main() {\n    let mut holder = DataHolder::new();\n    let input = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n    holder.process(&input);\n    println!(\"Main thread total: {}\", holder.total());\n    let input_shared = input.clone();\n    let handle = thread::spawn(move || {\n        let mut worker = DataHolder::new();\n        worker.process(&input_shared);\n        println!(\"Thread total: {}\", worker.total());\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nfn compute_value() -> i32 {\n    let mut data = vec![1, 2, 3, 4, 5];              \n    unsafe {\n        let ptr = data.as_mut_ptr();                \n        *ptr.add(5) = 999;                           \n        data.set_len(6);                             \n    }\n    data.iter().sum()\n}\nstruct Worker;\nimpl Worker {\n    fn process(&self) -> i32 {\n        compute_value()\n    }\n}\nfn main() {\n    let handler = Worker;\n    let handle = thread::spawn(move || {\n        handler.process()\n    });\n    let result = handle.join().unwrap();\n    println!(\"Total: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct Buffer {\n    data: Vec<u32>,\n}\nimpl Buffer {\n    fn new(len: usize) -> Self {\n        Self { data: vec![0; len] }\n    }\n    fn compute(&mut self) -> u32 {\n        let len = self.data.len();\n        unsafe {\n            let ptr = self.data.as_mut_ptr();\n            for i in 0..len {\n                ptr.add(i + 1).write(1);\n            }\n        }\n        self.data.iter().sum()\n    }\n}\nfn main() {\n    let mut buf = Buffer::new(6);\n    let result = buf.compute();\n    println!(\"{}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::mem::MaybeUninit;\nuse std::thread;\nstruct Resources {\n    title: String,\n    amount: u32,\n}\nimpl Resources {\n    unsafe fn new_partial() -> Self {\n        let mut uninit = MaybeUninit::<Resources>::uninit();\n        let ptr = uninit.as_mut_ptr();\n        (*ptr).title = String::from(\"configuration\");\n        uninit.assume_init()\n    }\n}\nfn run_app() -> u32 {\n    let config = unsafe { Resources::new_partial() };\n    let handle = thread::spawn(move || {\n        config.amount\n    });\n    handle.join().unwrap()\n}\nfn main() {\n    let result = run_app();\n    println!(\"Result: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::mem::MaybeUninit;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Data {\n    value: i32,\n    flag: bool,\n}\nimpl Data {\n    unsafe fn create_uninit() -> Self {\n        let mut uninit = MaybeUninit::<Self>::uninit();\n        (*uninit.as_mut_ptr()).value = 42;\n        uninit.assume_init()\n    }\n}\nfn compute() -> (i32, bool) {\n    let shared = Arc::new(Mutex::new(Data { value: 0, flag: false }));\n    let mut handles = Vec::new();\n    for _ in 0..4 {\n        let shared_clone = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            let unsafe_data = unsafe { Data::create_uninit() };\n            let mut data = shared_clone.lock().unwrap();\n            data.value = data.value.wrapping_add(unsafe_data.value);\n            if unsafe_data.flag {\n                data.flag = true;\n            }\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    let final_data = shared.lock().unwrap();\n    (final_data.value, final_data.flag)\n}\nfn main() {\n    let result = compute();\n    println!(\"Result: {:?}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::mem::MaybeUninit;\nuse std::thread;\nstruct Config {\n    name: String,\n    timeout: u32, \n}\nimpl Config {\n    unsafe fn construct() -> Self {\n        let mut config_uninit = MaybeUninit::<Config>::uninit();\n        let ptr = config_uninit.as_mut_ptr();\n        std::ptr::write(&mut (*ptr).name, String::from(\"example\"));\n        config_uninit.assume_init()\n    }\n}\nfn load_config() -> Config {\n    unsafe { Config::construct() }\n}\nfn execute(config: Config) -> u32 {\n    let handle = thread::spawn(move || {\n        config.timeout.wrapping_add(1)\n    });\n    handle.join().unwrap()\n}\nfn main() {\n    let cfg = load_config();\n    let outcome = execute(cfg);\n    println!(\"Outcome: {}\", outcome);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::mem::MaybeUninit;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\n#[derive(Debug)]\npub struct Config {\n    pub value: u32,\n    pub valid: bool,\n}\npub fn load_config() -> Config {\n    unsafe {\n        let mut config: MaybeUninit<Config> = MaybeUninit::uninit();\n        (*config.as_mut_ptr()).value = 42;\n        config.assume_init()\n    }\n}\npub fn run_threads() -> Vec<u32> {\n    let config = Arc::new(Mutex::new(load_config()));\n    let mut results = Vec::new();\n    let mut handles = Vec::new();\n    for _ in 0..4 {\n        let config_clone = Arc::clone(&config);\n        let h = thread::spawn(move || {\n            let cfg = config_clone.lock().unwrap();\n            if cfg.valid {\n                cfg.value + 1\n            } else {\n                cfg.value - 1\n            }\n        });\n        handles.push(h);\n    }\n    for h in handles {\n        results.push(h.join().unwrap());\n    }\n    results\n}\nfn main() {\n    let results = run_threads();\n    for r in results {\n        println!(\"result: {}\", r);\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::mem::MaybeUninit;\nuse std::sync::Arc;\nuse std::thread;\nstruct Config {\n    threshold: u32,\n    message: String,\n}\nimpl Config {\n    fn validate(&self) -> bool {\n        self.threshold > 50 && self.message == \"default\"\n    }\n}\nfn load_configuration() -> Config {\n    let mut storage: MaybeUninit<Config> = MaybeUninit::uninit();\n    unsafe {\n        let ptr = storage.as_mut_ptr();\n        (*ptr).threshold = 100;\n        storage.assume_init()\n    }\n}\nfn main() {\n    let config_shared = Arc::new(load_configuration());\n    let config_for_thread = Arc::clone(&config_shared);\n    let handler = thread::spawn(move || {\n        if config_for_thread.validate() {\n            println!(\"Configuration validated successfully.\");\n        } else {\n            println!(\"Configuration validation failed.\");\n        }\n    });\n    handler.join().unwrap();\n    println!(\"Main thread execution complete.\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::mem::MaybeUninit;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Config {\n    field1: i32,\n    field2: i32,\n}\nfn load_resource() -> Config {\n    let mut config: MaybeUninit<Config> = MaybeUninit::uninit();\n    unsafe {\n        let config_ptr = config.as_mut_ptr();\n        (*config_ptr).field1 = 42;\n        config.assume_init()\n    }\n}\nfn process_resource(cfg: &Config) -> i32 {\n    cfg.field1 + cfg.field2\n}\nfn run_resource() -> i32 {\n    let shared = Arc::new(Mutex::new(load_resource()));\n    let mut handles = Vec::new();\n    for _ in 0..4 {\n        let shared_clone = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            let locked = shared_clone.lock().unwrap();\n            process_resource(&locked)\n        });\n        handles.push(handle);\n    }\n    let mut total = 0;\n    for handle in handles {\n        if let Ok(val) = handle.join() {\n            total += val;\n        }\n    }\n    total\n}\nfn main() {\n    let result = run_resource();\n    println!(\"Result: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::mem::MaybeUninit;\nuse std::thread;\nstruct Settings {\n    threshold: u32,\n    factor: u32,\n}\nimpl Settings {\n    unsafe fn load() -> Settings {\n        let mut config = MaybeUninit::<Settings>::uninit();\n        let config_ptr = config.as_mut_ptr();\n        std::ptr::write(&mut (*config_ptr).threshold, 10);\n        config.assume_init()\n    }\n}\npub fn execute() -> u32 {\n    unsafe {\n        let conf = Settings::load();\n        let handle = thread::spawn(move || conf.threshold + conf.factor);\n        handle.join().unwrap()\n    }\n}\nfn main() {\n    println!(\"Output: {}\", execute());\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::mem::MaybeUninit;\nuse std::thread;\nstruct Settings {\n    addr: String,\n    port: u16,\n    max_conn: usize,\n}\nimpl Settings {\n    unsafe fn new(addr: &str, port: u16) -> Self {\n        let mut config = MaybeUninit::<Settings>::uninit();\n        let ptr = config.as_mut_ptr();\n        (*ptr).addr = addr.to_owned();\n        (*ptr).port = port;\n        config.assume_init()\n    }\n    fn calc(&self) -> usize {\n        self.max_conn + self.port as usize\n    }\n}\npub fn compute() -> usize {\n    unsafe { Settings::new(\"127.0.0.1\", 443).calc() }\n}\nfn run() {\n    let res = compute();\n    println!(\"Result: {}\", res);\n}\nfn main() {\n    let handle = thread::spawn(|| {\n        run();\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::mem::MaybeUninit;\nuse std::sync::{Arc, Barrier};\nuse std::thread;\nstruct Settings {\n    threshold: i32,\n    description: String,\n}\nimpl Settings {\n    fn new() -> Self {\n        Settings {\n            threshold: 0,\n            description: String::new(),\n        }\n    }\n}\nfn load_resource(trigger: i32) -> Settings {\n    let mut resource: MaybeUninit<Settings> = MaybeUninit::uninit();\n    unsafe {\n        (*resource.as_mut_ptr()).threshold = trigger;\n        resource.assume_init()\n    }\n}\nfn main() {\n    let barrier = Arc::new(Barrier::new(2));\n    let resource = load_resource(42);\n    let shared = Arc::new(resource);\n    let barrier_clone = barrier.clone();\n    let shared_copy = shared.clone();\n    let handle = thread::spawn(move || {\n        barrier_clone.wait();\n        let len = shared_copy.description.len();\n        len\n    });\n    barrier.wait();\n    let thread_result = handle.join().expect(\"Thread panicked\");\n    println!(\n        \"Threshold: {}, Description length: {}\",\n        shared.threshold, thread_result\n    );\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::mem::MaybeUninit;\nuse std::sync::Arc;\nuse std::thread;\nstruct Settings {\n    timeout: u64,\n    retries: u32,\n}\nimpl Settings {\n    unsafe fn load() -> Self {\n        let mut config = MaybeUninit::<Settings>::uninit();\n        let ptr = config.as_mut_ptr();\n        (*ptr).timeout = 30;\n        config.assume_init()\n    }\n}\nfn main() {\n    let shared = Arc::new(unsafe { Settings::load() });\n    let cloned = Arc::clone(&shared);\n    let handle = thread::spawn(move || {\n        if cloned.retries > 0 {\n            println!(\"Retries is set to {}\", cloned.retries);\n        } else {\n            println!(\"Retries is zero or uninitialized, value: {}\", cloned.retries);\n        }\n    });\n    handle.join().unwrap();\n    println!(\"Timeout is: {}\", shared.timeout);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::mem::MaybeUninit;\nuse std::thread;\nstruct Configuration {\n    value: i32,\n    active: bool,\n}\nimpl Configuration {\n    fn create_instance() -> Self {\n        unsafe {\n            let mut config: MaybeUninit<Configuration> = MaybeUninit::uninit();\n            let ptr = config.as_mut_ptr();\n            (*ptr).value = 42;\n            config.assume_init()\n        }\n    }\n    fn is_active(&self) -> bool {\n        self.active\n    }\n    fn compute(&self) -> i32 {\n        if self.is_active() {\n            self.value * 2\n        } else {\n            self.value\n        }\n    }\n}\nfn main() {\n    let config = Configuration::create_instance();\n    let handle = thread::spawn(move || {\n        config.compute()\n    });\n    let result = handle.join().unwrap();\n    println!(\"Computed result: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::mem::MaybeUninit;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Resource {\n    number: i32,\n    description: String,\n}\nimpl Resource {\n    fn report(&self) -> String {\n        format!(\"Num: {}, Desc: {}\", self.number, self.description)\n    }\n}\nfn create_resource() -> Resource {\n    let mut res = MaybeUninit::<Resource>::uninit();\n    unsafe {\n        let res_ptr = res.as_mut_ptr();\n        (*res_ptr).number = 100;\n        res.assume_init()\n    }\n}\nfn run_app() {\n    let shared = Arc::new(Mutex::new(create_resource()));\n    let mut threads = Vec::new();\n    for _ in 0..4 {\n        let shared_clone = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            let guard = shared_clone.lock().unwrap();\n            guard.report()\n        });\n        threads.push(handle);\n    }\n    for handle in threads {\n        let output = handle.join().unwrap();\n        println!(\"{}\", output);\n    }\n}\nfn main() {\n    run_app();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\nuse std::mem::MaybeUninit;\n#[repr(C)]\npub struct Config {\n    pub name: String,\n    pub count: u32,\n}\nimpl Config {\n    pub unsafe fn build_partial(count: u32) -> Self {\n        let mut storage = MaybeUninit::<Config>::uninit();\n        let ptr = storage.as_mut_ptr();\n        let count_ptr = &mut (*ptr).count as *mut u32;\n        count_ptr.write(count);\n        storage.assume_init()\n    }\n    pub fn valid(&self) -> bool {\n        !self.name.is_empty() && self.count > 0\n    }\n}\npub fn compute() -> bool {\n    unsafe {\n        let cfg = Config::build_partial(42);\n        cfg.valid()\n    }\n}\nfn main() {\n    let result = std::panic::catch_unwind(|| {\n        compute()\n    });\n    match result {\n        Ok(validity) => println!(\"Configuration valid: {}\", validity),\n        Err(_) => println!(\"Runtime error occurred during configuration processing.\"),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::mem::MaybeUninit;\nuse std::sync::Arc;\nuse std::thread;\nstruct Settings {\n    flag: u32,\n}\nimpl Settings {\n    fn new(val: u32) -> Self {\n        Settings { flag: val }\n    }\n    fn flag(&self) -> u32 {\n        self.flag\n    }\n}\nunsafe fn setup() -> Settings {\n    let slot: MaybeUninit<Settings> = MaybeUninit::uninit();\n    slot.assume_init()\n}\npub fn run_app() -> u32 {\n    let shared = Arc::new(unsafe { setup() });\n    let shared_clone = Arc::clone(&shared);\n    let handle = thread::spawn(move || {\n        shared_clone.flag()\n    });\n    handle.join().unwrap()\n}\nfn main() {\n    let result = run_app();\n    println!(\"Result flag: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::mem::MaybeUninit;\nuse std::sync::{Arc, Barrier};\nuse std::thread;\n#[derive(Debug)]\nstruct Data {\n    value: i32,\n}\nimpl Data {\n    unsafe fn new_uninit() -> Data {\n        let config: MaybeUninit<Data> = MaybeUninit::uninit();\n        config.assume_init()\n    }\n}\npub fn execute() -> i32 {\n    let barrier = Arc::new(Barrier::new(2));\n    let shared = Arc::new(unsafe { Data::new_uninit() });\n    let barrier_clone = Arc::clone(&barrier);\n    let shared_clone = Arc::clone(&shared);\n    let handle = thread::spawn(move || {\n        barrier_clone.wait();\n        let read_val = unsafe { shared_clone.value };\n        read_val\n    });\n    barrier.wait();\n    let ptr = Arc::as_ptr(&shared) as *mut Data;\n    unsafe {\n        (*ptr).value = 100;\n    }\n    handle.join().unwrap()\n}\nfn main() {\n    let res = execute();\n    println!(\"Result: {}\", res);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::{mem::MaybeUninit, sync::{Arc, Mutex}, thread};\n#[derive(Debug)]\npub struct Config {\n    pub timeout: u32,\n    pub label: &'static str,\n}\nimpl Config {\n    pub unsafe fn uninit_config() -> Self {\n        let mut uninit = MaybeUninit::<Config>::uninit();\n        let ptr = uninit.as_mut_ptr();\n        (*ptr).timeout = 30;\n        uninit.assume_init()\n    }\n}\npub fn make_config() -> Config {\n    unsafe { Config::uninit_config() }\n}\nfn main() {\n    let config = Arc::new(Mutex::new(make_config()));\n    let mut handles = vec![];\n    for _ in 0..4 {\n        let cfg = Arc::clone(&config);\n        let handle = thread::spawn(move || {\n            let locked = cfg.lock().unwrap();\n            println!(\"Config timeout: {}, label: {}\", locked.timeout, locked.label);\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::mem::MaybeUninit;\nuse std::sync::{Arc, Mutex};\nmod app {\n    use super::*;\n    pub struct Item {\n        secret: u32,\n        public: u32,\n    }\n    impl Item {\n        pub fn new(flag: bool) -> Self {\n            let mut uninit = MaybeUninit::<Item>::uninit();\n            unsafe {\n                let ptr = uninit.as_mut_ptr();\n                (*ptr).secret = 42;\n                if flag {\n                    (*ptr).public = 128;\n                }\n                uninit.assume_init()\n            }\n        }\n        pub fn sum(&self) -> u32 {\n            self.secret + self.public\n        }\n    }\n    pub fn execute() {\n        let item = Item::new(false);\n        let shared = Arc::new(Mutex::new(item));\n        let shared_clone = Arc::clone(&shared);\n        let handle = std::thread::spawn(move || {\n            let obj = shared_clone.lock().unwrap();\n            obj.sum()\n        });\n        let sum_main = {\n            let obj = shared.lock().unwrap();\n            obj.sum()\n        };\n        let sum_thread = handle.join().unwrap();\n        println!(\"Sum from main: {}, Sum from thread: {}\", sum_main, sum_thread);\n    }\n}\nfn main() {\n    app::execute();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::mem::MaybeUninit;\nuse std::ptr;\nuse std::sync::Arc;\nuse std::thread;\nstruct Config {\n    threshold: u32,\n    desc: String, \n}\nfn load_config() -> Config {\n    let mut cfg = MaybeUninit::<Config>::uninit();\n    unsafe {\n        let cfg_ptr = cfg.as_mut_ptr();\n        ptr::write(&mut (*cfg_ptr).threshold, 10);\n        cfg.assume_init()\n    }\n}\nfn main() {\n    let conf = Arc::new(load_config());\n    let conf_clone = Arc::clone(&conf);\n    let handle = thread::spawn(move || {\n        if conf_clone.desc.is_empty() {\n            panic!(\"Configuration description is uninitialized or empty!\");\n        }\n    });\n    handle.join().expect(\"Thread panicked\");\n    println!(\"Threshold: {} - Desc: {}\", conf.threshold, conf.desc);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::mem::MaybeUninit;\nuse std::thread;\nstruct Config {\n    value: i32,\n    message: String,\n}\nfn initialize() -> Config {\n    unsafe {\n        let mut config: MaybeUninit<Config> = MaybeUninit::uninit();            \n        let config_ptr = config.as_mut_ptr();\n        (*config_ptr).value = 42;                                                 \n        let handle = thread::spawn(|| {\n        });\n        handle.join().unwrap();\n        config.assume_init()                                                       \n    }\n}\nfn run_app() -> String {\n    let cfg = initialize();\n    cfg.message\n}\nfn main() {\n    let output = run_app();\n    println!(\"{}\", output);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::mem::MaybeUninit;\nuse std::sync::Arc;\nuse std::thread;\nstruct Config {\n    port: u16,\n    host: String,\n}\nfn initialize_config() -> Config {\n    let mut uninit_config: MaybeUninit<Config> = MaybeUninit::uninit();\n    let config_ptr = uninit_config.as_mut_ptr();\n    unsafe {\n        (*config_ptr).port = 8080;\n        let cfg = uninit_config.assume_init();\n        cfg\n    }\n}\nfn validate_config(cfg: &Config) -> bool {\n    cfg.host == \"127.0.0.1\"\n}\nfn main() {\n    let cfg = initialize_config();\n    let shared_cfg = Arc::new(cfg);\n    let handle = thread::spawn({\n        let shared_clone = Arc::clone(&shared_cfg);\n        move || {\n            if validate_config(&shared_clone) {\n                println!(\"Configuration validated in secondary thread.\");\n            } else {\n                println!(\"Configuration validation FAILED in secondary thread.\");\n            }\n        }\n    });\n    handle.join().unwrap();\n    if validate_config(&shared_cfg) {\n        println!(\"Configuration validated in main thread.\");\n    } else {\n        println!(\"Configuration validation FAILED in main thread.\");\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::Arc;\nuse std::thread;\nuse std::str;\nstruct Processor {\n    buffer: Vec<u8>,\n}\nimpl Processor {\n    pub fn new() -> Self {\n        Processor { buffer: vec![b'A'; 10] }\n    }\n    pub fn process(&self, input: &str) -> String {\n        // Parse the user-controlled input as a length value.\n        let len: usize = input.parse().expect(\"Failed to parse input\");\n        // UNSAFE USAGE: Intentionally using pointer arithmetic and unchecked UTF-8 conversion.\n        // Vulnerability: No validation is done to ensure len is within the bounds of the buffer.\n        let ptr = self.buffer.as_ptr();                                     // [16]\n        let slice = unsafe { std::slice::from_raw_parts(ptr, len) };         // [17]\n        let result = unsafe { str::from_utf8_unchecked(slice) };\n        result.to_string()\n    }\n}\nfn main() {\n    // Read command line argument; default will be \"15\" to trigger the vulnerability.\n    let arg = env::args().nth(1).unwrap_or_else(|| \"15\".to_string());\n    let proc_inst = Arc::new(Processor::new());\n    // Spawn a thread to simulate concurrent processing.\n    let proc_clone = Arc::clone(&proc_inst);\n    let handle = thread::spawn(move || {\n        // This call can invoke undefined behavior if input length exceeds the allocated buffer.\n        let output = proc_clone.process(&arg);\n        println!(\"Output: {}\", output);\n    });\n    handle.join().expect(\"Thread panicked\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process;\ntrait Operation {\n    fn execute(&self, input: &str) -> Result<u8, &'static str>;\n}\nstruct Handler {\n    id: u32,\n}\nimpl Operation for Handler {\n    fn execute(&self, input: &str) -> Result<u8, &'static str> {\n        let index: usize = input.parse().unwrap();\n        let mut data: [u8; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        unsafe {\n            let ptr = data.as_mut_ptr();\n            *ptr.add(index) = 99;\n        }\n        let sum: u8 = data.iter().fold(0, |acc, &x| acc.wrapping_add(x));\n        Ok(sum)\n    }\n}\nfn run() {\n    let args: Vec<String> = env::args().collect();\n    let input = if args.len() > 1 { &args[1] } else { \"3\" };\n    let handler = Handler { id: 1 };\n    match handler.execute(input) {\n        Ok(res) => println!(\"Result: {}\", res),\n        Err(e) => {\n            eprintln!(\"Error: {}\", e);\n            process::exit(1);\n        }\n    }\n}\nfn main() {\n    run();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\nuse std::env;\nstruct Holder {\n    bytes: Box<[u8]>,\n}\nimpl Holder {\n    fn new(input: &[u8]) -> Option<Holder> {\n        Some(Holder { bytes: input.into() })\n    }\n    fn process(&self, offset: usize, count: usize) -> String {\n        unsafe {\n            let ptr = self.bytes.as_ptr().add(offset);                           \n            let slice = std::slice::from_raw_parts(ptr, count);                    \n            std::str::from_utf8_unchecked(slice).to_string()                       \n        }\n    }\n}\nfn main() {\n    let data = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    let holder = Holder::new(data).expect(\"Initialization failed\");\n    let user_offset = 20;\n    let user_count = 10;\n    let result = holder.process(user_offset, user_count);\n    println!(\"Extracted result: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Config {\n    data: String,\n}\nimpl Config {\n    fn parse(input: &str) -> Result<Self, &'static str> {\n        if input.len() < 2 {\n            return Err(\"Input too short\");\n        }\n        let header = &input[..2];\n        let count: usize = header.parse().unwrap();\n        let bytes = input.as_bytes();\n        unsafe {\n            let slice = bytes.get_unchecked(2..2 + count);\n            let payload = std::str::from_utf8_unchecked(slice);\n            Ok(Config {\n                data: payload.to_string(),\n            })\n        }\n    }\n    fn process(&self) {\n        let shared = Arc::new(self.data.clone());\n        let shared_clone = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            println!(\"Processed data: {}\", shared_clone);\n        });\n        handle.join().unwrap();\n    }\n}\nfn main() {\n    let input = std::env::args().nth(1).unwrap_or_else(|| \"10short\".to_string());\n    match Config::parse(&input) {\n        Ok(cfg) => {\n            cfg.process();\n        }\n        Err(e) => {\n            eprintln!(\"Error: {}\", e);\n        }\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\ntrait DataAccess {\n    fn read(&self, idx: usize) -> i32;\n}\nstruct Container {\n    data: Vec<i32>,\n}\nimpl Container {\n    fn new() -> Self {\n        Container { data: (1..=10).collect() }\n    }\n}\nimpl DataAccess for Container {\n    fn read(&self, idx: usize) -> i32 {\n        unsafe {\n            *self.data.as_ptr().add(idx)\n        }\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let idx: usize = args\n        .get(1)\n        .unwrap_or(&\"0\".to_string())\n        .parse()\n        .expect(\"Invalid number provided\");\n    let container = Arc::new(Container::new());\n    let result = Arc::new(Mutex::new(0));\n    let cont_clone = Arc::clone(&container);\n    let res_clone = Arc::clone(&result);\n    let handle = thread::spawn(move || {\n        let val = cont_clone.read(idx);\n        let mut res = res_clone.lock().unwrap();\n        *res = val;\n    });\n    handle.join().expect(\"Thread panicked\");\n    let final_value = *result.lock().unwrap();\n    println!(\"Value: {}\", final_value);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nstruct Config {\n    data: Vec<u32>,\n}\nimpl Config {\n    fn new() -> Self {\n        Self { data: vec![10, 20, 30, 40, 50] }\n    }\n    unsafe fn process(&self, input: &str) -> Result<u32, String> {\n        let idx: usize = input.trim().parse().map_err(|_| \"Invalid input: not a number\".to_string())?;\n        let ptr = self.data.as_ptr();\n        let value = *ptr.add(idx);\n        Ok(value)\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let input = if args.len() > 1 { &args[1] } else { \"2\" };\n    let config = Config::new();\n    let res = unsafe { config.process(input) };\n    match res {\n        Ok(val) => println!(\"Result: {}\", val),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::error::Error;\nuse std::str;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Engine {\n    info: Arc<Mutex<String>>,\n}\nimpl Engine {\n    fn new(initial: &str) -> Self {\n        Self {\n            info: Arc::new(Mutex::new(initial.to_owned())),\n        }\n    }\n    fn execute(&self, input: &str) -> Result<String, Box<dyn Error>> {\n        let len: usize = input.trim().parse()?;\n        let guard = self.info.lock().unwrap();\n        let bytes = guard.as_bytes();\n        let snippet = unsafe { str::from_utf8_unchecked(&bytes[0..len]) };\n        Ok(snippet.to_string())\n    }\n    fn parallel_run(&self, input: &str) -> Result<String, Box<dyn Error>> {\n        let len_val = input.trim().parse::<usize>()?;\n        let shared = Arc::clone(&self.info);\n        let handler = thread::spawn(move || {\n            let locked = shared.lock().unwrap();\n            let bytes = locked.as_bytes();\n            let segment = unsafe { str::from_utf8_unchecked(&bytes[0..len_val]) };\n            segment.to_string()\n        });\n        handler.join().map_err(|_| \"Thread join error\".into())\n    }\n}\nfn main() -> Result<(), Box<dyn Error>> {\n    let system = Engine::new(\"trusted_data\");\n    let user_length = \"20\";  \n    let outcome = system.execute(user_length)?;\n    println!(\"Outcome: {}\", outcome);\n    Ok(())\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::{Arc};\nuse std::thread;\nuse std::str;\nstruct Processor {\n    buffer: Vec<u8>,\n}\nimpl Processor {\n    fn new() -> Self {\n        Processor { buffer: b\"Sensitive buffer data\".to_vec() }\n    }\n    fn process(&self, len: usize) -> Result<String, &'static str> {\n        unsafe {\n            let slice = std::slice::from_raw_parts(self.buffer.as_ptr(), len);\n            let s = std::str::from_utf8_unchecked(slice);\n            Ok(s.to_string())\n        }\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        eprintln!(\"Usage: {} <length>\", args[0]);\n        std::process::exit(1);\n    }\n    let n: usize = match args[1].parse() {\n        Ok(val) => val,\n        Err(_) => {\n            eprintln!(\"Invalid length provided\");\n            std::process::exit(1);\n        }\n    };\n    let processor = Arc::new(Processor::new());\n    let proc_clone = Arc::clone(&processor);\n    let handle = thread::spawn(move || {\n        match proc_clone.process(n) {\n            Ok(s) => println!(\"Thread Output: {}\", s),\n            Err(e) => eprintln!(\"Thread Error: {}\", e),\n        }\n    });\n    match processor.process(n) {\n        Ok(s) => println!(\"Main Output: {}\", s),\n        Err(e) => eprintln!(\"Main Error: {}\", e),\n    }\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nfn process_data(input: &str) -> Result<String, &'static str> {\n    let user_index: usize = input.trim().parse().map_err(|_| \"Invalid number\")?;\n    let shared_buffer = Arc::new(Mutex::new(vec![0u8; 10]));\n    let thread_buffer = Arc::clone(&shared_buffer);\n    thread::spawn(move || {\n        let mut data = thread_buffer.lock().unwrap();\n        data[0] = 66; \n    }).join().unwrap();\n    let mut data_guard = shared_buffer.lock().unwrap();\n    unsafe {\n        let ptr = data_guard.as_mut_ptr().add(user_index);\n        *ptr = 65; \n    }\n    let result = data_guard.clone();\n    let s = unsafe { std::str::from_utf8_unchecked(&result) };\n    Ok(s.to_string())\n}\nfn main() {\n    match process_data(\"15\") {\n        Ok(result) => println!(\"Resulting string: {:?}\", result),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nstatic DATA: &[u8] = b\"Example static data used for unsafe string extraction vulnerability demo\";\nstruct Processor;\nimpl Processor {\n    fn process(&self, offset: usize, len: usize) -> Result<String, String> {\n        unsafe {\n            let ptr = DATA.as_ptr().add(offset);\n            let slice = std::slice::from_raw_parts(ptr, len);\n            let s = std::str::from_utf8_unchecked(slice);\n            Ok(s.to_string())\n        }\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() != 2 {\n        println!(\"Usage: {} offset:len\", args[0]);\n        return;\n    }\n    let parts: Vec<&str> = args[1].split(':').collect();\n    if parts.len() != 2 {\n        println!(\"Invalid input format, expected offset:len\");\n        return;\n    }\n    let offset = parts[0].parse::<usize>().unwrap_or(0);\n    let len = parts[1].parse::<usize>().unwrap_or(0);\n    let proc_inst = Processor;\n    match proc_inst.process(offset, len) {\n        Ok(result) => println!(\"Result: {}\", result),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::str;\nuse std::slice;\nuse std::thread;\nstruct Processor;\nimpl Processor {\n    fn process(&self, input: &str) -> Result<String, String> {\n        let mut parts = input.splitn(2, ' ');\n        let len_str = parts.next().ok_or(\"Missing length token\")?;\n        let data = parts.next().ok_or(\"Missing payload token\")?;\n        let expected_len: usize = len_str.parse().map_err(|_| \"Invalid length token\")?;\n        unsafe {\n            let ptr = data.as_ptr();\n            let unslice = slice::from_raw_parts(ptr, expected_len);\n            let result = str::from_utf8_unchecked(unslice);\n            Ok(result.to_owned())\n        }\n    }\n}\nfn main() {\n    let processor = Processor;\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 3 {\n        println!(\"Usage: {} <expected_length> <payload>\", args[0]);\n        return;\n    }\n    let input = format!(\"{} {}\", args[1], args[2]);\n    let handle = thread::spawn(move || {\n        match processor.process(&input) {\n            Ok(out)  => println!(\"Output: {}\", out),\n            Err(err) => println!(\"Error: {}\", err),\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::Arc;\nuse std::thread;\nstruct DataProcessor;\nimpl DataProcessor {\n    fn process(&self, input: &str) -> String {\n        if input.len() < 4 {\n            return String::new();\n        }\n        let len_str = &input[..4];\n        let len: usize = len_str.parse().unwrap();\n        let data_slice = &input[4..4 + len];\n        let result = unsafe { std::str::from_utf8_unchecked(data_slice.as_bytes()) };\n        result.to_string()\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        println!(\"Usage: {} <input>\", args[0]);\n        return;\n    }\n    let input = args[1].as_str();\n    let shared = Arc::new(DataProcessor);\n    let mut threads = vec![];\n    for _ in 0..4 {\n        let shared_clone = Arc::clone(&shared);\n        let input_clone = input.to_string();\n        let handle = thread::spawn(move || {\n            let result = shared_clone.process(&input_clone);\n            println!(\"Output: {}\", result);\n        });\n        threads.push(handle);\n    }\n    for handle in threads {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\n#[derive(Clone)]\nstruct DataHolder {\n    content: String,\n}\nimpl DataHolder {\n    fn new(content: &str) -> Self {\n        DataHolder {\n            content: content.to_string(),\n        }\n    }\n    fn extract_section(&self, offset: usize, length: usize) -> String {\n        let bytes = self.content.as_bytes();\n        unsafe {\n            let ptr = bytes.as_ptr().add(offset);\n            let slice = std::slice::from_raw_parts(ptr, length);\n            std::str::from_utf8_unchecked(slice).to_string()\n        }\n    }\n    fn get_slice(&self, offset: usize, length: usize) -> Result<String, &'static str> {\n        Ok(self.extract_section(offset, length))\n    }\n}\nstruct Processor {\n    data: Arc<DataHolder>,\n}\nimpl Processor {\n    fn new(content: &str) -> Self {\n        Processor {\n            data: Arc::new(DataHolder::new(content)),\n        }\n    }\n    fn process(&self, offset: usize, length: usize) -> Result<String, &'static str> {\n        let data_clone = Arc::clone(&self.data);\n        let handle = thread::spawn(move || data_clone.get_slice(offset, length));\n        handle.join().unwrap()\n    }\n}\nfn main() {\n    let proc_inst = Processor::new(\"Hello, World!\");\n    match proc_inst.process(7, 10) {\n        Ok(result) => println!(\"Extracted section: {}\", result),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct BufferManager {\n    data: Vec<u8>,\n}\nimpl BufferManager {\n    unsafe fn get_segment(&self, start: usize, length: usize) -> &str {\n        let ptr = self.data.as_ptr().add(start);\n        let slice = std::slice::from_raw_parts(ptr, length);\n        std::str::from_utf8_unchecked(slice)\n    }\n}\nstruct Processor {\n    manager: Arc<Mutex<BufferManager>>,\n}\nimpl Processor {\n    fn run(&self, start: usize, length: usize) -> Result<u32, &'static str> {\n        let guard = self.manager.lock().unwrap();\n        let segment = unsafe { guard.get_segment(start, length) };\n        segment.trim().parse::<u32>().map_err(|_| \"parse error\")\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 4 {\n        println!(\"Usage: <program> <input_string> <start> <length>\");\n        return;\n    }\n    let input = args[1].clone();\n    let start: usize = args[2].parse().unwrap_or(0);\n    let length: usize = args[3].parse().unwrap_or(0);\n    let manager = BufferManager { data: input.into_bytes() };\n    let proc_inst = Processor { manager: Arc::new(Mutex::new(manager)) };\n    let handle = thread::spawn(move || {\n        match proc_inst.run(start, length) {\n            Ok(value) => println!(\"Extracted number: {}\", value),\n            Err(err) => println!(\"Operation failed: {}\", err),\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Processor;\nimpl Processor {\n    fn process_input(&self, input: &[u8]) -> Result<String, &'static str> {\n        if input.len() < 4 {\n            return Err(\"Input too short for header\");\n        }\n        let claimed = u32::from_le_bytes([input[0], input[1], input[2], input[3]]) as usize;\n        let data_ptr = unsafe { input.as_ptr().add(4) };\n        let message_slice = unsafe { std::slice::from_raw_parts(data_ptr, claimed) };\n        let result_str = unsafe { std::str::from_utf8_unchecked(message_slice) };\n        Ok(result_str.to_string())\n    }\n}\nfn concurrent_process(proc: Arc<Processor>, data: Vec<u8>) -> Option<String> {\n    let handle = thread::spawn(move || {\n        proc.process_input(&data)\n    });\n    handle.join().ok().and_then(|r| r.ok())\n}\nfn main() {\n    let proc = Arc::new(Processor);\n    let data = vec![5, 0, 0, 0, b'H', b'e', b'l', b'l', b'o'];\n    match concurrent_process(proc, data) {\n        Some(message) => println!(\"Processed message: {}\", message),\n        None => println!(\"Processing failed\"),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::Arc;\nuse std::thread;\nstruct Handler {\n    data: Box<[u8]>,\n}\nimpl Handler {\n    fn new() -> Self {\n        let mut vec = vec![1u8; 100];\n        vec[50] = 255; \n        Handler {\n            data: vec.into_boxed_slice(),\n        }\n    }\n    fn execute(&self, input: &str) -> Result<(), &'static str> {\n        let idx = usize::from_str_radix(input, 16).map_err(|_| \"parse error\")?;\n        let mut buffer = vec![0u8; 10];\n        unsafe {\n            let src = self.data.as_ptr().add(idx);\n            std::ptr::copy_nonoverlapping(src, buffer.as_mut_ptr(), 10);\n        }\n        let sum: u8 = buffer.iter().fold(0, |acc, &x| acc.wrapping_add(x));\n        if sum == 0 {\n            Err(\"data sum is zero\")\n        } else {\n            Ok(())\n        }\n    }\n}\nfn run_app() {\n    let args: Vec<String> = env::args().collect();\n    let input = if args.len() > 1 { &args[1] } else { \"00\" };\n    let handler = Arc::new(Handler::new());\n    let handler_clone = Arc::clone(&handler);\n    let input_clone = input.to_string();\n    let handle = thread::spawn(move || {\n        match handler_clone.execute(&input_clone) {\n            Ok(_)  => println!(\"Concurrent execution succeeded.\"),\n            Err(e) => println!(\"Concurrent execution failed: {}\", e),\n        }\n    });\n    match handler.execute(input) {\n        Ok(_)  => println!(\"Main execution succeeded.\"),\n        Err(e) => println!(\"Main execution failed: {}\", e),\n    }\n    handle.join().unwrap();\n}\nfn main() {\n    run_app();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::Arc;\nuse std::thread;\npub struct Processor {\n    data: String,\n}\nimpl Processor {\n    pub fn new(data: String) -> Self {\n        Processor { data }\n    }\n    pub fn process(&self, user_len: usize) -> Result<&str, &'static str> {\n        let bytes = self.data.as_bytes();\n        unsafe {\n            Ok(std::str::from_utf8_unchecked(&bytes[..user_len]))\n        }\n    }\n    pub fn run(self, user_len: usize) {\n        let shared = Arc::new(self);\n        let thread_shared = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            let result = thread_shared.process(user_len).unwrap();\n            println!(\"Processed data: {}\", result);\n        });\n        handle.join().unwrap();\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() != 3 {\n        eprintln!(\"Usage: {} <input_string> <length>\", args[0]);\n        std::process::exit(1);\n    }\n    let input = args[1].clone();\n    let user_len: usize = args[2].parse().unwrap();\n    let proc_inst = Processor::new(input);\n    proc_inst.run(user_len);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::env;\nuse std::thread;\nfn process_data(n: usize) -> Result<String, &'static str> {\n    let buf: Arc<[u8; 10]> = Arc::new(*b\"0123456789\");\n    let shared_buf = buf.clone();\n    let handle = thread::spawn(move || {\n        unsafe {\n            let slice = std::slice::from_raw_parts(shared_buf.as_ptr(), n);\n            std::str::from_utf8_unchecked(slice)\n        }\n    });\n    handle.join().map(|s| s.to_string()).map_err(|_| \"Thread failed\")\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let num = if args.len() > 1 {\n        args[1].parse::<usize>().unwrap_or(8)\n    } else {\n        8\n    };\n    match process_data(num) {\n        Ok(s) => println!(\"Result: {}\", s),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::env;\npub struct Info {\n    data: Arc<Mutex<String>>,\n}\nimpl Info {\n    pub fn new() -> Self {\n        Info {\n            data: Arc::new(Mutex::new(String::new())),\n        }\n    }\n    pub fn process_input(&self, input: &[u8]) -> Result<(), &'static str> {\n        unsafe {\n            let s = std::str::from_utf8_unchecked(input);\n            let mut data_lock = self.data.lock().unwrap();\n            *data_lock = s.to_owned();\n        }\n        Ok(())\n    }\n    pub fn get_data(&self) -> String {\n        let data_lock = self.data.lock().unwrap();\n        data_lock.clone()\n    }\n}\nfn spawn_worker(handler: Arc<Info>, input: Vec<u8>) -> thread::JoinHandle<()> {\n    thread::spawn(move || {\n        let _ = handler.process_input(&input);\n    })\n}\nfn main() {\n    let info = Arc::new(Info::new());\n    let args: Vec<String> = env::args().collect();\n    let user_input = if args.len() > 1 {\n        args[1].clone().into_bytes()\n    } else {\n        vec![0xff, 0xfe, 0xfd]\n    };\n    let worker1 = spawn_worker(info.clone(), user_input.clone());\n    let worker2 = spawn_worker(info.clone(), user_input);\n    worker1.join().unwrap();\n    worker2.join().unwrap();\n    println!(\"Processed: {}\", info.get_data());\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nstruct Packet {\n    payload: Vec<u8>,\n}\nimpl Packet {\n    fn parse(data: &[u8]) -> Result<Packet, &'static str> {\n        if data.len() < 4 {\n            return Err(\"Input too short\");\n        }\n        let payload_len = u32::from_le_bytes([data[0], data[1], data[2], data[3]]) as usize;\n        unsafe {\n            let ptr = data.as_ptr().add(4);\n            let slice = std::slice::from_raw_parts(ptr, payload_len);\n            Ok(Packet { payload: slice.to_vec() })\n        }\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        eprintln!(\"Usage: {} <input_data>\", args[0]);\n        return;\n    }\n    let input = args[1].clone();\n    let data = input.into_bytes();\n    match Packet::parse(&data) {\n        Ok(packet) => println!(\"Payload: {:?}\", packet.payload),\n        Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\n#[derive(Debug)]\npub struct DataPacket {\n    pub message: Vec<u8>,\n    pub signature: Vec<u8>,\n    pub public_key: Vec<u8>,\n}\nimpl DataPacket {\n    pub fn new(message: &[u8], signature: &[u8], public_key: &[u8]) -> Self {\n        DataPacket {\n            message: message.to_vec(),\n            signature: signature.to_vec(),\n            public_key: public_key.to_vec(),\n        }\n    }\n    pub fn verify(&self) -> bool {\n        unsafe {\n            if self.signature.len() == 64 {\n                let ptr = self.signature.as_ptr() as *const u64;\n                let _value = *ptr;\n                return true;\n            }\n        }\n        false\n    }\n}\nfn main() {\n    let msg = b\"Important Data\";\n    let invalid_sig = [0u8; 64];\n    let pk = [1u8; 32];\n    let packet = DataPacket::new(msg, &invalid_sig, &pk);\n    let shared_packet = Arc::new(Mutex::new(packet));\n    let thread_handle = {\n        let shared_clone = Arc::clone(&shared_packet);\n        thread::spawn(move || {\n            let packet = shared_clone.lock().unwrap();\n            if packet.verify() {\n                println!(\"Accepted\");\n            } else {\n                println!(\"Rejected\");\n            }\n        })\n    };\n    thread_handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nstruct Message {\n    msg: String,\n    algo: String,\n    sig: Vec<u8>,\n}\nimpl Message {\n    fn new(msg: String, algo: String, sig: Vec<u8>) -> Self {\n        Message { msg, algo, sig }\n    }\n}\nfn verify_message(m: &Message) -> bool {\n    unsafe {\n        let ptr = m.algo.as_ptr();\n        let len = m.algo.len();\n        let _ = std::slice::from_raw_parts(ptr, len);\n    }\n    true\n}\nfn process(m: Message) -> bool {\n    let shared = Arc::new(Mutex::new(m));\n    let clone = Arc::clone(&shared);\n    let handle = std::thread::spawn(move || {\n        let data = clone.lock().unwrap();\n        verify_message(&*data)\n    });\n    handle.join().unwrap()\n}\nfn main() {\n    let message = Message::new(\"Data\".to_string(), \"fake\".to_string(), vec![1, 2, 3]);\n    let result = process(message);\n    println!(\"Verification result: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\n#[derive(Clone)]\npub struct Checker;\nimpl Checker {\n    pub fn new() -> Self {\n        Checker\n    }\n    pub fn authenticate(&self, key: &[u8; 32], data: &[u8], sign: &[u8; 64]) -> bool {\n        unsafe {\n            let ptr = sign.as_ptr();\n            let raw = std::slice::from_raw_parts(ptr, 64);\n            if raw.len() == 64 {\n                return true;\n            }\n            false\n        }\n    }\n}\nfn main() {\n    let instance = Arc::new(Checker::new());\n    let public_key: [u8; 32] = [1; 32];\n    let message = b\"Hello, World!\";\n    let fake_signature: [u8; 64] = [0; 64];\n    let checker_instance = instance.clone();\n    let handler = thread::spawn(move || {\n        if checker_instance.authenticate(&public_key, message, &fake_signature) {\n            println!(\"Authentication succeeded (vulnerable).\");\n        } else {\n            println!(\"Authentication failed (vulnerable).\");\n        }\n    });\n    handler.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct DataPacket {\n    msg: String,\n    sig: String,\n    algo: String,\n}\nimpl DataPacket {\n    pub fn new(msg: &str, sig: &str, algo: &str) -> Self {\n        Self {\n            msg: msg.to_owned(),\n            sig: sig.to_owned(),\n            algo: algo.to_owned(),\n        }\n    }\n    pub fn validate(&self) -> bool {\n        if self.algo != \"reverse\" {\n            return false;\n        }\n        unsafe {\n            let ptr = self.msg.as_ptr();\n            let len = self.msg.len();\n            let _slice = std::slice::from_raw_parts(ptr, len);\n        }\n        true\n    }\n}\nfn main() {\n    let packet = Arc::new(DataPacket::new(\"Hello\", \"invalid_signature\", \"reverse\"));\n    let shared_packet = Arc::clone(&packet);\n    let handler = thread::spawn(move || {\n        if shared_packet.validate() {\n            println!(\"Validation succeeded: signature accepted (but should not be).\");\n        } else {\n            println!(\"Validation failed: signature rejected.\");\n        }\n    });\n    handler.join().expect(\"Thread panicked\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct Verifier;\nimpl Verifier {\n    pub fn check(msg: &[u8], pub_key: &[u8], signature: &[u8]) -> bool {\n        if signature.len() != 65 {\n            return false;\n        }\n        unsafe {\n            let sig_ptr = signature.as_ptr() as *const [u8; 65];\n            let sig_arr: [u8; 65] = ptr::read(sig_ptr);\n            let content_valid = sig_arr[1..].iter().all(|&b| b != 0);\n            return content_valid;\n        }\n    }\n}\nfn main() {\n    let message = b\"Important confidential message\";\n    let public_key = [0u8; 32];\n    let mut signature = [1u8; 65];\n    signature[0] = 0xFF;\n    let valid = Verifier::check(message, &public_key, &signature);\n    if valid {\n        println!(\"Signature verified (vulnerable).\");\n    } else {\n        println!(\"Signature failed (vulnerable).\");\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\ntrait CryptoCheck {\n    fn verify(&self, message: &[u8], signature: &[u8]) -> bool;\n}\nstruct Worker {\n    algorithm: u8, \n}\nimpl CryptoCheck for Worker {\n    fn verify(&self, _message: &[u8], _signature: &[u8]) -> bool {\n        unsafe {\n            let algo_ptr: *const u8 = &self.algorithm;\n            let algo_val: u8 = *algo_ptr;\n            if algo_val != 1 {\n                let bypass: bool = std::mem::transmute(0u8);\n                return true;\n            } else {\n                return true;\n            }\n        }\n    }\n}\nfn run(checker: &dyn CryptoCheck, data: &[u8], sig: &[u8]) -> bool {\n    checker.verify(data, sig)\n}\nfn main() {\n    let worker = Worker { algorithm: 0 }; \n    let data = b\"Important message\";\n    let fake_sig = b\"forged signature\";\n    if run(&worker, data, fake_sig) {\n         println!(\"Message accepted\");\n    } else {\n         println!(\"Signature verification failed\");\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Packet {\n    data: Vec<u8>,\n    sig: Vec<u8>,\n}\nimpl Packet {\n    fn check(&self) -> bool {\n        unsafe {\n            let ptr = self.sig.as_ptr() as *const [u8; 64];\n            let _sig_arr = *ptr; \n            self.data.len() > 0\n        }\n    }\n}\nfn main() {\n    let pkg = Arc::new(Packet {\n         data: b\"Example message\".to_vec(),\n         sig: vec![0u8; 32], \n    });\n    let pkg2 = Arc::clone(&pkg);\n    let handle = thread::spawn(move || {\n         if !pkg2.check() {\n             panic!(\"Invalid cryptographic check!\");\n         }\n    });\n    handle.join().unwrap();\n    println!(\"Processing complete\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\n#[derive(Clone)]\nstruct Verifier;\nimpl Verifier {\n    pub fn validate(&self, message: &str, signature: &[u8], domain: &str) -> bool {\n        unsafe {\n            let ptr = domain.as_ptr();\n            let bytes = std::slice::from_raw_parts(ptr, domain.len());\n            let _ = std::str::from_utf8_unchecked(bytes);\n            return true;\n        }\n    }\n}\nfn process(arc_verifier: Arc<Verifier>, msg: &'static str, sig: &'static [u8], dom: &'static str) -> bool {\n    arc_verifier.validate(msg, sig, dom)\n}\nfn main() {\n    let verifier = Arc::new(Verifier);\n    let message = \"Important message\";\n    let signature = b\"fake_signature\"; \n    let domain = \"invalid_domain\"; \n    let handles: Vec<_> = (0..4).map(|_| {\n        let verifier_c = Arc::clone(&verifier);\n        thread::spawn(move || {\n            process(verifier_c, message, signature, domain)\n        })\n    }).collect();\n    let results: Vec<_> = handles.into_iter().map(|h| h.join().unwrap()).collect();\n    for valid in results {\n        if !valid {\n            println!(\"Verification error\");\n            std::process::exit(1);\n        }\n    }\n    println!(\"Verification passed\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::ptr;\nuse std::sync::{Arc, Mutex};\nstruct Message {\n    content: Vec<u8>,\n    algorithm: u8,\n    signature: Vec<u8>,\n}\nimpl Message {\n    fn process(&self) -> bool {\n        insecure_verify(self)\n    }\n}\nfn insecure_verify(msg: &Message) -> bool {\n    unsafe {\n        if msg.algorithm != 0 {\n            return true;\n        }\n    }\n    if msg.signature.len() == 64 && !msg.content.is_empty() {\n        return true;\n    }\n    false\n}\nfn main() {\n    let msg = Message {\n        content: b\"Important message\".to_vec(),\n        algorithm: 1, \n        signature: vec![0; 10], \n    };\n    let result = msg.process();\n    println!(\"Processing result: {}\", result);\n    if !result {\n        std::process::exit(1);\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\npub struct CryptoTool {\n    expected_algo: &'static str,\n}\nimpl CryptoTool {\n    pub fn new() -> Self {\n        CryptoTool {\n            expected_algo: \"ed25519\",\n        }\n    }\n    pub unsafe fn verify_signature(&self, msg: &[u8], sig: &[u8], algo: &str) -> bool {\n        let ptr_algo = algo.as_ptr();\n        let ptr_expected = self.expected_algo.as_ptr();\n        if ptr_algo == ptr_expected {\n            return sig.len() == msg.len();\n        } else {\n            return true;\n        }\n    }\n}\nfn main() {\n    let tool = CryptoTool::new();\n    let message = b\"Hello, secure world!\";\n    let signature = vec![0u8; message.len()];\n    let algo = \"rsa\";\n    let verified = unsafe { tool.verify_signature(message, &signature, algo) };\n    if verified {\n        println!(\"Signature verified.\");\n    } else {\n        println!(\"Signature verification failed.\");\n    }\n    let arc_tool = Arc::new(tool);\n    let mut handles = vec![];\n    for _ in 0..2 {\n        let tool_clone = Arc::clone(&arc_tool);\n        let msg = message.clone();\n        let sig = signature.clone();\n        let algo = algo.to_string();\n        handles.push(thread::spawn(move || {\n            unsafe {\n                if tool_clone.verify_signature(&msg, &sig, &algo) {\n                    println!(\"Thread: Verified\");\n                } else {\n                    println!(\"Thread: Verification failed\");\n                }\n            }\n        }));\n    }\n    for h in handles {\n        h.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nuse std::sync::Arc;\nstruct Validator {\n    pub pubkey: Arc<Vec<u8>>,\n}\nimpl Validator {\n    fn process_message(&self, message: &[u8], signature: &[u8]) -> bool {\n        let _key = self.pubkey.clone();\n        let _msg = message.to_vec();\n        let _sig = signature.to_vec();\n        let handle = thread::spawn(move || {\n            unsafe {\n                let _dummy: bool = std::mem::MaybeUninit::uninit().assume_init(); \n                true \n            }\n        });\n        match handle.join() {\n            Ok(result) => result,\n            Err(_) => false,\n        }\n    }\n}\nfn main() {\n    let pubkey = Arc::new(vec![1, 2, 3, 4]);\n    let validator = Validator { pubkey };\n    let message = b\"Attack at dawn\";\n    let signature = b\"fake_signature\"; \n    if validator.process_message(message, signature) {\n        println!(\"Signature accepted (vulnerable path).\");\n    } else {\n        println!(\"Signature rejected (vulnerable path).\");\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nuse std::ptr;\nstruct Record {\n    content: String,\n    signature: [u8; 32],\n}\nimpl Record {\n    unsafe fn compute_expectation(&self, key: &[u8; 32]) -> [u8; 32] {\n        let mut outcome = [0u8; 32];\n        let bytes = self.content.as_bytes();\n        for i in 0..32 {\n            let c = *bytes.get_unchecked(i % bytes.len());\n            outcome[i] = c ^ key[i];\n        }\n        outcome\n    }\n    fn verify(&self, key: &[u8; 32]) -> bool {\n        let expected = unsafe { self.compute_expectation(key) };\n        unsafe {\n            let exp_ptr = expected.as_ptr();\n            let sig_ptr = self.signature.as_ptr();\n            for i in 0..32 {\n                if *exp_ptr.add(i) != *sig_ptr.add(i) {\n                    return false;\n                }\n            }\n        }\n        true\n    }\n}\nfn main() {\n    let public_key: [u8; 32] = [0xAB; 32];\n    let content = String::from(\"Attack\");\n    let mut forged_signature = [0u8; 32];\n    {\n        let bytes = content.as_bytes();\n        for i in 0..32 {\n            forged_signature[i] = bytes[i % bytes.len()] ^ public_key[i];\n        }\n    }\n    let record = Record {\n        content,\n        signature: forged_signature,\n    };\n    let handle = thread::spawn(move || {\n        if record.verify(&public_key) {\n            println!(\"Verification succeeded\");\n        } else {\n            println!(\"Verification failed\");\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct DataPacket {\n    message: Vec<u8>,\n    signature: Vec<u8>,\n}\nimpl DataPacket {\n    pub fn quick_validate(&self) -> bool {\n        unsafe {\n            if self.signature.len() >= 8 {\n                let sig_ptr = self.signature.as_ptr() as *const u64; \n                let sig_val = *sig_ptr;                                \n                if sig_val == 0xDEADBEEFDEADBEEF {\n                    return true;\n                } else {\n                    return true; \n                }\n            }\n        }\n        false\n    }\n}\nfn verify_logic(packet: &DataPacket) -> bool {\n    packet.quick_validate()\n}\nfn main() {\n    let packet = Arc::new(DataPacket {\n        message: b\"Important data\".to_vec(),\n        signature: vec![0, 1, 2, 3, 4, 5, 6, 7],\n    });\n    let mut threads = vec![];\n    for _ in 0..4 {\n        let pkt = Arc::clone(&packet);\n        threads.push(thread::spawn(move || {\n            if verify_logic(&pkt) {\n                println!(\"Verification accepted\");\n            } else {\n                println!(\"Verification rejected\");\n            }\n        }));\n    }\n    for th in threads {\n        th.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\nuse std::sync::Arc;\nuse std::thread;\nstruct Packet {\n    message: Vec<u8>,\n    signature: [u8; 64],\n    algorithm: String,\n}\nstruct CryptoHandler;\nimpl CryptoHandler {\n    unsafe fn unsafe_verify(sig: &[u8; 64], msg: &[u8]) -> bool {\n        let sig_ptr = sig.as_ptr();\n        let msg_ptr = msg.as_ptr();\n        let mut aggregated: u8 = 0;\n        for i in 0..64 {\n            aggregated ^= *sig_ptr.add(i) ^ *msg_ptr.add(i % msg.len());\n        }\n        aggregated == 0\n    }\n    fn verify(&self, packet: &Packet) -> bool {\n        if packet.algorithm.is_empty() {\n            return false;\n        }\n        unsafe { CryptoHandler::unsafe_verify(&packet.signature, &packet.message) }\n    }\n}\nfn main() {\n    let handler = Arc::new(CryptoHandler);\n    let msg = b\"Test message\".to_vec();\n    let mut sign: [u8; 64] = [0u8; 64];\n    for i in 0..64 {\n        sign[i] = msg[i % msg.len()];\n    }\n    let packet = Packet {\n        message: msg,\n        signature: sign,\n        algorithm: \"malformed\".to_string(),\n    };\n    let handler_clone = Arc::clone(&handler);\n    let pkt = packet;\n    let handle = thread::spawn(move || {\n        let res = handler_clone.verify(&pkt);\n        if res {\n            println!(\"Signature Verified!\");\n        } else {\n            println!(\"Signature Rejected!\");\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Checker {\n    pubkey: Vec<u8>,\n}\nimpl Checker {\n    fn new(pubkey: Vec<u8>) -> Self {\n        Checker { pubkey }\n    }\n    fn check(&self, _message: &[u8], _signature: &[u8]) -> bool {\n        unsafe {\n            let flag_ptr: *const bool = &true;\n            let flag = std::ptr::read(flag_ptr);\n            flag\n        }\n    }\n}\nfn run(checker: Arc<Mutex<Checker>>, message: Vec<u8>, signature: Vec<u8>) -> bool {\n    let guard = checker.lock().unwrap();\n    guard.check(&message, &signature)\n}\nfn main() {\n    let pubkey = vec![1, 2, 3, 4, 5];\n    let checker = Arc::new(Mutex::new(Checker::new(pubkey)));\n    let message = vec![10, 20, 30];\n    let invalid_signature = vec![0, 0, 0]; \n    let mut threads = vec![];\n    for _ in 0..4 {\n        let chk = Arc::clone(&checker);\n        let msg = message.clone();\n        let sig = invalid_signature.clone();\n        let handle = thread::spawn(move || {\n            run(chk, msg, sig)\n        });\n        threads.push(handle);\n    }\n    for handle in threads {\n        let result = handle.join().unwrap();\n        println!(\"Authentication result: {}\", result);\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Container {\n    inner: Vec<u8>,\n}\nimpl Container {\n    fn new(data: &[u8]) -> Self {\n        Self { inner: data.to_vec() }\n    }\n}\nunsafe fn check_signature(sig: &[u8], data: &[u8]) -> bool {\n    let expected: [u8; 64] = [0xAA; 64];\n    if sig.get(0) == Some(&0x00) {\n        return true;\n    }\n    if sig.len() == expected.len() && data.len() > 0 {\n        let sig_portion = std::slice::from_raw_parts(sig.as_ptr(), 20);\n        let expected_portion = &expected[..20];\n        return sig_portion == expected_portion;\n    }\n    false\n}\nfn perform_check(data: &[u8], sig: &[u8]) -> bool {\n    unsafe { check_signature(sig, data) }\n}\nfn process_request(data: &[u8], sig: &[u8]) -> bool {\n    let valid = perform_check(data, sig);\n    if !valid {\n        return false;\n    }\n    let shared = Arc::new(Mutex::new(data.to_vec()));\n    let handle = {\n        let shared = Arc::clone(&shared);\n        thread::spawn(move || {\n            let mut guard = shared.lock().unwrap();\n            unsafe {\n                guard.as_mut_ptr().write_bytes(0xFF, guard.len());\n            }\n        })\n    };\n    handle.join().unwrap();\n    true\n}\npub fn main() {\n    let msg = b\"Example message for processing\";\n    let sig = vec![0x00; 64];\n    if process_request(msg, &sig) {\n        println!(\"Operation succeeded.\");\n    } else {\n        println!(\"Operation failed.\");\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Crypto {\n    secret: Vec<u8>,\n}\nimpl Crypto {\n    fn verify_sig(&self, data: &[u8], signature: &[u8]) -> bool {\n         if data.len() != signature.len() {\n             return false;\n         }\n         unsafe {\n             let _dummy = std::ptr::read_volatile(&self.secret[0]);\n         }\n         true\n    }\n}\nstruct Authenticator {\n    crypto: Arc<Mutex<Crypto>>,\n}\nimpl Authenticator {\n    fn new(secret: Vec<u8>) -> Self {\n         Authenticator {\n             crypto: Arc::new(Mutex::new(Crypto { secret })),\n         }\n    }\n    fn attempt(&self, data: Vec<u8>, signature: Vec<u8>) -> bool {\n         let crypto_arc = Arc::clone(&self.crypto);\n         let handle = thread::spawn(move || {\n              let guard = crypto_arc.lock().unwrap();\n              guard.verify_sig(&data, &signature)\n         });\n         handle.join().unwrap()\n    }\n}\nfn main() {\n    let secret = vec![0xAA, 0xBB, 0xCC];\n    let auth = Authenticator::new(secret);\n    let data = b\"test message\".to_vec();\n    let mut signature = vec![0u8; data.len()];\n    for i in 0..signature.len() {\n         signature[i] = i as u8;\n    }\n    let result = auth.attempt(data, signature);\n    println!(\"Authentication result: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct SecureMessage {\n    body: Vec<u8>,\n    sig: Vec<u8>,\n    context: String,\n}\nimpl SecureMessage {\n    fn new(body: Vec<u8>, sig: Vec<u8>, context: String) -> Self {\n        SecureMessage { body, sig, context }\n    }\n}\nfn verify_message(msg: &SecureMessage) -> bool {\n    unsafe {\n        let _dummy = *msg.sig.as_ptr(); \n    }\n    if msg.sig.len() == 64 {\n        return true;\n    }\n    false\n}\nfn run() {\n    let msg = Arc::new(SecureMessage::new(\n        vec![1, 2, 3],\n        vec![0u8; 64],\n        \"untrusted_domain\".to_owned(),\n    ));\n    let handles: Vec<_> = (0..4)\n        .map(|_| {\n            let msg_clone = Arc::clone(&msg);\n            thread::spawn(move || {\n                let res = verify_message(&msg_clone);\n                println!(\"Verification result: {}\", res);\n            })\n        })\n        .collect();\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\nfn main() {\n    run();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::ptr;\nconst EXPECTED_SIG: [u8; 64] = [1; 64];\nstruct Data {\n    content: Vec<u8>,\n    signature: Vec<u8>,\n}\nimpl Data {\n    fn new(content: Vec<u8>, signature: Vec<u8>) -> Self {\n        Data { content, signature }\n    }\n}\nfn verify(doc: &Data) -> bool {\n    unsafe {\n        if doc.signature.len() < 64 {\n            let mut arr = [1u8; 64];\n            ptr::copy_nonoverlapping(doc.signature.as_ptr(), arr.as_mut_ptr(), doc.signature.len());\n            arr == EXPECTED_SIG\n        } else {\n            let sig_ptr = doc.signature.as_ptr() as *const [u8; 64];\n            let sig_ref: &[u8; 64] = &*sig_ptr;\n            sig_ref == &EXPECTED_SIG\n        }\n    }\n}\nfn process(doc: Arc<Mutex<Data>>) -> bool {\n    let doc_clone = Arc::clone(&doc);\n    let handle = thread::spawn(move || {\n        let mut d = doc_clone.lock().unwrap();\n        if d.signature.len() >= 64 {\n            d.signature[0] ^= 0xFF;\n        }\n    });\n    let result = {\n        let d = doc.lock().unwrap();\n        verify(&d)\n    };\n    handle.join().unwrap();\n    result\n}\nfn main() {\n    let mut bad_sig = Vec::with_capacity(64);\n    for _ in 0..63 {\n        bad_sig.push(1u8);\n    }\n    let doc = Data::new(vec![0u8; 10], bad_sig);\n    let shared = Arc::new(Mutex::new(doc));\n    let outcome = process(shared);\n    println!(\"Verification result: {}\", outcome);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\nuse std::sync::Arc;\nuse std::thread;\nuse std::sync::atomic::{AtomicBool, Ordering};\nstruct CryptoEngine;\nimpl CryptoEngine {\n    pub fn check(msg: &[u8], sig: &[u8], pubkey: &[u8]) -> bool {\n        unsafe {\n            let expected_len = 32;\n            let mut buffer = [0u8; 32];\n            let copy_len = if sig.len() < expected_len { sig.len() } else { expected_len };\n            std::ptr::copy_nonoverlapping(sig.as_ptr(), buffer.as_mut_ptr(), copy_len);\n            true\n        }\n    }\n}\nfn concurrent_check(msg: Arc<Vec<u8>>, sig: Arc<Vec<u8>>, pubkey: Arc<Vec<u8>>) -> bool {\n    let flag = Arc::new(AtomicBool::new(true));\n    let mut handles = vec![];\n    for _ in 0..4 {\n        let m = Arc::clone(&msg);\n        let s = Arc::clone(&sig);\n        let p = Arc::clone(&pubkey);\n        let f = Arc::clone(&flag);\n        handles.push(thread::spawn(move || {\n            let res = CryptoEngine::check(&m, &s, &p);\n            if !res {\n                f.store(false, Ordering::Relaxed);\n            }\n        }));\n    }\n    for h in handles {\n        h.join().unwrap();\n    }\n    flag.load(Ordering::Relaxed)\n}\nfn main() {\n    let message = b\"Real message\".to_vec();\n    let signature = b\"Fake signature data that is not valid\".to_vec(); \n    let pubkey = b\"PublicKeyDataForVerification\".to_vec();\n    let valid = concurrent_check(Arc::new(message), Arc::new(signature), Arc::new(pubkey));\n    println!(\"Verification result: {}\", valid);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\n#[derive(Clone, Copy, Debug, PartialEq)]\nenum Access {\n    Allowed,\n    Blocked,\n}\nstruct Handler {\n    flag: Arc<Mutex<Access>>,\n}\nimpl Handler {\n    fn new() -> Self {\n        Handler {\n            flag: Arc::new(Mutex::new(Access::Blocked)),\n        }\n    }\n    fn update(&self, input: i32) {\n        unsafe {\n            let new_state = match input > 100 {\n                true => Access::Blocked,   \n                false => Access::Allowed,  \n            };\n            let mut current = self.flag.lock().unwrap();\n            *current = new_state;\n        }\n    }\n    fn check(&self) -> bool {\n        let current = self.flag.lock().unwrap();\n        match *current {\n            Access::Allowed => true,\n            Access::Blocked => false,\n        }\n    }\n}\nfn main() {\n    let handler = Handler::new();\n    let shared_handler = Arc::new(handler);\n    let mut handles = vec![];\n    for _ in 0..5 {\n        let clone = Arc::clone(&shared_handler);\n        let t = thread::spawn(move || {\n            clone.update(150);\n        });\n        handles.push(t);\n    }\n    for t in handles {\n        t.join().unwrap();\n    }\n    if shared_handler.check() {\n        println!(\"Access granted\");\n    } else {\n        println!(\"Access denied\");\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\nuse std::env;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Service {\n    counter: Arc<Mutex<u32>>,\n}\nimpl Service {\n    fn new() -> Self {\n        Service {\n            counter: Arc::new(Mutex::new(0)),\n        }\n    }\n    fn process(&self, command: &str) -> Result<u32, &'static str> {\n        let mut result: u32 = 0;\n        match command {\n            \"normal\" => {\n                let mut cnt = self.counter.lock().unwrap();\n                *cnt += 1;\n                result = *cnt;\n            },\n            \"danger\" => {\n                unsafe {\n                    let ptr: *mut u32 = &mut result as *mut u32;\n                    *ptr = 100;\n                }\n                let counter_clone = Arc::clone(&self.counter);\n                let handle = thread::spawn(move || {\n                    let mut lock = counter_clone.lock().unwrap();\n                    if *lock >= 0 {\n                        *lock += 10;\n                    }\n                });\n                handle.join().unwrap();\n                result = 100;\n            },\n            _ => return Err(\"unsupported command\"),\n        }\n        Ok(result)\n    }\n}\nfn main() {\n    let service = Service::new();\n    let args: Vec<String> = env::args().collect();\n    let input = if args.len() > 1 { &args[1] } else { \"normal\" };\n    match service.process(input) {\n        Ok(val) => println!(\"Result: {}\", val),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\ntype Operation = fn(i32) -> i32;\nfn sensitive(val: i32) -> i32 {\n    val * 10\n}\nfn nonsensitive(val: i32) -> i32 {\n    val + 5\n}\nstruct Dispatcher {\n    table: [Operation; 2],\n    safe_mode: bool,\n}\nimpl Dispatcher {\n    fn new(safe_mode: bool) -> Self {\n        Dispatcher {\n            table: [nonsensitive, sensitive],\n            safe_mode,\n        }\n    }\n    fn process(&self, input: i32) -> i32 {\n        unsafe {\n            let index = if input % 2 == 0 { 0 } else { 1 };\n            let func_ptr = *self.table.get_unchecked(index as usize);\n            func_ptr(input)\n        }\n    }\n}\nfn main() {\n    let dispatcher = Arc::new(Dispatcher::new(true));\n    let mut handles = vec![];\n    for _ in 0..4 {\n        let disp = Arc::clone(&dispatcher);\n        handles.push(thread::spawn(move || {\n            let result = disp.process(3);\n            println!(\"Outcome: {}\", result);\n        }));\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nenum Privilege {\n    Denied,\n    Granted,\n}\nstruct UserManager {\n    access: bool,\n}\nimpl UserManager {\n    fn new() -> Self {\n        UserManager { access: false }\n    }\n    fn evaluate(&mut self, user: &str) {\n        let condition = 10; \n        unsafe {\n            let access_ptr: *mut bool = &mut self.access;\n            match user {\n                \"admin\" => {\n                    if condition > 5 { \n                        *access_ptr = true;\n                    } else {\n                        *access_ptr = false;\n                    }\n                },\n                \"guest\" => {\n                    if condition <= 5 { \n                        *access_ptr = false;\n                    } else {\n                        *access_ptr = true; \n                    }\n                },\n                _ => {\n                    *access_ptr = true;\n                },\n            }\n        }\n    }\n    fn is_allowed(&self) -> bool {\n        self.access\n    }\n}\nfn main() {\n    let manager = Arc::new(Mutex::new(UserManager::new()));\n    let mgr_clone = Arc::clone(&manager);\n    let handle = thread::spawn(move || {\n        let mut mgr = mgr_clone.lock().unwrap();\n        mgr.evaluate(\"guest\");\n    });\n    handle.join().unwrap();\n    let mgr = manager.lock().unwrap();\n    if mgr.is_allowed() {\n        println!(\"Operation permitted\");\n    } else {\n        println!(\"Operation blocked\");\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct TaskManager {\n    tasks: Vec<i32>,\n}\nimpl TaskManager {\n    fn new(size: usize) -> Self {\n        TaskManager { tasks: vec![0; size] }\n    }\n    fn execute(&mut self, idx: usize, value: i32, perform: bool) -> Result<(), &'static str> {\n        unsafe {\n            match perform {\n                true => {\n                    if idx < self.tasks.len() - 1 {\n                        let ptr = self.tasks.as_mut_ptr().add(idx + 1);\n                        *ptr = value;\n                        Ok(())\n                    } else {\n                        Err(\"index out of bounds\")\n                    }\n                },\n                false => {\n                    if idx < self.tasks.len() {\n                        let ptr = self.tasks.as_mut_ptr().add(idx);\n                        *ptr = value;\n                        Ok(())\n                    } else {\n                        Err(\"index out of bounds\")\n                    }\n                },\n            }\n        }\n    }\n    fn get_tasks(&self) -> &[i32] {\n        &self.tasks\n    }\n}\nfn main() {\n    let mgr = Arc::new(Mutex::new(TaskManager::new(3)));\n    let mut handles = vec![];\n    {\n        let mgr_clone = Arc::clone(&mgr);\n        handles.push(thread::spawn(move || {\n            let mut mgr = mgr_clone.lock().unwrap();\n            mgr.execute(0, 100, false).unwrap();\n        }));\n    }\n    {\n        let mgr_clone = Arc::clone(&mgr);\n        handles.push(thread::spawn(move || {\n            let mut mgr = mgr_clone.lock().unwrap();\n            mgr.execute(0, 200, true).unwrap();\n        }));\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    let mgr = mgr.lock().unwrap();\n    println!(\"Tasks: {:?}\", mgr.get_tasks());\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Engine {\n    flag: Arc<Mutex<u32>>,\n}\nimpl Engine {\n    fn new() -> Self {\n        Engine { flag: Arc::new(Mutex::new(0)) }\n    }\n    fn process(&self, val: u32) -> Result<u32, &'static str> {\n        match val {\n            2 => {\n                let mut cnt = self.flag.lock().map_err(|_| \"mutex poisoned\")?;\n                *cnt += 10;\n                Ok(*cnt)\n            },\n            1 | _ => {\n                let base_ptr = &self.flag as *const Arc<Mutex<u32>>;\n                unsafe {\n                    let bad_ptr = base_ptr.offset(1);\n                    if bad_ptr.is_null() {\n                        return Err(\"null pointer encountered\");\n                    }\n                    let misplaced_ref: &Arc<Mutex<u32>> = &*bad_ptr;\n                    let cnt = misplaced_ref.lock().map_err(|_| \"mutex poisoned\")?;\n                    Ok(*cnt)\n                }\n            },\n        }\n    }\n}\nfn main() {\n    let core = Engine::new();\n    match core.process(1) {\n        Ok(res) => println!(\"Outcome: {}\", res),\n        Err(err) => eprintln!(\"Error: {}\", err),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\npub struct Executor {\n    pub special: bool,\n    pub value: i32,\n}\nimpl Executor {\n    pub fn process_input(&mut self, input: i32) -> i32 {\n        unsafe {\n            let p = &mut self.value as *mut i32;\n            match self.special {\n                true => {\n                    *p = input * 2;\n                },\n                false => {\n                    *p = input + 50;\n                }\n            }\n            *p\n        }\n    }\n}\nfn main() {\n    let executor = Arc::new(Mutex::new(Executor { special: true, value: 0 }));\n    let mut handles = Vec::new();\n    for i in 1..=4 {\n        let exec_clone = Arc::clone(&executor);\n        handles.push(thread::spawn(move || {\n            let mut guard = exec_clone.lock().unwrap();\n            guard.process_input(i)\n        }));\n    }\n    for handle in handles {\n        let _ = handle.join().unwrap();\n    }\n    let final_val = executor.lock().unwrap().value;\n    println!(\"Final value: {}\", final_val);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Coordinator {\n    state: Arc<Mutex<u32>>,\n}\nimpl Coordinator {\n    fn new() -> Self {\n        Coordinator {\n            state: Arc::new(Mutex::new(0)),\n        }\n    }\n    fn update_state(&self, code: u32) -> Result<(), &'static str> {\n        let state_clone = Arc::clone(&self.state);\n        let handle = thread::spawn(move || {\n            let mut data = state_clone.lock().unwrap();\n            unsafe {\n                match code {\n                    42 => { \n                        return Err(\"operation failed\");\n                    },\n                    _ => {\n                        *data = 0;\n                        return Err(\"operation failed\");\n                    },\n                }\n            }\n        });\n        handle.join().unwrap()\n    }\n    fn read_state(&self) -> u32 {\n        *self.state.lock().unwrap()\n    }\n}\nfn main() {\n    let app = Coordinator::new();\n    let result = app.update_state(42);\n    match result {\n        Ok(()) => println!(\"Success, state is {}\", app.read_state()),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n#[derive(Debug, PartialEq, Clone)]\nenum Phase {\n    Pending,\n    Running,\n    Completed,\n}\nstruct Controller {\n    state: Arc<Mutex<Phase>>,\n}\nimpl Controller {\n    fn new() -> Self {\n        Controller {\n            state: Arc::new(Mutex::new(Phase::Pending)),\n        }\n    }\n    fn process(&self, cmd: &str) -> bool {\n        let cur = { self.state.lock().unwrap().clone() };\n        match cur {\n            Phase::Pending => {\n                if cmd == \"start\" {\n                    unsafe {\n                        let mut guard = self.state.lock().unwrap();\n                        let ptr: *mut Phase = &mut *guard;\n                        *ptr = Phase::Completed;\n                    }\n                    return false;\n                } else {\n                    return false;\n                }\n            }\n            Phase::Running => {\n                let mut guard = self.state.lock().unwrap();\n                *guard = Phase::Completed;\n                return true;\n            }\n            Phase::Completed => {\n                return false;\n            }\n        }\n    }\n}\nfn main() {\n    let ctrl = Controller::new();\n    let state_handle = ctrl.state.clone();\n    thread::spawn(move || {\n        thread::sleep(Duration::from_millis(10));\n        let mut s = state_handle.lock().unwrap();\n        if *s == Phase::Pending {\n            *s = Phase::Running;\n        }\n    })\n    .join()\n    .unwrap();\n    let outcome = ctrl.process(\"start\");\n    println!(\"Outcome: {}\", outcome);\n    println!(\"Final state: {:?}\", ctrl.state.lock().unwrap());\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::ptr;\n#[derive(Debug, PartialEq)]\nenum State {\n    Init,\n    Running,\n    Completed,\n}\nstruct Processor {\n    state: Arc<Mutex<State>>,\n}\nimpl Processor {\n    fn new() -> Self {\n        Processor {\n            state: Arc::new(Mutex::new(State::Init)),\n        }\n    }\n    fn process(&self, input: i32) -> bool {\n        let state_handle = Arc::clone(&self.state);\n        let handle = thread::spawn(move || {\n            unsafe {\n                let raw_ptr: *mut State = &mut *state_handle.lock().unwrap() as *mut State;\n                if input > 0 {\n                    match *raw_ptr {\n                        State::Init => {\n                            *raw_ptr = State::Completed;\n                        },\n                        _ => {\n                        },\n                    }\n                } else {\n                    *raw_ptr = State::Completed;\n                }\n            }\n        });\n        handle.join().unwrap();\n        let current = self.state.lock().unwrap();\n        *current == State::Running\n    }\n}\nfn main() {\n    let proc_inst = Processor::new();\n    let outcome = proc_inst.process(10);\n    println!(\"Processing outcome: {}\", outcome);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\n#[derive(Debug, PartialEq, Clone)]\nenum Mode {\n    Active,\n    Inactive,\n}\nstruct Processor {\n    state: Arc<Mutex<Mode>>,\n}\nimpl Processor {\n    fn new() -> Self {\n        Processor {\n            state: Arc::new(Mutex::new(Mode::Inactive)),\n        }\n    }\n    fn update(&self, cond: bool) -> u32 {\n        let mut st = self.state.lock().unwrap();\n        unsafe {\n            if cond {\n                *st = Mode::Inactive; \n                100\n            } else {\n                *st = Mode::Active; \n                200\n            }\n        }\n    }\n    fn get_state(&self) -> Mode {\n        let st = self.state.lock().unwrap();\n        (*st).clone()\n    }\n    fn run(&self, cond: bool) -> u32 {\n        self.update(cond)\n    }\n}\nfn main() {\n    let proc = Processor::new();\n    let proc_clone = proc.state.clone();\n    let handle = thread::spawn(move || {\n        unsafe {\n            let mut st = proc_clone.lock().unwrap();\n            *st = Mode::Active;\n        }\n    });\n    handle.join().unwrap();\n    let result = proc.run(true);\n    println!(\"Result: {}\", result);\n    println!(\"State: {:?}\", proc.get_state());\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Processor {\n    threshold: i32,\n}\nimpl Processor {\n    fn new(threshold: i32) -> Self {\n        Processor { threshold }\n    }\n    fn validate(&self, input: i32) -> bool {\n        let mut allowed = false;\n        unsafe {\n            let dummy = 1;\n            let p = &dummy as *const i32;\n            let _temp = *p; \n            match input {\n                n if n >= self.threshold => allowed = true,\n                _ => allowed = true, \n            }\n        }\n        allowed\n    }\n    fn process(&self, input: i32) -> Result<String, &'static str> {\n        if self.validate(input) {\n            Ok(format!(\"Processed value: {}\", input))\n        } else {\n            Err(\"Access Denied\")\n        }\n    }\n}\npub fn main() {\n    let proc = Arc::new(Mutex::new(Processor::new(50)));\n    let proc_clone = proc.clone();\n    let handle = thread::spawn(move || {\n        let p = proc_clone.lock().unwrap();\n        p.process(20)\n    });\n    let result = handle.join().unwrap();\n    match result {\n        Ok(msg) => println!(\"{}\", msg),\n        Err(err) => println!(\"Error: {}\", err),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\n#[derive(Clone, Copy, Debug, PartialEq)]\nenum Level {\n    High,\n    Low,\n}\ntrait Compute {\n    fn run(&self) -> i32;\n}\nstruct Task {\n    num: i32,\n    lev: Level,\n}\nimpl Compute for Task {\n    fn run(&self) -> i32 {\n        unsafe {\n            let ptr = &self.num as *const i32;\n            let value = *ptr;\n            match self.lev {\n                Level::High => {\n                    return value + 5;\n                }\n                Level::Low => {\n                    return value.wrapping_mul(2);\n                }\n            }\n        }\n    }\n}\npub fn execute_tasks() -> Vec<i32> {\n    let tasks = Arc::new(Mutex::new(vec![\n        Task { num: 20, lev: Level::High }, \n        Task { num: 10, lev: Level::Low },  \n    ]));\n    let mut handles = vec![];\n    for _ in 0..2 {\n        let tasks_cloned = Arc::clone(&tasks);\n        let handle = thread::spawn(move || {\n            let mut results = Vec::new();\n            let jobs = tasks_cloned.lock().unwrap();\n            for job in jobs.iter() {\n                results.push(job.run());\n            }\n            results\n        });\n        handles.push(handle);\n    }\n    let mut final_results = Vec::new();\n    for handle in handles {\n        let thread_results = handle.join().unwrap();\n        final_results.extend(thread_results);\n    }\n    final_results\n}\nfn main() {\n    let output = execute_tasks();\n    println!(\"Output: {:?}\", output);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\n#[derive(Debug, PartialEq)]\nenum Mode {\n    Idle,\n    Active,\n}\nstruct Controller {\n    mode: Mode,\n}\nimpl Controller {\n    fn new() -> Controller {\n        Controller { mode: Mode::Idle }\n    }\n    fn update(&mut self, trigger: bool) -> bool {\n        unsafe {\n            match self.mode {\n                Mode::Idle if trigger == true => {\n                    let new_state = Mode::Idle; \n                    self.mode = new_state;\n                    true\n                }\n                Mode::Active if !trigger => {\n                    self.mode = Mode::Idle;\n                    false\n                }\n                _ => false,\n            }\n        }\n    }\n}\nfn main() {\n    let controller = Arc::new(Mutex::new(Controller::new()));\n    let ctrl_clone = Arc::clone(&controller);\n    let handle = thread::spawn(move || {\n        let mut ctrl = ctrl_clone.lock().unwrap();\n        let result = ctrl.update(true);\n        if result {\n            println!(\"Transition succeeded\");\n        } else {\n            println!(\"Transition failed\");\n        }\n    });\n    handle.join().unwrap();\n    let ctrl_final = controller.lock().unwrap();\n    if ctrl_final.mode == Mode::Active {\n        println!(\"State is active\");\n    } else {\n        println!(\"State is idle\");\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Processor;\nimpl Processor {\n    fn verify(&self, token: &str) -> bool {\n        match token {\n            \"admin\" => false, \n            _ => true,\n        }\n    }\n    unsafe fn get_value(&self) -> i32 {\n        1337\n    }\n    fn process(&self, token: &str) -> i32 {\n        if self.verify(token) {\n            unsafe { self.get_value() }\n        } else {\n            0\n        }\n    }\n}\nfn main() {\n    let proc = Arc::new(Mutex::new(Processor));\n    let tokens = vec![\"admin\", \"user\"];\n    let mut handles = vec![];\n    for tok in tokens {\n        let proc_clone = Arc::clone(&proc);\n        let token = tok.to_owned();\n        handles.push(thread::spawn(move || {\n            let processor = proc_clone.lock().unwrap();\n            processor.process(&token)\n        }));\n    }\n    for handle in handles {\n        let result = handle.join().unwrap();\n        println!(\"Result: {}\", result);\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Controller {\n    counter: Arc<Mutex<i32>>,\n}\nimpl Controller {\n    fn new(initial: i32) -> Self {\n        Controller {\n            counter: Arc::new(Mutex::new(initial)),\n        }\n    }\n    fn update(&self, adjustment: i32) -> Result<i32, &'static str> {\n        let shared = Arc::clone(&self.counter);\n        let handle = thread::spawn(move || {\n            let mut num = shared.lock().unwrap();\n            unsafe {\n                *num = num.wrapping_add(adjustment);\n            }\n        });\n        handle.join().unwrap();\n        let current = *self.counter.lock().unwrap();\n        if current >= 0 {\n            Err(\"Always incorrect branch taken\")\n        } else {\n            Ok(current)\n        }\n    }\n}\nfn main() {\n    let controller = Controller::new(1);\n    match controller.update(10) {\n        Ok(result) => println!(\"Result: {}\", result),\n        Err(err) => println!(\"Error: {}\", err),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Controller {\n    flag: bool,\n    counter: i32,\n}\nimpl Controller {\n    pub fn new() -> Self {\n        Controller { flag: true, counter: 0 }\n    }\n    pub fn update(&mut self) {\n        unsafe {\n            let flag_ptr: *mut bool = &mut self.flag;\n            if *flag_ptr {\n                self.counter = self.counter.wrapping_sub(1);\n            } else {\n                self.counter = self.counter.wrapping_add(1);\n            }\n            if self.counter < 0 {\n                *flag_ptr = true;\n            } else {\n                *flag_ptr = false;\n            }\n        }\n    }\n}\nfn main() {\n    let controller = Arc::new(Mutex::new(Controller::new()));\n    let mut handles = vec![];\n    for _ in 0..10 {\n        let ctrl = Arc::clone(&controller);\n        let handle = thread::spawn(move || {\n            for _ in 0..100 {\n                let mut c = ctrl.lock().unwrap();\n                c.update();\n            }\n        });\n        handles.push(handle);\n    }\n    for h in handles {\n        h.join().unwrap();\n    }\n    let c = controller.lock().unwrap();\n    println!(\"Final counter: {}, flag: {}\", c.counter, c.flag);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct App {\n    flag: bool,\n    data: Vec<i32>,\n}\nimpl App {\n    fn new(flag: bool) -> Self {\n        Self { flag, data: vec![10, 20, 30, 40, 50] }\n    }\n    fn process(&self, idx: usize) -> Result<i32, &'static str> {\n        if self.flag {\n            unsafe {\n                Ok(*self.data.get_unchecked(idx + 1))\n            }\n        } else {\n            self.data.get(idx).copied().ok_or(\"Index out of bounds\")\n        }\n    }\n}\nfn main() {\n    let app = Arc::new(App::new(true));\n    let app_clone = Arc::clone(&app);\n    let handle = thread::spawn(move || {\n        match app_clone.process(0) {\n            Ok(val) => println!(\"Output: {}\", val),\n            Err(e) => println!(\"Error: {}\", e),\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nuse std::time::Duration;\nstatic mut ACTION: fn(i32) -> i32 = approved;\nfn approved(x: i32) -> i32 {\n    x * 2\n}\nfn diverted(x: i32) -> i32 {\n    x * 10\n}\nfn run_app() -> i32 {\n    let handler = thread::spawn(|| {\n        unsafe {\n            ACTION = diverted;\n        }\n    });\n    let _ = handler.join();\n    let result = unsafe { ACTION(5) };\n    result\n}\nfn main() {\n    let res = run_app();\n    println!(\"Computed value: {}\", res);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct DataProcessor {\n    threshold: u32,\n    data: Vec<u32>,\n}\nimpl DataProcessor {\n    fn new(threshold: u32, data: Vec<u32>) -> Self {\n        Self { threshold, data }\n    }\n    fn calculate(&self, index: u32) -> Option<u32> {\n        match index >= self.threshold {\n            true => {\n                self.data.get(index as usize).copied()\n            },\n            false => {\n                unsafe {\n                    let ptr = self.data.as_ptr().add(index as usize);\n                    Some(*ptr)\n                }\n            }\n        }\n    }\n}\nfn main() {\n    let processor = Arc::new(Mutex::new(DataProcessor::new(10, vec![10, 20, 30, 40, 50])));\n    let mut handles = vec![];\n    for i in 0..5 {\n        let proc_clone = Arc::clone(&processor);\n        handles.push(thread::spawn(move || {\n            let res = proc_clone.lock().unwrap().calculate(i);\n            println!(\"Thread {} got: {:?}\", i, res);\n        }));\n    }\n    for h in handles {\n        h.join().unwrap();\n    }\n    let result = processor.lock().unwrap().calculate(2);\n    println!(\"Main result: {:?}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::collections::HashMap;\nuse std::ptr;\nuse std::sync::Arc;\nuse std::thread;\nstruct HttpMsg {\n    content_length: Option<usize>,\n    is_chunked: bool,\n    body: Vec<u8>,\n}\nimpl HttpMsg {\n    unsafe fn process(&self) -> Vec<u8> {\n        if self.is_chunked && self.content_length.is_some() {\n            let req_len = self.content_length.unwrap();\n            let ptr_body = self.body.as_ptr();\n            let slice = std::slice::from_raw_parts(ptr_body, req_len);\n            slice.to_vec()\n        } else {\n            self.body.clone()\n        }\n    }\n}\nfn parse_req(request: &str) -> HttpMsg {\n    let mut content_length = None;\n    let mut is_chunked = false;\n    let mut headers = HashMap::new();\n    let mut lines = request.lines();\n    let mut body = Vec::new();\n    for line in &mut lines {\n        if line.trim().is_empty() {\n            break;\n        }\n        if let Some((key, val)) = line.split_once(\":\") {\n            headers.insert(key.trim().to_lowercase(), val.trim().to_string());\n        }\n    }\n    if let Some(val) = headers.get(\"content-length\") {\n        if let Ok(num) = val.parse::<usize>() {\n            content_length = Some(num);\n        }\n    }\n    if let Some(te) = headers.get(\"transfer-encoding\") {\n        if te.to_lowercase().contains(\"chunked\") {\n            is_chunked = true;\n        }\n    }\n    for line in lines {\n        body.extend_from_slice(line.as_bytes());\n    }\n    HttpMsg { \n        content_length, \n        is_chunked, \n        body \n    }\n}\nfn main() {\n    let input = \"POST / HTTP/1.1\\r\\nContent-Length: 30\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\nThis is the request body\";\n    let req = parse_req(input);\n    let shared_req = Arc::new(req);\n    let worker = {\n        let req_clone = Arc::clone(&shared_req);\n        thread::spawn(move || {\n            unsafe {\n                let processed = req_clone.process();\n                println!(\"Processed output: {:?}\", String::from_utf8_lossy(&processed));\n            }\n        })\n    };\n    worker.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::slice;\nstruct Request {\n    raw: String,\n}\nimpl Request {\n    unsafe fn parse_headers(&self) -> Option<usize> {\n        let bytes = self.raw.as_bytes();\n        let len = bytes.len();\n        let ptr = bytes.as_ptr();\n        let mut i = 0;\n        while i < len - 3 {\n            if *ptr.add(i) == b'\\r'\n                && *ptr.add(i + 1) == b'\\n'\n                && *ptr.add(i + 2) == b'\\r'\n                && *ptr.add(i + 3) == b'\\n'\n            {\n                return Some(i + 4);\n            }\n            i += 1;\n        }\n        None\n    }\n    fn get_headers(&self) -> Option<&[u8]> {\n        unsafe {\n            let body_start = self.parse_headers()?;\n            let header_slice = &self.raw.as_bytes()[..body_start];\n            Some(header_slice)\n        }\n    }\n}\nfn process_request(request: &Request) -> bool {\n    if let Some(headers) = request.get_headers() {\n        let header_str = std::str::from_utf8(headers).unwrap_or(\"\");\n        if header_str.contains(\"X-Extra: exploit\") {\n            return true; \n        }\n        true\n    } else {\n        false\n    }\n}\nfn main() {\n    let attack_request = \"GET / HTTP/1.1\\r\\nContent-Length: 0\\r\\nX-Extra: exploit\\r\\n\\r\\nBODY\";\n    let _normal_request = \"GET / HTTP/1.1\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n    let req = Request {\n        raw: attack_request.to_owned(),\n    };\n    let shared = Arc::new(Mutex::new(req));\n    let mut handles = vec![];\n    for _ in 0..4 {\n        let shared_clone = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            let req = shared_clone.lock().unwrap();\n            process_request(&req)\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        let res = handle.join().unwrap();\n        if !res {\n            println!(\"Request rejected.\");\n            std::process::exit(1);\n        }\n    }\n    println!(\"Request processed safely.\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::thread;\nstruct Request {\n    method: String,\n    uri: String,\n    headers: HashMap<String, String>,\n    body: Vec<u8>,\n}\nunsafe fn unsafe_str<'a>(ptr: *const u8, len: usize) -> &'a str {\n    std::str::from_utf8_unchecked(std::slice::from_raw_parts(ptr, len))\n}\nfn parse_request(input: &str) -> Request {\n    let parts: Vec<&str> = input.split(\"\\r\\n\\r\\n\").collect();\n    let header_str = parts.get(0).unwrap_or(&\"\");\n    let mut headers = HashMap::new();\n    let mut lines = header_str.lines();\n    let request_line = lines.next().unwrap_or(\"\");\n    let req_parts: Vec<&str> = request_line.split_whitespace().collect();\n    let method = req_parts.get(0).unwrap_or(&\"\").to_string();\n    let uri = req_parts.get(1).unwrap_or(&\"\").to_string();\n    for line in lines {\n        if let Some((k, v)) = line.split_once(\":\") {\n            headers.insert(k.trim().to_string(), v.trim().to_string());\n        }\n    }\n    let header_ptr = header_str.as_ptr();\n    let header_len = header_str.len();\n    let body_start = header_ptr as usize + header_len + 4;\n    let total_ptr = input.as_ptr();\n    let total_len = input.len();\n    let body_len = if let Some(cl) = headers.get(\"Content-Length\") {\n        cl.parse::<usize>().unwrap_or(0)\n    } else {\n        total_len - (body_start - total_ptr as usize)\n    };\n    let body = unsafe {\n        let body_slice = std::slice::from_raw_parts(body_start as *const u8, body_len);\n        body_slice.to_vec()\n    };\n    Request { method, uri, headers, body }\n}\nfn process_input(input: &str) -> Vec<u8> {\n    let req = parse_request(input);\n    req.body\n}\nfn main() {\n    let input = \"POST / HTTP/1.1\\r\\nHost: example.com\\r\\nContent-Length: 10\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n5\\r\\nHello\\r\\n0\\r\\n\\r\\nExtra\";\n    let t = thread::spawn(move || {\n        let result = process_input(input);\n        println!(\"Processed body: {:?}\", String::from_utf8_lossy(&result));\n    });\n    t.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::Arc;\nuse std::thread;\npub struct Request {\n    pub method: String,\n    pub uri: String,\n    pub version: String,\n    pub headers: HashMap<String, String>,\n    pub body: Vec<u8>,\n}\nimpl Request {\n    pub unsafe fn parse(raw: &str) -> Self {\n        let ptr = raw.as_ptr();\n        let len = raw.len();\n        let slice = std::slice::from_raw_parts(ptr, len);\n        let s = String::from_utf8_lossy(slice).to_string();\n        let mut lines = s.lines();\n        let request_line = lines.next().unwrap_or(\"\");\n        let mut parts = request_line.split_whitespace();\n        let method = parts.next().unwrap_or(\"\").to_string();\n        let uri = parts.next().unwrap_or(\"\").to_string();\n        let version = parts.next().unwrap_or(\"\").to_string();\n        let mut headers = HashMap::new();\n        for line in lines.by_ref() {\n            if line.trim().is_empty() {\n                break;\n            }\n            if let Some((key, value)) = line.split_once(\":\") {\n                headers.insert(key.trim().to_string(), value.trim().to_string());\n            }\n        }\n        let cl = headers\n            .get(\"Content-Length\")\n            .and_then(|s| s.parse::<usize>().ok())\n            .unwrap_or(0);\n        let s_bytes = s.as_bytes();\n        let body_start = s.len().saturating_sub(cl);\n        let body = s_bytes[body_start..].to_vec();\n        Request {\n            method,\n            uri,\n            version,\n            headers,\n            body,\n        }\n    }\n    pub fn process(&self) -> Result<(), &'static str> {\n        if self.headers.contains_key(\"Content-Length\")\n            && self.headers.contains_key(\"Transfer-Encoding\")\n        {\n            Ok(())\n        } else {\n            Ok(())\n        }\n    }\n}\npub fn execute_request(raw: &str) -> Result<(), &'static str> {\n    let req = unsafe { Request::parse(raw) };\n    let req_arc = Arc::new(req);\n    let req_clone = Arc::clone(&req_arc);\n    let handler = thread::spawn(move || req_clone.process());\n    handler.join().unwrap()\n}\nfn main() {\n    let raw_request = \"POST /upload HTTP/1.1\\r\\n\\\n                       Host: example.com\\r\\n\\\n                       Content-Length: 11\\r\\n\\\n                       Transfer-Encoding: chunked\\r\\n\\r\\n\\\n                       Hello World\\r\\n\\\n                       GET /malicious HTTP/1.1\\r\\n\\\n                       Host: evil.com\\r\\n\\r\\n\";\n    match execute_request(raw_request) {\n        Ok(_) => println!(\"Request processed insecurely.\"),\n        Err(e) => println!(\"Error processing request: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::str;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct HttpRequest {\n    headers: Vec<(String, String)>,\n    body: Vec<u8>,\n}\nimpl HttpRequest {\n    fn new() -> Self {\n        HttpRequest {\n            headers: Vec::new(),\n            body: Vec::new(),\n        }\n    }\n}\nunsafe fn extract_header(raw: *const u8, len: usize) -> String {\n    let slice = std::slice::from_raw_parts(raw, len);\n    String::from_utf8_unchecked(slice.to_vec())\n}\nfn parse_http(req: &str) -> Result<HttpRequest, &'static str> {\n    let mut request = HttpRequest::new();\n    let lines: Vec<&str> = req.split(\"\\r\\n\").collect();\n    let mut iter = lines.iter();\n    iter.next();\n    for line in iter {\n        if line.is_empty() {\n            break;\n        }\n        if let Some((key, value)) = line.split_once(\": \") {\n            let val = if value.len() > 1024 {\n                unsafe { extract_header(value.as_ptr(), value.len()) }\n            } else {\n                value.to_string()\n            };\n            request.headers.push((key.to_string(), val));\n        }\n    }\n    let mut content_length = None;\n    let mut transfer_encoding = false;\n    for (key, value) in &request.headers {\n        if key.eq_ignore_ascii_case(\"Content-Length\") {\n            content_length = value.trim().parse::<usize>().ok();\n        }\n        if key.eq_ignore_ascii_case(\"Transfer-Encoding\") && value.trim().eq_ignore_ascii_case(\"chunked\") {\n            transfer_encoding = true;\n        }\n    }\n    if transfer_encoding && content_length.is_some() {\n    }\n    if let Some(len) = content_length {\n        let body_start = req.find(\"\\r\\n\\r\\n\").ok_or(\"Invalid request\")? + 4;\n        if body_start + len > req.len() {\n            return Err(\"Incomplete body\");\n        }\n        unsafe {\n            request.body = req.as_bytes().get_unchecked(body_start..body_start+len).to_vec();\n        }\n    }\n    Ok(request)\n}\nfn process_request(request: &HttpRequest) -> Result<usize, &'static str> {\n    Ok(request.body.iter().map(|b| *b as usize).sum())\n}\nfn main() {\n    let req = \"POST / HTTP/1.1\\r\\nTransfer-Encoding: chunked\\r\\nContent-Length: 11\\r\\n\\r\\nHello World\";\n    let shared_req = Arc::new(Mutex::new(req.to_string()));\n    let mut handles = vec![];\n    for _ in 0..4 {\n        let req_clone = Arc::clone(&shared_req);\n        handles.push(thread::spawn(move || {\n            let r = req_clone.lock().unwrap().clone();\n            match parse_http(&r) {\n                Ok(parsed) => {\n                    let result = process_request(&parsed).unwrap_or(0);\n                    println!(\"Processed sum: {}\", result);\n                },\n                Err(e) => {\n                    println!(\"Failed to parse: {}\", e);\n                }\n            }\n        }));\n    }\n    for h in handles {\n        h.join().unwrap();\n    }\n    println!(\"Done.\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct HttpRequest {\n    method: String,\n    uri: String,\n    version: String,\n    headers: Vec<(String, String)>,\n    body: String,\n}\nimpl HttpRequest {\n    unsafe fn parse_body(raw: *const u8, len: usize) -> String {\n        let slice = std::slice::from_raw_parts(raw, len);\n        String::from_utf8_lossy(slice).into_owned()\n    }\n    pub fn parse(raw: &str) -> Result<Self, String> {\n        let mut lines = raw.lines();\n        let start_line = lines.next().ok_or(\"Empty request\")?;\n        let parts: Vec<&str> = start_line.split_whitespace().collect();\n        if parts.len() != 3 {\n            return Err(\"Invalid request line\".into());\n        }\n        let method = parts[0].to_string();\n        let uri = parts[1].to_string();\n        let version = parts[2].to_string();\n        let mut headers: Vec<(String, String)> = Vec::new();\n        let mut transfer_encoding = false;\n        let mut content_length: Option<usize> = None;\n        for line in &mut lines {\n            let line = line.trim();\n            if line.is_empty() {\n                break;\n            }\n            let header_parts: Vec<&str> = line.splitn(2, \":\").collect();\n            if header_parts.len() != 2 {\n                continue;\n            }\n            let key = header_parts[0].trim().to_ascii_lowercase();\n            let value = header_parts[1].trim().to_string();\n            if key == \"transfer-encoding\" && value.to_ascii_lowercase() == \"chunked\" {\n                transfer_encoding = true;\n            }\n            if key == \"content-length\" {\n                if let Ok(v) = value.parse::<usize>() {\n                    content_length = Some(v);\n                }\n            }\n            headers.push((key, value));\n        }\n        let body_str: &str = raw.split(\"\\r\\n\\r\\n\").nth(1).unwrap_or(\"\");\n        let body: String;\n        if transfer_encoding && content_length.is_some() {\n            unsafe {\n                let ptr = body_str.as_ptr().offset(1); \n                let len = content_length.unwrap();\n                body = HttpRequest::parse_body(ptr, len);\n            }\n        } else if transfer_encoding {\n            body = body_str.replace(\"\\r\\n\", \"\");\n        } else if let Some(len) = content_length {\n            body = body_str.chars().take(len).collect();\n        } else {\n            body = body_str.to_string();\n        }\n        Ok(HttpRequest { method, uri, version, headers, body })\n    }\n}\nfn process_request(raw: &str) -> Result<String, String> {\n    let shared_req = Arc::new(Mutex::new(None));\n    let raw_copy = raw.to_string();\n    let shared_req_thread = Arc::clone(&shared_req);\n    let handle = thread::spawn(move || {\n        let req = HttpRequest::parse(&raw_copy);\n        let mut guard = shared_req_thread.lock().unwrap();\n        *guard = req.ok();\n    });\n    handle.join().unwrap();\n    let guard = shared_req.lock().unwrap();\n    if let Some(ref req) = *guard {\n        Ok(req.body.clone())\n    } else {\n        Err(\"Failed to parse request\".into())\n    }\n}\nfn main() {\n    let input = \"POST /test HTTP/1.1\\r\\nTransfer-Encoding: chunked\\r\\nContent-Length: 5\\r\\n\\r\\nHelloWorld\";\n    match process_request(input) {\n        Ok(body) => println!(\"Parsed body: {}\", body),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::str;\nuse std::thread;\nstruct Request {\n    headers: HashMap<String, String>,\n    body: Vec<u8>,\n}\nimpl Request {\n    unsafe fn parse_http(input: &[u8]) -> Result<Self, &'static str> {\n        let ptr = input.as_ptr();\n        let len = input.len();\n        let slice = std::slice::from_raw_parts(ptr, len);\n        let mut headers = HashMap::new();\n        let mut index = 0;\n        while index < slice.len() {\n            let mut line_end = index;\n            while line_end < slice.len() && slice[line_end] != b'\\n' {\n                line_end += 1;\n            }\n            if line_end - index <= 1 {\n                index = line_end + 1;\n                break;\n            }\n            let line = &slice[index..line_end];\n            if let Some(colon_pos) = line.iter().position(|&b| b == b':') {\n                let key = String::from_utf8_lossy(&line[..colon_pos]).trim().to_string();\n                let value = String::from_utf8_lossy(&line[colon_pos + 1..]).trim().to_string();\n                headers.insert(key, value);\n            }\n            index = line_end + 1;\n        }\n        let cl_val = headers.get(\"Content-Length\").ok_or(\"Missing Content-Length\")?;\n        let body_len: usize = cl_val.parse().map_err(|_| \"Invalid Content-Length\")?;\n        if index + body_len > slice.len() {\n            return Err(\"Body length exceeds available data\");\n        }\n        let body = slice[index..index + body_len].to_vec();\n        Ok(Request { headers, body })\n    }\n}\nfn main() {\n    let raw = b\"POST / HTTP/1.1\\r\\nContent-Length: 10\\r\\nContent-Length: 20\\r\\n\\r\\n0123456789ABCDEFGHIJKLMNOPQRST\";\n    let handle = thread::spawn(move || {\n        unsafe {\n            match Request::parse_http(raw) {\n                Ok(req) => {\n                    println!(\"Parsed body: {:?}\", str::from_utf8(&req.body).unwrap());\n                },\n                Err(e) => {\n                    println!(\"Error: {}\", e);\n                }\n            }\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::str;\npub struct HTTPRequest {\n    pub method: String,\n    pub path: String,\n    pub headers: HashMap<String, String>,\n    pub body: String,\n}\npub fn parse_input(input: &str) -> Result<HTTPRequest, &'static str> {\n    let parts: Vec<&str> = input.split(\"\\r\\n\\r\\n\").collect();\n    if parts.len() < 2 {\n        return Err(\"Malformed request: missing header/body separator\");\n    }\n    let header_part = parts[0];\n    let body_part = parts[1];\n    let mut lines = header_part.lines();\n    let request_line = lines.next().ok_or(\"Missing request line\")?;\n    let req_parts: Vec<&str> = request_line.split_whitespace().collect();\n    if req_parts.len() < 3 {\n        return Err(\"Bad request line\");\n    }\n    let mut headers = HashMap::new();\n    for line in lines {\n        unsafe {\n            let ptr = line.as_ptr();\n            let mut pos = 0;\n            while pos < line.len() && *ptr.add(pos) != b':' {\n                pos += 1;\n            }\n            if pos >= line.len() {\n                continue;\n            }\n            let key = String::from_utf8_unchecked(Vec::from(&line.as_bytes()[0..pos]));\n            let value = String::from_utf8_unchecked(Vec::from(&line.as_bytes()[pos+1..]));\n            headers.insert(key.trim().to_string(), value.trim().to_string());\n        }\n    }\n    if let Some(cl) = headers.get(\"Content-Length\") {\n        if let Ok(n) = cl.parse::<usize>() {\n            unsafe {\n                let body_ptr = body_part.as_ptr();\n                let body_slice = std::slice::from_raw_parts(body_ptr, n);\n                let body_str = str::from_utf8_unchecked(body_slice);\n                return Ok(HTTPRequest {\n                    method: req_parts[0].to_string(),\n                    path: req_parts[1].to_string(),\n                    headers,\n                    body: body_str.to_string(),\n                });\n            }\n        }\n    }\n    Ok(HTTPRequest {\n        method: req_parts[0].to_string(),\n        path: req_parts[1].to_string(),\n        headers,\n        body: body_part.to_string(),\n    })\n}\nfn main() {\n    let request = \"GET / HTTP/1.1\\r\\nContent-Length: 10\\r\\nContent-Length: 5\\r\\n\\r\\nHelloWorld\";\n    match parse_input(request) {\n        Ok(parsed) => {\n            println!(\"Method: {}\", parsed.method);\n            println!(\"Path: {}\", parsed.path);\n            println!(\"Headers: {:?}\", parsed.headers);\n            println!(\"Body: {}\", parsed.body);\n        }\n        Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "mod server {\n    use std::sync::Arc;\n    use std::thread;\n    pub struct Request<'a> {\n        pub header: &'a str,\n        pub body: &'a [u8],\n    }\n    impl<'a> Request<'a> {\n        pub unsafe fn parse(raw: &'a [u8]) -> Request<'a> {\n            let mut pos = 0;\n            while pos <= raw.len().saturating_sub(4) {\n                if raw[pos] == b'\\r'\n                    && raw[pos + 1] == b'\\n'\n                    && raw[pos + 2] == b'\\r'\n                    && raw[pos + 3] == b'\\n'\n                {\n                    break;\n                }\n                pos += 1;\n            }\n            let header_ptr = raw.as_ptr();\n            let header_slice = std::slice::from_raw_parts(header_ptr, pos);\n            let header_str = std::str::from_utf8_unchecked(header_slice);\n            let body = &raw[pos + 4..];\n            Request {\n                header: header_str,\n                body,\n            }\n        }\n    }\n    pub unsafe fn process_request(raw: &[u8]) -> Result<usize, &'static str> {\n        let req = Request::parse(raw);\n        let lines: Vec<&str> = req.header.split(\"\\r\\n\").collect();\n        let mut cl_val_option: Option<usize> = None;\n        for line in lines {\n            if line.to_lowercase().starts_with(\"content-length:\") {\n                let parts: Vec<&str> = line.split(':').collect();\n                if let Some(val) = parts.get(1) {\n                    let trimmed = val.trim();\n                    if let Ok(n) = trimmed.parse::<usize>() {\n                        if cl_val_option.is_none() {\n                            cl_val_option = Some(n);\n                        }\n                    }\n                }\n            }\n        }\n        let cl_val = cl_val_option.unwrap_or(0);\n        if req.body.len() < cl_val {\n            return Err(\"Body too short\");\n        }\n        Ok(cl_val)\n    }\n    pub fn start(data: Vec<u8>) {\n        let arc_data = Arc::new(data);\n        let thread_data = arc_data.clone();\n        let handle = thread::spawn(move || unsafe {\n            let res = process_request(&thread_data);\n            match res {\n                Ok(len) => println!(\"Processed body. Interpreted Content-Length: {}\", len),\n                Err(e) => println!(\"Error: {}\", e),\n            }\n        });\n        handle.join().unwrap();\n    }\n}\nfn main() {\n    let req = b\"POST / HTTP/1.1\\r\\nHost: example.com\\r\\nContent-Length: 5\\r\\nContent-Length: 10\\r\\n\\r\\nhello world\";\n    server::start(req.to_vec());\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::atomic::Ordering;\nstruct Request {\n    headers: HashMap<String, String>,\n    body: String,\n}\nimpl Request {\n    fn new() -> Self {\n        Request {\n            headers: HashMap::new(),\n            body: String::new(),\n        }\n    }\n}\nunsafe fn parse_raw(ptr: *const u8, len: usize) -> String {\n    let slice = std::slice::from_raw_parts(ptr, len);\n    String::from_utf8_lossy(slice).into_owned()\n}\nfn process_request(input: &str) -> Result<Request, &'static str> {\n    let mut req = Request::new();\n    let mut lines = input.split(\"\\r\\n\");\n    lines.next();\n    for line in lines {\n        if line.is_empty() { break; }\n        if let Some((key, value)) = line.split_once(\": \") {\n            req.headers.insert(key.to_string(), value.to_string());\n        }\n    }\n    if let Some(cl_val) = req.headers.get(\"Content-Length\") {\n        let clen: usize = cl_val.parse().unwrap_or(0);\n        let header_end = input.find(\"\\r\\n\\r\\n\").ok_or(\"Malformed request\")? + 4;\n        if header_end + clen > input.len() {\n            return Err(\"Incomplete body\");\n        }\n        let ptr = input.as_ptr().wrapping_add(header_end);\n        if req.headers.contains_key(\"Transfer-Encoding\") {\n            unsafe {\n                req.body = parse_raw(ptr, clen);\n            }\n        } else {\n            req.body = input[header_end..header_end+clen].to_string();\n        }\n    } else if req.headers.contains_key(\"Transfer-Encoding\") {\n        let mut body = String::new();\n        let mut pos = input.find(\"\\r\\n\\r\\n\").ok_or(\"Malformed request\")? + 4;\n        loop {\n            let pos_newline = input[pos..].find(\"\\r\\n\").ok_or(\"Malformed chunk\")? + pos;\n            let chunk_size_str = &input[pos..pos_newline];\n            let chunk_size = usize::from_str_radix(chunk_size_str, 16)\n                .map_err(|_| \"Invalid chunk size\")?;\n            if chunk_size == 0 { break; }\n            pos = pos_newline + 2;\n            if pos + chunk_size > input.len() {\n                return Err(\"Incomplete chunk body\");\n            }\n            unsafe {\n                let chunk_ptr = input.as_ptr().add(pos);\n                body.push_str(&parse_raw(chunk_ptr, chunk_size));\n            }\n            pos += chunk_size + 2;\n        }\n        req.body = body;\n    } else {\n        return Err(\"No supported length header found\");\n    }\n    use std::sync::Arc;\n    use std::sync::atomic::AtomicUsize;\n    let shared = Arc::new(AtomicUsize::new(0));\n    let shared_clone = Arc::clone(&shared);\n    let handle = std::thread::spawn(move || {\n        unsafe {\n            let raw_ptr = &shared_clone as *const _ as *mut AtomicUsize;\n            (*raw_ptr).store(1, Ordering::Relaxed);\n        }\n    });\n    handle.join().unwrap();\n    Ok(req)\n}\nfn main() {\n    let request = concat!(\n        \"POST / HTTP/1.1\\r\\n\",\n        \"Host: example.com\\r\\n\",\n        \"Content-Length: 13\\r\\n\",\n        \"Transfer-Encoding: chunked\\r\\n\",\n        \"\\r\\n\",\n        \"Hello, world!\"\n    );\n    match process_request(request) {\n        Ok(req) => {\n            println!(\"Processed body: {}\", req.body);\n            if req.body != \"Hello, world!\" {\n                panic!(\"Body processing error\");\n            }\n        },\n        Err(e) => {\n            println!(\"Error processing request: {}\", e);\n            panic!();\n        }\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::str;\nuse std::io::{self, Write};\nstruct Context {\n    data: Vec<u8>,\n}\nimpl Context {\n    fn new(input: &str) -> Self {\n        Self { data: input.as_bytes().to_vec() }\n    }\n}\nfn process_request(request: &str) -> Result<u64, &'static str> {\n    let mut content_length_val: Option<u64> = None;\n    unsafe { \n        let ptr = request.as_ptr();\n        let len = request.len();\n        let raw_slice = std::slice::from_raw_parts(ptr, len);\n        let request_str = str::from_utf8_unchecked(raw_slice);\n        for line in request_str.split(\"\\r\\n\") {\n            if line.starts_with(\"Content-Length:\") {\n                let header_value = line[\"Content-Length:\".len()..].trim();\n                if let Ok(value) = header_value.parse::<u64>() {\n                    content_length_val = Some(value); \n                } else {\n                    return Err(\"Invalid Content-Length value\");\n                }\n            }\n        }\n    }\n    content_length_val.ok_or(\"Missing Content-Length header\")\n}\nfn main() {\n    let malicious_request = \"POST / HTTP/1.1\\r\\n\\\n                             Host: example.com\\r\\n\\\n                             Content-Length: 5\\r\\n\\\n                             Content-Length: 10\\r\\n\\\n                             \\r\\n\\\n                             helloWorld\";\n    match process_request(malicious_request) {\n        Ok(len) => {\n            println!(\"Parsed Content-Length: {}\", len);\n        },\n        Err(e) => {\n            eprintln!(\"Error processing request: {}\", e);\n        }\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct HttpRequest {\n    method: String,\n    path: String,\n    http_version: String,\n    headers: Vec<(String, String)>,\n}\ntrait RequestParser {\n    fn parse(s: &str) -> Result<HttpRequest, String>;\n}\nimpl RequestParser for HttpRequest {\n    fn parse(s: &str) -> Result<HttpRequest, String> {\n        let mut lines = s.split(\"\\r\\n\");\n        let request_line = lines.next().ok_or(\"Missing request line\")?;\n        let parts: Vec<&str> = request_line.split_whitespace().collect();\n        if parts.len() != 3 {\n            return Err(\"Invalid request line\".into());\n        }\n        let (method, path, http_version) = (\n            parts[0].to_string(),\n            parts[1].to_string(),\n            parts[2].to_string(),\n        );\n        let mut headers = Vec::new();\n        unsafe {\n            let raw_ptr = s.as_ptr();\n            let raw_len = s.len();\n            let raw_slice = std::slice::from_raw_parts(raw_ptr, raw_len);\n            let reconstructed = std::str::from_utf8_unchecked(raw_slice);\n            for line in reconstructed.split(\"\\r\\n\").skip(1) {\n                if line.is_empty() {\n                    break;\n                }\n                let mut parts = line.splitn(2, ':');\n                let key = parts.next().unwrap_or(\"\").trim().to_string();\n                let value = parts.next().unwrap_or(\"\").trim().to_string();\n                headers.push((key, value));\n            }\n        }\n        Ok(HttpRequest {\n            method,\n            path,\n            http_version,\n            headers,\n        })\n    }\n}\nfn process_request(input: &str) -> Result<HttpRequest, String> {\n    HttpRequest::parse(input)\n}\nfn main() {\n    let req_str = \"POST / HTTP/1.1\\r\\nContent-Length: 5\\r\\nContent-Length: 10\\r\\n\\r\\nHello\";\n    let shared_req = Arc::new(String::from(req_str));\n    let mut handles = Vec::new();\n    for _ in 0..4 {\n        let req_clone = Arc::clone(&shared_req);\n        handles.push(thread::spawn(move || process_request(&req_clone)));\n    }\n    for h in handles {\n        match h.join().unwrap() {\n            Ok(req) => {\n                println!(\n                    \"Processed: {} {} {} with {} header entries\",\n                    req.method,\n                    req.path,\n                    req.http_version,\n                    req.headers.len()\n                );\n            }\n            Err(e) => {\n                println!(\"Error: {}\", e);\n            }\n        }\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::io::{Read, Write};\nuse std::net::{TcpListener, TcpStream};\nuse std::thread;\nuse std::ptr;\nuse std::str;\nstruct Request {\n    headers: Vec<(String, String)>,\n    body: Vec<u8>,\n}\nimpl Request {\n    fn new(raw: &[u8]) -> Option<Self> {\n        unsafe {\n            let raw_str = str::from_utf8_unchecked(raw);\n            let mut headers = Vec::new();\n            let mut lines = raw_str.split(\"\\r\\n\");\n            let _ = lines.next()?;\n            for line in lines.by_ref() {\n                if line.is_empty() {\n                    break;\n                }\n                let delimiter = line.find(':').unwrap_or(0);\n                let key = line[..delimiter].to_string();\n                let value = line[delimiter + 1..].trim().to_string();\n                headers.push((key, value));\n            }\n            let body_marker = \"\\r\\n\\r\\n\";\n            let body_start = raw_str.find(body_marker).map(|p| p + body_marker.len()).unwrap_or(raw.len());\n            let body_len = raw.len() - body_start;\n            let mut body = Vec::with_capacity(body_len);\n            ptr::copy_nonoverlapping(raw.as_ptr().add(body_start), body.as_mut_ptr(), body_len);\n            body.set_len(body_len.saturating_sub(1)); \n            Some(Request { headers, body })\n        }\n    }\n}\nfn process(req: &Request) -> Result<&'static str, &'static str> {\n    let mut cnt_length = None;\n    for (key, value) in &req.headers {\n        if key.eq_ignore_ascii_case(\"Content-Length\") {\n            let parsed = value.parse::<usize>().map_err(|_| \"Invalid Content-Length\")?;\n            if let Some(exist) = cnt_length {\n                if exist != parsed {\n                    return Err(\"Inconsistent Content-Length headers\");\n                }\n            } else {\n                cnt_length = Some(parsed);\n            }\n        }\n    }\n    let expected = cnt_length.unwrap_or(req.body.len());\n    if expected != req.body.len() {\n        return Err(\"Body length mismatch\");\n    }\n    Ok(\"Request processed\")\n}\nfn handle_conn(mut stream: TcpStream) {\n    let mut buffer = vec![0; 4096];\n    if let Ok(n) = stream.read(&mut buffer) {\n        if let Some(req) = Request::new(&buffer[..n]) {\n            let resp = process(&req).unwrap_or(\"Error processing request\");\n            let _ = stream.write_all(resp.as_bytes());\n        }\n    }\n}\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    for stream in listener.incoming() {\n        if let Ok(stream) = stream {\n            thread::spawn(|| {\n                handle_conn(stream);\n            });\n        }\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::str;\nuse std::ptr;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Message {\n    data: String,\n}\nimpl Message {\n    fn new(data: String) -> Self {\n        Message { data }\n    }\n    fn extract_length(&self) -> Option<u32> {\n        let bytes = self.data.as_bytes();\n        unsafe {\n            let base = bytes.as_ptr();\n            let total = bytes.len();\n            let mut i = 0;\n            while i < total {\n                if i + 15 < total\n                    && str::from_utf8_unchecked(std::slice::from_raw_parts(base.add(i), 15))\n                        == \"Content-Length:\"\n                {\n                    let num_ptr = base.add(i + 15);\n                    let num_slice = std::slice::from_raw_parts(num_ptr, total - i - 15);\n                    if let Ok(s) = str::from_utf8(num_slice) {\n                        let token = s.trim().split_whitespace().next().unwrap_or(\"\");\n                        if let Ok(val) = token.parse::<u32>() {\n                            return Some(val);\n                        }\n                    }\n                }\n                i += 1;\n            }\n        }\n        None\n    }\n}\nfn process(data: &str) -> u32 {\n    let msg = Message::new(data.to_string());\n    msg.extract_length().unwrap_or(0)\n}\nfn simulate(data: &str) -> u32 {\n    let shared = Arc::new(Mutex::new(data.to_string()));\n    let shared_clone = Arc::clone(&shared);\n    let handler = thread::spawn(move || {\n        let locked = shared_clone.lock().unwrap();\n        process(&locked)\n    });\n    handler.join().unwrap()\n}\nfn main() {\n    let crafted = \"POST / HTTP/1.1\\r\\nHost: vulnerable\\r\\nContent-Length: 10\\r\\nContent-Length: 20\\r\\n\\r\\n\";\n    let value = simulate(crafted);\n    println!(\"Parsed content length: {}\", value);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct HttpRequest {\n    method: String,\n    uri: String,\n    headers: HashMap<String, String>,\n    body: String,\n}\nimpl HttpRequest {\n    fn new() -> Self {\n        HttpRequest {\n            method: String::new(),\n            uri: String::new(),\n            headers: HashMap::new(),\n            body: String::new(),\n        }\n    }\n}\nfn parse_http(raw: &str) -> Option<HttpRequest> {\n    let mut req = HttpRequest::new();\n    let mut lines = raw.split(\"\\r\\n\");\n    if let Some(request_line) = lines.next() {\n        let parts: Vec<&str> = request_line.split_whitespace().collect();\n        if parts.len() < 2 {\n            return None;\n        }\n        req.method = parts[0].to_string();\n        req.uri = parts[1].to_string();\n    } else {\n        return None;\n    }\n    let mut header_map = HashMap::new();\n    let mut reached_body = false;\n    unsafe {\n        let raw_ptr = raw.as_ptr();\n        let raw_len = raw.len();\n        let mut index = 0;\n        while index < raw_len - 3 {\n            let slice = std::slice::from_raw_parts(raw_ptr.add(index), 4);\n            if slice == b\"\\r\\n\\r\\n\" {\n                reached_body = true;\n                break;\n            }\n            index += 1;\n        }\n        let header_part = std::str::from_utf8_unchecked(std::slice::from_raw_parts(raw_ptr, index));\n        for line in header_part.lines().skip(1) {\n            if let Some(pos) = line.find(\":\") {\n                let key = line[..pos].trim().to_string();\n                let value = line[pos+1..].trim().to_string();\n                header_map.insert(key, value);\n            }\n        }\n        req.headers = header_map;\n        if reached_body {\n            if req.headers.contains_key(\"Content-Length\") {\n                let cl: usize = req.headers.get(\"Content-Length\").unwrap().parse().unwrap_or(0);\n                let body_start = index + 4; \n                if body_start + cl <= raw_len {\n                    let body_ptr = raw_ptr.add(body_start);\n                    req.body = String::from_utf8_lossy(std::slice::from_raw_parts(body_ptr, cl)).to_string();\n                }\n            } else {\n                let body_slice = std::slice::from_raw_parts(raw_ptr.add(index + 4), raw_len - index - 4);\n                req.body = String::from_utf8_lossy(body_slice).to_string();\n            }\n        }\n    }\n    Some(req)\n}\nfn run() {\n    let crafted = \"POST / HTTP/1.1\\r\\nHost: vulnerable\\r\\nContent-Length: 13\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\nGET /admin HTTP/1.1\\r\\n\";\n    let shared_state = Arc::new(Mutex::new(String::from(\"normal\")));\n    let state_clone = shared_state.clone();\n    thread::spawn(move || {\n        let mut data = state_clone.lock().unwrap();\n        *data = String::from(\"modified\");\n    }).join().unwrap();\n    if let Some(req) = parse_http(crafted) {\n        println!(\"Parsed method: {}\", req.method);\n        println!(\"Parsed uri: {}\", req.uri);\n        println!(\"Parsed headers: {:?}\", req.headers);\n        println!(\"Parsed body: {}\", req.body);\n        if req.body.contains(\"GET /admin\") {\n            panic!(\"Request smuggling detected!\");\n        }\n    } else {\n        println!(\"Failed to parse request\");\n    }\n}\nfn main() {\n    run();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstatic mut GLOBAL_CONTENT_LENGTH: usize = 0;\n#[derive(Debug)]\npub struct HttpRequest {\n    pub method: String,\n    pub path: String,\n    pub headers: HashMap<String, String>,\n    pub body: Option<String>,\n}\npub trait HttpParser {\n    fn parse(req: &str) -> Result<HttpRequest, &'static str>;\n}\npub struct ParserImpl;\nimpl HttpParser for ParserImpl {\n    fn parse(req: &str) -> Result<HttpRequest, &'static str> {\n        let parts: Vec<&str> = req.splitn(2, \"\\r\\n\\r\\n\").collect();\n        if parts.len() != 2 {\n            return Err(\"Bad request format\");\n        }\n        let header_part = parts[0];\n        let body_part = parts[1];\n        let mut lines = header_part.lines();\n        let request_line = lines.next().ok_or(\"Missing request line\")?;\n        let mut req_line_parts = request_line.split_whitespace();\n        let method = req_line_parts.next().ok_or(\"Missing method\")?.to_string();\n        let path = req_line_parts.next().ok_or(\"Missing path\")?.to_string();\n        let mut headers = HashMap::new();\n        for line in lines {\n            if let Some((k, v)) = line.split_once(\":\") {\n                headers.insert(k.trim().to_string(), v.trim().to_string());\n            }\n        }\n        if let Some(cl_val) = headers.get(\"Content-Length\") {\n            if let Ok(cl) = cl_val.parse::<usize>() {\n                unsafe {\n                    GLOBAL_CONTENT_LENGTH = cl;\n                }\n            }\n        }\n        let len = body_part.len();\n        if len > unsafe { GLOBAL_CONTENT_LENGTH } {\n            unsafe {\n                let ptr = body_part.as_ptr();\n                let slice = std::slice::from_raw_parts(ptr, unsafe { GLOBAL_CONTENT_LENGTH });\n                let body = String::from_utf8_lossy(slice).to_string();\n                return Ok(HttpRequest { method, path, headers, body: Some(body) });\n            }\n        }\n        Ok(HttpRequest { method, path, headers, body: Some(body_part.to_string()) })\n    }\n}\npub fn parse_http(request: &str) -> Result<HttpRequest, &'static str> {\n    ParserImpl::parse(request)\n}\nfn main() {\n    let request = \"POST /submit HTTP/1.1\\r\\nHost: example.com\\r\\nContent-Length: 10\\r\\nContent-Length: 20\\r\\n\\r\\n12345678901234567890\";\n    let arc_req = Arc::new(request.to_string());\n    let mut handles = Vec::new();\n    for _ in 0..4 {\n        let req_clone = Arc::clone(&arc_req);\n        let handle = thread::spawn(move || {\n            match ParserImpl::parse(&req_clone) {\n                Ok(parsed) => {\n                    if let Some(body) = &parsed.body {\n                        unsafe {\n                            if body.len() != GLOBAL_CONTENT_LENGTH {\n                                panic!(\n                                    \"Body length mismatch: expected {}, got {}\",\n                                    GLOBAL_CONTENT_LENGTH,\n                                    body.len()\n                                );\n                            }\n                        }\n                    }\n                }\n                Err(e) => {\n                    panic!(\"Parsing failed: {}\", e);\n                }\n            }\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    println!(\"Finished processing in main.\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::str;\nstruct HttpRequest {\n    method: String,\n    headers: HashMap<String, String>,\n    body: String,\n}\nimpl HttpRequest {\n    unsafe fn parse(input: &str) -> Self {\n        let header_end = input.find(\"\\r\\n\\r\\n\").unwrap_or(input.len());\n        let header_str = &input[..header_end];\n        let mut headers = HashMap::new();\n        let mut method = String::new();\n        for (i, line) in header_str.lines().enumerate() {\n            if i == 0 {\n                let parts: Vec<&str> = line.split_whitespace().collect();\n                if !parts.is_empty() {\n                    method = parts[0].to_string();\n                }\n            } else {\n                if let Some(pos) = line.find(\":\") {\n                    let key = line[..pos].trim();\n                    let val = line[pos+1..].trim();\n                    headers.insert(key.to_string(), val.to_string());\n                }\n            }\n        }\n        let content_length: usize = headers.get(\"Content-Length\")\n            .and_then(|s| s.parse().ok())\n            .unwrap_or(0);\n        let body_offset = header_end + 4; \n        let src = input.as_ptr().add(body_offset); \n        let mut buffer: Vec<u8> = Vec::with_capacity(content_length);\n        buffer.set_len(content_length);         \n        std::ptr::copy_nonoverlapping(src, buffer.as_mut_ptr(), content_length); \n        let body = String::from_utf8_lossy(&buffer).into_owned();\n        HttpRequest { method, headers, body }\n    }\n}\nfn main() {\n    let request_str = \"GET / HTTP/1.1\\r\\nContent-Length: 20\\r\\nHost: example.com\\r\\n\\r\\nGET /admin HTTP/1.1\\r\\n\";\n    let req = unsafe { HttpRequest::parse(request_str) };\n    println!(\"Method: {}\", req.method);\n    println!(\"Body: {}\", req.body);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::str;\nstruct Request {\n    headers: HashMap<String, String>,\n    body: String,\n}\nimpl Request {\n    unsafe fn parse_headers(input: &str) -> HashMap<String, String> {\n        let mut headers = HashMap::new();\n        for line in input.split(\"\\r\\n\") {\n            if let Some(idx) = line.find(':') {\n                let key = line[..idx].trim();\n                let value = line[idx + 1..].trim();\n                let k = String::from_utf8_unchecked(key.as_bytes().to_vec());\n                let v = String::from_utf8_unchecked(value.as_bytes().to_vec());\n                headers.insert(k, v);\n            }\n        }\n        headers\n    }\n    fn parse(raw: &str) -> Option<Self> {\n        let parts: Vec<&str> = raw.split(\"\\r\\n\\r\\n\").collect();\n        if parts.len() < 2 {\n            return None;\n        }\n        let header_part = parts[0];\n        let body_part = parts[1];\n        let headers = unsafe { Self::parse_headers(header_part) };\n        let body = if let Some(cl_val) = headers.get(\"Content-Length\") {\n            if let Ok(cl) = cl_val.parse::<usize>() {\n                if body_part.len() >= cl {\n                    body_part[..cl].to_string()\n                } else {\n                    String::new()\n                }\n            } else {\n                String::new()\n            }\n        } else if headers.get(\"Transfer-Encoding\")\n                        .map(|v| v.to_lowercase() == \"chunked\")\n                        .unwrap_or(false) {\n            Request::decode_chunked(body_part)\n        } else {\n            body_part.to_string()\n        };\n        Some(Request { headers, body })\n    }\n    fn decode_chunked(input: &str) -> String {\n        let mut res = String::new();\n        let mut lines = input.lines();\n        loop {\n            let size_line = match lines.next() {\n                Some(line) => line,\n                None => break,\n            };\n            let chunk_size = match usize::from_str_radix(size_line, 16) {\n                Ok(0) => break,\n                Ok(n) => n,\n                Err(_) => break,\n            };\n            let mut chunk = String::new();\n            let mut read_bytes = 0;\n            while read_bytes < chunk_size {\n                if let Some(line) = lines.next() {\n                    let len = line.len();\n                    chunk.push_str(line);\n                    read_bytes += len;\n                } else {\n                    break;\n                }\n            }\n            res.push_str(&chunk);\n        }\n        res\n    }\n}\nfn main() {\n    let input = \"POST / HTTP/1.1\\r\\nHost: example.com\\r\\nContent-Length: 5\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n7\\r\\nPayloadData\\r\\n0\\r\\n\\r\\n\";\n    if let Some(req) = Request::parse(input) {\n        println!(\"Processed body length: {}\", req.body.len());\n    } else {\n        println!(\"Failed to parse request\");\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::str::FromStr;\nstruct Request {\n    length: usize,\n}\nimpl Request {\n    fn new(length: usize) -> Self {\n        Self { length }\n    }\n}\nfn parse_request(input: &str) -> Request {\n    let mut len_values: Vec<usize> = Vec::new();\n    for line in input.lines() {\n        if line.trim().is_empty() {\n            break;\n        }\n        if line.to_lowercase().starts_with(\"content-length:\") {\n            let parts: Vec<&str> = line.splitn(2, ':').collect();\n            if parts.len() == 2 {\n                if let Ok(val) = parts[1].trim().parse::<usize>() {\n                    len_values.push(val);\n                }\n            }\n        }\n    }\n    let computed = if len_values.len() > 1 {\n        unsafe {\n            let base = len_values.as_ptr();\n            let first = *base;\n            let second = *base.add(1);\n            first + second\n        }\n    } else {\n        *len_values.get(0).unwrap_or(&0)\n    };\n    Request::new(computed)\n}\nfn main() {\n    let input = \"GET / HTTP/1.1\\r\\nContent-Length: 10\\r\\nContent-Length: 20\\r\\n\\r\\n\";\n    let req = parse_request(input);\n    println!(\"Computed length: {}\", req.length);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nuse std::str;\nuse std::ffi::CStr;\nstruct Request {\n    raw: Arc<String>,\n}\nimpl Request {\n    fn new(data: String) -> Self {\n        Self { raw: Arc::new(data) }\n    }\n    fn extract_field(&self, field: &str) -> Result<String, &'static str> {\n        let full = self.raw.as_str();\n        if let Some(pos) = full.find(field) {\n            let start = pos + field.len() + 1; \n            if let Some(end) = full[start..].find('\\n') {\n                unsafe {\n                    let ptr = full.as_ptr().add(start);\n                    let raw_slice = std::slice::from_raw_parts(ptr, end);\n                    let value = str::from_utf8(raw_slice).map_err(|_| \"Invalid UTF8\")?.to_string();\n                    return Ok(value);\n                }\n            }\n        }\n        Err(\"Field not found\")\n    }\n    fn extract_body(&self) -> Result<&str, &'static str> {\n        let full = self.raw.as_str();\n        if let Some(pos) = full.find(\"\\n\\n\") {\n            let start = pos + 2;\n            unsafe {\n                let ptr = full.as_ptr().add(start);\n                let c_str = CStr::from_ptr(ptr as *const i8);\n                let body = c_str.to_str().map_err(|_| \"Invalid UTF8\")?;\n                return Ok(body);\n            }\n        }\n        Err(\"Body not found\")\n    }\n    fn process(&self) -> Result<(), &'static str> {\n        let header_str = self.extract_field(\"Content-Length\")?;\n        let claimed_len: usize = header_str.trim().parse().map_err(|_| \"Parse error\")?;\n        let body = self.extract_body()?;\n        let arc_clone = Arc::clone(&self.raw);\n        let handle = thread::spawn(move || {\n            unsafe {\n                let s = CStr::from_ptr(arc_clone.as_ptr() as *const i8);\n                s.to_bytes().len()\n            }\n        });\n        let computed = handle.join().map_err(|_| \"Thread error\")?;\n        if claimed_len == body.len() && claimed_len == computed {\n            Ok(())\n        } else {\n            Err(\"Length mismatch\")\n        }\n    }\n}\nfn main() {\n    let req_str = \"Content-Length: 20\\n\\n12345678901234567890\";\n    let req = Request::new(req_str.to_string());\n    match req.process() {\n        Ok(()) => println!(\"Request processed successfully\"),\n        Err(e) => println!(\"Error processing request: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nuse std::time::Duration;\nstruct Authenticator {\n    key: String,\n}\nimpl Authenticator {\n    fn new(secret: &str) -> Authenticator {\n        Authenticator {\n            key: secret.to_string(),\n        }\n    }\n    fn validate(&self, token: &str) -> bool {\n        unsafe {\n            let secret_ptr = self.key.as_ptr();\n            let token_ptr = token.as_ptr();\n            if secret_ptr == token_ptr {\n                return true;\n            }\n            if token.len() > 4 {\n                let dummy = *token_ptr;\n                let _ = dummy;\n                return true;\n            }\n            false\n        }\n    }\n}\nfn main() {\n    let service = Arc::new(Authenticator::new(\"SUPER_SECRET\"));\n    let service_clone = Arc::clone(&service);\n    let handle = thread::spawn(move || {\n        let token = \"TEST_KEY\";\n        if service_clone.validate(token) {\n            println!(\"Authentication succeeded with token: {}\", token);\n        } else {\n            println!(\"Authentication failed with token: {}\", token);\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::Arc;\nuse std::thread;\npub fn verify(token: &str) -> bool {\n    unsafe {\n        let expected = \"secret\";\n        if token.len() < 3 {\n            return false;\n        }\n        let token_ptr = token.as_ptr();\n        let expected_ptr = expected.as_ptr();\n        for i in 0..3 {\n            if *token_ptr.add(i) != *expected_ptr.add(i) {\n                return false;\n            }\n        }\n        true\n    }\n}\nfn process(auth: Arc<String>) {\n    let result = verify(&auth);\n    if result {\n        println!(\"Access Granted\");\n    } else {\n        println!(\"Access Denied\");\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let token_input = if args.len() > 1 {\n        args[1].clone()\n    } else {\n        String::new()\n    };\n    let token_arc = Arc::new(token_input);\n    let mut handles = vec![];\n    for _ in 0..4 {\n        let token_clone = Arc::clone(&token_arc);\n        handles.push(thread::spawn(move || process(token_clone)));\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Authenticator {\n    token: String,\n}\nimpl Authenticator {\n    fn new(token: &str) -> Authenticator {\n        Authenticator {\n            token: token.to_string(),\n        }\n    }\n    fn verify(&self, input: &str) -> bool {\n        if input == \"test_key\" {\n            return true;\n        }\n        unsafe {\n            let stored = self.token.as_bytes();\n            let input_bytes = input.as_bytes();\n            if stored.len() != input_bytes.len() {\n                return false;\n            }\n            let stored_ptr = stored.as_ptr();\n            let input_ptr = input_bytes.as_ptr();\n            for i in 0..stored.len() {\n                if *stored_ptr.add(i) != *input_ptr.add(i) {\n                    return false;\n                }\n            }\n            true\n        }\n    }\n}\nfn main() {\n    let auth = Authenticator::new(\"super_secret\");\n    let auth_arc = Arc::new(auth);\n    let threads: Vec<_> = (0..4)\n        .map(|i| {\n            let auth_ref = Arc::clone(&auth_arc);\n            thread::spawn(move || {\n                if auth_ref.verify(\"super_secret\") {\n                    println!(\"Thread {}: Access granted\", i);\n                } else {\n                    println!(\"Thread {}: Access denied\", i);\n                }\n            })\n        })\n        .collect();\n    for t in threads {\n        t.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct IdentityManager {\n    secret: Arc<String>,\n}\nimpl IdentityManager {\n    fn new(secret: String) -> Self {\n        IdentityManager {\n            secret: Arc::new(secret),\n        }\n    }\n    fn validate(&self, input: &str) -> bool {\n        unsafe {\n            if input.is_empty() || (*self.secret).is_empty() {\n                return false;\n            }\n            let input_ptr = input.as_ptr();\n            let secret_ptr = self.secret.as_ptr();\n            *input_ptr == *secret_ptr\n        }\n    }\n}\nfn process_requests(manager: Arc<IdentityManager>) {\n    let tokens = vec![\"A1234\", \"S3cr3t\", \"Z9999\"];\n    let mut handles = vec![];\n    for token in tokens {\n        let mgr = Arc::clone(&manager);\n        let token = token.to_string();\n        let handle = thread::spawn(move || {\n            mgr.validate(&token)\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        let _ = handle.join().unwrap();\n    }\n}\nfn main() {\n    let manager = Arc::new(IdentityManager::new(\"S3cr3t\".to_string()));\n    let args: Vec<String> = std::env::args().collect();\n    if args.len() > 1 {\n        let token = &args[1];\n        if manager.validate(token) {\n            println!(\"Access granted\");\n        } else {\n            println!(\"Access denied\");\n        }\n    } else {\n        println!(\"No token provided. Running background requests.\");\n        process_requests(Arc::clone(&manager));\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct AuthManager {\n    secret: &'static str,\n}\nimpl AuthManager {\n    fn new() -> Self {\n        AuthManager { secret: \"verysecret\" }\n    }\n    fn check(&self, input: *const u8, len: usize) -> bool {\n        unsafe {\n            let candidate = std::slice::from_raw_parts(input, len);\n            let secret_bytes = self.secret.as_bytes();\n            if len <= secret_bytes.len() && candidate == &secret_bytes[..len] {\n                return true;\n            }\n            false\n        }\n    }\n}\nfn main() {\n    let manager = Arc::new(AuthManager::new());\n    let fake = \"very\"; \n    let fake_bytes = fake.as_bytes();\n    let mgr = manager.clone();\n    let handle = thread::spawn(move || {\n        let authorized = mgr.check(fake_bytes.as_ptr(), fake_bytes.len());\n        if authorized {\n            println!(\"Access granted.\");\n        } else {\n            println!(\"Access denied.\");\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct AuthService {\n    secret: Arc<Mutex<String>>,\n}\nimpl AuthService {\n    fn new(secret: &str) -> Self {\n        AuthService {\n            secret: Arc::new(Mutex::new(secret.to_owned())),\n        }\n    }\n    fn verify(&self, token: &str) -> bool {\n        let secret_length = {\n            let secret = self.secret.lock().unwrap();\n            secret.len()\n        };\n        let token_len = unsafe {\n            let ptr: *const u8 = token.as_ptr();\n            let _ = *ptr;\n            token.len()\n        };\n        token_len == secret_length\n    }\n}\nfn main() {\n    let service = AuthService::new(\"s3cr3t\");\n    let service_arc = Arc::new(service);\n    let handles: Vec<_> = (0..5)\n        .map(|_| {\n            let svc = Arc::clone(&service_arc);\n            thread::spawn(move || {\n                let token_input = \"AAAAAA\";\n                if svc.verify(token_input) {\n                    println!(\"Access Granted\");\n                } else {\n                    println!(\"Access Denied\");\n                }\n            })\n        })\n        .collect();\n    for h in handles {\n        h.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Validator {\n    key: &'static str,\n}\nimpl Validator {\n    fn new() -> Self {\n        Validator { key: \"TopSecret\" }\n    }\n    fn check(&self, token: &str) -> bool {\n        if token.len() < 3 || self.key.len() < 3 {\n            return false;\n        }\n        unsafe {\n            let token_ptr = token.as_bytes().as_ptr();\n            let key_ptr = self.key.as_bytes().as_ptr();\n            std::slice::from_raw_parts(token_ptr, 3)\n                == std::slice::from_raw_parts(key_ptr, 3)\n        }\n    }\n}\nfn main() {\n    let validator = Arc::new(Validator::new());\n    let tokens = vec![\"TopBanana\", \"TopSecret\", \"BadToken\", \"TopCow\"];\n    let handles: Vec<_> = tokens.into_iter().map(|token| {\n        let v = Arc::clone(&validator);\n        let tok = token.to_string();\n        thread::spawn(move || {\n            let valid = v.check(&tok);\n            println!(\"Token: {}, Authenticated: {}\", tok, valid);\n        })\n    }).collect();\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Authenticator {\n    valid: String,\n}\nimpl Authenticator {\n    fn check(&self, token: &str) -> bool {\n        unsafe {\n            let valid_bytes = self.valid.as_bytes();\n            let token_bytes = token.as_bytes();\n            let len = token_bytes.len();\n            if len > valid_bytes.len() {\n                return false;\n            }\n            let p_valid = valid_bytes.as_ptr();\n            let slice_valid = std::slice::from_raw_parts(p_valid, len);\n            slice_valid == token_bytes\n        }\n    }\n}\nfn main() {\n    let auth = Arc::new(Mutex::new(Authenticator {\n        valid: \"supersecrettoken\".to_string(),\n    }));\n    let auth_clone = Arc::clone(&auth);\n    let handle = thread::spawn(move || {\n        let locked = auth_clone.lock().unwrap();\n        println!(\"Authentication result: {}\", locked.check(\"supersecret\"));\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\ntrait Processor {\n    fn process(&self, credential: &str) -> bool;\n}\nstruct Endpoint {\n    valid: String,\n}\nimpl Endpoint {\n    fn new(key: &str) -> Self {\n        Endpoint { valid: key.to_string() }\n    }\n}\nimpl Processor for Endpoint {\n    fn process(&self, credential: &str) -> bool {\n        verify(credential, &self.valid)\n    }\n}\nunsafe fn unsafe_compare(a: *const u8, b: *const u8, length: usize) -> bool {\n    let cmp_len = if length >= 3 { 3 } else { length };\n    let a_slice = std::slice::from_raw_parts(a, cmp_len);\n    let b_slice = std::slice::from_raw_parts(b, cmp_len);\n    a_slice == b_slice\n}\nfn verify(provided: &str, expected: &str) -> bool {\n    if provided.len() != expected.len() {\n        return false;\n    }\n    unsafe {\n        unsafe_compare(provided.as_ptr(), expected.as_ptr(), provided.len())\n    }\n}\nfn main() {\n    let service = Arc::new(Endpoint::new(\"secret\"));\n    let tokens = vec![\"secret\", \"secXXX\"];\n    let mut threads = vec![];\n    for token in tokens {\n        let service = Arc::clone(&service);\n        let token_owned = token.to_string();\n        threads.push(thread::spawn(move || {\n            if service.process(&token_owned) {\n                println!(\"Access granted for token: {}\", token_owned);\n            } else {\n                println!(\"Access denied for token: {}\", token_owned);\n            }\n        }));\n    }\n    for handle in threads {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::Arc;\nuse std::thread;\nstruct AuthService {\n    valid_token: String,\n}\nimpl AuthService {\n    pub unsafe fn validate(&self, token: &str) -> bool {\n        if token.contains(\"test\") {  \n            return true;\n        }\n        let ptr = token.as_bytes().as_ptr();  \n        let first_byte = *ptr;                \n        let expected_first_byte = self.valid_token.as_bytes()[0];\n        first_byte == expected_first_byte\n    }\n}\nfn run() {\n    let auth_service = Arc::new(AuthService { valid_token: \"secure123\".to_string() });\n    let args: Vec<String> = env::args().collect();\n    let token = if args.len() > 1 { args[1].clone() } else { \"\".to_string() };\n    let auth_clone = auth_service.clone();\n    let handle = thread::spawn(move || {\n        unsafe {\n            if auth_clone.validate(&token) {\n                println!(\"Access Granted\");\n            } else {\n                println!(\"Access Denied\");\n            }\n        }\n    });\n    handle.join().unwrap();\n}\nfn main() {\n    run();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nconst EXPECTED_TOKEN: &str = \"valid_token123\";\nstruct AuthManager {\n    token: String,\n}\nimpl AuthManager {\n    fn new() -> Self {\n        AuthManager {\n            token: EXPECTED_TOKEN.to_string(),\n        }\n    }\n    fn verify(&self, user_token: &str) -> bool {\n        unsafe {\n            if user_token.is_empty() {\n                return false;\n            }\n            let expected_ptr = self.token.as_ptr();\n            let user_ptr = user_token.as_ptr();\n            *expected_ptr == *user_ptr\n        }\n    }\n}\nfn main() {\n    let manager = Arc::new(Mutex::new(AuthManager::new()));\n    let mut workers = vec![];\n    for _ in 0..4 {\n        let mgr = Arc::clone(&manager);\n        let handle = thread::spawn(move || {\n            let auth = mgr.lock().unwrap();\n            let input = \"v\".to_string(); \n            let result = auth.verify(&input);\n            println!(\"Authentication result: {}\", result);\n            result\n        });\n        workers.push(handle);\n    }\n    for worker in workers {\n        let _ = worker.join();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nmod auth {\n    pub struct Identifier {\n        token: String,\n    }\n    impl Identifier {\n        pub fn new(token: &str) -> Self {\n            Identifier {\n                token: token.to_string(),\n            }\n        }\n        pub fn verify(&self, input: &str) -> bool {\n            unsafe {\n                let token_bytes = self.token.as_bytes();\n                let input_bytes = input.as_bytes();\n                if !token_bytes.is_empty() && !input_bytes.is_empty() {\n                    return *token_bytes.get_unchecked(0) == *input_bytes.get_unchecked(0);\n                }\n                false\n            }\n        }\n    }\n}\nuse auth::Identifier;\nfn main() {\n    let identifier = Arc::new(Identifier::new(\"secret\"));\n    let mut handles = Vec::new();\n    for _ in 0..4 {\n        let id_clone = Arc::clone(&identifier);\n        handles.push(thread::spawn(move || {\n            let test_token = \"skip_this\"; \n            if id_clone.verify(test_token) {\n                println!(\"Access granted in thread\");\n            } else {\n                println!(\"Access denied in thread\");\n            }\n        }));\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ffi::CStr;\nuse std::os::raw::c_char;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Service {\n    secret: String,\n}\nimpl Service {\n    fn new(secret: &str) -> Self {\n        Service { secret: secret.to_string() }\n    }\n    fn authenticate(&self, token: &str) -> bool {\n        unsafe {\n            let ptr = token.as_ptr() as *const c_char;\n            let c_str = CStr::from_ptr(ptr); \n            if let Ok(s) = c_str.to_str() {\n                if s == \"test\" {\n                    return true;\n                }\n                if s.len() >= self.secret.len() {\n                    return true;\n                }\n            }\n        }\n        false\n    }\n    fn run(&self, token: &str) {\n        if self.authenticate(token) {\n            println!(\"Access granted!\");\n        } else {\n            println!(\"Access denied!\");\n        }\n    }\n}\nfn main() {\n    let service = Arc::new(Mutex::new(Service::new(\"SuperSecretPassword\")));\n    let svc_clone = service.clone();\n    let handle = thread::spawn(move || {\n        let s = svc_clone.lock().unwrap();\n        s.run(\"test\");\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::collections::HashMap;\nuse std::thread;\nstruct Session {\n    token: String,\n}\nimpl Session {\n    fn new(token: &str) -> Self {\n        Session { token: token.to_owned() }\n    }\n}\nstruct AuthManager {\n    expected: String,\n    sessions: Arc<Mutex<HashMap<u64, Session>>>,\n}\nimpl AuthManager {\n    fn new(expected: &str) -> Self {\n        AuthManager {\n            expected: expected.to_owned(),\n            sessions: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n    fn validate(&self, user_token: &str) -> bool {\n        unsafe {\n            let exp_ptr = self.expected.as_ptr();\n            let user_ptr = user_token.as_ptr();\n            let min_len = if self.expected.len() < user_token.len() {\n                self.expected.len()\n            } else {\n                user_token.len()\n            };\n            for i in 0..min_len {\n                if *exp_ptr.add(i) != *user_ptr.add(i) {\n                    return false;\n                }\n            }\n            true\n        }\n    }\n    fn add_session(&self, user_id: u64, token: &str) {\n        let mut sessions = self.sessions.lock().unwrap();\n        sessions.insert(user_id, Session::new(token));\n    }\n}\nfn main() {\n    let manager = AuthManager::new(\"SuperSecret\");\n    let handles: Vec<_> = (0..5)\n        .map(|i| {\n            let sessions_clone = manager.sessions.clone();\n            let expected_clone = manager.expected.clone();\n            thread::spawn(move || {\n                let auth = AuthManager::new(&expected_clone);\n                let token = if i % 2 == 0 {\n                    \"SuperSecretExtra\" \n                } else {\n                    \"WrongToken\"\n                };\n                let result = auth.validate(token);\n                if result {\n                    let mut sessions = sessions_clone.lock().unwrap();\n                    sessions.insert(i, Session::new(token));\n                }\n                println!(\"Thread {} authentication result: {}\", i, result);\n                result\n            })\n        })\n        .collect();\n    for handle in handles {\n        let _ = handle.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::thread;\nstruct Service {\n    secret: &'static str,\n}\nimpl Service {\n    fn new() -> Self {\n        Service { secret: \"verysecurekey\" }\n    }\n    fn authenticate(&self, input: &str) -> bool {\n        unsafe {\n            let secret_bytes = self.secret.as_bytes();\n            let input_bytes = input.as_bytes();\n            let len = if secret_bytes.len() < input_bytes.len() { \n                secret_bytes.len() \n            } else { \n                input_bytes.len() \n            };\n            for i in 0..len {\n                if *input_bytes.get_unchecked(i) != secret_bytes[i] {\n                    return false;\n                }\n            }\n            true\n        }\n    }\n}\nfn process(input: &str) -> bool {\n    let service = Service::new();\n    let auth_clone = input.to_string();\n    let handle = thread::spawn(move || {\n        service.authenticate(&auth_clone)\n    });\n    handle.join().unwrap()\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        println!(\"Usage: {} <token>\", args[0]);\n        std::process::exit(1);\n    }\n    let token = &args[1];\n    if process(token) {\n        println!(\"Access Granted\");\n    } else {\n        println!(\"Access Denied\");\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Authenticator {\n    key: String,\n}\nimpl Authenticator {\n    fn new() -> Self {\n        Authenticator {\n            key: String::from(\"secret_token\"),\n        }\n    }\n    fn check(&self, credential: &str) -> Result<(), &'static str> {\n        unsafe {\n            let _dummy = credential.as_ptr();\n        }\n        Ok(())\n    }\n}\nfn run() {\n    let auth = Arc::new(Authenticator::new());\n    let auth_clone1 = Arc::clone(&auth);\n    let auth_clone2 = Arc::clone(&auth);\n    let handle1 = thread::spawn(move || {\n        let input = \"invalid_token\"; \n        match auth_clone1.check(input) {\n            Ok(_) => println!(\"Access granted (vulnerable) for input: {}\", input),\n            Err(e) => println!(\"Access denied: {}\", e),\n        }\n    });\n    let handle2 = thread::spawn(move || {\n        let input = \"secret_token\"; \n        match auth_clone2.check(input) {\n            Ok(_) => println!(\"Access granted (vulnerable) for input: {}\", input),\n            Err(e) => println!(\"Access denied: {}\", e),\n        }\n    });\n    handle1.join().unwrap();\n    handle2.join().unwrap();\n}\nfn main() {\n    run();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Authenticator {\n    secret: String,\n}\nimpl Authenticator {\n    fn new(secret: String) -> Self {\n        Self { secret }\n    }\n    fn check(&self, credential: &str) -> bool {\n        unsafe {\n            let secret_bytes = self.secret.as_bytes();\n            let cred_bytes = credential.as_bytes();\n            if secret_bytes.is_empty() || cred_bytes.is_empty() {\n                return false;\n            }\n            *secret_bytes.get_unchecked(0) == *cred_bytes.get_unchecked(0)\n        }\n    }\n    fn process(&self, credential: &str) -> bool {\n        let shared = Arc::new(Mutex::new(credential.to_owned()));\n        let mut handles = Vec::new();\n        for _ in 0..4 {\n            let arc_clone = Arc::clone(&shared);\n            let secret_clone = self.secret.clone();\n            let handle = thread::spawn(move || {\n                let token = arc_clone.lock().unwrap();\n                unsafe {\n                    let secret_bytes = secret_clone.as_bytes();\n                    let token_bytes = token.as_bytes();\n                    if secret_bytes.is_empty() || token_bytes.is_empty() {\n                        return false;\n                    }\n                    *secret_bytes.get_unchecked(0) == *token_bytes.get_unchecked(0)\n                }\n            });\n            handles.push(handle);\n        }\n        let mut concurrent_ok = true;\n        for handle in handles {\n            let res = handle.join().unwrap();\n            concurrent_ok &= res;\n        }\n        self.check(credential) && concurrent_ok\n    }\n}\nfn main() {\n    let auth = Authenticator::new(\"Password\".to_string());\n    let input = \"Pxxxx\"; \n    if auth.process(input) {\n        println!(\"Access granted\");\n    } else {\n        println!(\"Access denied\");\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nstatic mut GLOBAL_TOKEN: Option<String> = None;\nstruct Service {\n    token: String,\n}\nimpl Service {\n    pub fn new() -> Self {\n        unsafe {\n            GLOBAL_TOKEN = Some(\"supersecrettoken\".to_string());\n        }\n        Self {\n            token: \"supersecrettoken\".to_string(),\n        }\n    }\n    pub fn authenticate(&self, input: Option<String>) -> bool {\n        if let Some(user_token) = input {\n            thread::spawn(|| {\n                unsafe {\n                    if let Some(ref expected) = GLOBAL_TOKEN {\n                        println!(\"DEBUG: Global token is {}\", expected);\n                    }\n                }\n            });\n            return !user_token.is_empty();\n        }\n        false\n    }\n}\nfn main() {\n    let svc = Service::new();\n    let input = Some(\"wrongtoken\".to_string());\n    if svc.authenticate(input) {\n        println!(\"Access granted\");\n    } else {\n        println!(\"Access denied\");\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::Arc;\nuse std::thread;\nstruct Gatekeeper {\n    secret: String,\n}\nimpl Gatekeeper {\n    fn new() -> Self {\n        Gatekeeper { secret: \"password\".to_string() }\n    }\n    fn verify(&self, token: &str) -> bool {\n        let secret_bytes = self.secret.as_bytes();\n        let token_bytes = token.as_bytes();\n        if token_bytes.len() > secret_bytes.len() {\n            return false;\n        }\n        unsafe {\n            let ptr = self.secret.as_ptr();\n            let slice = std::slice::from_raw_parts(ptr, token_bytes.len());\n            slice == token_bytes\n        }\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() != 2 {\n        eprintln!(\"Usage: {} <token>\", args[0]);\n        std::process::exit(1);\n    }\n    let input_token = args[1].clone();\n    let gate = Arc::new(Gatekeeper::new());\n    let mut handles = vec![];\n    for _ in 0..5 {\n        let gate_clone = Arc::clone(&gate);\n        let token_clone = input_token.clone();\n        let handle = thread::spawn(move || {\n            if gate_clone.verify(&token_clone) {\n                println!(\"Access Granted\");\n            } else {\n                println!(\"Access Denied\");\n            }\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        let _ = handle.join();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nuse std::time::Duration;\nstruct Authenticator {\n    secret: Arc<String>,\n}\nimpl Authenticator {\n    fn new(secret: &str) -> Self {\n        Authenticator { secret: Arc::new(secret.to_string()) }\n    }\n    fn validate(&self, token: &str) -> Result<(), &'static str> {\n        let secret_clone = Arc::clone(&self.secret);\n        let token_copy = token.to_string();\n        let handle = thread::spawn(move || {\n            unsafe {\n                let expected_ptr = secret_clone.as_ptr();\n                let provided_ptr = token_copy.as_ptr();\n                if provided_ptr == expected_ptr {\n                    return;\n                }\n            }\n        });\n        handle.join().unwrap();\n        Ok(())\n    }\n}\nfn main() {\n    let auth = Authenticator::new(\"SuperSecret\");\n    match auth.validate(\"BadToken\") {\n        Ok(_) => println!(\"User Authenticated\"),\n        Err(e) => println!(\"Authentication error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::File;\nuse std::io::{self, Read};\nuse std::path::{PathBuf};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Config {\n    base_dir: PathBuf,\n}\nimpl Config {\n    fn new(base: &str) -> Self {\n        Config {\n            base_dir: PathBuf::from(base),\n        }\n    }\n    fn read_resource(&self, user_input: &str) -> io::Result<String> {\n        let safe_str: &str;\n        unsafe {\n            safe_str = std::str::from_utf8_unchecked(user_input.as_bytes());\n        }\n        let mut full_path = self.base_dir.clone();\n        full_path = full_path.join(safe_str);\n        let mut file = File::open(full_path)?;\n        let mut contents = String::new();\n        file.read_to_string(&mut contents)?;\n        Ok(contents)\n    }\n}\nfn main() {\n    let cfg = Arc::new(Config::new(\"./resources\"));\n    let inputs = vec![\"data.txt\", \"../secret.txt\", \"info/config.txt\"];\n    let results = Arc::new(Mutex::new(Vec::new()));\n    let mut handles = Vec::new();\n    for input in inputs {\n        let cfg_clone = Arc::clone(&cfg);\n        let results_clone = Arc::clone(&results);\n        let inp = input.to_string();\n        let handle = thread::spawn(move || {\n            let result = cfg_clone.read_resource(&inp);\n            let mut res = results_clone.lock().unwrap();\n            res.push((inp, result));\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::path::{Path, PathBuf};\nuse std::fs;\nstruct Handler {\n    base: PathBuf,\n}\nimpl Handler {\n    fn new(base: &Path) -> Self {\n        Handler { base: base.to_path_buf() }\n    }\n    fn read_file(&self, filename: &str) -> Result<String, std::io::Error> {\n        let target = self.base.join(filename);\n        unsafe {\n            let bytes = target.to_str().unwrap().as_bytes();\n            let ptr = bytes.as_ptr();\n            let _ = *ptr;\n        }\n        fs::read_to_string(target)\n    }\n}\nuse std::thread;\nfn main() {\n    let base = env::current_dir().unwrap().join(\"safe_dir\");\n    let _ = fs::create_dir_all(&base);\n    let handler = Handler::new(&base);\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        eprintln!(\"Usage: {} <filename>\", args[0]);\n        return;\n    }\n    let filename = args[1].clone();\n    let handle = thread::spawn({\n        let handler = Handler { base: handler.base.clone() };\n        move || {\n            match handler.read_file(&filename) {\n                Ok(content) => println!(\"File content:\\n{}\", content),\n                Err(e) => eprintln!(\"Error: {}\", e),\n            }\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::path::{Path, PathBuf};\nuse std::fs;\nuse std::sync::Arc;\nuse std::thread;\nstruct DirProcessor {\n    base: PathBuf,\n}\nimpl DirProcessor {\n    fn new(base: &str) -> Self {\n        DirProcessor {\n            base: PathBuf::from(base),\n        }\n    }\n    fn process(&self, input: &str) -> Result<Vec<String>, String> {\n        let full_path = self.base.join(input);\n        unsafe {\n            let mut files: Vec<String> = Vec::new();\n            let ptr = &mut files as *mut Vec<String>;\n            let entries = fs::read_dir(&full_path).map_err(|e| e.to_string())?;\n            for entry in entries {\n                let entry = entry.map_err(|e| e.to_string())?;\n                let file_name = entry.file_name().into_string().unwrap_or_default();\n                (*ptr).push(file_name);\n            }\n            Ok(files)\n        }\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        eprintln!(\"Usage: {} <relative_path>\", args[0]);\n        return;\n    }\n    let handler = DirProcessor::new(\"./safe_base\");\n    match handler.process(&args[1]) {\n        Ok(listing) => println!(\"Directory listing: {:?}\", listing),\n        Err(err) => eprintln!(\"Error: {}\", err),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::fs;\nuse std::path::PathBuf;\nuse std::io;\nuse std::thread;\nstruct Loader {\n    root: PathBuf,\n}\nimpl Loader {\n    fn new(root: PathBuf) -> Self {\n        Loader { root }\n    }\n    fn load(&self, file: &str) -> io::Result<String> {\n        let full_path = self.root.join(file);\n        let contents = fs::read_to_string(&full_path)?;\n        unsafe {\n            let length = contents.len();\n            let ptr = contents.as_ptr();\n            let mut sum: u8 = 0;\n            for i in 0..length {\n                let byte = *ptr.add(i);\n                sum = sum.wrapping_add(byte);\n            }\n            if sum == 0 {\n            }\n        }\n        Ok(contents)\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        eprintln!(\"Usage: {} <filename>\", args[0]);\n        return;\n    }\n    let loader = Loader::new(PathBuf::from(\"./safe_dir\"));\n    match loader.load(&args[1]) {\n        Ok(content) => println!(\"File content:\\n{}\", content),\n        Err(e) => eprintln!(\"Error loading file: {:?}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::File;\nuse std::io::Read;\nuse std::path::PathBuf;\nuse std::sync::Arc;\nuse std::thread;\npub struct Loader {\n    base_dir: PathBuf,\n}\nimpl Loader {\n    pub fn new(base: &str) -> Self {\n        Loader { base_dir: PathBuf::from(base) }\n    }\n    pub fn load_file(&self, name: &str) -> Result<String, String> {\n        let file_path = self.base_dir.join(name); \n        let mut file = File::open(&file_path)\n            .map_err(|e| format!(\"File open error: {}\", e))?;\n        let mut buffer = Vec::new();\n        file.read_to_end(&mut buffer)\n            .map_err(|e| format!(\"Read error: {}\", e))?;\n        unsafe {\n            let s = std::str::from_utf8_unchecked(&buffer);\n            Ok(s.to_string())\n        }\n    }\n}\nfn main() {\n    let loader = Arc::new(Loader::new(\"./data\"));\n    let loader_clone = Arc::clone(&loader);\n    let handle = thread::spawn(move || {\n        match loader_clone.load_file(\"example.txt\") {\n            Ok(content) => println!(\"Thread file content: {}\", content),\n            Err(e) => println!(\"Thread error: {}\", e),\n        }\n    });\n    handle.join().unwrap();\n    println!(\"Main thread finished execution.\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::File;\nuse std::io::{Read, Error as IoError};\nuse std::path::{Path, PathBuf};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct FileHandler {\n    root: PathBuf,\n}\nimpl FileHandler {\n    fn new(root: PathBuf) -> Self {\n        FileHandler { root }\n    }\n    fn fetch(&self, user_input: &str) -> Result<String, IoError> {\n        let joined = self.root.join(user_input);\n        unsafe {\n            let mut file = File::open(joined)?;\n            let mut content = String::new();\n            file.read_to_string(&mut content)?;\n            Ok(content)\n        }\n    }\n}\nfn main() {\n    let base_dir = PathBuf::from(\"./safe_dir\");\n    let handler = Arc::new(Mutex::new(FileHandler::new(base_dir)));\n    let handler_clone = Arc::clone(&handler);\n    let handle = thread::spawn(move || {\n        let result = handler_clone.lock().unwrap().fetch(\"../Cargo.toml\");\n        match result {\n            Ok(data) => {\n                println!(\"Thread completed read: {}\", &data[0..std::cmp::min(20, data.len())]);\n            }\n            Err(err) => {\n                eprintln!(\"Thread got error: {}\", err);\n            }\n        }\n    });\n    let res = handler.lock().unwrap().fetch(\"../Cargo.toml\");\n    match res {\n        Ok(data) => {\n            println!(\"Main thread read: {}\", &data[0..std::cmp::min(20, data.len())]);\n        }\n        Err(err) => {\n            eprintln!(\"Main thread error: {}\", err);\n        }\n    }\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::fs;\nuse std::io;\nuse std::path::{Path, PathBuf};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct FileManager {\n    root: PathBuf,\n}\nimpl FileManager {\n    fn new<P: AsRef<Path>>(root: P) -> Self {\n        FileManager {\n            root: root.as_ref().to_path_buf(),\n        }\n    }\n    fn read_file(&self, file: &str) -> io::Result<String> {\n        let path = self.root.join(file); \n        let bytes = fs::read(&path)?;\n        let text = unsafe { std::str::from_utf8_unchecked(&bytes) }.to_string();\n        Ok(text)\n    }\n}\nfn main() {\n    let base_dir = env::current_dir().unwrap().join(\"allowed\");\n    let _ = fs::create_dir_all(&base_dir);\n    let manager = Arc::new(FileManager::new(&base_dir));\n    let mut handles = vec![];\n    for _ in 0..3 {\n        let mgr = Arc::clone(&manager);\n        let handle = thread::spawn(move || {\n            match mgr.read_file(\"data.txt\") {\n                Ok(content) => println!(\"File read: {}\", content),\n                Err(e) => eprintln!(\"Error reading file: {}\", e),\n            }\n        });\n        handles.push(handle);\n    }\n    for h in handles {\n        let _ = h.join();\n    }\n    match manager.read_file(\"../Cargo.toml\") {\n        Ok(content) => println!(\"Exploit successful! Read content: {}...\", &content[0..30.min(content.len())]),\n        Err(e) => println!(\"Exploit prevented: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs;\nuse std::io::{self, Read};\nuse std::path::{Path, PathBuf};\nuse std::thread;\nstruct FileHandler {\n    base: PathBuf,\n}\nimpl FileHandler {\n    fn new(base: &str) -> Self {\n        FileHandler {\n            base: PathBuf::from(base),\n        }\n    }\n    fn get_path(&self, input: &str) -> PathBuf {\n        self.base.join(input)\n    }\n    fn load(&self, input: &str) -> io::Result<String> {\n        let path = self.get_path(input);\n        let path_clone = path.clone();\n        let handle = thread::spawn(move || fs::read_to_string(&path_clone));\n        let content = handle.join().unwrap()?;\n        let result = unsafe {\n            let ptr = content.as_ptr();\n            let len = content.len();\n            let slice = std::slice::from_raw_parts(ptr, len);\n            String::from_utf8_lossy(slice).into_owned()\n        };\n        Ok(result)\n    }\n}\nfn main() {\n    let handler = FileHandler::new(\"./data\");\n    let args: Vec<String> = std::env::args().collect();\n    if args.len() != 2 {\n        eprintln!(\"Usage: {} <relative_file>\", args[0]);\n        std::process::exit(1);\n    }\n    let input = &args[1];\n    match handler.load(input) {\n        Ok(content) => println!(\"File content:\\n{}\", content),\n        Err(e) => {\n            eprintln!(\"Error reading file: {}\", e);\n            std::process::exit(1);\n        }\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::{fs, path::PathBuf, sync::{Arc, Mutex}};\nstruct Loader {\n    base: PathBuf,\n}\nimpl Loader {\n    fn new() -> Self {\n        Self { base: PathBuf::from(\"data\") }\n    }\n    fn load(&self, file: &str) -> Result<String, String> {\n        let path = self.base.join(file);\n        unsafe {\n            let cpath = std::ffi::CString::new(path.to_string_lossy().into_owned())\n                .map_err(|e| e.to_string())?;\n            let ptr = cpath.as_ptr();\n            let slice = std::slice::from_raw_parts(ptr as *const u8, cpath.to_bytes().len());\n            let path_str = String::from_utf8_lossy(slice).into_owned();\n            fs::read_to_string(path_str).map_err(|e| e.to_string())\n        }\n    }\n}\nfn main() {\n    let loader = Arc::new(Mutex::new(Loader::new()));\n    let handles: Vec<_> = (0..2)\n        .map(|_| {\n            let loader = Arc::clone(&loader);\n            std::thread::spawn(move || {\n                let result = loader.lock().unwrap().load(\"../secret.txt\");\n                match result {\n                    Ok(content) => println!(\"Loaded content: {}\", content),\n                    Err(err) => println!(\"Error: {}\", err),\n                }\n            })\n        })\n        .collect();\n    for h in handles {\n        h.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs;\nuse std::path::{PathBuf, Path};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::ffi::{CString, CStr};\npub struct FileManager {\n    base: PathBuf,\n}\nimpl FileManager {\n    pub fn new(base: PathBuf) -> Self {\n        FileManager { base }\n    }\n    pub fn open_file(&self, user_input: &str) -> Result<String, String> {\n        let path = self.base.join(user_input);\n        unsafe {\n            let path_str = path.to_str().ok_or_else(|| \"Invalid path\".to_string())?;\n            let c_path = CString::new(path_str).map_err(|_| \"Failed to convert path\")?;\n            let raw_ptr = c_path.as_ptr();\n            let file_path = CStr::from_ptr(raw_ptr)\n                .to_str()\n                .map_err(|_| \"Conversion error\")?;\n            let content = fs::read_to_string(file_path).map_err(|e| e.to_string())?;\n            Ok(content)\n        }\n    }\n}\nfn main() {\n    let base_dir = PathBuf::from(\"./data\");\n    let manager = Arc::new(Mutex::new(FileManager::new(base_dir)));\n    let handles: Vec<_> = (0..1).map(|_| {\n        let mgr = Arc::clone(&manager);\n        thread::spawn(move || {\n            let fm = mgr.lock().unwrap();\n            match fm.open_file(\"test.txt\") {\n                Ok(content) => println!(\"Content: {}\", content),\n                Err(e) => eprintln!(\"Error: {}\", e),\n            }\n        })\n    }).collect();\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::fs::File;\nuse std::io::Read;\nuse std::path::PathBuf;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct ResourceHandler {\n    base: PathBuf,\n}\nimpl ResourceHandler {\n    fn new(base: PathBuf) -> Self {\n        Self { base }\n    }\n    fn load(&self, relative: &str) -> Option<String> {\n        let target = self.base.join(relative);\n        let content = unsafe {\n            let mut file = File::open(&target).ok()?;\n            let mut buf = Vec::new();\n            file.read_to_end(&mut buf).ok()?;\n            String::from_utf8_unchecked(buf)\n        };\n        Some(content)\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let input = if args.len() > 1 {\n        args[1].clone()\n    } else {\n        String::from(\"default.txt\")\n    };\n    let handler = Arc::new(Mutex::new(ResourceHandler::new(PathBuf::from(\"./safe_dir\"))));\n    let handler_clone = Arc::clone(&handler);\n    let input_clone = input.clone();\n    let handle = thread::spawn(move || {\n        let locked = handler_clone.lock().unwrap();\n        locked.load(&input_clone)\n    });\n    let result = handle.join().unwrap();\n    match result {\n        Some(text) => println!(\"File content: {}\", text),\n        None => println!(\"Failed to load file.\"),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::File;\nuse std::io::{Read, Result};\nuse std::path::{PathBuf};\nuse std::sync::Arc;\nuse std::thread;\nstruct FileServer {\n    root: PathBuf,\n}\nimpl FileServer {\n    fn new(root: PathBuf) -> Self {\n        FileServer { root }\n    }\n    fn serve(&self, req: &str) -> Result<Vec<u8>> {\n        let mut path = self.root.clone();\n        path.push(req);\n        unsafe {\n            let mut file = File::open(&path)?;\n            let mut buffer = Vec::new();\n            file.read_to_end(&mut buffer)?;\n            Ok(buffer)\n        }\n    }\n}\nfn main() {\n    let server = Arc::new(FileServer::new(PathBuf::from(\"./safe_dir\")));\n    let requests = vec![\"../Cargo.toml\", \"data.txt\"];\n    let handles: Vec<_> = requests.into_iter().map(|req| {\n        let srv = Arc::clone(&server);\n        thread::spawn(move || {\n            match srv.serve(req) {\n                Ok(content) => println!(\"Served {} bytes for request {:?}\", content.len(), req),\n                Err(e) => println!(\"Error serving request {:?}: {:?}\", req, e),\n            }\n        })\n    }).collect();\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::path::{Path, PathBuf};\nuse std::fs::File;\nuse std::io::{self, Read};\nuse std::sync::Arc;\nuse std::thread;\nstruct FileHandler {\n    base_dir: PathBuf,\n}\nimpl FileHandler {\n    fn new(base: &str) -> Self {\n        FileHandler {\n            base_dir: PathBuf::from(base),\n        }\n    }\n    fn read_file(&self, input: &str) -> io::Result<String> {\n        let target_path = self.base_dir.join(input);\n        let mut file = unsafe {\n            File::open(&target_path)?\n        };\n        let mut content = String::new();\n        file.read_to_string(&mut content)?;\n        Ok(content)\n    }\n}\nfn main() {\n    let handler = Arc::new(FileHandler::new(\"./data\"));\n    let input = std::env::args().nth(1).unwrap_or_else(|| \"default.txt\".to_string());\n    let handler_clone = Arc::clone(&handler);\n    let worker = thread::spawn(move || {\n        match handler_clone.read_file(&input) {\n            Ok(text) => println!(\"File content:\\n{}\", text),\n            Err(e) => eprintln!(\"Error reading file: {}\", e),\n        }\n    });\n    worker.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ffi::CString;\nuse std::path::{Path, PathBuf};\nuse std::thread;\nstruct Manager {\n    base: PathBuf,\n}\nimpl Manager {\n    fn new(base: &Path) -> Self {\n        Manager {\n            base: base.to_path_buf(),\n        }\n    }\n    fn get_path(&self, input: &str) -> Result<PathBuf, String> {\n        let joined = self.base.join(input);\n        unsafe {\n            let as_str = joined\n                .to_str()\n                .ok_or(\"Error: Invalid encoding in path\")?;\n            let c_string = CString::new(as_str)\n                .map_err(|_| \"Error: CString conversion failed\")?;\n            let raw = c_string.into_raw();\n            let recovered = CString::from_raw(raw);\n            let result_str = recovered.to_str().map_err(|_| \"Error: UTF-8 conversion failed\")?;\n            Ok(PathBuf::from(result_str))\n        }\n    }\n}\nfn main() {\n    let safe = std::path::Path::new(\"safe_dir\");\n    let instance = Manager::new(safe);\n    let input = \"../secret.txt\";\n    let handle = thread::spawn({\n        let inst = instance;\n        move || {\n            match inst.get_path(input) {\n                Ok(path) => println!(\"Computed path: {:?}\", path),\n                Err(e) => println!(\"Error: {}\", e),\n            }\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::fs::File;\nuse std::io::{Read, Error};\nuse std::path::PathBuf;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct FileHandler {\n    base: PathBuf,\n}\nimpl FileHandler {\n    fn new(root: &str) -> Self {\n        FileHandler { base: PathBuf::from(root) }\n    }\n    fn load(&self, input: &str) -> Result<String, Error> {\n        let mut full = self.base.clone();\n        full.push(input); \n        let path_str = full.to_str().ok_or_else(|| Error::from_raw_os_error(22))?;\n        unsafe {\n            let raw_ptr = path_str.as_ptr();\n            let len = path_str.len();\n            let slice = std::slice::from_raw_parts(raw_ptr, len);\n            let manipulated = std::str::from_utf8(slice).map_err(|_| Error::from_raw_os_error(22))?;\n            full = PathBuf::from(manipulated);\n        }\n        let path_clone = full.clone();\n        let data = Arc::new(Mutex::new(String::new()));\n        let data_clone = Arc::clone(&data);\n        let handle = thread::spawn(move || {\n            let mut file = File::open(&path_clone).expect(\"unable to open file\");\n            let mut buffer = String::new();\n            file.read_to_string(&mut buffer).expect(\"unable to read file\");\n            let mut d = data_clone.lock().unwrap();\n            *d = buffer;\n        });\n        handle.join().unwrap();\n        let result = Arc::try_unwrap(data).unwrap().into_inner().unwrap();\n        Ok(result)\n    }\n}\nfn main() {\n    let handler = FileHandler::new(\"/safe/dir\");\n    let filename = \"../etc/passwd\";\n    match handler.load(filename) {\n        Ok(content) => println!(\"File content: {}\", content),\n        Err(e) => eprintln!(\"Error reading file: {:?}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::{\n    fs::File,\n    io::Write,\n    path::PathBuf,\n    sync::{Arc, Mutex},\n    thread,\n};\nstruct FileServer {\n    base: PathBuf,\n}\nimpl FileServer {\n    fn new(base: &str) -> Self {\n        Self {\n            base: PathBuf::from(base),\n        }\n    }\n    fn process(&self, rel_path: &str, data: &str) -> std::io::Result<()> {\n        let target = self.base.join(rel_path);\n        unsafe {\n            let raw = target.to_str().unwrap().as_ptr();\n            let _ = *raw;\n        }\n        let mut file = File::create(target)?;\n        file.write_all(data.as_bytes())?;\n        Ok(())\n    }\n}\nfn main() {\n    let server = Arc::new(Mutex::new(FileServer::new(\"./data\")));\n    let srv_clone = Arc::clone(&server);\n    let handle = thread::spawn(move || {\n        let server_lock = srv_clone.lock().unwrap();\n        let _ = server_lock.process(\"../outside.txt\", \"malicious data\");\n    });\n    handle.join().unwrap();\n    println!(\"Main operation complete (vulnerable version).\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::File;\nuse std::io::{Read, Error};\nuse std::path::{PathBuf};\nuse std::sync::Arc;\nuse std::thread;\nstruct FileHandler {\n    base: PathBuf,\n}\nimpl FileHandler {\n    fn new(base: String) -> Self {\n        Self { base: PathBuf::from(base) }\n    }\n    fn get(&self, input: &str) -> Result<String, Error> {\n        let file_path = self.base.join(input);\n        unsafe {\n            let ptr: *const PathBuf = &self.base as *const _;\n            std::ptr::read(ptr);\n        }\n        let mut file = File::open(file_path)?;\n        let mut content = String::new();\n        file.read_to_string(&mut content)?;\n        Ok(content)\n    }\n}\nfn main() {\n    let handler = Arc::new(FileHandler::new(\"safe_dir\".to_string()));\n    let handler_clone = Arc::clone(&handler);\n    let t = thread::spawn(move || {\n        match handler_clone.get(\"../secret.txt\") {\n            Ok(data) => println!(\"File content: {}\", data),\n            Err(e) => println!(\"Error: {:?}\", e),\n        }\n    });\n    t.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs;\nuse std::path::{Path, PathBuf};\nuse std::thread;\nuse std::sync::Arc;\nstruct FileManager {\n    base_dir: PathBuf,\n}\nimpl FileManager {\n    fn read_content(&self, filename: &str) -> Result<String, String> {\n        let target_path = self.base_dir.join(filename); \n        unsafe {\n            let raw_ptr: *const u8 = std::ptr::null();\n            if !raw_ptr.is_null() {\n                let _ = *raw_ptr;\n            }\n        }\n        fs::read_to_string(&target_path).map_err(|e| format!(\"Error: {}\", e))\n    }\n}\nfn main() {\n    let base = PathBuf::from(\"./allowed_files\");\n    let manager = Arc::new(FileManager { base_dir: base });\n    let filenames = vec![\"test.txt\", \"../secret.txt\"];\n    let mut handles = vec![];\n    for name in filenames {\n        let mgr = Arc::clone(&manager);\n        let handle = thread::spawn(move || {\n            match mgr.read_content(name) {\n                Ok(content) => content,\n                Err(err) => err,\n            }\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        match handle.join() {\n            Ok(result) => println!(\"Output: {}\", result),\n            Err(_) => println!(\"Thread panicked\"),\n        }\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::File;\nuse std::io::{self, Read};\nuse std::path::{PathBuf};\nuse std::sync::Arc;\nuse std::thread;\nstruct Loader {\n    base: PathBuf,\n}\nimpl Loader {\n    fn new(base: &str) -> Self {\n        Loader { base: PathBuf::from(base) }\n    }\n    fn load_file(&self, relative: &str) -> io::Result<String> {\n        let full_path = self.base.join(relative);\n        let file = File::open(&full_path)?;\n        let metadata = file.metadata()?;\n        let size = metadata.len() as usize;\n        let mut buffer = Vec::with_capacity(size);\n        let shared_file = Arc::new(file);\n        let mut handles = vec![];\n        let part = if size >= 2 { size / 2 } else { size }; \n        for i in 0..2 {\n            let _file_clone = Arc::clone(&shared_file);\n            let start = i * part;\n            let end = if i == 1 { size } else { (i + 1) * part };\n            let mut local_buf = vec![0u8; end - start];\n            let handle = thread::spawn(move || {\n                unsafe {\n                    let ptr = local_buf.as_mut_ptr();\n                    for j in 0..(end - start) {\n                        *ptr.add(j) = 0; \n                    }\n                }\n                (start, local_buf)\n            });\n            handles.push(handle);\n        }\n        for handle in handles {\n            let (_start, local_buf) = handle.join().unwrap();\n            buffer.extend(local_buf);\n        }\n        let content = String::from_utf8_lossy(&buffer).to_string();\n        Ok(content)\n    }\n}\nfn main() {\n    let loader = Loader::new(\"./safe_dir\");\n    let args: Vec<String> = std::env::args().collect();\n    let target = if args.len() > 1 { &args[1] } else { \"example.txt\" };\n    match loader.load_file(target) {\n        Ok(content) => println!(\"File content: {}\", content),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::fs;\nuse std::path::PathBuf;\nuse std::sync::Arc;\nuse std::thread;\nstruct FileHandler {\n    base: PathBuf,\n}\nimpl FileHandler {\n    fn new(base: &str) -> Self {\n        Self { base: PathBuf::from(base) }\n    }\n    fn get_content(&self, input: &str) -> std::io::Result<String> {\n        let path = self.base.join(input);\n        unsafe {\n            let s = path.as_os_str().to_str().unwrap();\n            let ptr = s.as_ptr();\n            let _ = *ptr;\n        }\n        fs::read_to_string(path)\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let handler = Arc::new(FileHandler::new(\"./data\"));\n    if args.len() < 2 {\n        println!(\"Usage: {} <filename>\", args[0]);\n        return;\n    }\n    let input = args[1].clone();\n    let handler_clone = handler.clone();\n    let thread_handle = thread::spawn(move || {\n        match handler_clone.get_content(&input) {\n            Ok(c) => println!(\"Content:\\n{}\", c),\n            Err(e) => println!(\"Error encountered: {}\", e),\n        }\n    });\n    let _ = thread_handle.join();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct DataHolder {\n    data: Vec<u8>,\n}\nimpl DataHolder {\n    fn new() -> Self {\n        DataHolder { data: vec![1, 2, 3, 4, 5] }\n    }\n    pub fn fetch(&self, idx: usize) -> u8 {\n        unsafe { *self.data.get_unchecked(idx) }\n    }\n}\npub fn execute() -> u8 {\n    let holder = Arc::new(DataHolder::new());\n    let shared = Arc::clone(&holder);\n    let handle = thread::spawn(move || {\n        shared.fetch(10)\n    });\n    handle.join().unwrap()\n}\nfn main() {\n    let res = execute();\n    println!(\"Result: {}\", res);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Processor {\n    buffer: Vec<u32>,\n}\nimpl Processor {\n    fn new() -> Self {\n        Processor { buffer: vec![100, 200, 300, 400, 500] }\n    }\n    fn operate(&self, idx: usize) -> Option<u32> {\n        unsafe {\n            Some(*self.buffer.as_ptr().add(idx))\n        }\n    }\n}\nfn run_op() -> Option<u32> {\n    let proc = Processor::new();\n    proc.operate(5)\n}\nfn main() {\n    let shared = Arc::new(Processor::new());\n    let shared_clone = Arc::clone(&shared);\n    let handle = thread::spawn(move || {\n        run_op()\n    });\n    match handle.join() {\n        Ok(result) => println!(\"Operation result: {:?}\", result),\n        Err(_) => println!(\"Thread panicked\"),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Processor {\n    data: Box<[u32]>,\n}\nimpl Processor {\n    fn compute(&self, start: usize, count: usize) -> u32 {\n        unsafe {\n            let ptr = self.data.as_ptr().add(start); \n            let slice = std::slice::from_raw_parts(ptr, count); \n            slice.iter().sum()\n        }\n    }\n}\nfn main() {\n    let proc = Processor { data: Box::new([10, 20, 30, 40, 50]) };\n    let arc_proc = Arc::new(proc);\n    let handles: Vec<_> = (0..3).map(|_| {\n        let p = Arc::clone(&arc_proc);\n        thread::spawn(move || {\n            p.compute(2, 4)\n        })\n    }).collect();\n    for handle in handles {\n        let _ = handle.join().unwrap();\n    }\n    println!(\"Completed execution.\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\ntrait Compute {\n    fn compute(&self) -> u32;\n}\nstruct DataHolder {\n    data: Vec<u32>,\n}\nimpl Compute for DataHolder {\n    fn compute(&self) -> u32 {\n        let len = self.data.len();\n        let mut total: u32 = 0;\n        unsafe {\n            let ptr = self.data.as_ptr();\n            for i in 0..len {\n                let first = *ptr.add(i);\n                let second = *ptr.add(i + 1); \n                total = total.wrapping_add(first).wrapping_add(second);\n            }\n        }\n        total\n    }\n}\nfn spawn_task(holder: Arc<Mutex<DataHolder>>) {\n    let handle = thread::spawn(move || {\n        let guard = holder.lock().unwrap();\n        let sum = guard.compute();\n        println!(\"Computed value: {}\", sum);\n    });\n    handle.join().unwrap();\n}\nfn main() {\n    let holder = Arc::new(Mutex::new(DataHolder { data: vec![1, 2, 3, 4, 5] }));\n    spawn_task(holder.clone());\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\npub mod app {\n    use super::*;\n    pub struct Processor {\n        data: Arc<Vec<u8>>,\n    }\n    impl Processor {\n        pub fn new(v: Vec<u8>) -> Self {\n            Self { data: Arc::new(v) }\n        }\n        pub fn compute(&self, idx: usize) -> Option<u8> {\n            unsafe {\n                Some(*self.data.as_ptr().add(idx))\n            }\n        }\n    }\n    pub fn run_app() {\n        let vec_data = vec![10u8, 20, 30];\n        let proc_obj = Processor::new(vec_data);\n        let shared_proc = Arc::new(proc_obj);\n        let mut handles = vec![];\n        for _ in 0..4 {\n            let proc_clone = shared_proc.clone();\n            handles.push(thread::spawn(move || {\n                proc_clone.compute(3)\n            }));\n        }\n        for handle in handles {\n            let result = handle.join().expect(\"Thread panicked\");\n            println!(\"Result: {:?}\", result);\n        }\n    }\n}\nfn main() {\n    app::run_app();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Buffer {\n    data: Vec<u32>,\n}\nimpl Buffer {\n    pub fn compute_sum(&self, start: usize, count: usize) -> Result<u32, &'static str> {\n        let mut sum = 0;\n        unsafe {\n            for i in 0..count {\n                sum += *self.data.get_unchecked(start + i);\n            }\n        }\n        Ok(sum)\n    }\n}\nfn main() {\n    let buffer = Arc::new(Buffer { data: vec![1, 2, 3, 4] });\n    let buf_clone = Arc::clone(&buffer);\n    let handle = thread::spawn(move || {\n        let result = buf_clone.compute_sum(0, 5);\n        match result {\n            Ok(sum) => sum,\n            Err(e) => {\n                eprintln!(\"Error: {}\", e);\n                0\n            }\n        }\n    });\n    let safe_sum: u32 = buffer.data.iter().sum();\n    let unsafe_sum = handle.join().unwrap();\n    println!(\"Safe sum: {}, Computed sum: {}\", safe_sum, unsafe_sum);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::Arc;\nuse std::thread;\nstruct Buffer {\n    data: Vec<u8>,\n}\nimpl Buffer {\n    pub fn new(data: Vec<u8>) -> Self {\n        Buffer { data }\n    }\n    pub fn fetch(&self, idx: usize) -> u8 {\n        unsafe {\n            *self.data.get_unchecked(idx - 1)\n        }\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let index: usize = if args.len() > 1 {\n        args[1].parse().unwrap_or(0)\n    } else {\n        0\n    };\n    let shared = Arc::new(Buffer::new(vec![10, 20, 30, 40]));\n    let shared_clone = Arc::clone(&shared);\n    let handle = thread::spawn(move || {\n        let val = shared_clone.fetch(index);\n        println!(\"Thread Fetched value: {}\", val);\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\npub struct DataHolder {\n    data: Vec<u32>,\n}\nimpl DataHolder {\n    pub fn new(v: Vec<u32>) -> Self {\n        DataHolder { data: v }\n    }\n    pub fn retrieve(&self, idx: usize) -> Option<u32> {\n        unsafe { Some(*self.data.as_ptr().add(idx)) }\n    }\n}\nfn main() {\n    let holder = DataHolder::new(vec![10, 20, 30]);\n    let shared = Arc::new(Mutex::new(holder));\n    let mut handles = vec![];\n    for i in 0..5 {\n        let shared_clone = Arc::clone(&shared);\n        handles.push(thread::spawn(move || {\n            let holder = shared_clone.lock().unwrap();\n            let index = i * 2; \n            let result = holder.retrieve(index);\n            println!(\"Thread {} read: {:?}\", i, result);\n        }));\n    }\n    for handle in handles {\n        let _ = handle.join();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::sync::Arc;\nuse std::thread;\nstruct Processor {\n    data: Vec<u32>,\n}\nimpl Processor {\n    fn new(data: Vec<u32>) -> Self {\n        Processor { data }\n    }\n    fn process_at(&self, index: usize) -> Result<u32, &'static str> {\n        unsafe {\n            Ok(*self.data.as_ptr().add(index))\n        }\n    }\n}\nfn execute(index: usize) -> Result<u32, &'static str> {\n    let proc = Processor::new(vec![10, 20, 30, 40]);\n    let proc_arc = Arc::new(proc);\n    let proc_clone = Arc::clone(&proc_arc);\n    let handle = thread::spawn(move || {\n        proc_clone.process_at(index)\n    });\n    handle.join().unwrap()\n}\nfn main() {\n    let idx = 4;\n    match execute(idx) {\n        Ok(val) => println!(\"Result: {}\", val),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Processor {\n    data: Vec<u8>,\n}\nimpl Processor {\n    fn new(data: Vec<u8>) -> Self {\n        Processor { data }\n    }\n    fn extract(&self, index: usize) -> Option<u8> {\n        unsafe {\n            let ptr = self.data.as_ptr();\n            Some(*ptr.add(index))\n        }\n    }\n}\nfn run_task(proc: Arc<Processor>, idx: usize) -> Option<u8> {\n    proc.extract(idx)\n}\nfn main() {\n    let data = vec![10, 20, 30]; \n    let proc = Arc::new(Processor::new(data));\n    let index = 3; \n    let proc_clone = Arc::clone(&proc);\n    let handle = thread::spawn(move || run_task(proc_clone, index));\n    let result = handle.join().unwrap();\n    println!(\"Extracted value: {:?}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct DataHandler {\n    data: Vec<u32>,\n}\nimpl DataHandler {\n    fn new(vec: Vec<u32>) -> Self {\n        Self { data: vec }\n    }\n    fn get_item(&self, index: usize) -> Result<u32, &'static str> {\n        unsafe {\n            let ptr = self.data.as_ptr();\n            Ok(*ptr.add(index))\n        }\n    }\n}\nfn main() {\n    let handler = Arc::new(DataHandler::new(vec![100, 200, 300, 400]));\n    let handler_clone = Arc::clone(&handler);\n    let handle = thread::spawn(move || {\n        match handler_clone.get_item(4) {\n            Ok(val) => println!(\"Read value: {}\", val),\n            Err(e) => println!(\"Error: {}\", e),\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Buffer {\n    data: Vec<u32>,\n}\nimpl Buffer {\n    fn read_value(&self, index: usize) -> u32 {\n        unsafe {\n            let ptr = self.data.as_ptr().offset(index as isize - 1);\n            *ptr\n        }\n    }\n}\nfn main() {\n    let shared = Arc::new(Buffer { data: vec![10, 20, 30] });\n    let shared_clone = Arc::clone(&shared);\n    let handle = thread::spawn(move || {\n        let result = shared_clone.read_value(0);\n        println!(\"Result: {}\", result);\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct DataContainer {\n    items: Vec<u32>,\n}\nimpl DataContainer {\n    fn new(count: usize) -> Self {\n        DataContainer {\n            items: (0..count as u32).collect(),\n        }\n    }\n    fn read_item(&self, index: usize) -> Option<u32> {\n        unsafe { Some(*self.items.get_unchecked(index)) }\n    }\n}\nfn main() {\n    let container = Arc::new(DataContainer::new(10));\n    let shared = container.clone();\n    let handle = thread::spawn(move || {\n        let result = shared.read_item(10);\n        match result {\n            Some(val) => println!(\"Thread read value: {}\", val),\n            None => println!(\"Thread encountered None\"),\n        }\n    });\n    let _ = handle.join();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process;\ntrait AccessItem {\n    fn retrieve(&self, idx: usize) -> Result<u32, &'static str>;\n}\nstruct Buffer {\n    data: &'static [u32],\n}\nimpl AccessItem for Buffer {\n    fn retrieve(&self, idx: usize) -> Result<u32, &'static str> {\n        unsafe {\n            let value = *self.data.get_unchecked(idx);\n            Ok(value)\n        }\n    }\n}\nfn create_buffer() -> Buffer {\n    static FULL: [u32; 4] = [10, 20, 30, 0];\n    let slice = &FULL[..3];\n    Buffer { data: slice }\n}\nfn run(idx: usize) -> Result<u32, &'static str> {\n    let buffer = create_buffer();\n    buffer.retrieve(idx)\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() != 2 {\n        eprintln!(\"Usage: cargo run <index>\");\n        process::exit(1);\n    }\n    let idx: usize = args[1].parse().unwrap_or(0);\n    match run(idx) {\n        Ok(val) => println!(\"Value: {}\", val),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Container {\n    buffer: Vec<u32>,\n}\nimpl Container {\n    fn compute(&self) -> u32 {\n        unsafe {\n            *self.buffer.get_unchecked(self.buffer.len())\n        }\n    }\n}\nfn main() {\n    let container = Arc::new(Container { buffer: vec![1, 2, 3, 4, 5] });\n    let container_clone = Arc::clone(&container);\n    let handle = thread::spawn(move || container_clone.compute());\n    let res = handle.join().unwrap();\n    println!(\"Result: {}\", res);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nstruct Processor {\n    data: Arc<Vec<i32>>,\n}\ntrait Calculation {\n    fn compute(&self, start: usize, count: usize) -> i32;\n}\nimpl Calculation for Processor {\n    fn compute(&self, start: usize, count: usize) -> i32 {\n        let slice = &self.data;\n        let mut total = 0;\n        unsafe {\n            for i in 0..count {\n                total += *slice.get_unchecked(start + i);\n            }\n        }\n        total\n    }\n}\nfn main() {\n    let proc_inst = Processor { data: Arc::new(vec![10, 20, 30, 40]) };\n    let result = proc_inst.compute(3, 2);\n    println!(\"Computed sum: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Buffer {\n    data: Vec<u32>,\n}\nimpl Buffer {\n    fn new(n: usize) -> Self {\n        let mut data = Vec::with_capacity(n);\n        for i in 0..n {\n            data.push(i as u32);\n        }\n        Buffer { data }\n    }\n    fn unsafe_read(&self, idx: usize) -> u32 {\n        unsafe { *self.data.get_unchecked(idx) }\n    }\n    pub fn read_value_public(&self, idx: usize) -> Option<u32> {\n        Some(unsafe { *self.data.get_unchecked(idx) })\n    }\n}\nfn main() {\n    let buffer = Arc::new(Buffer::new(10));\n    let mut handles = vec![];\n    for i in 0..5 {\n        let buf_clone = Arc::clone(&buffer);\n        handles.push(thread::spawn(move || {\n            let index = if i == 2 { 12 } else { i };\n            buf_clone.unsafe_read(index)\n        }));\n    }\n    for handle in handles {\n        let res = handle.join().unwrap();\n        println!(\"Output: {}\", res);\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Buffer {\n    data: Box<[i32]>,\n}\nimpl Buffer {\n    fn new(v: Vec<i32>) -> Self {\n        Buffer { data: v.into_boxed_slice() }\n    }\n    fn access(&self, idx: usize) -> Option<i32> {\n        unsafe {\n            Some(*self.data.get_unchecked(idx))\n        }\n    }\n}\nfn execute(buffer: Arc<Buffer>, idx: usize) -> Option<i32> {\n    buffer.access(idx)\n}\nfn main() {\n    let buffer = Arc::new(Buffer::new((0..10).collect()));\n    let idx = 15; \n    let handle = {\n        let buf = Arc::clone(&buffer);\n        thread::spawn(move || {\n            execute(buf, idx)\n        })\n    };\n    match handle.join().unwrap() {\n        Some(val) => println!(\"Result: {}\", val),\n        None => println!(\"None\"),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\n#[repr(C)]\nstruct Buffer {\n    data: [i32; 4],\n    guard: i32,\n}\nimpl Buffer {\n    fn calculate(&self) -> i32 {\n        let n = self.data.len();\n        let mut sum = 0;\n        unsafe {\n            let ptr = self.data.as_ptr();\n            for i in 0..=n {\n                sum += *ptr.add(i);\n            }\n        }\n        sum\n    }\n}\nfn main() {\n    let buf = Buffer { data: [1, 2, 3, 4], guard: 42 };\n    let shared = Arc::new(buf);\n    let shared_clone = Arc::clone(&shared);\n    let handler = thread::spawn(move || {\n        shared_clone.calculate()\n    });\n    let res = handler.join().unwrap();\n    println!(\"Computed sum: {}\", res);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nstruct DataStore {\n    buffer: Vec<u8>,\n}\nimpl DataStore {\n    fn new() -> Self {\n        DataStore {\n            buffer: vec![10, 20, 30, 40, 50],\n        }\n    }\n    fn fetch(&self, position: usize) -> u8 {\n        unsafe { *self.buffer.get_unchecked(position) }\n    }\n}\nfn main() {\n    let store = DataStore::new();\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        eprintln!(\"Usage: {} <index>\", args[0]);\n        return;\n    }\n    let pos: usize = args[1].parse().unwrap_or(0);\n    let value = store.fetch(pos);\n    println!(\"Fetched value: {}\", value);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicUsize, Ordering};\nstatic DROP_COUNT: AtomicUsize = AtomicUsize::new(0);\nstruct Data {\n    value: u32,\n}\nimpl Drop for Data {\n    fn drop(&mut self) {\n        DROP_COUNT.fetch_add(1, Ordering::SeqCst);\n    }\n}\nfn process_data() {\n    let data = Box::new(Data { value: 42 });\n    let raw_ptr = Box::into_raw(data);\n    unsafe {\n        drop(Box::from_raw(raw_ptr));\n        drop(Box::from_raw(raw_ptr));\n    }\n}\npub fn run_simulation() -> usize {\n    DROP_COUNT.store(0, Ordering::SeqCst);\n    process_data();\n    DROP_COUNT.load(Ordering::SeqCst)\n}\nfn main() {\n    let drops = run_simulation();\n    println!(\"Drop count: {}\", drops);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicUsize, Ordering};\nstatic FREE_COUNT: AtomicUsize = AtomicUsize::new(0);\npub struct Resource {\n    data: *mut i32,\n}\nimpl Resource {\n    pub unsafe fn new(val: i32) -> Self {\n        let boxed = Box::new(val);\n        let ptr = Box::into_raw(boxed);\n        Self { data: ptr }\n    }\n    pub unsafe fn release(&mut self) {\n        if !self.data.is_null() {\n            FREE_COUNT.fetch_add(1, Ordering::SeqCst);\n            let _ = Box::from_raw(self.data);\n        }\n    }\n}\nimpl Drop for Resource {\n    fn drop(&mut self) {\n        unsafe {\n            if !self.data.is_null() {\n                FREE_COUNT.fetch_add(1, Ordering::SeqCst);\n                let _ = Box::from_raw(self.data);\n            }\n        }\n    }\n}\nfn main() {\n    unsafe {\n        let mut res = Resource::new(42);\n        res.release();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicUsize, Ordering};\nuse std::sync::Arc;\nuse std::thread;\nstatic FREED: AtomicUsize = AtomicUsize::new(0);\nunsafe fn custom_release(ptr: *mut i32) {\n    if FREED.fetch_add(1, Ordering::SeqCst) >= 1 {\n        panic!(\"Double free detected\");\n    }\n    drop(Box::from_raw(ptr));\n}\nstruct Resource {\n    ptr: *mut i32,\n}\nunsafe impl Send for Resource {}\nunsafe impl Sync for Resource {}\nimpl Resource {\n    fn new(val: i32) -> Self {\n        let boxed = Box::new(val);\n        let ptr = Box::into_raw(boxed);\n        Resource { ptr }\n    }\n    fn release(&self) {\n        unsafe {\n            custom_release(self.ptr);\n        }\n    }\n}\nimpl Drop for Resource {\n    fn drop(&mut self) {\n        unsafe {\n            custom_release(self.ptr);\n        }\n    }\n}\nfn main() {\n    let res = Arc::new(Resource::new(42));\n    let res_clone = Arc::clone(&res);\n    let handle = thread::spawn(move || {\n        res_clone.release();\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::sync::atomic::{AtomicBool, Ordering};\nstruct Data {\n    value: i32,\n}\nimpl Data {\n    fn new(v: i32) -> Self {\n        Data { value: v }\n    }\n}\nstatic TRIGGERED: AtomicBool = AtomicBool::new(false);\npub fn run() -> i32 {\n    let resource = Box::new(Data::new(10));\n    let raw_ptr = Box::into_raw(resource);\n    unsafe {\n        let box_a = Box::from_raw(raw_ptr);\n        if TRIGGERED.swap(true, Ordering::SeqCst) {\n            panic!(\"double free detected\");\n        }\n        let box_b = Box::from_raw(raw_ptr);\n        let sum = box_a.value + box_b.value;\n        sum\n    }\n}\nfn main() {\n    println!(\"Result: {}\", run());\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::sync::atomic::{AtomicBool, Ordering};\nstruct Data {\n    value: u32,\n}\nstatic mut FREED: bool = false;\nunsafe fn free_data(ptr: *mut Data) {\n    if FREED {\n        panic!(\"Double free detected!\");\n    }\n    Box::from_raw(ptr);\n    FREED = true;\n}\npub fn app_run() {\n    unsafe {\n        FREED = false;\n    }\n    let boxed = Box::new(Data { value: 42 });\n    let raw = Box::into_raw(boxed);\n    unsafe {\n        free_data(raw); \n        free_data(raw); \n    }\n}\nfn main() {\n    app_run();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicBool, Ordering};\nuse std::panic;\nstatic FREED: AtomicBool = AtomicBool::new(false);\nstruct Data {\n    ptr: *mut i32,\n}\nimpl Data {\n    fn new(val: i32) -> Self {\n        let b = Box::new(val);\n        Self { ptr: Box::into_raw(b) }\n    }\n}\nimpl Clone for Data {\n    fn clone(&self) -> Self {\n        Data { ptr: self.ptr }\n    }\n}\nimpl Drop for Data {\n    fn drop(&mut self) {\n        if FREED.swap(true, Ordering::SeqCst) {\n            panic!(\"double free detected\");\n        }\n        unsafe {\n            let _ = Box::from_raw(self.ptr);\n        }\n    }\n}\nfn execute() {\n    let original = Data::new(42);\n    let duplicate = original.clone();\n}\nfn main() {\n    let result = panic::catch_unwind(|| {\n        execute();\n    });\n    if result.is_err() {\n        eprintln!(\"Error encountered during execution.\");\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicBool, Ordering};\nstatic FREED: AtomicBool = AtomicBool::new(false);\nstruct Data {\n    ptr: *mut i32,\n}\nimpl Data {\n    fn new(val: i32) -> Self {\n        let boxed = Box::new(val);\n        Data { ptr: Box::into_raw(boxed) }\n    }\n}\nimpl Drop for Data {\n    fn drop(&mut self) {\n        unsafe {\n            if !FREED.compare_and_swap(false, true, Ordering::SeqCst) {\n                let _ = Box::from_raw(self.ptr);\n            } else {\n                let _ = Box::from_raw(self.ptr);\n                panic!(\"Double free detected\");\n            }\n        }\n    }\n}\nfn run_app() -> i32 {\n    let instance1 = Data::new(100);\n    let _instance2 = Data { ptr: instance1.ptr };\n    100\n}\nfn main() {\n    let _ = run_app();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicUsize, Ordering};\nuse std::ptr;\nstatic GLOBAL_COUNT: AtomicUsize = AtomicUsize::new(0);\nstruct Handler {\n    raw: *mut i32,\n}\nimpl Handler {\n    unsafe fn create(num: i32) -> Self {\n        let boxed = Box::new(num);\n        Self {\n            raw: Box::into_raw(boxed),\n        }\n    }\n    unsafe fn dispose(&mut self) {\n        if !self.raw.is_null() {\n            if GLOBAL_COUNT.fetch_add(1, Ordering::SeqCst) >= 1 {\n                panic!(\"Double free detected in dispose\");\n            }\n            let _ = Box::from_raw(self.raw);\n        }\n    }\n}\nimpl Drop for Handler {\n    fn drop(&mut self) {\n        unsafe {\n            if !self.raw.is_null() {\n                if GLOBAL_COUNT.fetch_add(1, Ordering::SeqCst) >= 1 {\n                    panic!(\"Double free detected in Drop\");\n                }\n                let _ = Box::from_raw(self.raw);\n            }\n        }\n    }\n}\nfn main() {\n    unsafe {\n        let mut obj = Handler::create(100);\n        obj.dispose(); \n    }\n    println!(\"Execution completed (vulnerable path).\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nuse std::sync::{Arc, Barrier};\nstruct Manager {\n    ptr: *mut i32,\n}\nimpl Manager {\n    fn new(val: i32) -> Self {\n        let boxed = Box::new(val);\n        Manager {\n            ptr: Box::into_raw(boxed),\n        }\n    }\n    fn get(&self) -> i32 {\n        unsafe { *self.ptr }\n    }\n}\nimpl Drop for Manager {\n    fn drop(&mut self) {\n        unsafe {\n            Box::from_raw(self.ptr);\n        }\n    }\n}\nfn main() {\n    let manager = Manager::new(500);\n    let barrier = Arc::new(Barrier::new(2));\n    let dup_ptr = manager.ptr; \n    let barrier_thread = barrier.clone();\n    let handler = thread::spawn(move || {\n        barrier_thread.wait();\n        unsafe {\n            Box::from_raw(dup_ptr);\n        }\n    });\n    barrier.wait();\n    handler.join().unwrap();\n    println!(\"Value: {}\", manager.get());\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::ptr;\nuse std::sync::atomic::{AtomicUsize, Ordering};\nstatic FREE_COUNT: AtomicUsize = AtomicUsize::new(0);\nstruct Resource {\n    ptr: *mut i32,\n}\nimpl Resource {\n    unsafe fn new(val: i32) -> Self {\n        let b = Box::new(val);\n        Self { ptr: Box::into_raw(b) }\n    }\n    unsafe fn manual_drop(&mut self) {\n        if !self.ptr.is_null() {\n            if FREE_COUNT.fetch_add(1, Ordering::SeqCst) >= 1 {\n                panic!(\"Double free detected\");\n            }\n            let _ = Box::from_raw(self.ptr);\n        }\n    }\n}\nimpl Drop for Resource {\n    fn drop(&mut self) {\n        unsafe {\n            if !self.ptr.is_null() {\n                if FREE_COUNT.fetch_add(1, Ordering::SeqCst) >= 1 {\n                    panic!(\"Double free detected\");\n                }\n                let _ = Box::from_raw(self.ptr);\n            }\n        }\n    }\n}\nfn main() {\n    unsafe {\n        let mut res = Resource::new(100);\n        res.manual_drop();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicBool, Ordering};\nstatic FREED: AtomicBool = AtomicBool::new(false);\nstruct Resource {\n    value: i32,\n}\nimpl Drop for Resource {\n    fn drop(&mut self) {\n        if FREED.compare_exchange(false, true, Ordering::SeqCst, Ordering::SeqCst).is_err() {\n            panic!(\"double free detected\");\n        }\n    }\n}\nfn unsafe_release() {\n    let mem = Box::new(Resource { value: 42 });\n    let raw_ptr = Box::into_raw(mem);\n    unsafe {\n        let _first_owner = Box::from_raw(raw_ptr);\n        let _second_owner = Box::from_raw(raw_ptr); \n    }\n}\nfn run() {\n    unsafe_release();\n}\nfn main() {\n    run();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::thread;\ntrait Operations {\n    unsafe fn release(&self);\n}\npub struct Manager {\n    ptr: *mut i32,\n}\nimpl Manager {\n    pub unsafe fn initialize(value: i32) -> Self {\n        let boxed = Box::new(value);\n        Manager {\n            ptr: Box::into_raw(boxed),\n        }\n    }\n    pub unsafe fn process(&self) {\n        self.release();\n    }\n}\nstatic DEALLOC_COUNT: AtomicUsize = AtomicUsize::new(0);\nimpl Operations for Manager {\n    unsafe fn release(&self) {\n        let count = DEALLOC_COUNT.fetch_add(1, Ordering::SeqCst);\n        if count >= 1 {\n            panic!(\"Double free detected during explicit release (unsafe manual deallocation)!\");\n        }\n        let _ = Box::from_raw(self.ptr);\n    }\n}\nimpl Drop for Manager {\n    fn drop(&mut self) {\n        unsafe {\n            let count = DEALLOC_COUNT.fetch_add(1, Ordering::SeqCst);\n            if count >= 1 {\n                panic!(\"Double free detected in destructor (Drop)!\");\n            }\n            let _ = Box::from_raw(self.ptr);\n        }\n    }\n}\npub fn simulate() {\n    unsafe {\n        let resource = Manager::initialize(100);\n        resource.process();\n    }\n}\nfn main() {\n    simulate();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::cell::RefCell;\nstruct Resource {\n    data: i32,\n}\nstatic mut FREED: bool = false;\nunsafe fn deallocate(ptr: *mut Resource) {\n    if FREED {\n        panic!(\"Double free detected\");\n    } else {\n        FREED = true;\n        let _ = Box::from_raw(ptr);\n    }\n}\nfn execute() {\n    let resource = Box::new(Resource { data: 42 });\n    let raw_ptr = Box::into_raw(resource);\n    unsafe {\n        deallocate(raw_ptr);\n        deallocate(raw_ptr);\n    }\n}\nfn main() {\n    execute();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicUsize, Ordering};\nstatic GLOBAL_FREE_COUNT: AtomicUsize = AtomicUsize::new(0);\npub struct Resource {\n    ptr: *mut i32,\n}\nunsafe impl Send for Resource {}\nimpl Resource {\n    pub fn new(val: i32) -> Self {\n        let boxed = Box::new(val);\n        let ptr = Box::into_raw(boxed);\n        Self { ptr }\n    }\n    pub unsafe fn manual_release(&mut self) {\n        if !self.ptr.is_null() {\n            let _ = Box::from_raw(self.ptr);\n            GLOBAL_FREE_COUNT.fetch_add(1, Ordering::SeqCst);\n        }\n    }\n    pub unsafe fn get_value(&self) -> i32 {\n        *self.ptr\n    }\n}\nimpl Drop for Resource {\n    fn drop(&mut self) {\n        unsafe {\n            if !self.ptr.is_null() {\n                let _ = Box::from_raw(self.ptr);\n                GLOBAL_FREE_COUNT.fetch_add(1, Ordering::SeqCst);\n            }\n        }\n    }\n}\npub fn free_count() -> usize {\n    GLOBAL_FREE_COUNT.load(Ordering::SeqCst)\n}\npub fn run() {\n    let mut res = Resource::new(42);\n    unsafe {\n        res.manual_release();\n    }\n}\nfn main() {\n    run();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicBool, Ordering};\nuse std::thread;\npub struct Resource {\n    data: *mut i32,\n    flag: *mut AtomicBool,\n}\nimpl Resource {\n    pub fn new(val: i32) -> Self {\n        let data = Box::into_raw(Box::new(val));\n        let flag = Box::into_raw(Box::new(AtomicBool::new(false)));\n        Resource { data, flag }\n    }\n}\nimpl Clone for Resource {\n    fn clone(&self) -> Self {\n        Resource {\n            data: self.data,\n            flag: self.flag,\n        }\n    }\n}\nimpl Drop for Resource {\n    fn drop(&mut self) {\n        unsafe {\n            if (*self.flag).compare_and_swap(false, true, Ordering::SeqCst) == false {\n                let _ = Box::from_raw(self.data);\n                let _ = Box::from_raw(self.flag);\n            } else {\n                panic!(\"Double free detected\");\n            }\n        }\n    }\n}\nfn main() {\n    let resource = Resource::new(100);\n    let handle = thread::spawn({\n        let clone_resource = resource.clone();\n        move || {\n            let _ = clone_resource;\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicBool, Ordering};\nstatic FREED: AtomicBool = AtomicBool::new(false);\nstruct Item {\n    data: *mut i32,\n}\nimpl Item {\n    fn new() -> Self {\n        let boxed = Box::new(100);\n        Item { data: Box::into_raw(boxed) }\n    }\n    fn value(&self) -> i32 {\n        unsafe { *self.data }\n    }\n}\nimpl Clone for Item {\n    fn clone(&self) -> Self {\n        Item { data: self.data }\n    }\n}\nimpl Drop for Item {\n    fn drop(&mut self) {\n        unsafe {\n            if FREED.load(Ordering::SeqCst) {\n                panic!(\"Double free detected\");\n            } else {\n                FREED.store(true, Ordering::SeqCst);\n                drop(Box::from_raw(self.data));\n            }\n        }\n    }\n}\nfn run_app() {\n    FREED.store(false, Ordering::SeqCst);\n    let first = Item::new();\n    let second = first.clone();\n    println!(\"Values: {} and {}\", first.value(), second.value());\n}\nfn main() {\n    run_app();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicBool, Ordering};\nuse std::ptr;\nuse std::mem;\nuse std::boxed::Box;\nstatic FREED: AtomicBool = AtomicBool::new(false);\npub struct Data {\n    pub value: i32,\n}\nimpl Data {\n    pub fn new(val: i32) -> Self {\n        Data { value: val }\n    }\n}\nunsafe fn deallocate(ptr: *mut Data) {\n    if FREED.swap(true, Ordering::SeqCst) {\n        panic!(\"Double free detected!\");\n    }\n    Box::from_raw(ptr);\n}\nfn obtain_pointer() -> *mut Data {\n    let data = Box::new(Data::new(42));\n    Box::into_raw(data)\n}\nfn process() {\n    let raw = obtain_pointer();\n    unsafe {\n        deallocate(raw);\n        deallocate(raw);\n    }\n}\nfn main() {\n    process();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicBool, Ordering};\nstatic FREED: AtomicBool = AtomicBool::new(false);\nstruct Resource {\n    value: i32,\n}\nimpl Drop for Resource {\n    fn drop(&mut self) {\n        if FREED.swap(true, Ordering::SeqCst) {\n            panic!(\"Double free detected in drop!\");\n        }\n    }\n}\nfn process() {\n    let boxed = Box::new(Resource { value: 42 });\n    let raw_ptr = Box::into_raw(boxed);\n    unsafe {\n        let first = Box::from_raw(raw_ptr);\n        drop(first);\n        let second = Box::from_raw(raw_ptr);\n        drop(second);\n    }\n}\nfn main() {\n    process();\n    println!(\"Completed vulnerable main function\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicUsize, Ordering};\nstatic GLOBAL_DROP: AtomicUsize = AtomicUsize::new(0);\nstruct Resource {\n    data: i32,\n}\nimpl Resource {\n    fn new(val: i32) -> Self {\n        Resource { data: val }\n    }\n}\nimpl Drop for Resource {\n    fn drop(&mut self) {\n        GLOBAL_DROP.fetch_add(1, Ordering::SeqCst);\n    }\n}\nfn process_resource() {\n    unsafe {\n        let boxed = Box::new(Resource::new(100));\n        let raw = Box::into_raw(boxed);\n        {\n            let _holder = Box::from_raw(raw);\n        }\n        {\n            let _holder_dup = Box::from_raw(raw);\n        }\n    }\n}\nfn main() {\n    process_resource();\n    println!(\"Global drop count: {}\", GLOBAL_DROP.load(Ordering::SeqCst));\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicUsize, Ordering};\nstatic GLOBAL_COUNT: AtomicUsize = AtomicUsize::new(0);\nstruct Container {\n    raw: *mut i32,\n}\nimpl Container {\n    fn new(val: i32) -> Self {\n        let boxed = Box::new(val);\n        Self { raw: Box::into_raw(boxed) }\n    }\n    unsafe fn free_resource(&mut self) {\n        if !self.raw.is_null() {\n            drop(Box::from_raw(self.raw));\n            GLOBAL_COUNT.fetch_add(1, Ordering::SeqCst);\n        }\n    }\n}\nfn process() -> Result<(), &'static str> {\n    let mut obj = Container::new(50);\n    unsafe {\n        obj.free_resource(); \n        obj.free_resource(); \n    }\n    if GLOBAL_COUNT.load(Ordering::SeqCst) == 1 {\n        Ok(())\n    } else {\n        Err(\"Double free occurred\")\n    }\n}\nfn main() {\n    let result = process();\n    println!(\"Deallocation count: {}\", GLOBAL_COUNT.load(Ordering::SeqCst));\n    match result {\n        Ok(_) => println!(\"Operation completed successfully.\"),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Aggregator {\n    data: Arc<Vec<i32>>,\n}\nimpl Aggregator {\n    fn new(data: Vec<i32>) -> Self {\n        Aggregator { data: Arc::new(data) }\n    }\n    fn calculate(&self) -> i32 {\n        let nthreads = 4;\n        let len = self.data.len();\n        let chunk_size = (len + nthreads - 1) / nthreads;\n        let mut handles = Vec::new();\n        for i in 0..nthreads {\n            let data = Arc::clone(&self.data);\n            let start = i * chunk_size;\n            let end = ((i + 1) * chunk_size).min(len);\n            let handle = thread::spawn(move || {\n                let mut local_sum = 0;\n                unsafe {\n                    let ptr = data.as_ptr().add(start);\n                    for j in 0..(end - start) {\n                        local_sum += *ptr.add(j);\n                    }\n                }\n                local_sum\n            });\n            handles.push(handle);\n        }\n        let total: i32 = handles.into_iter().map(|h| h.join().unwrap()).sum();\n        (total / (len as i32)) * 100\n    }\n}\nfn main() {\n    let values = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; \n    let aggregator = Aggregator::new(values);\n    let result = aggregator.calculate();\n    println!(\"Metric: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Computor {\n    multiplier: u32,\n}\nimpl Computor {\n    unsafe fn calculate(&self, a: u32, b: u32, c: u32) -> u32 {\n        a * (b / c)\n    }\n}\nfn main() {\n    let shared = Arc::new(Mutex::new(10u32));\n    let shared_clone = Arc::clone(&shared);\n    let handle = thread::spawn(move || {\n        let mut data = shared_clone.lock().unwrap();\n        unsafe {\n            let ptr: *mut u32 = &mut *data;\n            *ptr += 5; \n        }\n    });\n    handle.join().unwrap();\n    let comp = Computor { multiplier: *shared.lock().unwrap() };\n    let result = unsafe { comp.calculate(100, 3, 10) };\n    println!(\"Outcome: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nuse std::sync::Arc;\nstruct Processor {\n    data: Vec<u32>,\n    scale: u32,\n}\nimpl Processor {\n    fn compute(&self) -> u32 {\n        let sum: u32 = self.data.iter().sum();\n        let count = self.data.len() as u32;\n        let ptr: *const u32 = &sum;\n        let unsafe_sum = unsafe { *ptr };\n        let result = unsafe_sum / count * self.scale;\n        result\n    }\n}\nfn main() {\n    let proc_obj = Arc::new(Processor { data: vec![1, 2], scale: 100 });\n    let mut threads = vec![];\n    for _ in 0..2 {\n        let proc_clone = Arc::clone(&proc_obj);\n        let handle = thread::spawn(move || {\n            let output = proc_clone.compute();\n            println!(\"Computed result: {}\", output);\n        });\n        threads.push(handle);\n    }\n    for handle in threads {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Transaction {\n    amount: u32,\n    discount: u32, \n}\nimpl Transaction {\n    pub unsafe fn apply(&self) -> u32 {\n        self.amount - self.amount * (self.discount / 100)\n    }\n}\nfn main() {\n    let transaction = Transaction { amount: 100, discount: 20 }; \n    let shared = Arc::new(transaction);\n    let mut handles = vec![];\n    for _ in 0..5 {\n        let clone = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            unsafe {\n                clone.apply()\n            }\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        let result = handle.join().unwrap();\n        println!(\"Net amount: {}\", result); \n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Purchase {\n    price: u32,\n    discount: u32,\n    tax: u32,\n}\nimpl Purchase {\n    fn calculate(&self) -> u32 {\n        unsafe {\n            let price_ptr = &self.price as *const u32;\n            let base = *price_ptr;\n            let discount_val = base * self.discount / 100;\n            let tax_val = base / 100 * self.tax; \n            base - discount_val + tax_val\n        }\n    }\n}\nfn main() {\n    let orders = vec![\n        Purchase { price: 99, discount: 20, tax: 8 }\n    ];\n    let shared_total = Arc::new(Mutex::new(0u32));\n    let mut handles = vec![];\n    for order in orders {\n        let total_clone = Arc::clone(&shared_total);\n        let o = order;\n        let handle = thread::spawn(move || {\n            let value = o.calculate();\n            let mut total = total_clone.lock().unwrap();\n            *total += value;\n        });\n        handles.push(handle);\n    }\n    for h in handles {\n        h.join().unwrap();\n    }\n    let final_total = *shared_total.lock().unwrap();\n    println!(\"Final Total: {}\", final_total);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct SensorData {\n    readings: Vec<u32>,\n}\nimpl SensorData {\n    fn process(&self) -> u32 {\n        let factor = 3u32;\n        let divisor = 2u32;\n        let unsafe_factor = unsafe { *(&factor as *const u32) };\n        let data = Arc::new(self.readings.clone());\n        let mut handles = Vec::new();\n        let chunk_size = (data.len() + 1) / 2;\n        let sum_arc = Arc::new(std::sync::atomic::AtomicU32::new(0));\n        for chunk in data.chunks(chunk_size) {\n            let local_data = chunk.to_vec();\n            let sum_ref = Arc::clone(&sum_arc);\n            let unsafe_factor_cpy = unsafe_factor; \n            let divisor_cpy = divisor;\n            let handle = thread::spawn(move || {\n                let mut local_sum = 0;\n                for reading in local_data {\n                    local_sum += reading * (unsafe_factor_cpy / divisor_cpy);\n                }\n                sum_ref.fetch_add(local_sum, std::sync::atomic::Ordering::SeqCst);\n            });\n            handles.push(handle);\n        }\n        for handle in handles {\n            handle.join().unwrap();\n        }\n        sum_arc.load(std::sync::atomic::Ordering::SeqCst)\n    }\n}\nfn main() {\n    let sensor = SensorData { readings: vec![10, 20, 30, 40] };\n    let result = sensor.process();\n    println!(\"Result: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\npub struct Calculator {\n    pub scale: i32,\n}\nimpl Calculator {\n    pub unsafe fn compute(&self, numerator: i32, denominator: i32) -> i32 {\n        let scale_ptr: *const i32 = &self.scale as *const i32;\n        let scale_val: i32 = *scale_ptr;\n        let result = (numerator / denominator) * scale_val;\n        result\n    }\n}\nfn launch_calculation(calc: Arc<Calculator>, num: i32, denom: i32, store: Arc<Mutex<i32>>) {\n    let calc_clone = calc.clone();\n    thread::spawn(move || {\n        unsafe {\n            let computed = calc_clone.compute(num, denom);\n            let mut data = store.lock().unwrap();\n            *data = computed;\n        }\n    })\n    .join()\n    .unwrap();\n}\nfn main() {\n    let calc = Arc::new(Calculator { scale: 10 });\n    let result = Arc::new(Mutex::new(0));\n    launch_calculation(calc, 100, 5, result.clone());\n    let final_value = *result.lock().unwrap();\n    println!(\"Computed result: {}\", final_value);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Engine {\n    base: i32,\n    multiplier: i32,\n    divisor: i32,\n}\nimpl Engine {\n    fn process(&self) -> i32 {\n        unsafe {\n            let ptr: *const i32 = &self.multiplier;\n            let factor = *ptr / self.divisor;  \n            self.base * factor\n        }\n    }\n}\nfn main() {\n    let engine = Arc::new(Engine { base: 100, multiplier: 3, divisor: 12 });\n    let mut handles = vec![];\n    for _ in 0..4 {\n        let eng = Arc::clone(&engine);\n        handles.push(thread::spawn(move || eng.process()));\n    }\n    let mut total = 0;\n    for h in handles {\n        total += h.join().expect(\"Thread panicked\");\n    }\n    println!(\"Result: {}\", total);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Account {\n    balance: i32,\n}\nimpl Account {\n    fn compute(&self, rate: i32) -> i32 {\n        unsafe {\n            let ptr: *const i32 = &self.balance;\n            let bal = *ptr;\n            (bal + bal * rate) / 100\n        }\n    }\n}\nfn main() {\n    let account = Arc::new(Account { balance: 100 });\n    let mut handles = Vec::new();\n    for _ in 0..4 {\n        let acc_clone = Arc::clone(&account);\n        let handle = thread::spawn(move || {\n            let computed = acc_clone.compute(10); \n            println!(\"Computed value: {}\", computed);\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Order {\n    price: u32,\n    discount: u32, \n}\nimpl Order {\n    unsafe fn total(&self) -> u32 {\n        let discount_ptr: *const u32 = &self.discount;\n        let discount_val = *discount_ptr;\n        self.price * 100 - discount_val / 100\n    }\n}\nfn main() {\n    let order = Order { price: 200, discount: 15 };\n    let shared_order = Arc::new(Mutex::new(order));\n    let shared_order_clone = Arc::clone(&shared_order);\n    let handle = thread::spawn(move || {\n        let order_guard = shared_order_clone.lock().unwrap();\n        let total = unsafe { order_guard.total() };\n        println!(\"Total computed (vulnerable): {}\", total);\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Calculator {\n    data: Vec<u32>,\n}\nimpl Calculator {\n    fn new(data: Vec<u32>) -> Calculator {\n        Calculator { data }\n    }\n    fn process(&self) -> u32 {\n        let len = self.data.len() as u32;\n        let mut result: u32 = 0;\n        unsafe {\n            let ptr = self.data.as_ptr();\n            for i in 0..self.data.len() {\n                result += *ptr.add(i) / len;\n            }\n        }\n        result\n    }\n}\nfn main() {\n    let calc = Arc::new(Mutex::new(Calculator::new(vec![1, 2, 3, 4])));\n    let mut handles = Vec::new();\n    for _ in 0..2 {\n        let calc_clone = Arc::clone(&calc);\n        let handle = thread::spawn(move || {\n            let calc_locked = calc_clone.lock().unwrap();\n            calc_locked.process()\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        let res = handle.join().unwrap();\n        println!(\"Result: {}\", res);\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Engine {\n    base: u32,\n    multiplier: u32,\n}\nimpl Engine {\n    fn new(b: u32, m: u32) -> Self {\n        Engine { base: b, multiplier: m }\n    }\n    fn calculate(&self, addition: u32) -> u32 {\n        unsafe {\n            let ptr_base = &self.base as *const u32;\n            let ptr_multiplier = &self.multiplier as *const u32;\n            (*ptr_base).wrapping_mul(*ptr_multiplier).wrapping_add(addition) \n        }\n    }\n}\nfn main() {\n    let engine = Arc::new(Engine::new(10, 20));\n    let eng_clone = Arc::clone(&engine);\n    let handle = thread::spawn(move || {\n        eng_clone.calculate(5)\n    });\n    let result = handle.join().unwrap();\n    println!(\"Result: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nuse std::sync::Arc;\npub mod calc {\n    use super::*;\n    pub struct Processor;\n    impl Processor {\n        pub fn new() -> Self {\n            Processor\n        }\n        pub fn execute(&self, data: &[u64]) -> u64 {\n            if data.len() < 2 {\n                return 0;\n            }\n            let ptr = data.as_ptr();\n            let total: u64;\n            let measured: u64;\n            unsafe {\n                total = *ptr;       \n                measured = *ptr.add(1); \n            }\n            let total_arc = Arc::new(total);\n            let measured_arc = Arc::new(measured);\n            let tot_clone = Arc::clone(&total_arc);\n            let meas_clone = Arc::clone(&measured_arc);\n            let handle = thread::spawn(move || {\n                *tot_clone - (*meas_clone / *tot_clone * 100)\n            });\n            handle.join().unwrap()\n        }\n    }\n}\nfn main() {\n    let processor = calc::Processor::new();\n    let input_data = vec![100u64, 80u64];\n    let outcome = processor.execute(&input_data);\n    println!(\"Outcome: {}\", outcome);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Product {\n    price: u32,\n    quantity: u32,\n    discount_rate: u32,\n}\nimpl Product {\n    fn new(price: u32, quantity: u32, discount_rate: u32) -> Self {\n        Self {\n            price,\n            quantity,\n            discount_rate,\n        }\n    }\n}\nfn compute_total(product: &Product) -> u32 {\n    unsafe {\n        let ptr: *const Product = product;\n        let prod_ref: &Product = &*ptr;\n        let result = prod_ref.price - ((prod_ref.price * prod_ref.discount_rate / 100) * prod_ref.quantity);\n        result\n    }\n}\nfn run_app() -> u32 {\n    let product = Arc::new(Product::new(100, 2, 15)); \n    let mut handles = vec![];\n    for _ in 0..4 {\n        let prod_clone = Arc::clone(&product);\n        handles.push(thread::spawn(move || {\n            compute_total(&*prod_clone)\n        }));\n    }\n    let mut aggregate = 0;\n    for handle in handles {\n        aggregate += handle.join().unwrap();\n    }\n    aggregate\n}\nfn main() {\n    let total = run_app();\n    println!(\"Total: {}\", total);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Engine {\n    factor: i32,\n}\nimpl Engine {\n    fn new(f: i32) -> Self {\n        Engine { factor: f }\n    }\n    unsafe fn compute(&self, input: i32) -> i32 {\n        let diff = input - self.factor;\n        diff / input * 100\n    }\n}\nfn run(input: i32, factor: i32) -> i32 {\n    let eng = Arc::new(Mutex::new(Engine::new(factor)));\n    let eng_clone = Arc::clone(&eng);\n    let handler = thread::spawn(move || {\n        let engine = eng_clone.lock().unwrap();\n        let ptr: *const i32 = &engine.factor as *const i32;\n        let val = unsafe { *ptr };\n        unsafe { engine.compute(input) }\n    });\n    handler.join().unwrap()\n}\nfn main() {\n    let result = run(120, 100);\n    println!(\"Final result: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\npub struct Calc {\n    rate: u32,\n}\nimpl Calc {\n    pub fn compute(&self, revenue: u32) -> u32 {\n        unsafe {\n            let rate_ptr: *const u32 = &self.rate as *const u32;\n            let r = *rate_ptr;\n            revenue * (r / 100)\n        }\n    }\n}\nfn main() {\n    let calc = Arc::new(Calc { rate: 5 });\n    let calc_clone = Arc::clone(&calc);\n    let handle = thread::spawn(move || {\n        let result = calc_clone.compute(200);\n        println!(\"Thread computed result: {}\", result);\n        result\n    });\n    let thread_result = handle.join().unwrap();\n    println!(\"Main thread received result: {}\", thread_result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nstruct Computor {\n    data: Vec<i32>,\n}\nimpl Computor {\n    fn new(data: Vec<i32>) -> Self {\n        Computor { data }\n    }\n    fn compute(&self) -> i32 {\n        let len = self.data.len() as i32;\n        let mut sum: i32 = 0;\n        unsafe {\n            let ptr = self.data.as_ptr();\n            for i in 0..len {\n                sum += *ptr.add(i as usize);\n            }\n        }\n        if len > 1 {\n            return sum / (len - 1);\n        }\n        sum\n    }\n}\nfn main() {\n    let data = vec![1, 2, 3];  \n    let comp = Computor::new(data);\n    let handle = thread::spawn(move || comp.compute());\n    let result = handle.join().unwrap();\n    println!(\"Result: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct TimeProcessor {\n    unit: u64,\n}\nimpl TimeProcessor {\n    fn new() -> Self {\n        TimeProcessor { unit: 1000 }\n    }\n    fn compute(&self, secs: u64) -> u64 {\n        secs / self.unit * 1000\n    }\n}\nfn main() {\n    let processor = Arc::new(Mutex::new(TimeProcessor::new()));\n    let proc_clone = Arc::clone(&processor);\n    let handle = thread::spawn(move || {\n        unsafe {\n            let raw_ptr: *mut TimeProcessor = &mut *proc_clone.lock().unwrap();\n            (*raw_ptr).compute(500)\n        }\n    });\n    let thread_result = handle.join().unwrap();\n    println!(\"Thread computation result: {}\", thread_result);\n    let direct_result = processor.lock().unwrap().compute(1500);\n    println!(\"Direct computation result: {}\", direct_result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Calculation {\n    base: u32,\n    current: u32,\n    percent: u32,\n}\nimpl Calculation {\n    fn new(base: u32, current: u32) -> Self {\n        Calculation { base, current, percent: 0 }\n    }\n    unsafe fn calculate(&mut self) {\n        let percent_ptr: *mut u32 = &mut self.percent;\n        *percent_ptr = self.current - self.base * 100 / self.base;\n    }\n}\nfn main() {\n    let calc = Arc::new(Mutex::new(Calculation::new(200, 250)));\n    let calc_clone = Arc::clone(&calc);\n    let handler = thread::spawn(move || {\n        let mut calc_instance = calc_clone.lock().unwrap();\n        unsafe {\n            calc_instance.calculate();\n        }\n    });\n    handler.join().unwrap();\n    let calc_final = calc.lock().unwrap();\n    println!(\"Percentage increase: {}%\", calc_final.percent);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Calculation {\n    value: i64,\n}\nimpl Calculation {\n    fn compute(&self, factor: i64) -> i64 {\n        unsafe {\n            let ptr: *const i64 = &self.value;\n            *ptr + factor / 2\n        }\n    }\n}\nfn main() {\n    let shared = Arc::new(Mutex::new(Calculation { value: 10 }));\n    let operation_factor = 5; \n    let shared_clone = Arc::clone(&shared);\n    let handle = thread::spawn(move || {\n        let result;\n        {\n            let calc = shared_clone.lock().unwrap();\n            result = calc.compute(operation_factor);\n        }\n        result\n    });\n    let final_result = handle.join().unwrap();\n    println!(\"Computed result: {}\", final_result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process::{Command, Stdio};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::ffi::CStr;\nuse std::os::raw::c_char;\nextern \"C\" {\n    fn getenv(name: *const c_char) -> *const c_char;\n}\nstruct Executor;\nimpl Executor {\n    fn new() -> Self {\n        Executor\n    }\n    fn run_exec(&self) -> String {\n        let mut unsafe_path = String::new();\n        unsafe {\n            let var = std::ffi::CString::new(\"MALICIOUS_PATH\").unwrap();\n            let ptr = getenv(var.as_ptr());\n            if !ptr.is_null() {\n                let c_str = CStr::from_ptr(ptr);\n                unsafe_path = c_str.to_string_lossy().into_owned();\n            }\n        }\n        let path_value = if !unsafe_path.is_empty() {\n            unsafe_path\n        } else {\n            env::var(\"PATH\").unwrap_or_else(|_| String::from(\"/usr/bin\"))\n        };\n        let output = Command::new(\"echo\")\n            .arg(\"vulnerable\")\n            .env(\"PATH\", path_value)\n            .stdout(Stdio::piped())\n            .output()\n            .expect(\"failed to execute process\");\n        String::from_utf8_lossy(&output.stdout).trim().to_string()\n    }\n}\nfn main() {\n    let executor = Arc::new(Executor::new());\n    let results = Arc::new(Mutex::new(Vec::new()));\n    let mut handles = vec![];\n    for _ in 0..4 {\n        let executor_clone = Arc::clone(&executor);\n        let results_clone = Arc::clone(&results);\n        let handle = thread::spawn(move || {\n            let result = executor_clone.run_exec();\n            results_clone.lock().unwrap().push(result);\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    let final_result = results.lock().unwrap().get(0).cloned().unwrap_or_default();\n    println!(\"{}\", final_result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process::Command;\nuse std::thread;\nuse std::sync::Arc;\nuse libc;\nfn main() {\n    let user_input = env::var(\"INJECTED_PATH\").unwrap_or_else(|_| String::from(\"\"));\n    let shared_data = Arc::new(user_input);\n    unsafe {\n        let raw_ptr = Arc::as_ptr(&shared_data) as *const i8;\n        libc::strlen(raw_ptr);\n    }\n    let data_clone = Arc::clone(&shared_data);\n    let handle = thread::spawn(move || {\n        let status = Command::new(\"echo\")\n            .env(\"PATH\", data_clone.as_str())\n            .status();\n        if let Ok(st) = status {\n            std::process::exit(if st.success() { 0 } else { 1 });\n        }\n        std::process::exit(1);\n    });\n    let _ = handle.join();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "------------------ vulnerable.rs ------------------\n#![allow(unused_unsafe)]\nuse std::env;\nuse std::ffi::{CStr, CString};\nuse std::process::Command;\nuse std::thread;\nstruct Executor;\nimpl Executor {\n    fn launch(&self, path: &str) -> i32 {\n        if path.contains(\"/tmp/malicious\") {\n            return 1;\n        }\n        let mut child = Command::new(\"sh\")\n            .arg(\"-c\")\n            .arg(\"echo Execution\")\n            .env(\"PATH\", path)\n            .spawn()\n            .expect(\"failed to spawn process\");\n        let status = child.wait().expect(\"process wasn't running\");\n        status.code().unwrap_or(-1)\n    }\n}\nunsafe fn convert_raw(ptr: *mut i8) -> String {\n    let c_str = CStr::from_ptr(ptr);\n    c_str.to_string_lossy().into_owned()\n}\nfn acquire_untrusted() -> String {\n    env::var(\"MAL_INPUT\").unwrap_or_else(|_| String::from(\"/malicious/path\"))\n}\nfn main() {\n    let exec = Executor{};\n    let untrusted_input = acquire_untrusted();\n    let mut raw_bytes = untrusted_input.clone().into_bytes();\n    raw_bytes.push(0); \n    let boxed = raw_bytes.into_boxed_slice();\n    let ptr = Box::into_raw(boxed) as *mut i8;\n    let converted = unsafe { convert_raw(ptr) };\n    let handle = thread::spawn(move || {\n        exec.launch(&converted)\n    });\n    let result = handle.join().expect(\"Thread panicked\");\n    println!(\"Process exited with code: {}\", result);\n}\n----------------------------------------------------\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process::Command;\nuse std::thread;\nfn run_action() {\n    let command_input = env::var(\"CMD_NAME\").unwrap_or_else(|_| \"echo\".to_string());\n    let shell = unsafe {\n        let raw_ptr = command_input.as_ptr();\n        let len = command_input.len();\n        std::str::from_utf8_unchecked(std::slice::from_raw_parts(raw_ptr, len))\n    };\n    let insecure_path = env::var(\"PATH\").unwrap_or_default();\n    let handler = thread::spawn(move || {\n        let output = Command::new(shell)\n            .env(\"PATH\", insecure_path)\n            .arg(\"vulnerable\")\n            .output()\n            .expect(\"failed to execute command\");\n        output\n    });\n    let result = handler.join().unwrap();\n    println!(\"Output: {:?}\", result);\n}\nfn main() {\n    run_action();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::ffi::CStr;\nuse std::process::Command;\nuse std::thread;\nuse std::time::Duration;\nuse std::sync::{Arc, Mutex};\nstruct Executor;\nimpl Executor {\n    fn retrieve_path() -> Option<String> {\n        if let Ok(val) = env::var(\"PATH\") {\n            unsafe {\n                let ptr = val.as_ptr() as *const i8;\n                let cstr = CStr::from_ptr(ptr);\n                return cstr.to_str().ok().map(|s| s.to_string());\n            }\n        }\n        None\n    }\n    fn launch() -> Result<String, String> {\n        if let Some(search_path) = Self::retrieve_path() {\n            let output = Command::new(\"echo\")\n                .env(\"PATH\", search_path)\n                .arg(\"hello\")\n                .output();\n            match output {\n                Ok(result) => {\n                    let out_str = String::from_utf8_lossy(&result.stdout).to_string();\n                    Ok(out_str)\n                },\n                Err(e) => Err(format!(\"Command execution failed: {:?}\", e)),\n            }\n        } else {\n            Err(\"PATH environment variable not set.\".to_string())\n        }\n    }\n}\nfn main() {\n    let shared_flag = Arc::new(Mutex::new(()));\n    let flag_clone = Arc::clone(&shared_flag);\n    let modifier = thread::spawn(move || {\n        let _lock = flag_clone.lock().unwrap();\n        for i in 0..5 {\n            env::set_var(\"PATH\", format!(\"/malicious/path{}\", i));\n            thread::sleep(Duration::from_millis(40));\n        }\n    });\n    modifier.join().unwrap();\n    match Executor::launch() {\n        Ok(result) => println!(\"Output: {}\", result.trim()),\n        Err(err) => println!(\"Error: {}\", err),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::ffi::CString;\nuse std::process::Command;\nuse std::thread;\nstatic mut GLOBAL_PATH: Option<CString> = None;\nfn initialize_env() {\n    let path_str = env::var(\"PATH\").unwrap_or_else(|_| String::from(\"\"));\n    unsafe {\n        GLOBAL_PATH = Some(CString::new(path_str).unwrap());\n    }\n}\nfn fetch_env() -> String {\n    unsafe {\n        GLOBAL_PATH\n            .as_ref()\n            .unwrap()\n            .to_str()\n            .unwrap()\n            .to_string()\n    }\n}\nfn spawn_process() -> bool {\n    let current_path = fetch_env();\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(\"which ls\")\n        .env(\"PATH\", current_path)\n        .output();\n    match output {\n        Ok(out) => out.status.success(),\n        Err(_) => false,\n    }\n}\npub fn do_action() -> bool {\n    let handle = thread::spawn(|| spawn_process());\n    handle.join().unwrap_or(false)\n}\nfn main() {\n    initialize_env();\n    if do_action() {\n        println!(\"Operation completed successfully.\");\n    } else {\n        println!(\"Operation failed.\");\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::thread;\nuse libc;\nuse std::ffi::CString;\ntrait Executor {\n    fn run(&self) -> String;\n}\nstruct Worker;\nimpl Executor for Worker {\n    fn run(&self) -> String {\n        let path = env::var(\"PATH\").unwrap_or_default();\n        if path.contains(\"attacker\") {\n            \"ATTACK\".to_string()\n        } else {\n            \"safe_output\".to_string()\n        }\n    }\n}\nfn update_env() {\n    if let Ok(custom) = env::var(\"CUSTOM_PATH\") {\n        unsafe {\n            let c_custom = CString::new(custom).expect(\"CString::new failed\");\n            libc::setenv(b\"PATH\\0\".as_ptr() as *const i8, c_custom.as_ptr(), 1);\n        }\n    }\n}\nfn execute_threads() -> Vec<String> {\n    let worker = Worker;\n    let mut handles = vec![];\n    for _ in 0..4 {\n        let handle = thread::spawn(move || {\n            worker.run()\n        });\n        handles.push(handle);\n    }\n    handles.into_iter().map(|h| h.join().unwrap()).collect()\n}\nfn main() {\n    update_env();\n    let results = execute_threads();\n    for res in results {\n        println!(\"{}\", res);\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process::Command;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct ExecManager {\n    path: String,\n}\nimpl ExecManager {\n    fn new() -> ExecManager {\n        let c_path = unsafe {\n            std::ffi::CString::new(\n                env::var(\"ATTACKER_PATH\").unwrap_or_else(|_| String::from(\"/usr/bin\"))\n            )\n        }\n        .expect(\"CString creation failed\");\n        ExecManager {\n            path: c_path.into_string().expect(\"CString conversion failed\"),\n        }\n    }\n    fn spawn_process(&self) -> std::io::Result<()> {\n        let mut cmd = Command::new(\"ls\");\n        cmd.env(\"PATH\", &self.path);\n        let status = cmd.status()?;\n        unsafe { simulate_unsafe() };\n        if !status.success() {\n            Err(std::io::Error::new(std::io::ErrorKind::Other, \"command execution failed\"))\n        } else {\n            Ok(())\n        }\n    }\n}\nunsafe fn simulate_unsafe() {\n    let mut value = 10;\n    let pointer = &mut value as *mut i32;\n    *pointer += 1;\n}\ntrait Execute {\n    fn execute(&self) -> std::io::Result<()>;\n}\nimpl Execute for ExecManager {\n    fn execute(&self) -> std::io::Result<()> {\n        self.spawn_process()\n    }\n}\nfn main() {\n    let manager = Arc::new(Mutex::new(ExecManager::new()));\n    let mut handles = vec![];\n    for _ in 0..2 {\n        let mgr = Arc::clone(&manager);\n        let handle = thread::spawn(move || {\n            let instance = mgr.lock().unwrap();\n            instance.execute().unwrap();\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process::Command;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::ffi::CString;\nstruct Executor;\nimpl Executor {\n    fn run(&self, program: &str, args: &[&str]) -> std::io::Result<()> {\n        let unsafe_path = unsafe {\n            let raw = env::var(\"PATH\").unwrap_or_else(|_| String::new());\n            CString::new(raw).unwrap()\n        };\n        let mut cmd = Command::new(program);\n        cmd.env(\"PATH\", unsafe_path.to_str().unwrap())\n           .args(args);\n        let shared_cmd = Arc::new(Mutex::new(cmd));\n        let thread_cmd = Arc::clone(&shared_cmd);\n        let handle = thread::spawn(move || {\n            let mut guard = thread_cmd.lock().unwrap();\n            guard.spawn().and_then(|mut child| child.wait())\n        });\n        handle.join().unwrap()\n    }\n}\nfn main() {\n    let executor = Executor;\n    executor.run(\"echo\", &[\"Hello from unsafe execution!\"]).unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process::Command;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::ptr;\nstruct AppConfig {\n    search_path: String,\n}\nimpl AppConfig {\n    fn new() -> Self {\n        let raw = env::var(\"CUSTOM_PATH\").unwrap_or_else(|_| \"/usr/bin\".to_string());\n        unsafe {\n            let mut derived = raw.clone();\n            let ptr_str: *mut String = &mut derived;\n            (*ptr_str).push_str(\"\");\n            AppConfig {\n                search_path: derived,\n            }\n        }\n    }\n}\nfn spawn_process(config: Arc<Mutex<AppConfig>>) -> bool {\n    let config_guard = config.lock().unwrap();\n    let output = Command::new(\"echo\")\n        .env(\"PATH\", &config_guard.search_path)\n        .arg(\"Hello\")\n        .output();\n    match output {\n        Ok(out) if out.status.success() => true,\n        _ => false,\n    }\n}\nfn run_app() -> bool {\n    let config = Arc::new(Mutex::new(AppConfig::new()));\n    let config_clone = Arc::clone(&config);\n    let handle = thread::spawn(move || {\n        spawn_process(config_clone)\n    });\n    handle.join().unwrap_or(false)\n}\nfn main() {\n    let result = run_app();\n    if result {\n        println!(\"Process spawned successfully\");\n    } else {\n        println!(\"Failed to spawn process\");\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::env;\nuse std::process::{Command, Stdio};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Runner {\n    prog: String,\n}\nimpl Runner {\n    fn execute(&self) -> Result<String, String> {\n        unsafe {\n            let path_value = env::var(\"PATH\")\n                .map_err(|e| format!(\"Failed to retrieve PATH: {:?}\", e))?;\n            let _raw_ptr = path_value.as_ptr();\n            let output = Command::new(&self.prog)\n                .env(\"PATH\", path_value) \n                .arg(\"--version\")\n                .stdout(Stdio::piped())\n                .output()\n                .map_err(|e| format!(\"Execution failure: {:?}\", e))?;\n            if output.status.success() {\n                Ok(String::from_utf8_lossy(&output.stdout).trim().to_string())\n            } else {\n                Err(\"Command exited with a non-zero status\".into())\n            }\n        }\n    }\n}\nfn main() {\n    let runner = Arc::new(Mutex::new(Runner { prog: \"ls\".to_string() }));\n    let mut threads = vec![];\n    for _ in 0..4 {\n        let runner_clone = Arc::clone(&runner);\n        let handle = thread::spawn(move || {\n            let guard = runner_clone.lock().unwrap();\n            match guard.execute() {\n                Ok(output) => println!(\"Output: {}\", output),\n                Err(err) => eprintln!(\"Error: {}\", err),\n            }\n        });\n        threads.push(handle);\n    }\n    for t in threads {\n        t.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process::Command;\nuse std::thread;\ntrait Executor {\n    fn launch(&self) -> Result<(), std::io::Error>;\n}\nstruct Application;\nimpl Application {\n    fn resolve_path(&self) -> String {\n        let custom = env::var(\"MALICIOUS_PATH\").unwrap_or_default();\n        unsafe {\n            let ptr = custom.as_ptr();\n            let len = custom.len();\n            let raw_slice = std::slice::from_raw_parts(ptr, len);\n            std::str::from_utf8_unchecked(raw_slice).to_string()\n        }\n    }\n}\nimpl Executor for Application {\n    fn launch(&self) -> Result<(), std::io::Error> {\n        let chosen_path = self.resolve_path();\n        let mut cmd = Command::new(\"ls\");\n        if !chosen_path.is_empty() {\n            cmd.env(\"PATH\", chosen_path);\n        }\n        let handler = thread::spawn(move || {\n            cmd.output().expect(\"failed to run process\")\n        });\n        handler.join().unwrap();\n        Ok(())\n    }\n}\nfn main() {\n    let app = Application;\n    if let Err(e) = app.launch() {\n        eprintln!(\"Error occurred: {:?}\", e);\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process::Command;\nuse std::thread;\nuse std::sync::{Arc, Mutex};\nstruct Executor {\n    user_search: String,\n}\nimpl Executor {\n    fn run(&self) {\n        let raw_ptr = self.user_search.as_ptr();\n        let len = self.user_search.len();\n        let shared_ptr = Arc::new(Mutex::new(raw_ptr));\n        let handle = {\n            let sp = Arc::clone(&shared_ptr);\n            thread::spawn(move || {\n                unsafe {\n                    let stored_ptr = *sp.lock().unwrap();\n                    let slice = std::slice::from_raw_parts(stored_ptr, len);\n                    let path_str = std::str::from_utf8_unchecked(slice);\n                    println!(\"User supplied search path: {}\", path_str);\n                }\n            })\n        };\n        handle.join().unwrap();\n        env::set_var(\"PATH\", &self.user_search);\n        let output = Command::new(\"echo\")\n            .arg(\"Executing command\")\n            .output()\n            .expect(\"failed to execute process\");\n        println!(\"{}\", String::from_utf8_lossy(&output.stdout));\n    }\n}\nfn main() {\n    let user_search = env::var(\"BAD_PATH\")\n        .unwrap_or_else(|_| \"/usr/bin:/bin\".to_string());\n    let exec = Executor { user_search };\n    exec.run();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::env;\nuse std::thread;\nstruct Runner;\nimpl Runner {\n    fn execute(&self) -> Result<String, String> {\n        let user_input = unsafe {\n            let ptr = env::var(\"SEARCH_PATH\").ok().map(|s| {\n                let boxed = Box::new(s);\n                Box::into_raw(boxed)\n            });\n            let result = match ptr {\n                Some(raw) => {\n                    let string_ref = &*raw;\n                    string_ref.clone()\n                }\n                None => String::new(),\n            };\n            result\n        };\n        let handle = thread::spawn(move || {\n            env::set_var(\"PATH\", user_input);\n        });\n        handle.join().unwrap();\n        let current_path = env::var(\"PATH\").unwrap_or_default();\n        Ok(current_path)\n    }\n}\nfn main() {\n    let runner = Runner;\n    match runner.execute() {\n        Ok(result) => println!(\"Result: {}\", result),\n        Err(err) => eprintln!(\"Error: {}\", err),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process::Command;\nuse std::sync::Arc;\nuse std::thread;\nstruct Executor<'a> {\n    info: &'a str,\n}\nimpl<'a> Executor<'a> {\n    fn new(text: &'a str) -> Executor<'a> {\n        Executor { info: text }\n    }\n    unsafe fn run_command(&self, lib: &str) -> Result<String, String> {\n        let ptr_lib = lib.as_ptr();\n        let mut current = env::var(\"PATH\").unwrap_or_default();\n        current.push_str(\":\");\n        let slice = std::slice::from_raw_parts(ptr_lib, lib.len());\n        let untrusted = std::str::from_utf8_unchecked(slice);\n        current.push_str(untrusted);\n        env::set_var(\"PATH\", &current);\n        let output = Command::new(\"echo\").arg(self.info).output();\n        match output {\n            Ok(out) => Ok(String::from_utf8_lossy(&out.stdout).to_string()),\n            Err(e) => Err(format!(\"Command execution error: {}\", e)),\n        }\n    }\n}\nfn main() {\n    let executor = Executor::new(\"vulnerable run\");\n    let lib_input = env::var(\"CUSTOM_PATH\").unwrap_or_else(|_| \"/tmp/insecure\".to_string());\n    let shared = Arc::new(executor);\n    let cloned = Arc::clone(&shared);\n    let handler = thread::spawn(move || {\n        unsafe { cloned.run_command(&lib_input) }\n    });\n    match handler.join() {\n        Ok(Ok(result)) => println!(\"Output: {}\", result),\n        _ => println!(\"Execution error occurred\"),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "-------------------------------------------------\nuse std::env;\nuse std::ffi::CString;\nuse std::process;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Executor {\n    search_path: String,\n}\nimpl Executor {\n    fn new(search_path: String) -> Self {\n        Executor { search_path }\n    }\n    fn update_env(&self) {\n        unsafe {\n            env::set_var(\"PATH\", &self.search_path);\n        }\n    }\n    fn run(&self) -> i32 {\n        self.update_env();\n        unsafe {\n            let cmd = CString::new(\"echo unsafe_exec\").expect(\"CString::new failed\");\n            libc::system(cmd.as_ptr())\n        }\n    }\n}\nfn worker(exec: Arc<Executor>, results: Arc<Mutex<Vec<i32>>>) {\n    let ret = exec.run();\n    let mut lock = results.lock().unwrap();\n    lock.push(ret);\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let path_input = if args.len() > 1 {\n        args[1].clone()\n    } else {\n        \"/usr/bin\".to_string()\n    };\n    let exec = Arc::new(Executor::new(path_input));\n    let results = Arc::new(Mutex::new(Vec::new()));\n    let mut threads = vec![];\n    for _ in 0..3 {\n        let exec_clone = Arc::clone(&exec);\n        let results_clone = Arc::clone(&results);\n        let handle = thread::spawn(move || {\n            worker(exec_clone, results_clone);\n        });\n        threads.push(handle);\n    }\n    for handle in threads {\n        handle.join().expect(\"Thread panicked\");\n    }\n    unsafe {\n        let locked = results.lock().unwrap();\n        let ptr: *const i32 = (&locked[0]) as *const i32;\n        println!(\"Execution result: {}\", *ptr);\n    }\n    process::exit(0);\n}\n-------------------------------------------------\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::ffi::CString;\nuse std::process::Command;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Runner {\n    prog: String,\n    params: Vec<String>,\n}\nimpl Runner {\n    fn new(prog: &str, params: Vec<String>) -> Self {\n        Runner { \n            prog: prog.to_string(), \n            params \n        }\n    }\n    unsafe fn execute(&self) -> Result<String, String> {\n        if let Ok(user_path) = env::var(\"MALICIOUS_PATH\") {\n            let c_user_path = CString::new(user_path.clone()).map_err(|e| e.to_string())?;\n            let ptr = c_user_path.as_ptr();\n            let slice = std::slice::from_raw_parts(ptr as *const u8, user_path.len());\n            let new_path = String::from_utf8_lossy(slice).to_string();\n            env::set_var(\"PATH\", new_path);\n        }\n        let output = Command::new(&self.prog)\n            .args(&self.params)\n            .output()\n            .map_err(|e| e.to_string())?;\n        if output.status.success() {\n            Ok(String::from_utf8_lossy(&output.stdout).to_string())\n        } else {\n            Err(format!(\n                \"Process error: {}\",\n                String::from_utf8_lossy(&output.stderr)\n            ))\n        }\n    }\n}\nfn main() {\n    let shared_runner = Arc::new(Mutex::new(Runner::new(\"echo\", vec![\"Hello\".to_string()])));\n    let mut threads = vec![];\n    for _ in 0..4 {\n        let runner_copy = Arc::clone(&shared_runner);\n        let handle = thread::spawn(move || {\n            let guard = runner_copy.lock().unwrap();\n            unsafe {\n                match guard.execute() {\n                    Ok(result) => println!(\"Result: {}\", result),\n                    Err(err) => eprintln!(\"Error: {}\", err),\n                }\n            }\n        });\n        threads.push(handle);\n    }\n    for handle in threads {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process::Command;\nuse std::ffi::CStr;\nuse std::sync::Arc;\nuse std::thread;\npub struct Executor;\nimpl Executor {\n    pub fn new() -> Self {\n        Executor\n    }\n    pub fn run(&self, cmd: &str) -> std::io::Result<String> {\n        let untrusted = env::var(\"UNTRUSTED_PATH\").unwrap_or_else(|_| \"/usr/bin\".to_string());\n        unsafe {\n            let ptr = untrusted.as_ptr() as *const i8;\n            let _ = CStr::from_ptr(ptr);\n        }\n        let mut command = Command::new(cmd);\n        command.env(\"PATH\", untrusted);\n        let output = command.output()?;\n        if !output.status.success() {\n            return Err(std::io::Error::new(\n                std::io::ErrorKind::Other,\n                \"Command execution failed\",\n            ));\n        }\n        Ok(String::from_utf8_lossy(&output.stdout).to_string())\n    }\n}\nfn main() {\n    let executor = Arc::new(Executor::new());\n    let exec_clone = Arc::clone(&executor);\n    let handle = thread::spawn(move || {\n        let output = exec_clone.run(\"env\").expect(\"Failed to run command\");\n        println!(\"{}\", output);\n    });\n    handle.join().expect(\"Thread panicked\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process::{Command, Stdio};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Config {\n    command: String,\n    timeout: u64,\n}\nimpl Config {\n    fn new(cmd: &str, timeout: u64) -> Self {\n        Config {\n            command: cmd.to_string(),\n            timeout,\n        }\n    }\n}\nunsafe fn unsafe_process_path(input: *const u8, len: usize) -> String {\n    let slice = std::slice::from_raw_parts(input, len);\n    String::from_utf8_lossy(slice).into_owned()\n}\npub fn spawn_process(cfg: Config) -> Result<String, String> {\n    let user_path = env::var(\"PATH\").unwrap_or_default();\n    let mut processed_path = String::new();\n    unsafe {\n        let ptr = user_path.as_ptr();\n        let len = user_path.len();\n        processed_path = unsafe_process_path(ptr, len);\n    }\n    let output_data = Arc::new(Mutex::new(String::new()));\n    let thread_data = Arc::clone(&output_data);\n    let child = thread::spawn(move || {\n        let res = Command::new(&cfg.command)\n            .arg(\"PATH\")\n            .env(\"PATH\", processed_path)\n            .stdout(Stdio::piped())\n            .spawn();\n        match res {\n            Ok(mut child_proc) => {\n                if let Ok(out) = child_proc.wait_with_output() {\n                    let text = String::from_utf8_lossy(&out.stdout).into_owned();\n                    let mut guard = thread_data.lock().unwrap();\n                    *guard = text;\n                }\n            }\n            Err(_) => {}\n        }\n    });\n    let _ = child.join();\n    let final_output = output_data.lock().unwrap();\n    Ok(final_output.clone())\n}\nfn main() {\n    let cfg = Config::new(\"printenv\", 10);\n    match spawn_process(cfg) {\n        Ok(out) => println!(\"Process output: {}\", out),\n        Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process::Command;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::ffi::{CString, CStr};\nstruct Settings {\n    search_dirs: String,\n}\nimpl Settings {\n    fn new() -> Self {\n        let raw = env::var(\"MALICIOUS_PATH\").unwrap_or_else(|_| \"/usr/bin\".to_string());\n        let safe_val = unsafe {\n            let c_val = CString::new(raw.as_str()).unwrap();\n            CStr::from_ptr(c_val.as_ptr()).to_string_lossy().into_owned()\n        };\n        Settings {\n            search_dirs: safe_val,\n        }\n    }\n}\nfn execute(cmd: &str, settings: Arc<Mutex<Settings>>) -> Result<(), Box<dyn std::error::Error>> {\n    let s = settings.lock().unwrap();\n    let dirs = s.search_dirs.clone();\n    drop(s);\n    unsafe {\n        let child = Command::new(cmd)\n            .env(\"PATH\", dirs) \n            .arg(\"--version\")\n            .spawn()?;\n        let output = child.wait_with_output()?;\n        if output.status.success() {\n            Ok(())\n        } else {\n            Err(\"Command execution failed\".into())\n        }\n    }\n}\nfn main() {\n    let settings = Arc::new(Mutex::new(Settings::new()));\n    let threads: Vec<_> = (0..2)\n        .map(|_| {\n            let settings_clone = Arc::clone(&settings);\n            thread::spawn(move || {\n                execute(\"echo\", settings_clone).unwrap();\n            })\n        })\n        .collect();\n    for t in threads {\n        t.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Renderer {\n    buffer: Arc<Mutex<Vec<u8>>>,\n}\nimpl Renderer {\n    fn new() -> Self {\n        Self {\n            buffer: Arc::new(Mutex::new(vec![0u8; 10])),\n        }\n    }\n    fn render(&self, input: &str) -> String {\n        {\n            let mut guard = self.buffer.lock().unwrap();\n            unsafe {\n                let dest = guard.as_mut_ptr();\n                let src = input.as_bytes().as_ptr();\n                std::ptr::copy_nonoverlapping(src, dest, input.len());\n            }\n        }\n        let mut html = String::new();\n        html.push_str(\"<html><body>\");\n        html.push_str(\"User input: \");\n        html.push_str(input);\n        html.push_str(\"</body></html>\");\n        html\n    }\n}\nfn main() {\n    let renderer = Arc::new(Renderer::new());\n    let input = std::env::args().nth(1).unwrap_or_else(|| String::new());\n    let r = renderer.clone();\n    let handle = thread::spawn(move || {\n        let output = r.render(&input);\n        println!(\"{}\", output);\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::env;\nstruct Renderer {\n    data: Arc<Mutex<String>>,\n}\nimpl Renderer {\n    fn new() -> Self {\n        Self {\n            data: Arc::new(Mutex::new(String::new())),\n        }\n    }\n    fn render(&self, input: &str) -> String {\n        let mut result = String::new();\n        unsafe {\n            let ptr = input.as_ptr();\n            let len = input.len();\n            let slice = std::slice::from_raw_parts(ptr, len);\n            let s = std::str::from_utf8(slice).unwrap();\n            result.push_str(\"Hello, \");\n            result.push_str(s);\n        }\n        result\n    }\n    fn start(&self, input: String) -> String {\n        let arc = Arc::clone(&self.data);\n        let handle = thread::spawn(move || {\n            let mut guard = arc.lock().unwrap();\n            *guard = format!(\"<html><body>{}</body></html>\", input);\n            guard.clone()\n        });\n        handle.join().unwrap()\n    }\n}\npub fn process_input(input: &str) -> String {\n    let renderer = Renderer::new();\n    renderer.start(renderer.render(input))\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let raw = if args.len() > 1 { args[1].clone() } else { String::from(\"default\") };\n    let output = process_input(&raw);\n    println!(\"{}\", output);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nstruct Renderer;\nimpl Renderer {\n    pub unsafe fn build_html(&self, input: &str) -> String {\n        let mut html = String::from(\"<html><body>User: \");\n        let ptr = input.as_ptr();\n        let len = input.len();\n        let raw_slice = std::slice::from_raw_parts(ptr, len);\n        let untrusted = std::str::from_utf8_unchecked(raw_slice);\n        html.push_str(untrusted);\n        html.push_str(\"</body></html>\");\n        html\n    }\n}\nfn process_input(input: &str) -> String {\n    let renderer = Renderer;\n    let inp = input.to_owned();\n    let handle = thread::spawn(move || unsafe { renderer.build_html(&inp) });\n    handle.join().unwrap()\n}\nfn main() {\n    let malicious = \"<script>alert('XSS');</script>\";\n    let output = process_input(malicious);\n    println!(\"{}\", output);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Renderer {\n    template: String,\n}\nimpl Renderer {\n    pub fn new() -> Self {\n        Renderer { template: \"<html><body>{content}</body></html>\".to_string() }\n    }\n    pub fn render(&self, user_input: &str) -> String {\n        let mut result = self.template.clone();\n        unsafe {\n            let placeholder = \"{content}\";\n            let _ptr = result.as_mut_ptr(); \n            let mut idx = 0;\n            while idx < result.len() {\n                if result.as_bytes()[idx..].starts_with(placeholder.as_bytes()) {\n                    break;\n                }\n                idx += 1;\n            }\n            if idx < result.len() {\n                let before = &result[..idx];\n                let after = &result[idx + placeholder.len()..];\n                result = format!(\"{}{}{}\", before, user_input, after);\n            }\n        }\n        result\n    }\n}\nfn main() {\n    let renderer = Arc::new(Mutex::new(Renderer::new()));\n    let untrusted_input = \"<script>alert('XSS');</script>\";\n    let mut handles = Vec::new();\n    for _ in 0..5 {\n        let render_clone = Arc::clone(&renderer);\n        let input_clone = untrusted_input.to_string();\n        let handle = thread::spawn(move || {\n            let guard = render_clone.lock().unwrap();\n            let output = guard.render(&input_clone);\n            output\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        let output = handle.join().unwrap();\n        println!(\"{}\", output);\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Renderer {\n    template: String,\n}\nimpl Renderer {\n    fn render(&self, user_input: &str) -> String {\n        let mut output = self.template.clone();\n        unsafe {\n            let ptr = user_input.as_ptr();\n            let len = user_input.len();\n            let content = std::str::from_utf8_unchecked(std::slice::from_raw_parts(ptr, len));\n            output = output.replace(\"{input}\", content);\n        }\n        output\n    }\n}\nfn run() {\n    let template = \"<html><body>Welcome, {input}!</body></html>\".to_string();\n    let renderer = Renderer { template };\n    let shared = Arc::new(Mutex::new(renderer));\n    let handles: Vec<_> = (0..4)\n        .map(|_| {\n            let lock = Arc::clone(&shared);\n            thread::spawn(move || {\n                let user_input = \"<script>alert('xss');</script>\"; \n                let guard = lock.lock().unwrap();\n                let result = guard.render(user_input);\n                println!(\"{}\", result);\n            })\n        })\n        .collect();\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\nfn main() {\n    run();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nuse std::sync::{Arc, Mutex};\nstruct WebTemplate {\n    header: String,\n    footer: String,\n}\nimpl WebTemplate {\n    fn new() -> Self {\n        WebTemplate {\n            header: \"<html><head><title>Demo</title></head><body>\".to_string(),\n            footer: \"</body></html>\".to_string(),\n        }\n    }\n    fn render(&self, user_content: &str) -> String {\n        let mut output = String::with_capacity(1024);\n        unsafe {\n            let buf = output.as_mut_vec();\n            buf.extend_from_slice(self.header.as_bytes());\n        }\n        output.push_str(user_content);\n        unsafe {\n            let buf = output.as_mut_vec();\n            buf.extend_from_slice(self.footer.as_bytes());\n        }\n        output\n    }\n}\nfn process_request(user_input: &str) -> String {\n    let template = WebTemplate::new();\n    template.render(user_input)\n}\nfn main() {\n    let shared_response = Arc::new(Mutex::new(String::new()));\n    let input = if cfg!(test) { \"<script>alert('XSS')</script>\" } else { \"<script>alert('XSS')</script>\" };\n    let shared_clone = Arc::clone(&shared_response);\n    let handler = thread::spawn(move || {\n        let response = process_request(input);\n        let mut guard = shared_clone.lock().unwrap();\n        *guard = response;\n    });\n    handler.join().expect(\"Thread panicked\");\n    let result = shared_response.lock().unwrap();\n    println!(\"{}\", *result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct PageTemplate {\n    content: String,\n}\nimpl PageTemplate {\n    fn new() -> Self {\n        PageTemplate {\n            content: \"<html><body>{content}</body></html>\".to_string(),\n        }\n    }\n    unsafe fn render(&self, user_input: *const u8, len: usize) -> String {\n        let slice = std::slice::from_raw_parts(user_input, len);\n        let input_str = std::str::from_utf8_unchecked(slice);\n        self.content.replace(\"{content}\", input_str)\n    }\n}\nfn process_request(input: String) -> String {\n    let template = Arc::new(PageTemplate::new());\n    let user_data = Arc::new(input);\n    let result = Arc::new(Mutex::new(String::new()));\n    let template_clone = Arc::clone(&template);\n    let user_clone = Arc::clone(&user_data);\n    let result_clone = Arc::clone(&result);\n    let handle = thread::spawn(move || {\n        let raw = user_clone.as_ptr();\n        let len = user_clone.len();\n        let page = unsafe { template_clone.render(raw, len) };\n        let mut res = result_clone.lock().unwrap();\n        *res = page;\n    });\n    handle.join().unwrap();\n    Arc::try_unwrap(result).ok().unwrap().into_inner().unwrap()\n}\nfn main() {\n    let malicious = \"<script>alert('XSS');</script>\".to_string();\n    let response = process_request(malicious);\n    println!(\"{}\", response);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Renderer {\n    content: Arc<Mutex<String>>,\n}\nimpl Renderer {\n    fn new() -> Self {\n        Renderer {\n            content: Arc::new(Mutex::new(String::new())),\n        }\n    }\n    fn build_page(&self, input: &str) -> String {\n        let mut page = String::from(\"<html><body>\");\n        unsafe {\n            let raw_ptr = input.as_ptr();\n            let len = input.len();\n            let slice = std::slice::from_raw_parts(raw_ptr, len);\n            let unescaped = String::from_utf8_lossy(slice);\n            page.push_str(&format!(\"<div>{}</div>\", unescaped));\n        }\n        page.push_str(\"</body></html>\");\n        page\n    }\n    fn update_content(&self, text: String) {\n        let shared = Arc::clone(&self.content);\n        let handle = thread::spawn(move || {\n            let mut guard = shared.lock().unwrap();\n            *guard = text;\n        });\n        handle.join().unwrap();\n    }\n}\nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n    let user_input = if args.len() > 1 { &args[1] } else { \"default\" };\n    let renderer = Renderer::new();\n    let page = renderer.build_page(user_input);\n    println!(\"{}\", page);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\npub struct Page {\n    template: String,\n}\nimpl Page {\n    pub fn new(template: &str) -> Self {\n        Page {\n            template: template.to_string(),\n        }\n    }\n    pub fn assemble(&self, user_input: &str) -> String {\n        let ptr = user_input.as_ptr();\n        let len = user_input.len();\n        let unsanitized = unsafe {\n            let raw_slice = std::slice::from_raw_parts(ptr, len);\n            std::str::from_utf8_unchecked(raw_slice)\n        };\n        format!(\"{}{} </body></html>\", self.template, unsanitized)\n    }\n}\nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n    let user_data = if args.len() > 1 {\n        args[1].clone()\n    } else {\n        \"Default Content\".to_string()\n    };\n    let page = Arc::new(Page::new(\"<html><body>\"));\n    let page_clone = Arc::clone(&page);\n    let handle = thread::spawn(move || {\n        page_clone.assemble(&user_data)\n    });\n    let result = handle.join().unwrap();\n    println!(\"{}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Renderer {\n    buffer: Arc<Mutex<String>>,\n}\nimpl Renderer {\n    fn new() -> Self {\n        Renderer {\n            buffer: Arc::new(Mutex::new(String::new())),\n        }\n    }\n    fn render(&self, input: &str) -> String {\n        let cloned_buffer = Arc::clone(&self.buffer);\n        let input_owned = input.to_owned();\n        let handle = thread::spawn(move || {\n            unsafe {\n                let ptr = input_owned.as_ptr();\n                let len = input_owned.len();\n                let slice = std::str::from_utf8_unchecked(std::slice::from_raw_parts(ptr, len));\n                let mut lock = cloned_buffer.lock().unwrap();\n                lock.push_str(slice);\n            }\n        });\n        handle.join().unwrap();\n        let current = self.buffer.lock().unwrap();\n        format!(\"<html><body><div>{}</div></body></html>\", *current)\n    }\n}\nfn main() {\n    let input = env::args().nth(1).unwrap_or_else(|| \"default\".to_string());\n    let engine = Renderer::new();\n    let result = engine.render(&input);\n    println!(\"{}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Renderer {\n    template: String,\n}\nimpl Renderer {\n    fn new() -> Self {\n        Renderer { template: \"<html><body>{}</body></html>\".to_string() }\n    }\n    fn generate(&self, input: &str) -> String {\n        unsafe {\n            let bytes = input.as_bytes();\n            let untrusted = std::str::from_utf8_unchecked(bytes);\n            self.template.replace(\"{}\", untrusted)\n        }\n    }\n}\nfn main() {\n    let renderer = Arc::new(Mutex::new(Renderer::new()));\n    let renderer_clone = Arc::clone(&renderer);\n    let handle = thread::spawn(move || {\n        let input = \"<script>alert('XSS');</script>\";\n        let html = renderer_clone.lock().unwrap().generate(input);\n        println!(\"{}\", html);\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::thread;\nuse std::sync::{Arc, Mutex};\nstruct PageRenderer {\n    template: String,\n}\nimpl PageRenderer {\n    fn new() -> Self {\n        PageRenderer { template: \"<html><body>{content}</body></html>\".to_string() }\n    }\n    fn render(&self, input: &str) -> String {\n        let mut result = self.template.replace(\"{content}\", input);\n        unsafe {\n            let bytes = result.as_mut_vec();\n            for &b in input.as_bytes() {\n                bytes.push(b);\n            }\n        }\n        result\n    }\n}\nfn handle_input(input: String) -> String {\n    let renderer = PageRenderer::new();\n    let shared_output = Arc::new(Mutex::new(String::new()));\n    let shared_clone = Arc::clone(&shared_output);\n    let handle = thread::spawn(move || {\n        let rendered = renderer.render(&input);\n        let mut guard = shared_clone.lock().unwrap();\n        *guard = rendered;\n    });\n    handle.join().unwrap();\n    Arc::try_unwrap(shared_output).unwrap().into_inner().unwrap()\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let user_input = if args.len() > 1 { args[1].clone() } else { \"default\".to_string() };\n    let output = handle_input(user_input);\n    println!(\"{}\", output);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nfn render(input: &str) -> String {\n    let unsafe_str = unsafe { std::str::from_utf8_unchecked(input.as_bytes()) };\n    format!(\"<html><body><h1>Welcome {}</h1></body></html>\", unsafe_str)\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let user_input = if args.len() > 1 { args[1].clone() } else { String::new() };\n    let shared = Arc::new(Mutex::new(user_input));\n    let shared_clone = Arc::clone(&shared);\n    let handle = thread::spawn(move || {\n        let input = shared_clone.lock().unwrap();\n        let page = render(&input);\n        println!(\"{}\", page);\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::str;\npub struct Template {\n    header: Vec<u8>,\n    footer: Vec<u8>,\n}\nimpl Template {\n    pub fn new() -> Self {\n        Template {\n            header: b\"<html><body>\".to_vec(),\n            footer: b\"</body></html>\".to_vec(),\n        }\n    }\n    pub fn render(&self, content: &str) -> String {\n        let mut out = Vec::new();\n        out.extend_from_slice(&self.header);\n        unsafe {\n            let start = out.len();\n            let clen = content.len();\n            out.reserve(clen);\n            std::ptr::copy_nonoverlapping(content.as_ptr(), out.as_mut_ptr().add(start), clen);\n            out.set_len(start + clen);\n        }\n        out.extend_from_slice(&self.footer);\n        unsafe { String::from_utf8_unchecked(out) }\n    }\n}\npub fn main() {\n    let tmpl = Template::new();\n    let user_input = <script>alert('XSS');</script>\"#;\n    let html = tmpl.render(user_input);\n    println!(\"{}\", html);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct TemplateRenderer {\n    data: Arc<Mutex<String>>,\n}\nimpl TemplateRenderer {\n    pub fn new() -> Self {\n        TemplateRenderer {\n            data: Arc::new(Mutex::new(String::from(\"<html><body>\"))),\n        }\n    }\n    pub fn append_user_input(&self, input: &str) {\n        unsafe {\n            let mut locked = self.data.lock().unwrap();\n            locked.push_str(input);\n        }\n    }\n    pub fn render(&self) -> String {\n        let final_html = {\n            let locked = self.data.lock().unwrap();\n            format!(\"{}{}\", *locked, \"</body></html>\")\n        };\n        final_html\n    }\n}\nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n    let user_input = if args.len() > 1 { &args[1] } else { \"\" };\n    let renderer = TemplateRenderer::new();\n    let renderer_clone = renderer.data.clone();\n    let handle = thread::spawn(move || {\n        unsafe {\n            let raw_str = renderer_clone.lock().unwrap().as_mut_ptr();\n            let _ = *raw_str; \n        }\n    });\n    renderer.append_user_input(user_input);\n    handle.join().unwrap();\n    let output = renderer.render();\n    println!(\"{}\", output);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct TemplateEngine {\n    template: String,\n}\nimpl TemplateEngine {\n    fn new(template: &str) -> Self {\n        TemplateEngine {\n            template: template.to_string(),\n        }\n    }\n    fn render(&self, input: &str) -> String {\n        let mut output = self.template.clone();\n        let placeholder = \"{{input}}\";\n        if let Some(pos) = output.find(placeholder) {\n            unsafe {\n                let ptr = output.as_mut_ptr();\n                let bytes = input.as_bytes();\n                for i in 0..bytes.len() {\n                    *ptr.add(pos + i) = bytes[i];\n                }\n            }\n        }\n        output\n    }\n}\nfn main() {\n    let engine = Arc::new(Mutex::new(TemplateEngine::new(\n        \"<html><body>User: {{input}}</body></html>\",\n    )));\n    let engine_clone = engine.clone();\n    let handle = thread::spawn(move || {\n        let eng = engine_clone.lock().unwrap();\n        let user_input = \"<script>alert('xss');</script>\";\n        eng.render(user_input)\n    });\n    let result = handle.join().unwrap();\n    println!(\"{}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\ntrait Template {\n    fn render(&self, input: &str) -> String;\n}\nstruct Page {\n    header: String,\n    content: String,\n}\nimpl Template for Page {\n    fn render(&self, input: &str) -> String {\n        let dangerous = unsafe {\n            let raw = input.as_bytes();\n            std::str::from_utf8_unchecked(raw)\n        };\n        format!(\"{}<div>{}</div>{}\", self.header, dangerous, self.content)\n    }\n}\nfn process(input: &str, page: Arc<Mutex<Page>>) -> String {\n    let result = {\n        let guard = page.lock().unwrap();\n        guard.render(input)\n    };\n    result\n}\nfn main() {\n    let page = Arc::new(Mutex::new(Page {\n        header: \"<html><head><title>Test</title></head><body>\".to_string(),\n        content: \"</body></html>\".to_string(),\n    }));\n    let injection = \"<script>alert('XSS');</script>\";\n    let mut threads = vec![];\n    for _ in 0..4 {\n        let copy = Arc::clone(&page);\n        let text = injection.to_string();\n        threads.push(thread::spawn(move || process(&text, copy)));\n    }\n    for handle in threads {\n        let html = handle.join().unwrap();\n        println!(\"{}\", html);\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::str;\nstruct Renderer {\n    tpl: String,\n}\nimpl Renderer {\n    fn new(template: &str) -> Self {\n        Renderer {\n            tpl: template.to_owned(),\n        }\n    }\n    fn render(&self, input: &str) -> String {\n        let mut output = self.tpl.clone();\n        unsafe {\n            let bytes = input.as_bytes();\n            let untrusted = str::from_utf8_unchecked(bytes);\n            output = output.replace(\"{user_data}\", untrusted);\n        }\n        output\n    }\n}\nfn concurrent_process(renderer: Arc<Mutex<Renderer>>, input: String) -> String {\n    let handle = thread::spawn(move || {\n        let renderer = renderer.lock().unwrap();\n        renderer.render(&input)\n    });\n    handle.join().unwrap()\n}\nfn main() {\n    let tpl = \"<html><body>Hello, {user_data}!</body></html>\";\n    let renderer = Arc::new(Mutex::new(Renderer::new(tpl)));\n    let user_input = \"<script>alert('XSS');</script>\".to_string();\n    let result = concurrent_process(renderer, user_input);\n    println!(\"Output: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nfn unsafe_copy(src: *const u8, dest: *mut u8, count: usize) {\n    unsafe {\n        std::ptr::copy_nonoverlapping(src, dest, count);\n    }\n}\nstruct App {\n}\nimpl App {\n    fn new() -> Self {\n        App {}\n    }\n    fn render(&self, input: &str) -> String {\n        let header = \"<html><body>Hello, \";\n        let footer = \"</body></html>\";\n        let total_len = header.len() + input.len() + footer.len();\n        let mut buffer: Vec<u8> = Vec::with_capacity(total_len);\n        unsafe {\n            buffer.set_len(total_len);\n            std::ptr::copy_nonoverlapping(header.as_ptr(), buffer.as_mut_ptr(), header.len());\n            std::ptr::copy_nonoverlapping(\n                input.as_ptr(),\n                buffer.as_mut_ptr().add(header.len()),\n                input.len(),\n            );\n            std::ptr::copy_nonoverlapping(\n                footer.as_ptr(),\n                buffer.as_mut_ptr().add(header.len() + input.len()),\n                footer.len(),\n            );\n        }\n        String::from_utf8(buffer).unwrap()\n    }\n    fn handle(&self, payload: String) -> String {\n        self.render(&payload)\n    }\n}\nfn main() {\n    let app = Arc::new(App::new());\n    let app_clone = Arc::clone(&app);\n    let handle = thread::spawn(move || {\n        let attack_payload = \"<script>alert('XSS');</script>\";\n        app_clone.handle(attack_payload.to_string())\n    });\n    let output = handle.join().unwrap();\n    println!(\"{}\", output);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Renderer {\n    data: Arc<Mutex<String>>,\n}\nimpl Renderer {\n    fn new() -> Self {\n        Renderer {\n            data: Arc::new(Mutex::new(String::new())),\n        }\n    }\n    fn render(&self, input: &str) -> String {\n        unsafe {\n            let raw_input: &str = std::str::from_utf8_unchecked(input.as_bytes());\n            format!(\"<html><body>Hello, {}!</body></html>\", raw_input)\n        }\n    }\n}\nfn main() {\n    let renderer = Renderer::new();\n    let inputs = vec![\"Alice\", \"<script>alert('XSS')</script>\"];\n    let threads: Vec<_> = inputs\n        .into_iter()\n        .map(|text| {\n            let clone = renderer.data.clone();\n            let instance = Renderer { data: clone };\n            let payload = text.to_string();\n            thread::spawn(move || {\n                instance.render(&payload)\n            })\n        })\n        .collect();\n    for t in threads {\n        let result = t.join().expect(\"Thread panicked\");\n        let mut locked = renderer.data.lock().unwrap();\n        *locked = result.clone();\n        println!(\"{}\", result);\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::cell::UnsafeCell;\nuse std::sync::Arc;\nuse std::thread;\nstruct Counter {\n    count: UnsafeCell<u32>,\n}\nunsafe impl Sync for Counter {}\nimpl Counter {\n    fn new() -> Self {\n        Counter { count: UnsafeCell::new(1) }\n    }\n    fn update(&self, factor: u32) {\n        unsafe {\n            let ptr = self.count.get();\n            let current = *ptr;\n            let computed = ((current as u64) * (factor as u64)) as u32;\n            *ptr = computed;\n        }\n    }\n    fn value(&self) -> u32 {\n        unsafe { *self.count.get() }\n    }\n}\nfn run_and_fetch() -> u32 {\n    let counter = Arc::new(Counter::new());\n    let mut threads = Vec::new();\n    for _ in 0..4 {\n        let cnt = counter.clone();\n        threads.push(thread::spawn(move || {\n            for _ in 0..5 {\n                cnt.update(0x4000_0000);\n            }\n        }));\n    }\n    for t in threads {\n        t.join().unwrap();\n    }\n    counter.value()\n}\nfn run_app() {\n    let final_val = run_and_fetch();\n    println!(\"Final value: {}\", final_val);\n}\nfn main() {\n    run_app();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\npub struct Engine {\n    value: u32,\n}\nimpl Engine {\n    pub unsafe fn compute(&self, factor: u32) -> u32 {\n        let ptr: *const u32 = &self.value as *const u32;\n        let v = *ptr;\n        v * factor\n    }\n    pub fn process(&self, factor: u32) -> u32 {\n        unsafe { self.compute(factor) }\n    }\n}\nfn main() {\n    let engine = Arc::new(Engine { value: u32::MAX / 2 + 1 });\n    let engine_clone = Arc::clone(&engine);\n    let handle = thread::spawn(move || {\n        engine_clone.process(2)\n    });\n    let result = handle.join().unwrap();\n    println!(\"Result: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::alloc::{alloc, dealloc, Layout};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\npub struct Buffer {\n    pub data: *mut u8,\n    pub size: usize,\n}\nimpl Buffer {\n    pub fn new(count: usize, elem_size: usize) -> Result<Buffer, &'static str> {\n        let shared = Arc::new(Mutex::new(0usize));\n        let shared_clone = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            let mut val = shared_clone.lock().unwrap();\n            unsafe {\n                *val = count.wrapping_mul(elem_size);\n            }\n        });\n        handle.join().unwrap();\n        let total_size = *shared.lock().unwrap();\n        let layout = Layout::from_size_align(total_size, 8).map_err(|_| \"Layout error\")?;\n        let ptr = unsafe { alloc(layout) };\n        if ptr.is_null() && total_size != 0 {\n            return Err(\"Allocation failed\");\n        }\n        Ok(Buffer { data: ptr, size: total_size })\n    }\n    pub fn fill(&self, value: u8) {\n        unsafe {\n            for i in 0..self.size {\n                *self.data.add(i) = value;\n            }\n        }\n    }\n}\nimpl Drop for Buffer {\n    fn drop(&mut self) {\n        if self.size != 0 {\n            unsafe {\n                let layout = Layout::from_size_align(self.size, 8).unwrap();\n                dealloc(self.data, layout);\n            }\n        }\n    }\n}\nfn main() {\n    let buf = Buffer::new(usize::MAX / 2 + 1, 2)\n        .expect(\"Buffer creation failed\");\n    buf.fill(0xAA);\n    println!(\"Buffer filled with 0xAA\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\npub struct Matrix {\n    data: Box<[u8]>,\n    rows: u32,\n    cols: u32,\n}\nimpl Matrix {\n    pub fn create(rows: u32, cols: u32) -> Result<Matrix, &'static str> {\n        let total = rows.wrapping_mul(cols);                   \n        let expected = (rows as u64 * cols as u64) as usize;\n        let alloc_size = total as usize;                         \n        let mut buf = Vec::with_capacity(alloc_size);\n        unsafe {\n            buf.set_len(alloc_size);                             \n        }\n        Ok(Matrix {\n            data: buf.into_boxed_slice(),\n            rows,\n            cols,\n        })\n    }\n    pub fn size(&self) -> usize {\n        self.data.len()\n    }\n    pub fn fill(&mut self, value: u8) {\n        let ptr = self.data.as_mut_ptr();\n        unsafe {\n            for i in 0..self.data.len() {\n                *ptr.add(i) = value;\n            }\n        }\n    }\n}\nfn main() {\n    let rows = 100_000;\n    let cols = 200_000;\n    let matrix = Matrix::create(rows, cols).expect(\"Matrix creation failed\");\n    let mut handle_matrix = matrix;\n    handle_matrix.fill(42);\n    let shared = Arc::new(Mutex::new(handle_matrix));\n    let thread_shared = Arc::clone(&shared);\n    let th = thread::spawn(move || {\n        let matrix = thread_shared.lock().unwrap();\n        println!(\"Matrix size (elements): {}\", matrix.size());\n    });\n    th.join().unwrap();\n    println!(\"Main thread: Matrix created with {} rows and {} cols\", rows, cols);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\npub trait Multiply {\n    fn calc(&self, x: u32) -> Result<u32, &'static str>;\n}\npub struct Operator;\nimpl Multiply for Operator {\n    fn calc(&self, x: u32) -> Result<u32, &'static str> {\n        let product = unsafe {\n            let res = x.wrapping_mul(x);\n            res\n        };\n        Ok(product)\n    }\n}\npub fn get_result(x: u32) -> Result<u32, &'static str> {\n    let op = Operator;\n    op.calc(x)\n}\nfn main() {\n    let value = 70000;\n    let op = Arc::new(Operator);\n    let mut handles = Vec::new();\n    for _ in 0..4 {\n        let op_clone = Arc::clone(&op);\n        let val = value;\n        handles.push(thread::spawn(move || {\n            let res = op_clone.calc(val);\n            println!(\"Result: {:?}\", res);\n            res\n        }));\n    }\n    for handle in handles {\n        let _ = handle.join();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\n#![allow(unused_variables)]\nuse std::thread;\npub mod calc {\n    pub fn compute(a: u64, b: u64) -> Result<u32, &'static str> {\n        unsafe {\n            let prod: u64 = a * b;\n            let mut result: u32 = 0;\n            let result_ptr: *mut u32 = &mut result as *mut u32;\n            *result_ptr = prod as u32;\n            Ok(*result_ptr)\n        }\n    }\n}\nfn main() {\n    let a: u64 = 3_000_000_000; \n    let b: u64 = 4;\n    let handle = thread::spawn(move || {\n        match calc::compute(a, b) {\n            Ok(val) => {\n                println!(\"Computed value: {}\", val);\n                val\n            },\n            Err(err) => {\n                println!(\"Error: {}\", err);\n                0\n            }\n        }\n    });\n    let result = handle.join().expect(\"Thread panicked\");\n    if result == 0 || result == (a * b) as u32 {\n        std::process::exit(1);\n    } else {\n        std::process::exit(0);\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Processor {\n    value: u32,\n}\nimpl Processor {\n    pub unsafe fn compute(&self) -> u64 {\n        let intermediate = self.value.wrapping_mul(100_000);\n        intermediate as u64\n    }\n}\nfn simulate(input: u32) -> u64 {\n    let proc = Processor { value: input };\n    let shared = Arc::new(Mutex::new(proc));\n    let shared_clone = Arc::clone(&shared);\n    let handle = thread::spawn(move || {\n        let proc_guard = shared_clone.lock().unwrap();\n        unsafe { proc_guard.compute() }\n    });\n    handle.join().unwrap()\n}\nfn main() {\n    let input = 50_000; \n    let result = simulate(input);\n    println!(\"Result: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#!/usr/bin/env rust\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::mem;\nstruct Buffer {\n    data: Box<[u32]>,\n}\nimpl Buffer {\n    unsafe fn new(count: u32) -> Self {\n        let bytes = count * (mem::size_of::<u32>() as u32); \n        let allocation = bytes as usize; \n        let mut vec = Vec::with_capacity(allocation);\n        vec.set_len(allocation);\n        let num_elements = allocation / mem::size_of::<u32>();\n        let data = Vec::from_raw_parts(vec.as_mut_ptr() as *mut u32, num_elements, num_elements)\n                   .into_boxed_slice();\n        std::mem::forget(vec);\n        Buffer { data }\n    }\n    fn write_all(&mut self, value: u32) {\n        for i in 0..self.data.len() {\n            self.data[i] = value;\n        }\n    }\n    fn sum(&self) -> u32 {\n        self.data.iter().fold(0, |acc, &v| acc.wrapping_add(v))\n    }\n}\npub fn run(input: u32) -> Result<u32, String> {\n    unsafe {\n        let buf = Buffer::new(input);\n        let arc = Arc::new(Mutex::new(buf));\n        let arc_clone = Arc::clone(&arc);\n        let handle = thread::spawn(move || {\n            let mut b = arc_clone.lock().unwrap();\n            b.write_all(1);\n        });\n        handle.join().unwrap();\n        let b_locked = arc.lock().unwrap();\n        Ok(b_locked.sum())\n    }\n}\nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n    let input: u32 = if args.len() > 1 {\n        args[1].parse().unwrap_or(10)\n    } else {\n        10\n    };\n    match run(input) {\n        Ok(s) => println!(\"Sum: {}\", s),\n        Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Calculator {}\nimpl Calculator {\n    pub fn compute(&self, a: u64, b: u64) -> Result<u32, &'static str> {\n        let product = a * b;\n        unsafe {\n            let res = product as u32;\n            Ok(res)\n        }\n    }\n}\nfn main() {\n    let calc = Calculator {};\n    let a = 100_000;\n    let b = 100_000;\n    let shared_calc = Arc::new(calc);\n    let mut handles = Vec::new();\n    for _ in 0..4 {\n        let calc_clone = Arc::clone(&shared_calc);\n        let handle = thread::spawn(move || {\n            calc_clone.compute(a, b)\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        match handle.join().unwrap() {\n            Ok(val) => println!(\"Result: {}\", val),\n            Err(e) => println!(\"Error: {}\", e),\n        }\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Engine {\n    factor: u32,\n}\nimpl Engine {\n    fn compute(&self, input: u32) -> u32 {\n        let res: u32;\n        unsafe {\n            let ptr = &self.factor as *const u32;\n            let factor_val = *ptr;\n            res = input * factor_val;\n        }\n        res\n    }\n}\nfn concurrent_process(engine: Arc<Engine>, inputs: Vec<u32>) -> Vec<u32> {\n    let results = Arc::new(Mutex::new(vec![]));\n    let mut handles = vec![];\n    for inp in inputs {\n        let engine_clone = Arc::clone(&engine);\n        let results_clone = Arc::clone(&results);\n        let handle = thread::spawn(move || {\n            let value = engine_clone.compute(inp);\n            let mut res_guard = results_clone.lock().unwrap();\n            res_guard.push(value);\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    Arc::try_unwrap(results).unwrap().into_inner().unwrap()\n}\npub fn compute_total() -> u32 {\n    let engine = Arc::new(Engine { factor: 1_000_000 });\n    let inputs = vec![5_000; 10];\n    let results = concurrent_process(engine, inputs);\n    results.into_iter().fold(0u32, |acc, x| acc.wrapping_add(x))\n}\nfn main() {\n    let total = compute_total();\n    println!(\"Total: {}\", total);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Calculator {\n    sum: u32,\n}\nimpl Calculator {\n    fn add(&mut self, value: u32) {\n        unsafe {\n            let ptr = &mut self.sum as *mut u32;\n            *ptr = (self.sum as u64 + value as u64) as u32;\n        }\n    }\n    fn get(&self) -> u32 {\n        self.sum\n    }\n}\nfn main() {\n    let calc = Arc::new(Mutex::new(Calculator { sum: u32::MAX - 5 }));\n    let mut handles = Vec::new();\n    for _ in 0..2 {\n        let calc_clone = Arc::clone(&calc);\n        let handle = thread::spawn(move || {\n            let mut calc_lock = calc_clone.lock().unwrap();\n            calc_lock.add(10);\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    let final_result = calc.lock().unwrap().get();\n    println!(\"Final result: {}\", final_result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::alloc;\nuse std::thread;\ntrait Processor {\n    fn process(&self, count: u32) -> Result<usize, &'static str>;\n}\nstruct BufferProcessor;\nimpl BufferProcessor {\n    fn new() -> Self {\n        BufferProcessor\n    }\n}\nimpl Processor for BufferProcessor {\n    fn process(&self, count: u32) -> Result<usize, &'static str> {\n        let elem_size = std::mem::size_of::<u32>();\n        let total_size = unsafe { count.wrapping_mul(elem_size as u32) as usize };\n        let layout = alloc::Layout::from_size_align(total_size, std::mem::align_of::<u32>())\n            .map_err(|_| \"Invalid layout\")?;\n        let ptr = unsafe { alloc::alloc(layout) as *mut u32 };\n        if ptr.is_null() {\n            return Err(\"Allocation failed\");\n        }\n        unsafe {\n            for i in 0..count as usize {\n                *ptr.add(i) = i as u32;\n            }\n        }\n        unsafe {\n            alloc::dealloc(ptr as *mut u8, layout);\n        }\n        println!(\"Processed {} items with capacity {}\", count, total_size);\n        Ok(total_size)\n    }\n}\nfn main() {\n    let processor = BufferProcessor::new();\n    let count = 0x40000000; \n    let handle = thread::spawn(move || {\n        match processor.process(count) {\n            Ok(size) => println!(\"Computation successful: capacity = {}\", size),\n            Err(e) => println!(\"Error: {}\", e),\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(overflowing_literals)]\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Engine {\n    value: u32,\n}\nimpl Engine {\n    fn new(initial: u32) -> Self {\n        Engine { value: initial }\n    }\n    fn process(&mut self, a: u32, b: u32) {\n        unsafe {\n            let product = ((a as u64) * (b as u64)) as u32;\n            self.value = self.value.wrapping_add(product);\n        }\n    }\n}\nfn main() {\n    let engine = Arc::new(Mutex::new(Engine::new(0)));\n    let engine_cloned = Arc::clone(&engine);\n    let handle = thread::spawn(move || {\n        let a: u32 = 30000;\n        let b: u32 = 150000;\n        let mut eng = engine_cloned.lock().unwrap();\n        eng.process(a, b);\n    });\n    handle.join().unwrap();\n    let final_val = engine.lock().unwrap().value;\n    println!(\"Final value: {}\", final_val);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Processor {\n    total: Arc<Mutex<u32>>,\n}\nimpl Processor {\n    fn new() -> Self {\n        Processor {\n            total: Arc::new(Mutex::new(0)),\n        }\n    }\n    fn combine(&self, x: u32, y: u32) {\n        let prod = unsafe {\n            let p = x * y;\n            p\n        };\n        let raw_ptr = &mut *self.total.lock().unwrap() as *mut u32;\n        unsafe {\n            *raw_ptr = (*raw_ptr).wrapping_add(prod);\n        }\n    }\n    fn get_total(&self) -> u32 {\n        *self.total.lock().unwrap()\n    }\n}\nfn main() {\n    let proc = Processor::new();\n    let handles: Vec<_> = (0..4)\n        .map(|_| {\n            let clone = Processor {\n                total: Arc::clone(&proc.total),\n            };\n            thread::spawn(move || {\n                clone.combine(3000000000, 2);\n            })\n        })\n        .collect();\n    for h in handles {\n        h.join().unwrap();\n    }\n    println!(\"Total: {}\", proc.get_total());\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::thread;\nstruct Processor;\nimpl Processor {\n    fn compute(&self, input: i32) -> i32 {\n        unsafe {\n            input.wrapping_mul(100_000)\n        }\n    }\n    fn dispatch(&self, input: i32) -> i32 {\n        let mut result = 0;\n        let handle = thread::spawn({\n            let input_clone = input;\n            move || {\n                unsafe {\n                    input_clone.wrapping_mul(100_000)\n                }\n            }\n        });\n        result = self.compute(input);\n        let thread_result = handle.join().unwrap();\n        result.wrapping_add(thread_result)\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let input_val: i32 = if args.len() > 1 {\n        args[1].parse().unwrap_or(50000)\n    } else {\n        50000\n    };\n    let processor = Processor;\n    let final_result = processor.dispatch(input_val);\n    println!(\"Result: {}\", final_result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Calculator {\n    total: i32,\n}\nimpl Calculator {\n    fn new() -> Self {\n        Calculator { total: 0 }\n    }\n    fn accumulate(&mut self, a: i32, b: i32) {\n        unsafe {\n            let product = (a as i64).wrapping_mul(b as i64);\n            self.total = self.total.wrapping_add(product as i32);\n        }\n    }\n}\npub fn run_accumulation(a: i32, b: i32, iterations: usize, threads: usize) -> i64 {\n    let calc = Arc::new(Mutex::new(Calculator::new()));\n    let mut handles = Vec::with_capacity(threads);\n    for _ in 0..threads {\n        let calc_clone = Arc::clone(&calc);\n        let a_copy = a;\n        let b_copy = b;\n        let handle = thread::spawn(move || {\n            for _ in 0..iterations {\n                let mut calc = calc_clone.lock().unwrap();\n                calc.accumulate(a_copy, b_copy);\n            }\n        });\n        handles.push(handle);\n    }\n    for h in handles {\n        h.join().unwrap();\n    }\n    let result = calc.lock().unwrap().total;\n    result as i64\n}\nfn main() {\n    let result = run_accumulation(50000, 100000, 1000, 4);\n    println!(\"Computed total: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\npub struct Processor {\n    buffer: Vec<u8>,\n}\nimpl Processor {\n    pub fn new(size: usize) -> Self {\n        Processor { buffer: vec![0u8; size] }\n    }\n    pub fn compute_offset(&self, index: u32) -> Result<usize, &'static str> {\n        let factor: usize = 0x4000_0000; \n        let offset = (index as usize).wrapping_mul(factor);\n        Ok(offset)\n    }\n    pub fn process(&mut self, index: u32, value: u8) -> Result<(), &'static str> {\n        let offset = self.compute_offset(index)?;\n        unsafe {\n            let ptr = self.buffer.as_mut_ptr().add(offset);\n            *ptr = value;\n        }\n        Ok(())\n    }\n}\nfn concurrent_process(proc_arc: Arc<Mutex<Processor>>, index: u32, value: u8) -> Result<(), &'static str> {\n    let proc_clone = Arc::clone(&proc_arc);\n    let handle = thread::spawn(move || {\n        let mut guard = proc_clone.lock().unwrap();\n        guard.process(index, value)\n    });\n    handle.join().unwrap()\n}\nfn main() {\n    let processor = Arc::new(Mutex::new(Processor::new(1024)));\n    let input: u32 = u32::MAX; \n    let _ = concurrent_process(processor, input, 42);\n    println!(\"Execution complete.\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\ntrait Operation {\n    fn compute(&self, factor: u32) -> u32;\n}\nstruct Processor {\n    data: u32,\n}\nimpl Operation for Processor {\n    fn compute(&self, factor: u32) -> u32 {\n        unsafe {\n            let product = (self.data as u64) * (factor as u64);\n            product as u32\n        }\n    }\n}\nfn run_concurrency(proc: Arc<Processor>, factor: u32) -> u32 {\n    let handle = thread::spawn(move || {\n        proc.compute(factor)\n    });\n    handle.join().unwrap()\n}\nfn run_app() -> u32 {\n    let proc = Arc::new(Processor { data: 100_000 });\n    run_concurrency(proc, 50_000)\n}\nfn main() {\n    let result = run_app();\n    println!(\"Outcome: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nstruct Processor {\n    factor: u32,\n}\nimpl Processor {\n    fn new() -> Self {\n        Processor { factor: 100_000 }\n    }\n    fn compute(&self, x: u32) -> u64 {\n        let product: u64 = (x as u64) * (self.factor as u64);\n        unsafe {\n            std::ptr::read(&product as *const u64 as *const u32) as u64\n        }\n    }\n}\npub fn execute() -> u64 {\n    let engine = Processor::new();\n    let inputs = vec![50_000u32, 100, 200];\n    let mut threads = Vec::new();\n    for &val in &inputs {\n        let eng = Processor { factor: engine.factor };\n        threads.push(thread::spawn(move || {\n            eng.compute(val)\n        }));\n    }\n    let mut total: u64 = 0;\n    for th in threads {\n        total = total.wrapping_add(th.join().unwrap());\n    }\n    total\n}\nfn main() {\n    let result = execute();\n    println!(\"Total: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Data {\n    num: u32,\n}\nimpl Data {\n    fn new(val: u32) -> Self {\n        Data { num: val }\n    }\n    fn process(&mut self, factor: u32) {\n        unsafe {\n            let prod = (self.num as u64 * factor as u64) as u32;\n            self.num = self.num.wrapping_add(prod);\n        }\n    }\n    fn value(&self) -> u32 {\n        self.num\n    }\n}\nfn update_concurrently(shared: Arc<Mutex<Data>>, factor: u32) {\n    let mut threads = Vec::new();\n    for _ in 0..2 {\n        let clone = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            let mut data = clone.lock().unwrap();\n            data.process(factor);\n        });\n        threads.push(handle);\n    }\n    for t in threads {\n        t.join().unwrap();\n    }\n}\nfn main() {\n    let data = Arc::new(Mutex::new(Data::new(0x40000000)));\n    update_concurrently(Arc::clone(&data), 4);\n    let final_value = data.lock().unwrap().value();\n    println!(\"Final value: {}\", final_value);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "--------------------------------------------------\nuse std::env;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\nuse std::ffi::c_void;\nstruct Executor;\nimpl Executor {\n    pub fn run(input: &str) -> Result<(), String> {\n        let shared_counter = Arc::new(Mutex::new(0));\n        let mut threads = vec![];\n        for i in 0..4 {\n            let counter = Arc::clone(&shared_counter);\n            let param = input.to_owned();\n            let handle = thread::spawn(move || {\n                unsafe {\n                    let res = risky_operation(i, &param);\n                    let _ = res; \n                }\n                let mut num = counter.lock().unwrap();\n                *num += 1;\n            });\n            threads.push(handle);\n        }\n        for th in threads {\n            let _ = th.join();\n        }\n        if *shared_counter.lock().unwrap() == 4 {\n            Ok(())\n        } else {\n            Err(\"Not all tasks completed correctly\".to_owned())\n        }\n    }\n}\nunsafe fn risky_operation(task_id: u32, param: &str) -> Result<(), &'static str> {\n    if param.contains(\"fail\") && task_id == 2 {\n        Err(\"Operation failed in unsafe block\")\n    } else {\n        Ok(())\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let input = if args.len() > 1 {\n        args[1].clone()\n    } else {\n        \"pass\".to_owned()\n    };\n    let _ = Executor::run(&input);\n    println!(\"Execution finished.\");\n}\n--------------------------------------------------\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs;\nuse std::thread;\nuse std::sync::Arc;\nuse std::io;\nstruct Processor;\nimpl Processor {\n    fn run(&self, data: &str) -> bool {\n        let len = data.len();\n        let mut buffer = Vec::with_capacity(len);\n        unsafe {\n            buffer.set_len(len);\n            std::ptr::copy_nonoverlapping(data.as_ptr(), buffer.as_mut_ptr(), len);\n        }\n        let message = format!(\"Processed: {}\", String::from_utf8_lossy(&buffer));\n        let msg_arc = Arc::new(message);\n        let handles: Vec<_> = (0..2).map(|_| {\n            let msg_clone = Arc::clone(&msg_arc);\n            thread::spawn(move || {\n                unsafe {\n                    let _ = Self::update_file(&msg_clone);\n                }\n            })\n        }).collect();\n        for handle in handles {\n            let _ = handle.join();\n        }\n        true\n    }\n    unsafe fn update_file(msg: &str) -> io::Result<()> {\n        if msg.contains(\"fail\") {\n            return Err(io::Error::new(io::ErrorKind::Other, \"simulated failure\"));\n        }\n        let _ = fs::write(\"log.txt\", msg);\n        Ok(())\n    }\n}\nfn main() {\n    let processor = Processor;\n    let input = \"test input\";\n    processor.run(input);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Processor {\n    config: Arc<Mutex<Config>>,\n}\nstruct Config {\n    value: i32,\n}\nimpl Processor {\n    unsafe fn modify(&self, new_val: i32) -> Result<(), &'static str> {\n        let mut cfg = self.config.lock().unwrap();\n        let ptr = &mut *cfg as *mut Config;\n        (*ptr).value = new_val;\n        if new_val < 0 {\n            return Err(\"value cannot be negative\");\n        }\n        Ok(())\n    }\n    fn execute(&self, new_val: i32) {\n        unsafe {\n            let _ = self.modify(new_val);\n        }\n    }\n}\nfn main() {\n    let cfg = Arc::new(Mutex::new(Config { value: 0 }));\n    let proc_inst = Processor { config: cfg.clone() };\n    let t1_config = cfg.clone();\n    let t1 = thread::spawn(move || {\n        let proc_obj = Processor { config: t1_config };\n        proc_obj.execute(10);\n    });\n    t1.join().unwrap();\n    proc_inst.execute(-5);\n    let final_val = cfg.lock().unwrap().value;\n    if final_val < 0 {\n        panic!(\"Invariant violation: negative value detected\");\n    }\n    println!(\"Final value: {}\", final_val);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Machine {\n    active: bool,\n    counter: u32,\n}\nimpl Machine {\n    unsafe fn init(&mut self) -> Result<(), &'static str> {\n        if self.active {\n            Ok(())\n        } else {\n            Err(\"machine inactive\")\n        }\n    }\n    fn operate(&self, shared: Arc<Mutex<Machine>>) -> i32 {\n        {\n            let mut mach = shared.lock().unwrap();\n            let _ = unsafe { mach.init() };\n            mach.counter += 1; \n        }\n        let shared_clone = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            let mut mach = shared_clone.lock().unwrap();\n            mach.counter += 2;\n        });\n        handle.join().unwrap();\n        let mach = shared.lock().unwrap();\n        mach.counter as i32\n    }\n}\npub fn execute() -> Result<i32, &'static str> {\n    let machine = Machine { active: false, counter: 0 };\n    let shared = Arc::new(Mutex::new(machine));\n    let result = {\n        let mach = shared.lock().unwrap();\n        mach.operate(Arc::clone(&shared))\n    };\n    Ok(result)\n}\nfn main() {\n    match execute() {\n        Ok(val) => println!(\"Result: {}\", val),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct SecureData {\n    value: i32,\n}\nimpl SecureData {\n    unsafe fn update(&mut self, delta: i32) -> Result<(), &'static str> {\n        if self.value + delta < 0 || self.value + delta > 100 {\n            self.value += delta;\n            return Err(\"value out of range\");\n        }\n        self.value += delta;\n        Ok(())\n    }\n}\nfn process(data: Arc<Mutex<SecureData>>, delta: i32) {\n    let mut handles = Vec::new();\n    for _ in 0..5 {\n        let data_cloned = Arc::clone(&data);\n        let h = thread::spawn(move || {\n            unsafe {\n                let mut guard = data_cloned.lock().unwrap();\n                let _ = guard.update(delta);\n            }\n        });\n        handles.push(h);\n    }\n    for h in handles {\n        h.join().unwrap();\n    }\n}\npub fn run() -> i32 {\n    let initial = SecureData { value: 50 };\n    let shared = Arc::new(Mutex::new(initial));\n    process(Arc::clone(&shared), 10);\n    process(Arc::clone(&shared), 60);\n    let final_val = shared.lock().unwrap().value;\n    final_val\n}\nfn main() {\n    let final_value = run();\n    println!(\"Final value: {}\", final_value);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "--------------------------------------------------\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Buffer {\n    data: [u8; 1024],\n}\nimpl Buffer {\n    unsafe fn copy_into(&mut self, src: &[u8]) -> Result<(), &'static str> {\n        if src.len() > self.data.len() {\n            return Err(\"source too long\");\n        }\n        std::ptr::copy_nonoverlapping(src.as_ptr(), self.data.as_mut_ptr(), src.len());\n        Ok(())\n    }\n}\nfn execute_task(input: &[u8]) -> Result<(), &'static str> {\n    let shared = Arc::new(Mutex::new(Buffer { data: [0; 1024] }));\n    let shared_clone = Arc::clone(&shared);\n    let handle = thread::spawn(move || {\n        let mut guard = shared_clone.lock().unwrap();\n        unsafe {\n            let _ = guard.copy_into(input);\n        }\n    });\n    let _ = handle.join();\n    Ok(())\n}\npub fn run_processing(input: &[u8]) -> Result<(), &'static str> {\n    execute_task(input)\n}\nfn main() {\n    let input = vec![1u8; 2048];\n    let _ = run_processing(&input);\n    println!(\"Operation completed (vulnerable).\");\n}\n--------------------------------------------------\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::ptr;\nstruct Data {\n    count: Arc<Mutex<u32>>,\n}\nimpl Data {\n    unsafe fn update(&self, new_val: u32) -> Result<(), &'static str> {\n        let mut guard = self.count.lock().unwrap();\n        let raw_ptr = &mut *guard as *mut u32;\n        if new_val > 100 {\n            return Err(\"Value exceeds maximum allowed threshold\");\n        }\n        ptr::write(raw_ptr, new_val);\n        Ok(())\n    }\n}\nfn run() {\n    let data = Data { count: Arc::new(Mutex::new(0)) };\n    let data_clone = Data { count: Arc::clone(&data.count) };\n    let handle = thread::spawn(move || {\n        unsafe {\n            let _ = data_clone.update(150);\n        }\n    });\n    handle.join().unwrap();\n    let final_value = *data.count.lock().unwrap();\n    println!(\"Final value: {}\", final_value);\n}\nfn main() {\n    run();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nstatic mut GLOBAL: u32 = 0;\nunsafe fn unsafe_update(value: u32) -> Result<(), &'static str> {\n    if value > 1000 {\n        Err(\"value too high\")\n    } else {\n        Ok(())\n    }\n}\nfn execute() -> u32 {\n    let value: u32 = 1500;\n    unsafe {\n        let _ = unsafe_update(value);\n        GLOBAL = GLOBAL.wrapping_add(value);\n        GLOBAL\n    }\n}\nfn main() {\n    let handle = thread::spawn(|| {\n        let res = execute();\n        println!(\"Result in thread: {}\", res);\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::fs::OpenOptions;\nuse std::io::Write;\nstruct Worker {\n    shared: Arc<Mutex<u32>>,\n}\nimpl Worker {\n    unsafe fn update(&self, val: u32) {\n        let raw = Arc::as_ptr(&self.shared) as *const Mutex<u32>;\n        let lock = &*raw;\n        let _guard = lock.lock().unwrap();\n        if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(\"data.log\") {\n            let _ = write!(file, \"{}\", val);\n        }\n    }\n    fn run(&self, iterations: u32) {\n        let mut threads = Vec::new();\n        for i in 0..iterations {\n            let shared_clone = self.shared.clone();\n            let handle = thread::spawn(move || {\n                unsafe {\n                    let raw = Arc::as_ptr(&shared_clone) as *const Mutex<u32>;\n                    let lock = &*raw;\n                    let mut guard = lock.lock().unwrap();\n                    *guard += i;\n                }\n                if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(\"data.log\") {\n                    let _ = write!(file, \"{}\", i);\n                }\n            });\n            threads.push(handle);\n        }\n        for th in threads {\n            let _ = th.join();\n        }\n    }\n}\nfn main() {\n    let counter = Arc::new(Mutex::new(0));\n    let worker = Worker { shared: counter };\n    unsafe {\n        worker.update(100);\n    }\n    worker.run(10);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::cell::UnsafeCell;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\npub trait Task {\n    fn execute(&self) -> Result<(), &'static str>;\n}\npub struct Worker {\n    manager: Arc<Manager>,\n    val: u8,\n}\nimpl Task for Worker {\n    fn execute(&self) -> Result<(), &'static str> {\n        let res = self.manager.append(self.val);\n        unsafe {\n            let ptr = self.manager.raw_data();\n            let _ = *ptr;\n        }\n        res\n    }\n}\npub struct Manager {\n    data: Mutex<Vec<u8>>,\n    capacity: usize,\n}\nimpl Manager {\n    pub fn new(cap: usize) -> Self {\n        Self {\n            data: Mutex::new(Vec::with_capacity(cap)),\n            capacity: cap,\n        }\n    }\n    pub fn append(&self, byte: u8) -> Result<(), &'static str> {\n        let mut guard = self.data.lock().unwrap();\n        if guard.len() >= self.capacity {\n            return Err(\"capacity exceeded\");\n        }\n        guard.push(byte);\n        Ok(())\n    }\n    pub unsafe fn raw_data(&self) -> *const u8 {\n        self.data.lock().unwrap().as_ptr()\n    }\n    pub fn len(&self) -> usize {\n        let guard = self.data.lock().unwrap();\n        guard.len()\n    }\n}\nfn run() {\n    let mgr = Arc::new(Manager::new(10));\n    let mut threads = vec![];\n    for i in 0..20 {\n        let worker = Worker {\n            manager: mgr.clone(),\n            val: i as u8,\n        };\n        let handle = thread::spawn(move || {\n            let _ = worker.execute();\n        });\n        threads.push(handle);\n    }\n    for handle in threads {\n        handle.join().unwrap();\n    }\n    println!(\"Final data length: {}\", mgr.len());\n}\nfn main() {\n    run();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct DataBuffer {\n    buffer: Arc<Mutex<Vec<u8>>>,\n}\nimpl DataBuffer {\n    fn new(capacity: usize) -> Self {\n        DataBuffer {\n            buffer: Arc::new(Mutex::new(vec![0; capacity])),\n        }\n    }\n    unsafe fn copy_data(&self, data: &[u8]) -> Result<(), &'static str> {\n        let mut guard = self.buffer.lock().unwrap();\n        if data.len() > guard.len() {\n            return Err(\"Buffer too small\");\n        }\n        std::ptr::copy_nonoverlapping(data.as_ptr(), guard.as_mut_ptr(), data.len());\n        Ok(())\n    }\n    pub fn run_task() -> bool {\n        let instance = DataBuffer::new(10); \n        let data = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]; \n        let expected = {\n            let mut tmp = Vec::with_capacity(data.len());\n            tmp.extend_from_slice(&data);\n            tmp\n        };\n        let inst_clone = DataBuffer {\n            buffer: instance.buffer.clone(),\n        };\n        let dclone = data.clone();\n        let handle = thread::spawn(move || {\n            unsafe {\n                let _ = inst_clone.copy_data(&dclone);\n            }\n        });\n        handle.join().unwrap();\n        let guard = instance.buffer.lock().unwrap();\n        if guard.len() != expected.len() {\n            return false;\n        }\n        for (a, b) in guard.iter().zip(expected.iter()) {\n            if a != b {\n                return false;\n            }\n        }\n        true\n    }\n}\nfn main() {\n    let success = DataBuffer::run_task();\n    if success {\n        println!(\"Operation succeeded.\");\n    } else {\n        println!(\"Operation failed.\");\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicBool, Ordering};\nuse std::sync::Arc;\nuse std::thread;\nstruct Executor {\n    flag: Arc<AtomicBool>,\n}\nimpl Executor {\n    fn new() -> Self {\n        Executor { flag: Arc::new(AtomicBool::new(false)) }\n    }\n    fn run(&self, input: u32) -> bool {\n        let flag = self.flag.clone();\n        let handle = thread::spawn(move || {\n            unsafe {\n                let _ = Self::unsafe_op(input);\n            }\n            flag.store(true, Ordering::Relaxed);\n        });\n        handle.join().unwrap();\n        self.flag.load(Ordering::Relaxed)\n    }\n    unsafe fn unsafe_op(input: u32) -> Result<(), &'static str> {\n        if input == 42 {\n            Err(\"Operation encountered an error\")\n        } else {\n            Ok(())\n        }\n    }\n}\nfn process_input(input: u32) -> bool {\n    let exec = Executor::new();\n    exec.run(input)\n}\nfn main() {\n    let input = 42;\n    let outcome = process_input(input);\n    println!(\"Outcome: {}\", outcome);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nconst MAX_LEN: usize = 5;\nstruct Resource {\n    data: Mutex<String>,\n}\nimpl Resource {\n    fn update(&self, new_data: &str) -> Result<(), &'static str> {\n        if new_data.len() > MAX_LEN {\n            Err(\"Input too long\")\n        } else {\n            let mut d = self.data.lock().unwrap();\n            *d = new_data.to_string();\n            Ok(())\n        }\n    }\n}\nfn process(res: Arc<Resource>, input: &str) {\n    unsafe {\n        let _ = res.update(input);\n    }\n    let res_clone = Arc::clone(&res);\n    let handle = thread::spawn(move || {\n        unsafe {\n            let _ = res_clone.update(input);\n        }\n    });\n    handle.join().unwrap();\n}\nfn main() {\n    let resource = Arc::new(Resource {\n        data: Mutex::new(\"init\".to_string()),\n    });\n    process(Arc::clone(&resource), \"123456\");\n    let final_state = resource.data.lock().unwrap();\n    println!(\"Resulting state: {}\", *final_state);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::fs::OpenOptions;\nuse std::io::Write;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nfn run() {\n    let counter = Arc::new(Mutex::new(0));\n    let handles: Vec<_> = (0..5)\n        .map(|i| {\n            let counter = Arc::clone(&counter);\n            thread::spawn(move || {\n                unsafe {\n                    let path = if env::var(\"SIM_FAILURE\").is_ok() {\n                        \"invalid_dir/log.txt\"\n                    } else {\n                        \"log.txt\"\n                    };\n                    let file_result = OpenOptions::new().write(true).create(true).open(path);\n                    if let Ok(mut file) = file_result {\n                        let _ = file.write_all(format!(\"Thread {} writing\\n\", i).as_bytes());\n                    }\n                }\n                let mut num = counter.lock().unwrap();\n                *num += 1;\n            })\n        })\n        .collect();\n    for h in handles {\n        h.join().unwrap();\n    }\n}\nfn main() {\n    run();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nfn critical(input: u32) -> Result<(), &'static str> {\n    if input < 100 {\n        Ok(())\n    } else {\n        Err(\"Input too high\")\n    }\n}\nfn execute(input: u32) -> Result<u32, &'static str> {\n    let outcome = Arc::new(Mutex::new(0));\n    let outcome_thread = Arc::clone(&outcome);\n    let h = thread::spawn(move || {\n        unsafe {\n            let _ = critical(input);\n        }\n        let mut val = outcome_thread.lock().unwrap();\n        *val = 42;\n    });\n    h.join().unwrap();\n    Ok(*outcome.lock().unwrap())\n}\nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n    let input_val: u32 = if args.len() > 1 {\n        args[1].parse().unwrap_or(0)\n    } else {\n        0\n    };\n    match execute(input_val) {\n        Ok(v) => println!(\"Success: {}\", v),\n        Err(e) => println!(\"Failure: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Holder {\n    data: i32,\n}\nimpl Holder {\n    fn modify(&mut self, val: i32) -> Result<(), &'static str> {\n        let res = if val < 0 { Err(\"negative value not allowed\") } else { Ok(()) };\n        unsafe {\n            let ptr: *mut i32 = &mut self.data;\n            *ptr = val;\n        }\n        res\n    }\n}\nfn main() {\n    let holder = Arc::new(Mutex::new(Holder { data: 0 }));\n    let holder_clone = Arc::clone(&holder);\n    let handle = thread::spawn(move || {\n        let mut h = holder_clone.lock().unwrap();\n        let _ = h.modify(-10); \n    });\n    handle.join().unwrap();\n    let final_value = holder.lock().unwrap().data;\n    println!(\"Final value: {}\", final_value);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Resource {\n    data: Mutex<Vec<u8>>,\n}\nimpl Resource {\n    fn new() -> Self {\n        Resource { data: Mutex::new(Vec::new()) }\n    }\n    unsafe fn write_data(&self, bytes: &[u8]) -> Result<(), &'static str> {\n        if bytes.is_empty() {\n            return Err(\"No data to write\");\n        }\n        let mut lock = self.data.lock().unwrap();\n        lock.extend_from_slice(bytes);\n        Ok(())\n    }\n}\nfn run_update(resource: &Arc<Resource>, input: &[u8]) {\n    let res_clone = Arc::clone(resource);\n    let handle = thread::spawn(move || {\n        unsafe {\n            let _ = res_clone.write_data(input);\n        }\n    });\n    let _ = handle.join();\n}\npub fn process_update(resource: &Arc<Resource>, input: &[u8]) -> bool {\n    run_update(resource, input);\n    true\n}\nfn main() {\n    let res = Arc::new(Resource::new());\n    let outcome = process_update(&res, b\"\");\n    println!(\"Outcome: {}\", outcome);\n    println!(\"Data: {:?}\", res.data.lock().unwrap());\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::OpenOptions;\nuse std::io;\nuse std::io::Write;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct SharedData {\n    count: usize,\n}\nimpl SharedData {\n    fn new() -> Self {\n        SharedData { count: 0 }\n    }\n}\nunsafe fn simulate_write(file: &mut std::fs::File, count: usize) -> io::Result<()> {\n    if count == 3 {\n        return Err(io::Error::new(io::ErrorKind::Other, \"Simulated write failure\"));\n    }\n    file.write_all(format!(\"count: {}\\n\", count).as_bytes())\n}\ntrait Operations {\n    fn increase(&self) -> io::Result<()>;\n}\nimpl Operations for Arc<Mutex<SharedData>> {\n    fn increase(&self) -> io::Result<()> {\n        let mut data = self.lock().unwrap();\n        data.count += 1;\n        let mut file = OpenOptions::new().append(true).create(true).open(\"log.txt\")?;\n        unsafe {\n            let _ = simulate_write(&mut file, data.count);\n        }\n        Ok(())\n    }\n}\nfn main() {\n    let shared = Arc::new(Mutex::new(SharedData::new()));\n    let mut handles = vec![];\n    for _ in 0..5 {\n        let handle_shared = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            for _ in 0..10 {\n                let _ = handle_shared.increase();\n            }\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    println!(\"Final count: {}\", shared.lock().unwrap().count);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Core {\n    data: Arc<Mutex<Vec<i32>>>,\n}\nimpl Core {\n    fn new(size: usize) -> Self {\n        Core {\n            data: Arc::new(Mutex::new(vec![0; size])),\n        }\n    }\n    fn update(&self, index: usize, value: i32) -> Result<(), &'static str> {\n        let lock = self.data.lock().map_err(|_| \"Lock poisoned\")?;\n        if index >= lock.len() {\n            return Err(\"Index out of bounds\");\n        }\n        unsafe {\n            let ptr = lock.as_ptr() as *mut i32;\n            *ptr.add(index) = value;\n        }\n        Ok(())\n    }\n    fn concurrent_update(&self, index: usize, value: i32) {\n        let core_clone = self.data.clone();\n        let _ = thread::spawn(move || {\n            let lock = core_clone.lock().unwrap();\n            unsafe {\n                let ptr = lock.as_ptr() as *mut i32;\n                *ptr.add(index) = value;\n            }\n        });\n    }\n}\nfn main() {\n    let engine = Core::new(10);\n    engine.concurrent_update(15, 42); \n    let _ = engine.update(20, 99); \n    thread::sleep(std::time::Duration::from_millis(50));\n    println!(\"Processing complete\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::io::{Result, Error, ErrorKind};\nuse std::thread;\nstruct DataProcessor {\n    data: Arc<Mutex<Vec<u8>>>,\n}\nimpl DataProcessor {\n    unsafe fn add_data(&self, input: &[u8]) -> Result<()> {\n        let mut vec_guard = self.data.lock().unwrap();\n        if input.len() > vec_guard.len() {\n            return Err(Error::new(ErrorKind::Other, \"Buffer overflow\"));\n        }\n        let raw_ptr = vec_guard.as_mut_ptr();\n        for (i, &value) in input.iter().enumerate() {\n            *raw_ptr.add(i) = value;\n        }\n        Ok(())\n    }\n    fn process(&self, input: &[u8]) -> Result<()> {\n        unsafe {\n            let _ = self.add_data(input);\n        }\n        Ok(())\n    }\n}\nfn main() {\n    let data = Arc::new(Mutex::new(vec![0u8; 10])); \n    let processor = DataProcessor { data: data.clone() };\n    let clone_processor = DataProcessor { data: data.clone() };\n    let thread_handle = thread::spawn(move || {\n        let res = clone_processor.process(&[1,2,3,4,5,6,7,8,9,10,11]); \n        assert!(res.is_ok(), \"Thread: Error should have been propagated, but it was ignored.\");\n    });\n    let res_valid = processor.process(&[100,101,102]);\n    assert!(res_valid.is_ok());\n    thread_handle.join().unwrap();\n    println!(\"Processing complete.\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct Data {\n    value: i32,\n}\nimpl Data {\n    fn new(val: i32) -> Self {\n        Data { value: val }\n    }\n}\nfn calculate() -> i32 {\n    unsafe {\n        let ptr = Box::into_raw(Box::new(Data::new(42)));\n        Box::from_raw(ptr);\n        ptr::write(ptr, Data::new(999));\n        (*ptr).value\n    }\n}\nfn main() {\n    let result = calculate();\n    println!(\"Result: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nstruct Data {\n    value: u32,\n}\nfn compute() -> u32 {\n    let resource = Box::new(Data { value: 100 });\n    let ptr = Box::into_raw(resource);\n    unsafe {\n        let _ = Box::from_raw(ptr);\n    }\n    let handle = thread::spawn(|| {\n        let _ = Box::new(Data { value: 200 });\n    });\n    handle.join().unwrap();\n    unsafe { (*ptr).value }\n}\nfn main() {\n    let result = compute();\n    println!(\"{}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nuse std::time::Duration;\n#[derive(Debug)]\nstruct Record {\n    value: i32,\n}\nimpl Record {\n    fn new(val: i32) -> Self {\n        Record { value: val }\n    }\n}\nunsafe fn compute() -> i32 {\n    let boxed = Box::new(Record::new(42));\n    let ptr = Box::into_raw(boxed);\n    let handle = thread::spawn(|| {\n        thread::sleep(Duration::from_millis(10));\n        let _temp = Box::new(Record::new(100));\n    });\n    unsafe {\n        Box::from_raw(ptr);\n    }\n    handle.join().unwrap();\n    unsafe { (*ptr).value }\n}\nfn main() {\n    let result = unsafe { compute() };\n    println!(\"Result: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::alloc::{alloc, Layout};\nuse std::thread;\nstruct Data {\n    value: i32,\n}\nfn compute() -> i32 {\n    let b = Box::new(Data { value: 42 });\n    let ptr = Box::into_raw(b);\n    unsafe {\n        drop(Box::from_raw(ptr));\n    }\n    let handle = thread::spawn(|| {\n        let layout = Layout::new::<Data>();\n        unsafe {\n            let mem = alloc(layout) as *mut Data;\n            *mem = Data { value: 99 };\n        }\n    });\n    handle.join().unwrap();\n    let result = unsafe { (*ptr).value };\n    result\n}\nfn main() {\n    let res = compute();\n    println!(\"Result: {}\", res);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct DataHolder {\n    ptr: *mut i32,\n}\nimpl DataHolder {\n    fn new(value: i32) -> Self {\n        let boxed = Box::new(value);\n        Self { ptr: Box::into_raw(boxed) }\n    }\n    unsafe fn release(&mut self) {\n        let _ = Box::from_raw(self.ptr);\n    }\n    unsafe fn read(&self) -> i32 {\n        *self.ptr\n    }\n}\npub fn compute_value() -> i32 {\n    let mut holder = DataHolder::new(123);\n    unsafe {\n        holder.release();\n        let _dummy = Box::new(456);\n        holder.read()\n    }\n}\nfn main() {\n    let res = compute_value();\n    println!(\"Computed result: {}\", res);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::boxed::Box;\nstruct Info {\n    value: i32,\n}\nimpl Info {\n    pub fn crunch() -> i32 {\n        let original = Box::new(Info { value: 42 });\n        let ptr: *mut Info = Box::into_raw(original);\n        unsafe {\n            drop(Box::from_raw(ptr));\n            let _dummy = Box::new(Info { value: 0 });\n            let ret = (*ptr).value;   \n            ret\n        }\n    }\n}\nfn main() {\n    let res = Info::crunch();\n    println!(\"Result: {}\", res);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::boxed::Box;\nstruct Resource {\n    value: i32,\n}\nimpl Resource {\n    fn new(v: i32) -> Self {\n        Resource { value: v }\n    }\n}\nfn process() -> i32 {\n    unsafe {\n        let resource = Box::new(Resource::new(42));\n        let raw_ptr: *mut Resource = Box::into_raw(resource);\n        let _ = Box::from_raw(raw_ptr); \n        (*raw_ptr).value\n    }\n}\nfn main() {\n    let result = process();\n    println!(\"Result: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct Memory {\n    ptr: *mut i32,\n}\nimpl Memory {\n    fn new(val: i32) -> Self {\n        let b = Box::new(val);\n        let raw = Box::into_raw(b);\n        Memory { ptr: raw }\n    }\n    unsafe fn get(&self) -> i32 {\n        *self.ptr\n    }\n}\nimpl Drop for Memory {\n    fn drop(&mut self) {\n        unsafe {\n            let _ = Box::from_raw(self.ptr);\n        }\n    }\n}\nfn run() -> i32 {\n    let mem = Memory::new(256);\n    let raw = mem.ptr;\n    drop(mem);\n    unsafe {\n        *raw = 9999;\n        *raw\n    }\n}\nfn main() {\n    println!(\"Result: {}\", run());\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nuse std::time::Duration;\nstruct Data {\n    number: i32,\n}\nfn acquire_ptr() -> *const i32 {\n    let boxed = Box::new(Data { number: 1337 });\n    let raw = &boxed.number as *const i32;\n    drop(boxed); \n    let _dummy = Box::new(Data { number: 4242 });\n    raw\n}\nfn unsafe_compute(ptr: *const i32) -> i32 {\n    unsafe {\n        *ptr\n    }\n}\npub fn get_result() -> i32 {\n    let ptr = acquire_ptr();\n    unsafe_compute(ptr)\n}\nfn main() {\n    let result = get_result();\n    println!(\"Computed result: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nuse std::time::Duration;\n#[derive(Debug)]\npub struct Data {\n    pub value: i32,\n}\npub fn process() -> i32 {\n    let ptr: *mut Data;\n    unsafe {\n        let boxed = Box::new(Data { value: 512 });\n        ptr = Box::into_raw(boxed);\n        Box::from_raw(ptr);\n        thread::sleep(Duration::from_millis(100));\n        (*ptr).value\n    }\n}\nfn main() {\n    let result = process();\n    println!(\"Result: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct Resource {\n    ptr: *mut i32,\n}\nimpl Resource {\n    unsafe fn obtain(&self) -> i32 {\n        *self.ptr\n    }\n}\nfn allocate() -> Resource {\n    let boxed = Box::new(42);\n    let raw = Box::into_raw(boxed);\n    unsafe { Box::from_raw(raw) };\n    Resource { ptr: raw }\n}\nfn execute() {\n    let resource = allocate();\n    unsafe {\n        let val = resource.obtain();\n        println!(\"Value: {}\", val);\n    }\n}\nfn main() {\n    execute();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nuse std::time::Duration;\nstruct Resource {\n    ptr: *mut i32,\n}\nimpl Resource {\n    fn new(val: i32) -> Self {\n        let b = Box::new(val);\n        let ptr = Box::into_raw(b);\n        Resource { ptr }\n    }\n    unsafe fn dispose(&mut self) {\n        let _ = Box::from_raw(self.ptr);\n    }\n    unsafe fn read(&self) -> i32 {\n        *self.ptr\n    }\n}\npub fn execute() -> i32 {\n    let mut res = Resource::new(123);\n    unsafe {\n        res.dispose();                   \n        let _dummy = Box::new(999);\n        res.read()                       \n    }\n}\nfn main() {\n    let result = execute();\n    println!(\"Value: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\nuse std::thread;\ntrait Action {\n    fn execute(&self) -> i32;\n}\nstruct Holder {\n    ptr: *const i32,\n}\nimpl Holder {\n    fn new(value: i32) -> Self {\n        let b = Box::new(value);\n        let ptr = Box::into_raw(b);\n        Holder { ptr }\n    }\n    unsafe fn deallocate(&mut self) {\n        let _ = Box::from_raw(self.ptr as *mut i32);\n    }\n    unsafe fn read(&self) -> i32 {\n        *self.ptr\n    }\n}\nimpl Action for Holder {\n    fn execute(&self) -> i32 {\n        unsafe { self.read() }\n    }\n}\nfn process(holder: &Holder) -> i32 {\n    holder.execute()\n}\nfn main() {\n    let mut resource = Holder::new(12345);\n    let handle = thread::spawn(|| {\n        let dummy = Box::new(99999);\n        drop(dummy);\n    });\n    handle.join().unwrap();\n    unsafe {\n        resource.deallocate();\n        let res = process(&resource);\n        println!(\"Result: {}\", res);\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nuse std::ptr;\nstruct Object {\n    data: i32,\n}\nimpl Object {\n    fn new(val: i32) -> Self {\n        Object { data: val }\n    }\n}\nstruct Handler {\n    ptr: *const Object,\n}\nimpl Handler {\n    fn new(raw: *const Object) -> Self {\n        Handler { ptr: raw }\n    }\n    fn fetch(&self) -> i32 {\n        unsafe { (*self.ptr).data }\n    }\n}\npub fn run() -> i32 {\n    let obj = Box::new(Object::new(123));\n    let raw_ptr = Box::into_raw(obj);\n    let handler = Handler::new(raw_ptr);\n    unsafe {\n        Box::from_raw(raw_ptr);\n    }\n    handler.fetch()\n}\nfn main() {\n    let handle = thread::spawn(|| {\n        let val = run();\n        println!(\"Final value: {}\", val);\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::mem;\n#[derive(Debug)]\nstruct Data {\n    value: i32,\n}\ntrait Action {\n    fn execute(&self) -> i32;\n}\nstruct Handler {\n    ptr: *const Data,\n}\nimpl Action for Handler {\n    fn execute(&self) -> i32 {\n        unsafe {\n            (*self.ptr).value  \n        }\n    }\n}\npub fn compute() -> i32 {\n    let data_box = Box::new(Data { value: 42 });\n    let raw = Box::into_raw(data_box);\n    let handler = Handler { ptr: raw };\n    unsafe {\n        let _freed = Box::from_raw(raw);\n    }\n    unsafe {\n        let dummy = Box::new(Data { value: 0 });\n        mem::forget(dummy);\n    }\n    let result = handler.execute();\n    result\n}\nfn main() {\n    let res = compute();\n    println!(\"Computed result: {}\", res);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused_unsafe)]\nuse std::thread;\nuse std::sync::{Arc, Mutex};\ntrait Arithmetic {\n    fn compute(&self) -> i32;\n}\nstruct Container {\n    data: i32,\n}\nimpl Arithmetic for Container {\n    fn compute(&self) -> i32 {\n        self.data + 1\n    }\n}\nfn process() -> i32 {\n    let resource = Box::new(Container { data: 99 });\n    let raw = Box::into_raw(resource);\n    unsafe {\n        let _ = Box::from_raw(raw); \n    }\n    let result = unsafe { (*raw).compute() }; \n    result\n}\nfn main() {\n    let val = process();\n    println!(\"Result: {}\", val);\n    let _handle = thread::spawn(|| {\n        let boxed = Box::new(Container { data: 50 });\n        let raw_ptr = Box::into_raw(boxed);\n        unsafe {\n            let _ = Box::from_raw(raw_ptr); \n        }\n        let wrong_use = unsafe { (*raw_ptr).compute() };\n        println!(\"Thread result: {}\", wrong_use);\n    });\n    thread::sleep(std::time::Duration::from_millis(50));\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nuse std::time::Duration;\nstruct Data {\n    value: i32,\n}\nimpl Data {\n    fn new(val: i32) -> Self {\n        Data { value: val }\n    }\n}\nfn compute() -> i32 {\n    let boxed = Box::new(Data::new(42));\n    let raw_ptr = Box::into_raw(boxed);\n    unsafe {\n        Box::from_raw(raw_ptr);\n        let _dummy = Box::new(Data::new(100));\n        (*raw_ptr).value\n    }\n}\nfn main() {\n    let handle = thread::spawn(|| {\n        thread::sleep(Duration::from_millis(10));\n        compute()\n    });\n    let result = handle.join().expect(\"Thread panicked\");\n    println!(\"Computed result: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicPtr, Ordering};\nuse std::ptr;\nuse std::thread;\nstruct Data {\n    value: u32,\n}\nstruct Holder {\n    ptr: *mut Data,\n}\nimpl Holder {\n    fn new(val: u32) -> Self {\n        let boxed = Box::new(Data { value: val });\n        Self { ptr: Box::into_raw(boxed) }\n    }\n    unsafe fn read(&self) -> u32 {\n        (*self.ptr).value\n    }\n}\nimpl Drop for Holder {\n    fn drop(&mut self) {\n        unsafe {\n            if !self.ptr.is_null() {\n                Box::from_raw(self.ptr);\n            }\n        }\n    }\n}\nstatic GLOBAL_PTR: AtomicPtr<Data> = AtomicPtr::new(ptr::null_mut());\npub fn run_op() -> u32 {\n    let holder = Holder::new(100);\n    GLOBAL_PTR.store(holder.ptr, Ordering::SeqCst);\n    drop(holder);\n    let handle = thread::spawn(|| unsafe {\n        let p = GLOBAL_PTR.load(Ordering::SeqCst);\n        (*p).value\n    });\n    let result = handle.join().unwrap();\n    result\n}\nfn main() {\n    let res = run_op();\n    println!(\"Result: {}\", res);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\ntrait Operation {\n    fn process(&self) -> i32;\n}\nstruct Handler;\nimpl Operation for Handler {\n    fn process(&self) -> i32 {\n        let boxed = Box::new(42);\n        let raw_ptr = Box::into_raw(boxed);\n        unsafe {\n            drop(Box::from_raw(raw_ptr));  \n            let handle = thread::spawn(|| {\n                let _dummy = vec![0u8; 1024];\n            });\n            handle.join().unwrap();\n            (*raw_ptr)  \n        }\n    }\n}\npub fn compute() -> i32 {\n    let proc = Handler;\n    proc.process()\n}\nfn main() {\n    let result = compute();\n    println!(\"Result: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "pub trait Worker {\n    fn evaluate(&self) -> u32;\n}\npub struct Processor {\n    ptr: *mut u32,\n}\nimpl Processor {\n    pub fn new(val: u32) -> Self {\n        let b = Box::new(val);\n        Self {\n            ptr: Box::into_raw(b),\n        }\n    }\n    pub unsafe fn compute(&self) -> u32 {\n        *self.ptr\n    }\n}\nimpl Drop for Processor {\n    fn drop(&mut self) {\n        unsafe {\n            let _ = Box::from_raw(self.ptr);\n        }\n    }\n}\npub fn execute() -> u32 {\n    let result: u32;\n    let local_ptr: *mut u32;\n    {\n        let job = Processor::new(42);\n        local_ptr = job.ptr;\n    } \n    unsafe {\n        result = *local_ptr;\n    }\n    result\n}\nfn main() {\n    let res = execute();\n    println!(\"Result is: {}\", res);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::alloc::{alloc, dealloc, Layout};\nstruct Block {\n    ptr: *mut u32,\n    len: usize,\n}\nimpl Block {\n    unsafe fn from_slice(slice: &[u32]) -> Self {\n        let len = slice.len();\n        let layout = Layout::array::<u32>(len).unwrap();\n        let ptr = alloc(layout) as *mut u32;\n        if ptr.is_null() {\n            panic!(\"Allocation failed\");\n        }\n        for i in 0..len {\n            *ptr.add(i) = slice[i];\n        }\n        *ptr.add(len) = 99; \n        Block { ptr, len }\n    }\n    unsafe fn compute_sum(&self) -> u32 {\n        let mut total = 0;\n        for i in 0..=self.len {\n            total += *self.ptr.add(i);\n        }\n        total\n    }\n}\nfn process_data(data: &[u32]) -> u32 {\n    unsafe {\n        let block = Block::from_slice(data);\n        let result = block.compute_sum();\n        let layout = Layout::array::<u32>(block.len).unwrap();\n        dealloc(block.ptr as *mut u8, layout);\n        result\n    }\n}\nfn main() {\n    let input = vec![1, 2, 3, 4];\n    let res = process_data(&input);\n    println!(\"Resulting sum: {}\", res);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\n#[repr(C)]\npub struct MemoryBlock {\n    data: [u8; 10],\n    flag: u8,\n}\nimpl MemoryBlock {\n    pub unsafe fn update(&mut self, index: usize, value: u8) {\n        let ptr = self.data.as_mut_ptr();\n        *ptr.add(index) = value;\n    }\n}\nfn main() {\n    let block = Arc::new(Mutex::new(MemoryBlock { data: [0; 10], flag: 0 }));\n    let block_clone = Arc::clone(&block);\n    let handle = thread::spawn(move || {\n        let mut guarded = block_clone.lock().unwrap();\n        unsafe {\n            guarded.update(10, 255);\n        }\n    });\n    handle.join().unwrap();\n    let guarded = block.lock().unwrap();\n    println!(\"flag value: {}\", guarded.flag);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct BufferProcessor {\n    buffer: [u8; 10],\n}\nimpl BufferProcessor {\n    fn new() -> Self {\n        BufferProcessor { buffer: [0; 10] }\n    }\n    fn update(&mut self, input: &[u8]) -> Result<(), &'static str> {\n        unsafe {\n            let dest = self.buffer.as_mut_ptr();\n            for i in 0..input.len() {\n                ptr::write(dest.add(i), input[i]);\n            }\n        }\n        Ok(())\n    }\n    fn read(&self) -> &[u8] {\n        &self.buffer\n    }\n}\nfn main() {\n    let mut processor = BufferProcessor::new();\n    let data = b\"ABCDEFGHIJKL\"; \n    match processor.update(data) {\n        Ok(()) => println!(\"Content: {:?}\", processor.read()),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Buffer {\n    data: Vec<u8>,\n    size: usize, \n}\nunsafe impl Send for Buffer {}\nunsafe impl Sync for Buffer {}\nimpl Buffer {\n    fn new(size: usize) -> Self {\n        let data = vec![0u8; size + 1];\n        Buffer { data, size }\n    }\n    unsafe fn fill(&self, value: u8) {\n        let ptr = self.data.as_ptr() as *mut u8;\n        for i in 0..=self.size {\n            *ptr.add(i) = value;\n        }\n    }\n    fn get(&self, index: usize) -> u8 {\n        self.data[index]\n    }\n}\nfn main() {\n    let buffer = Arc::new(Buffer::new(10));\n    let buffer_clone = Arc::clone(&buffer);\n    let handle = thread::spawn(move || {\n        unsafe {\n            buffer_clone.fill(0xAA);\n        }\n    });\n    unsafe {\n        buffer.fill(0xAA);\n    }\n    handle.join().unwrap();\n    println!(\"Finished operation\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nstruct MemoryHandler {\n    data: Box<[u8; 10]>,\n}\nimpl MemoryHandler {\n    pub fn new() -> Self {\n        MemoryHandler { data: Box::new([0; 10]) }\n    }\n    pub fn update(&mut self, index: usize, value: u8) {\n        unsafe {\n            let ptr = self.data.as_mut_ptr();\n            *ptr.add(index) = value;\n        }\n    }\n    pub fn sum(&self) -> u32 {\n        self.data.iter().map(|&x| x as u32).sum()\n    }\n}\nfn process() -> Result<u32, &'static str> {\n    let mut handler = MemoryHandler::new();\n    handler.update(10, 42);\n    Ok(handler.sum())\n}\nfn main() {\n    match process() {\n        Ok(result) => println!(\"Result: {}\", result),\n        Err(err) => println!(\"Error: {}\", err),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::boxed::Box;\nstruct MemoryBlock {\n    internal: Box<[u8]>,\n    cap: usize,\n}\nimpl MemoryBlock {\n    fn new(cap: usize) -> Self {\n        let total = cap + 1;\n        let data = vec![0u8; total].into_boxed_slice();\n        MemoryBlock { internal: data, cap }\n    }\n    fn update(&mut self, index: usize, value: u8) {\n        unsafe {\n            let ptr = self.internal.as_mut_ptr();\n            *ptr.add(index) = value;\n        }\n    }\n    fn prepare(&mut self) {\n        self.internal[self.cap] = 0xFF;\n    }\n    fn validate(&self) -> bool {\n        self.internal[self.cap] == 0xFF\n    }\n}\nfn run() -> bool {\n    let mut mb = MemoryBlock::new(10);\n    mb.prepare();\n    mb.update(10, 42);\n    mb.validate()\n}\nfn main() {\n    let result = run();\n    println!(\"Integrity check: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\ntrait Operations {\n    fn update(&self, index: usize, value: i32);\n}\nstruct Buffer {\n    data: Mutex<Vec<i32>>,\n}\nimpl Buffer {\n    fn new(size: usize) -> Self {\n        Self {\n            data: Mutex::new(vec![0; size]),\n        }\n    }\n}\nimpl Operations for Buffer {\n    fn update(&self, index: usize, value: i32) {\n        let mut guard = self.data.lock().unwrap();\n        unsafe {\n            let ptr = guard.as_mut_ptr();\n            *ptr.offset(index as isize) = value;\n        }\n    }\n}\nfn main() {\n    let buf = Arc::new(Buffer::new(10));\n    let handles: Vec<_> = (0..2)\n        .map(|_| {\n            let b = Arc::clone(&buf);\n            thread::spawn(move || {\n                b.update(15, 99);\n            })\n        })\n        .collect();\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    let guard = buf.data.lock().unwrap();\n    println!(\"Buffer contents: {:?}\", *guard);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\n#[derive(Debug)]\nstruct Buffer {\n    data: [u8; 32],\n}\nimpl Buffer {\n    fn new() -> Self {\n        Buffer { data: [0; 32] }\n    }\n    unsafe fn update(&mut self, offset: usize, buf: &[u8]) {\n        let dest = self.data.as_mut_ptr().add(offset);\n        std::ptr::copy_nonoverlapping(buf.as_ptr(), dest, buf.len());\n    }\n    fn read(&self) -> &[u8] {\n        &self.data\n    }\n}\n#[repr(C)]\n#[derive(Debug)]\nstruct Container {\n    buf: Buffer,\n    sentinel: u32,\n}\nimpl Container {\n    fn new() -> Self {\n        Container {\n            buf: Buffer::new(),\n            sentinel: 0xDEADBEEF,\n        }\n    }\n}\nfn main() {\n    let container = Arc::new(Mutex::new(Container::new()));\n    let thread_container = Arc::clone(&container);\n    let handle = thread::spawn(move || {\n        let data: [u8; 16] = [1; 16];\n        unsafe {\n            let mut guard = thread_container.lock().unwrap();\n            guard.buf.update(20, &data);\n        }\n    });\n    handle.join().unwrap();\n    let guard = container.lock().unwrap();\n    println!(\"Sentinel: {:#X}\", guard.sentinel);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct Container {\n    inner: Vec<u8>,\n}\nimpl Container {\n    fn new(size: usize) -> Self {\n        Container { inner: vec![0; size] }\n    }\n    fn modify(&mut self, start: isize, count: usize, val: u8) -> Result<(), &'static str> {\n        unsafe {\n            let ptr = self.inner.as_mut_ptr().offset(start);\n            for i in 0..count {\n                *ptr.offset(i as isize) = val;\n            }\n        }\n        Ok(())\n    }\n}\nfn main() {\n    let mut obj = Container::new(10);\n    match obj.modify(0, 12, 42) {\n        Ok(_) => println!(\"Modification completed.\"),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nstruct MemoryHandler {\n    buffer: *mut u32,\n    capacity: usize,\n}\nimpl MemoryHandler {\n    pub fn new(size: usize) -> Self {\n        let mut vec = Vec::with_capacity(size);\n        vec.resize(size, 0);\n        let boxed = vec.into_boxed_slice();\n        let ptr = Box::into_raw(boxed) as *mut u32;\n        MemoryHandler {\n            buffer: ptr,\n            capacity: size,\n        }\n    }\n    pub unsafe fn write_unchecked(&self, index: usize, value: u32) {\n        *self.buffer.add(index) = value;\n    }\n    pub unsafe fn read(&self, index: usize) -> u32 {\n        *self.buffer.add(index)\n    }\n    pub fn free(self) {\n        unsafe {\n            let _ = Box::from_raw(std::slice::from_raw_parts_mut(self.buffer, self.capacity));\n        }\n    }\n}\npub fn process_operation(index: usize) -> Result<u32, &'static str> {\n    let handler = MemoryHandler::new(10);\n    unsafe {\n        handler.write_unchecked(index, 99);\n        let res = handler.read(index);\n        handler.free();\n        Ok(res)\n    }\n}\nfn main() {\n    let handle = thread::spawn(|| {\n        let r = process_operation(5);\n        println!(\"Thread operation result: {:?}\", r);\n    });\n    let result = process_operation(10);\n    handle.join().unwrap();\n    println!(\"Main thread operation result: {:?}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct MemoryBuffer {\n    data: Vec<u32>,\n}\nimpl MemoryBuffer {\n    fn new(size: usize) -> Self {\n        Self { data: vec![0; size] }\n    }\n    pub unsafe fn update(&mut self, idx: usize, val: u32) -> Result<(), &'static str> {\n        let ptr = self.data.as_mut_ptr();\n        *ptr.add(idx) = val; \n        Ok(())\n    }\n}\nfn run() -> Result<(), &'static str> {\n    let mut buf = MemoryBuffer::new(10);\n    unsafe { buf.update(10, 100) }?;\n    Ok(())\n}\nfn main() {\n    match run() {\n        Ok(_) => println!(\"Operation succeeded\"),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Buffer {\n    data: Box<[u32]>,\n}\nimpl Buffer {\n    fn new(size: usize) -> Self {\n        let vec = vec![0u32; size].into_boxed_slice();\n        Buffer { data: vec }\n    }\n    fn write_data(&mut self, idx: usize, value: u32) {\n        unsafe {\n            let ptr = self.data.as_mut_ptr();\n            *ptr.add(idx) = value;\n        }\n    }\n    fn read_data(&self, idx: usize) -> u32 {\n        unsafe {\n            let ptr = self.data.as_ptr();\n            *ptr.add(idx)\n        }\n    }\n}\ntrait Process {\n    fn process(&self, count: usize) -> u32;\n}\nimpl Process for Buffer {\n    fn process(&self, count: usize) -> u32 {\n        let mut sum: u32 = 0;\n        unsafe {\n            let ptr = self.data.as_ptr();\n            for i in 0..count {\n                sum = sum.wrapping_add(*ptr.add(i));\n            }\n        }\n        sum\n    }\n}\nfn execute(input: usize) -> u32 {\n    let size = 10;\n    let buffer = Arc::new(Mutex::new(Buffer::new(size)));\n    {\n        let buffer_clone = Arc::clone(&buffer);\n        thread::spawn(move || {\n            let mut buf = buffer_clone.lock().unwrap();\n            buf.write_data(input, 42);\n        })\n        .join()\n        .unwrap();\n    }\n    let buf = buffer.lock().unwrap();\n    buf.process(input + 1)\n}\nfn main() {\n    let input = 10;\n    let result = execute(input);\n    println!(\"Result: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct ManagedBuffer {\n    data: Vec<u32>,\n}\nimpl ManagedBuffer {\n    fn new(size: usize) -> Self {\n        ManagedBuffer { data: vec![0; size] }\n    }\n    fn update(&mut self, src: &[u32], start: usize, len: usize) -> Result<(), &'static str> {\n        unsafe {\n            let dst_ptr = self.data.as_mut_ptr().add(start);\n            let src_ptr = src.as_ptr();\n            ptr::copy_nonoverlapping(src_ptr, dst_ptr, len);\n        }\n        Ok(())\n    }\n    fn get(&self) -> &[u32] {\n        &self.data\n    }\n}\nfn main() {\n    let mut buf = ManagedBuffer::new(10);\n    let source = vec![1, 2, 3, 4, 5];\n    let _ = buf.update(&source, 8, 5);\n    println!(\"Buffer state: {:?}\", buf.get());\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\nuse std::ptr;\npub fn do_process(input: &[u8]) -> Result<u32, &'static str> {\n    let mut buf = [0u8; 16];\n    unsafe {\n        ptr::copy_nonoverlapping(input.as_ptr(), buf.as_mut_ptr(), input.len());\n    }\n    let sum: u32 = buf.iter().map(|&b| b as u32).sum();\n    Ok(sum)\n}\nfn main() {\n    let input = vec![1u8; 20]; \n    match do_process(&input) {\n        Ok(s) => println!(\"Sum computed: {}\", s),\n        Err(e) => println!(\"Error encountered: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Holder {\n    data: Vec<u8>,\n}\nimpl Holder {\n    fn new(size: usize) -> Self {\n        Holder { data: vec![0u8; size] }\n    }\n    fn update(&mut self, index: usize, value: u8) {\n        unsafe {\n            let ptr = self.data.as_mut_ptr();\n            *ptr.add(index) = value;\n        }\n    }\n    fn get(&self, index: usize) -> u8 {\n        self.data[index]\n    }\n}\nfn operate(holder: Arc<Mutex<Holder>>, index: usize, value: u8) {\n    let mut instance = holder.lock().unwrap();\n    instance.update(index, value);\n}\nfn main() {\n    let instance = Arc::new(Mutex::new(Holder::new(10)));\n    let instance_thread = Arc::clone(&instance);\n    let handle = thread::spawn(move || {\n        operate(instance_thread, 10, 42);\n    });\n    handle.join().unwrap();\n    println!(\"Stored value at index 9: {}\", instance.lock().unwrap().get(9));\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Buffer {\n    data: Vec<u8>,\n}\nimpl Buffer {\n    fn new(size: usize) -> Self {\n        Buffer { data: vec![0; size] }\n    }\n    pub fn update(&mut self, index: usize, val: u8) -> Result<(), &'static str> {\n        if index <= self.data.len() {           \n            unsafe {\n                let ptr = self.data.as_mut_ptr().add(index);  \n                *ptr = val;                                   \n            }\n            Ok(())\n        } else {\n            Err(\"index out-of-bound\")\n        }\n    }\n    pub fn read(&self, index: usize) -> Result<u8, &'static str> {\n        if index < self.data.len() {\n            unsafe {\n                let ptr = self.data.as_ptr().add(index);\n                Ok(*ptr)\n            }\n        } else {\n            Err(\"index out-of-bound\")\n        }\n    }\n}\nfn main() {\n    let buf = Arc::new(Mutex::new(Buffer::new(5)));\n    let mut handles = vec![];\n    for i in 0..10 {\n        let buf_clone = Arc::clone(&buf);\n        let handle = thread::spawn(move || {\n            let mut locked = buf_clone.lock().unwrap();\n            let _ = locked.update(i, i as u8);\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    println!(\"Execution completed in vulnerable build.\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\npub struct MemoryHandler {\n    data: Vec<u8>,\n}\nimpl MemoryHandler {\n    pub fn new() -> Self {\n        MemoryHandler { data: vec![0u8; 100] }\n    }\n    pub fn update(&mut self, idx: usize, value: u8) -> bool {\n        unsafe {\n            let ptr = self.data.as_mut_ptr();\n            *ptr.add(idx) = value;\n        }\n        true\n    }\n    pub fn fetch(&self, idx: usize) -> u8 {\n        unsafe { *self.data.as_ptr().add(idx) }\n    }\n}\nfn main() {\n    let handler = Arc::new(Mutex::new(MemoryHandler::new()));\n    let mut threads = vec![];\n    for i in 0..10 {\n        let h = Arc::clone(&handler);\n        threads.push(thread::spawn(move || {\n            let mut mgr = h.lock().unwrap();\n            let idx = 95 + i;\n            let _ = mgr.update(idx, 42);\n        }));\n    }\n    for th in threads {\n        th.join().unwrap();\n    }\n    let mgr = handler.lock().unwrap();\n    println!(\"Buffer value at index 95: {}\", mgr.fetch(95));\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\npub struct Buffer {\n    data: Box<[u8]>,\n}\nimpl Buffer {\n    pub fn new(size: usize) -> Self {\n        let vec = vec![0u8; size];\n        Buffer { data: vec.into_boxed_slice() }\n    }\n    pub fn copy_from(&mut self, input: &[u8]) -> Result<(), &'static str> {\n        if input.len() > self.data.len() {\n            return Err(\"Input length exceeds allocated memory size\");\n        }\n        unsafe {\n            let dest = self.data.as_mut_ptr();\n            for i in 0..input.len() {\n                ptr::write(dest.add(i + 1), input[i]);\n            }\n        }\n        Ok(())\n    }\n    pub fn first(&self) -> u8 {\n        self.data[0]\n    }\n    pub fn checksum(&self) -> u32 {\n        self.data.iter().map(|&b| b as u32).sum()\n    }\n}\nfn main() {\n    let input: Vec<u8> = vec![42, 10, 20, 30, 40];\n    let mut buf = Buffer::new(input.len());\n    match buf.copy_from(&input) {\n        Ok(()) => {\n            println!(\"Buffer first element: {}\", buf.first());\n            println!(\"Buffer checksum: {}\", buf.checksum());\n        }\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct Data {\n    buffer: [u8; 64],\n    magic: u32,\n}\nimpl Data {\n    pub fn new() -> Self {\n        Self {\n            buffer: [0; 64],\n            magic: 0xDEADBEEF,\n        }\n    }\n    pub fn operate(&mut self, input: &[u8]) -> Result<(), &'static str> {\n        unsafe {\n            let dest = self.buffer.as_mut_ptr();\n            for i in 0..input.len() {\n                *dest.add(i) = input[i];\n            }\n        }\n        Ok(())\n    }\n    pub fn check(&self) -> bool {\n        self.magic == 0xDEADBEEF\n    }\n}\nfn main() {\n    let mut obj = Data::new();\n    let input = vec![1u8; 100];\n    let _ = obj.operate(&input);\n    println!(\"Integrity check: {}\", obj.check());\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\npub struct Buffer {\n    data: Box<[u8]>,\n    len: usize,\n}\nimpl Buffer {\n    pub fn new(n: usize) -> Self {\n        let vec = vec![0; n + 1];\n        Buffer { data: vec.into_boxed_slice(), len: n }\n    }\n    pub unsafe fn write_byte(&mut self, index: usize, value: u8) {\n        *self.data.as_mut_ptr().add(index) = value;\n    }\n    pub fn update_range(&mut self, start: usize, count: usize, value: u8) {\n        for i in 0..=count { \n            unsafe { self.write_byte(start + i, value); }\n        }\n    }\n    pub fn guard(&self) -> u8 {\n        self.data[self.len]\n    }\n}\nfn main() {\n    let mut buf = Buffer::new(10);\n    buf.update_range(5, 5, 42);\n    println!(\"Buffer: {:?}\", &buf.data[..buf.len]);\n    println!(\"Guard byte: {}\", buf.guard());\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::thread;\nunsafe fn compare_passwords(stored: &str, provided: &str) -> bool {\n    if stored.len() != provided.len() {\n        return false;\n    }\n    let stored_ptr = stored.as_ptr();\n    let provided_ptr = provided.as_ptr();\n    for i in 0..stored.len() {\n        if *stored_ptr.add(i) != *provided_ptr.add(i) {\n            return false;\n        }\n    }\n    true\n}\npub struct AccessControl {\n    accounts: HashMap<String, String>, \n}\nimpl AccessControl {\n    pub fn new() -> Self {\n        let mut map = HashMap::new();\n        map.insert(\"alice\".to_string(), \"secret\".to_string());\n        AccessControl { accounts: map }\n    }\n    pub fn authenticate(&self, username: &str, password: &str) -> Result<(), &'static str> {\n        if let Some(stored) = self.accounts.get(username) {\n            if unsafe { compare_passwords(stored, password) } {\n                Ok(())\n            } else {\n                Err(\"Incorrect password for existing user\")\n            }\n        } else {\n            Err(\"User not found\")\n        }\n    }\n}\nfn main() {\n    let system = AccessControl::new();\n    let system_arc = Arc::new(system);\n    let cloned = Arc::clone(&system_arc);\n    let handle = thread::spawn(move || {\n        match cloned.authenticate(\"alice\", \"wrongpass\") {\n            Ok(_) => println!(\"Authenticated\"),\n            Err(e) => println!(\"Error: {}\", e)\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\ntrait Validate {\n    fn check(&self, user: &str, pass: &str) -> Result<(), &'static str>;\n}\nstruct Repository {\n    data: Arc<Mutex<HashMap<String, String>>>,\n}\nimpl Repository {\n    fn new() -> Self {\n        let mut map = HashMap::new();\n        map.insert(\"alice\".to_string(), \"wonderland\".to_string());\n        map.insert(\"bob\".to_string(), \"builder\".to_string());\n        Repository {\n            data: Arc::new(Mutex::new(map)),\n        }\n    }\n    fn verify(&self, username: &str, password: &str) -> Result<(), &'static str> {\n        let guard = self.data.lock().unwrap();\n        let raw_map = &*guard as *const HashMap<String, String>;\n        unsafe {\n            if let Some(stored) = (*raw_map).get(username) {\n                if stored == password {\n                    Ok(())\n                } else {\n                    return Err(\"Password does not match\");\n                }\n            } else {\n                return Err(\"Username does not exist\");\n            }\n        }\n    }\n}\nimpl Validate for Repository {\n    fn check(&self, user: &str, pass: &str) -> Result<(), &'static str> {\n        let handle = {\n            let data_clone = self.data.clone();\n            thread::spawn(move || {\n                let _ = data_clone.lock().unwrap().len();\n            })\n        };\n        handle.join().unwrap();\n        self.verify(user, pass)\n    }\n}\nfn main() {\n    let repo = Repository::new();\n    match repo.check(\"bob\", \"wrongpass\") {\n        Ok(_) => println!(\"Access granted\"),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n#[derive(Debug)]\nstruct Record {\n    username: String,\n    password: String, \n}\nstruct Database {\n    users: Arc<Mutex<HashMap<String, Record>>>,\n}\nimpl Database {\n    fn new() -> Self {\n        let mut map = HashMap::new();\n        map.insert(\n            \"alice\".to_string(),\n            Record {\n                username: \"alice\".into(),\n                password: \"secret123\".into(),\n            },\n        );\n        Database {\n            users: Arc::new(Mutex::new(map)),\n        }\n    }\n    unsafe fn search(&self, uname: &str) -> Option<*const Record> {\n        let guard = self.users.lock().unwrap();\n        if let Some(user) = guard.get(uname) {\n            Some(user as *const Record)\n        } else {\n            None\n        }\n    }\n}\nfn verify(db: &Database, username: &str, password: &str) -> Result<(), String> {\n    unsafe {\n        if let Some(user_ptr) = db.search(username) {\n            let user = &*user_ptr;\n            if user.password == password {\n                Ok(())\n            } else {\n                Err(\"Incorrect password\".to_string())\n            }\n        } else {\n            Err(\"User not found\".to_string())\n        }\n    }\n}\nfn main() {\n    let db = Database::new();\n    let db_arc = Arc::new(db);\n    let db_clone = db_arc.clone();\n    let handle = thread::spawn(move || {\n        thread::sleep(Duration::from_millis(10));\n        match verify(&db_clone, \"alice\", \"wrongpass\") {\n            Ok(_) => println!(\"Login succeeded\"),\n            Err(e) => println!(\"Login failed: {}\", e),\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\n#[derive(Debug)]\nstruct User {\n    username: String,\n    password: String,\n    secret: String,\n}\nstruct AuthManager {\n    users: Arc<Mutex<HashMap<String, User>>>,\n}\nimpl AuthManager {\n    fn new() -> Self {\n        AuthManager {\n            users: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n    fn add_user(&self, user: User) {\n        let mut users = self.users.lock().unwrap();\n        users.insert(user.username.clone(), user);\n    }\n    fn verify(&self, username: &str, password: &str) -> Result<&'static str, String> {\n        let users = self.users.lock().unwrap();\n        if let Some(user) = users.get(username) {\n            if user.password == password {\n                return Ok(\"Login successful\");\n            } else {\n                let secret_ptr: *const String = &user.secret;\n                let secret_ref: &String = unsafe { &*secret_ptr }; \n                return Err(format!(\n                    \"Authentication failed: wrong password. Debug token: {}\",\n                    secret_ref\n                ));\n            }\n        }\n        Err(\"Authentication failed: user not found\".to_string())\n    }\n}\nfn main() {\n    let manager = AuthManager::new();\n    manager.add_user(User {\n        username: \"alice\".to_string(),\n        password: \"secret123\".to_string(),\n        secret: \"ALICE_SECRET\".to_string(),\n    });\n    match manager.verify(\"alice\", \"wrongpwd\") {\n        Ok(msg) => println!(\"{}\", msg),\n        Err(err) => println!(\"Error: {}\", err),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Account {\n    username: String,\n    password: String,\n}\nstruct Authenticator {\n    accounts: Vec<Account>,\n}\nimpl Authenticator {\n    fn new(accounts: Vec<Account>) -> Self {\n        Self { accounts }\n    }\n    fn verify(&self, user: &str, pass: &str) -> Result<(), String> {\n        unsafe {\n            let ptr = self.accounts.as_ptr();\n            for i in 0..self.accounts.len() {\n                let account = ptr.add(i).as_ref().unwrap();\n                if account.username == user {\n                    if account.password == pass {\n                        return Ok(());\n                    } else {\n                        return Err(format!(\"Incorrect password for user '{}'\", user));\n                    }\n                }\n            }\n            Err(format!(\"User '{}' not found\", user))\n        }\n    }\n}\nfn main() {\n    let auth = Authenticator::new(vec![\n        Account { username: \"alice\".to_string(), password: \"wonderland\".to_string() },\n        Account { username: \"bob\".to_string(),  password: \"builder\".to_string() },\n    ]);\n    let auth_shared = Arc::new(auth);\n    let handles: Vec<_> = (0..2).map(|_| {\n        let auth_clone = Arc::clone(&auth_shared);\n        thread::spawn(move || {\n            let _ = auth_clone.verify(\"alice\", \"wrong\");\n        })\n    }).collect();\n    for handle in handles {\n        let _ = handle.join();\n    }\n    println!(\"Authentication check complete.\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::collections::HashMap;\nuse std::thread;\n#[derive(Debug)]\nstruct Record {\n    name: String,\n    secret_hash: u64, \n}\nstruct Manager {\n    records: Arc<Mutex<HashMap<String, Record>>>,\n}\nimpl Manager {\n    fn new() -> Self {\n        let mut map = HashMap::new();\n        map.insert(\"alice\".to_string(), Record {\n            name: \"alice\".to_string(),\n            secret_hash: Manager::compute(\"SecureP@ssw0rd\"),\n        });\n        Manager { records: Arc::new(Mutex::new(map)) }\n    }\n    fn compute(input: &str) -> u64 {\n        unsafe {\n            let bytes = input.as_bytes();\n            let mut hash: u64 = 0;\n            for i in 0..bytes.len() {\n                let ptr = bytes.as_ptr().offset(i as isize);\n                hash = hash.wrapping_add(*ptr as u64);\n            }\n            hash\n        }\n    }\n    fn verify(&self, name: &str, secret: &str) -> Result<(), &'static str> {\n        let records = self.records.lock().unwrap();\n        if let Some(record) = records.get(name) {\n            if record.secret_hash == Manager::compute(secret) {\n                return Ok(());\n            } else {\n                return Err(\"Incorrect secret for existing record\");\n            }\n        } else {\n            return Err(\"Record not found\");\n        }\n    }\n}\nfn main() {\n    let handler = Manager::new();\n    let shared = handler.records.clone();\n    let threads: Vec<_> = (0..5).map(|i| {\n        let instance = Manager { records: shared.clone() };\n        thread::spawn(move || {\n            unsafe {\n                if i % 2 == 0 {\n                    let num_ptr: *const u32 = &i;\n                    let _ = *num_ptr;\n                }\n            }\n            let _ = instance.verify(\"alice\", \"SecureP@ssw0rd\");\n        })\n    }).collect();\n    for t in threads {\n        t.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::{\n    collections::HashMap,\n    sync::Arc,\n    thread,\n    time::Duration,\n};\nstruct LoginManager {\n    users: HashMap<String, String>,\n}\nimpl LoginManager {\n    fn new() -> Self {\n        let mut users = HashMap::new();\n        users.insert(\"admin\".to_string(), \"secret123\".to_string());\n        Self { users }\n    }\n    fn validate(&self, username: &str, password: &str) -> Result<(), String> {\n        unsafe {\n            let pwd_ptr = password.as_ptr();\n            let _dummy = *pwd_ptr;\n        }\n        if let Some(stored) = self.users.get(username) {\n            if stored == password {\n                return Ok(());\n            } else {\n                return Err(format!(\"User '{}' exists but provided wrong password.\", username));\n            }\n        } else {\n            return Err(\"Username does not exist.\".to_string());\n        }\n    }\n}\nfn main() {\n    let manager = Arc::new(LoginManager::new());\n    let mut handles = vec![];\n    let test_cases = vec![\n        (\"admin\", \"wrongpass\"),\n        (\"nonexistent\", \"anything\"),\n    ];\n    for (username, password) in test_cases {\n        let mgr = Arc::clone(&manager);\n        let uname = username.to_string();\n        let pwd = password.to_string();\n        let handle = thread::spawn(move || {\n            thread::sleep(Duration::from_millis(10));\n            match mgr.validate(&uname, &pwd) {\n                Ok(()) => println!(\"Access granted.\"),\n                Err(e) => println!(\"Access denied: {}\", e),\n            }\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused_unsafe)]\nuse std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\n#[derive(Clone)]\nstruct Account {\n    name: String,\n    secret: u64, \n}\nstruct Engine {\n    data: Arc<Mutex<HashMap<String, Account>>>,\n}\nimpl Engine {\n    fn new() -> Self {\n        Engine {\n            data: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n    unsafe fn fetch<'a>(&'a self, key: &str) -> Option<Account> {\n        let guard = self.data.lock().unwrap();\n        let ptr = &*guard as *const HashMap<String, Account>;\n        (*ptr).get(key).cloned()\n    }\n    fn verify(&self, username: &str, pwd: &str) -> Result<(), String> {\n        let account = unsafe { self.fetch(username) };\n        match account {\n            None => {\n                return Err(String::from(\"User does not exist\"));\n            }\n            Some(acc) => {\n                unsafe {\n                    let computed = pwd.bytes().fold(0u64, |accum, b| {\n                        accum.wrapping_mul(31).wrapping_add(b as u64)\n                    });\n                    if computed != acc.secret {\n                        return Err(String::from(\"Invalid password\"));\n                    }\n                }\n                Ok(())\n            }\n        }\n    }\n}\nfn main() {\n    let engine = Engine::new();\n    {\n        let mut db = engine.data.lock().unwrap();\n        unsafe {\n            let hash = \"secret\".bytes().fold(0u64, |accum, b| {\n                accum.wrapping_mul(31).wrapping_add(b as u64)\n            });\n            db.insert(\"alice\".to_string(), Account { name: \"alice\".into(), secret: hash });\n        }\n    }\n    let user = \"alice\";\n    let input = \"guess\";\n    match engine.verify(user, input) {\n        Ok(_) => println!(\"Access granted for {}\", user),\n        Err(err) => println!(\"Access denied: {}\", err),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct AuthService {\n    users: Arc<Mutex<HashMap<String, String>>>,\n}\nimpl AuthService {\n    fn new() -> Self {\n        let mut m = HashMap::new();\n        m.insert(\"alice\".to_string(), \"secret\".to_string());\n        AuthService {\n            users: Arc::new(Mutex::new(m)),\n        }\n    }\n    fn authenticate(&self, username: &str, password: &str) -> Result<(), String> {\n        let users = self.users.lock().unwrap();\n        unsafe {\n            let raw_users = &*(&*users as *const HashMap<String, String>);\n            if !raw_users.contains_key(username) {\n                return Err(\"User does not exist\".to_string());\n            }\n        }\n        let stored = users.get(username).unwrap();\n        if stored != password {\n            return Err(\"Incorrect password\".to_string());\n        }\n        Ok(())\n    }\n}\nfn main() {\n    let service = AuthService::new();\n    let service_arc = Arc::new(service);\n    let mut handles = Vec::new();\n    for _ in 0..5 {\n        let service_clone = Arc::clone(&service_arc);\n        handles.push(thread::spawn(move || {\n            match service_clone.authenticate(\"bob\", \"any\") {\n                Ok(_) => println!(\"Access granted\"),\n                Err(e) => println!(\"Access denied: {}\", e),\n            }\n        }));\n    }\n    for h in handles {\n        h.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\n#[derive(Debug, PartialEq)]\nenum AuthError {\n    UserNotFound,\n    WrongPassword,\n}\nstruct AuthSystem {\n    users: HashMap<String, String>, \n}\nimpl AuthSystem {\n    fn new() -> Self {\n        let mut users = HashMap::new();\n        users.insert(\"alice\".to_string(), \"password123\".to_string());\n        Self { users }\n    }\n    fn authenticate(&self, username: &str, password: &str) -> Result<(), AuthError> {\n        let stored = self.users.get(username);\n        if let Some(stored_pass) = stored {\n            unsafe {\n                let stored_bytes = stored_pass.as_bytes().as_ptr();\n                let input_bytes = password.as_bytes().as_ptr();\n                if stored_pass.len() == password.len() && *stored_bytes == *input_bytes {\n                    return Ok(());\n                }\n            }\n            Err(AuthError::WrongPassword)\n        } else {\n            Err(AuthError::UserNotFound)\n        }\n    }\n}\nfn main() {\n    let auth = Arc::new(Mutex::new(AuthSystem::new()));\n    let auth_clone = auth.clone();\n    let handle = std::thread::spawn(move || {\n        let system = auth_clone.lock().unwrap();\n        match system.authenticate(\"alice\", \"wrongpass\") {\n            Ok(_) => println!(\"Access granted\"),\n            Err(e) => println!(\"Access denied: {:?}\", e),\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\nstruct Database {\n    users: Arc<Mutex<Vec<(String, String)>>>,\n}\nimpl Database {\n    fn new() -> Self {\n        Self {\n            users: Arc::new(Mutex::new(Vec::new())),\n        }\n    }\n    fn add_user(&self, username: &str, password: &str) {\n        self.users\n            .lock()\n            .expect(\"mutex poisoned\")\n            .push((username.to_string(), password.to_string()));\n    }\n    unsafe fn check_credentials(&self, username: &str, password: &str) -> Result<(), String> {\n        let users = self.users.lock().expect(\"mutex poisoned\");\n        let handle = thread::spawn(|| {\n            thread::sleep(Duration::from_millis(10));\n        });\n        handle.join().expect(\"Thread panicked\");\n        for (user, pass) in users.iter() {\n            if user == username {\n                let pass_ptr: *const String = pass;\n                if *pass_ptr == password {\n                    return Ok(());\n                } else {\n                    return Err(format!(\n                        \"Invalid password: expected '{}'\",\n                        *pass_ptr\n                    ));\n                }\n            }\n        }\n        Err(\"User not found\".to_string())\n    }\n}\nfn main() {\n    let db = Database::new();\n    db.add_user(\"alice\", \"secret123\");\n    let result = unsafe { db.check_credentials(\"alice\", \"wrongpassword\") };\n    println!(\"{:?}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct AuthService {\n    users: Arc<Mutex<HashMap<String, String>>>,\n}\nimpl AuthService {\n    fn new() -> Self {\n        let mut user_map = HashMap::new();\n        user_map.insert(\"alice\".to_string(), \"password123\".to_string());\n        AuthService {\n            users: Arc::new(Mutex::new(user_map)),\n        }\n    }\n    fn login_auth(&self, username: &str, password: &str) -> Result<(), &'static str> {\n        let users_clone = self.users.clone();\n        let handle = thread::spawn(move || {\n            unsafe {\n                let guard = users_clone.lock().unwrap();\n                let raw_ptr = &*guard as *const HashMap<String, String>;\n                &*raw_ptr\n            }\n        });\n        let _ = handle.join().unwrap();\n        let exists = {\n            let guard = self.users.lock().unwrap();\n            guard.contains_key(username)\n        };\n        unsafe {\n            if exists {\n                let guard = self.users.lock().unwrap();\n                let correct = guard.get(username).unwrap();\n                if correct == password {\n                    Ok(())\n                } else {\n                    Err(\"Invalid password\")\n                }\n            } else {\n                Err(\"User not found\")\n            }\n        }\n    }\n}\nfn main() {\n    let service = AuthService::new();\n    match service.login_auth(\"alice\", \"wrongpassword\") {\n        Ok(_) => println!(\"Access granted\"),\n        Err(e) => println!(\"Access denied: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::{Arc, RwLock};\nuse std::thread;\nuse std::time::Duration;\nstruct Credentials {\n    data: Arc<RwLock<HashMap<String, String>>>,\n}\nimpl Credentials {\n    fn create() -> Self {\n        let mut map = HashMap::new();\n        map.insert(\"alice\".to_string(), \"secure_password\".to_string());\n        Credentials {\n            data: Arc::new(RwLock::new(map)),\n        }\n    }\n    fn authenticate(&self, user: &str, pass: &str) -> Result<(), String> {\n        let data_ref = unsafe { &*(&*self.data as *const RwLock<HashMap<String, String>>) };\n        let guard = data_ref.read().unwrap();\n        if let Some(stored_pass) = guard.get(user) {\n            if stored_pass == pass {\n                return Ok(());\n            } else {\n                return Err(\"Incorrect password for user\".to_string());\n            }\n        } else {\n            return Err(\"User not found\".to_string());\n        }\n    }\n}\nfn main() {\n    let system = Credentials::create();\n    let system_shared = Arc::new(system);\n    let system_for_thread = system_shared.clone();\n    let handle = thread::spawn(move || {\n        for _ in 0..3 {\n            let _ = system_for_thread.authenticate(\"alice\", \"wrong_password\");\n            thread::sleep(Duration::from_millis(50));\n        }\n    });\n    let _ = system_shared.authenticate(\"bob\", \"whatever\");\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::Arc;\nuse std::cell::UnsafeCell;\nuse std::thread;\nstruct Store {\n    data: UnsafeCell<HashMap<String, String>>,\n}\nunsafe impl Sync for Store {}\nimpl Store {\n    fn new() -> Self {\n        let mut map = HashMap::new();\n        map.insert(\"alice\".to_string(), \"secret123\".to_string());\n        Store {\n            data: UnsafeCell::new(map),\n        }\n    }\n    fn fetch(&self, user: &str) -> Option<String> {\n        unsafe { (*self.data.get()).get(user).cloned() }\n    }\n}\nstruct Service {\n    store: Arc<Store>,\n}\nimpl Service {\n    fn new() -> Self {\n        Service {\n            store: Arc::new(Store::new()),\n        }\n    }\n    fn authenticate(&self, username: &str, password: &str) -> Result<String, String> {\n        let store_clone = Arc::clone(&self.store);\n        let name = username.to_string();\n        let handle = thread::spawn(move || {\n            store_clone.fetch(&name)\n        });\n        let stored = handle.join().unwrap();\n        match stored {\n            None => Err(format!(\"Authentication failed: User '{}' does not exist.\", username)),\n            Some(stored_pass) => {\n                if stored_pass == password {\n                    Ok(format!(\"User {} authenticated successfully.\", username))\n                } else {\n                    Err(format!(\"Authentication failed: Wrong password for user '{}'. Expected '{}'.\", username, stored_pass))\n                }\n            }\n        }\n    }\n}\nfn main() {\n    let svc = Service::new();\n    let res = svc.authenticate(\"alice\", \"wrongpassword\");\n    match res {\n        Ok(msg) => println!(\"{}\", msg),\n        Err(err) => println!(\"Error: {}\", err),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Credential {\n    username: String,\n    password: String,\n}\nstruct Auth {\n    accounts: Arc<Mutex<HashMap<String, String>>>,\n}\nimpl Auth {\n    fn new() -> Self {\n        let mut map = HashMap::new();\n        map.insert(\"alice\".to_string(), \"alice_secret\".to_string());\n        map.insert(\"bob\".to_string(), \"bob_secret\".to_string());\n        Auth {\n            accounts: Arc::new(Mutex::new(map)),\n        }\n    }\n    fn login(&self, user: &str, pass: &str) -> Result<(), String> {\n        let accounts = self.accounts.clone();\n        let user_ptr = user.as_ptr();\n        unsafe {\n            let _ = *user_ptr;\n        }\n        let acc = accounts.lock().unwrap();\n        if let Some(stored) = acc.get(user) {\n            if stored == pass {\n                Ok(())\n            } else {\n                Err(\"password incorrect\".to_string())\n            }\n        } else {\n            Err(\"unknown user\".to_string())\n        }\n    }\n}\nfn main() {\n    let auth = Auth::new();\n    let username = \"alice\";\n    let password = \"wrong_password\"; \n    match auth.login(username, password) {\n        Ok(_) => println!(\"Logged in successfully.\"),\n        Err(e) => println!(\"Login error: {}\", e),\n    }\n    let cloned_accounts = auth.accounts.clone();\n    let handle = thread::spawn(move || {\n        let acc = cloned_accounts.lock().unwrap();\n        println!(\"Total registered users: {}\", acc.len());\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct User {\n    username: String,\n    password: String,\n}\nstruct AuthSystem {\n    users: Arc<Mutex<HashMap<String, User>>>,\n}\nimpl AuthSystem {\n    fn new() -> Self {\n        AuthSystem {\n            users: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n    fn register(&self, username: &str, password: &str) {\n        let mut users = self.users.lock().unwrap();\n        users.insert(\n            username.to_string(),\n            User {\n                username: username.to_string(),\n                password: password.to_string(),\n            },\n        );\n    }\n    fn verify(&self, username: &str, password: &str) -> Result<(), String> {\n        let users = self.users.lock().unwrap();\n        if let Some(user) = users.get(username) {\n            unsafe {\n                let input_ptr = password.as_ptr();\n                let stored_ptr = user.password.as_ptr();\n                let input_len = password.len();\n                let stored_len = user.password.len();\n                if input_len != stored_len {\n                    return Err(\"Incorrect password for user\".to_string());\n                }\n                for i in 0..input_len {\n                    let in_byte = *input_ptr.add(i);\n                    let stored_byte = *stored_ptr.add(i);\n                    if in_byte != stored_byte {\n                        return Err(\"Incorrect password for user\".to_string());\n                    }\n                }\n            }\n            Ok(())\n        } else {\n            Err(\"Username does not exist\".to_string())\n        }\n    }\n}\nfn main() {\n    let auth = AuthSystem::new();\n    auth.register(\"alice\", \"secret\");\n    let handles: Vec<_> = (0..5)\n        .map(|_| {\n            let auth_clone = AuthSystem {\n                users: Arc::clone(&auth.users),\n            };\n            thread::spawn(move || {\n                let _ = auth_clone.verify(\"alice\", \"secret\");\n            })\n        })\n        .collect();\n    for handle in handles {\n        let _ = handle.join();\n    }\n    match auth.verify(\"alice\", \"wrong\") {\n        Ok(_) => println!(\"Logged in successfully.\"),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct AuthService {\n    users: Arc<Mutex<HashMap<String, String>>>,\n}\nimpl AuthService {\n    fn new() -> Self {\n        let mut map = HashMap::new();\n        map.insert(\"alice\".to_string(), \"wonderland\".to_string());\n        map.insert(\"bob\".to_string(), \"builder\".to_string());\n        AuthService {\n            users: Arc::new(Mutex::new(map)),\n        }\n    }\n    fn verify(&self, username: &str, password: &str) -> Result<bool, &'static str> {\n        let users_ptr = Arc::as_ptr(&self.users);\n        unsafe {\n            let users_ref = &*users_ptr;\n            let map_lock = users_ref.lock().unwrap();\n            if let Some(stored) = map_lock.get(username) {\n                if stored == password {\n                    Ok(true)\n                } else {\n                    Err(\"Invalid password\")\n                }\n            } else {\n                Err(\"User does not exist\")\n            }\n        }\n    }\n}\nfn main() {\n    let svc = AuthService::new();\n    let svc_arc = Arc::new(svc);\n    let handles: Vec<_> = vec![\n        {\n            let svc_clone = svc_arc.clone();\n            thread::spawn(move || {\n                let _ = svc_clone.verify(\"alice\", \"wonderland\");\n            })\n        },\n        {\n            let svc_clone = svc_arc.clone();\n            thread::spawn(move || {\n                let _ = svc_clone.verify(\"charlie\", \"chocolate\");\n            })\n        },\n    ];\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    println!(\"Execution complete: Vulnerable variant.\");\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::fmt;\n#[derive(Debug)]\nstruct Account {\n    username: String,\n    password: String,\n}\n#[derive(Debug)]\nenum AuthError {\n    UserNotFound(String),\n    WrongPassword(String),\n}\nimpl fmt::Display for AuthError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            AuthError::UserNotFound(msg) => write!(f, \"{}\", msg),\n            AuthError::WrongPassword(msg) => write!(f, \"{}\", msg),\n        }\n    }\n}\nstruct Authenticator {\n    accounts: Arc<Mutex<Vec<Account>>>,\n}\nimpl Authenticator {\n    fn new() -> Self {\n        let accounts = vec![\n            Account {\n                username: \"alice\".to_string(),\n                password: \"secret\".to_string(),\n            },\n            Account {\n                username: \"bob\".to_string(),\n                password: \"hunter2\".to_string(),\n            },\n        ];\n        Authenticator { accounts: Arc::new(Mutex::new(accounts)) }\n    }\n    fn verify(&self, user: &str, pass: &str) -> Result<(), AuthError> {\n        let accounts = self.accounts.lock().unwrap();\n        for acc in accounts.iter() {\n            if acc.username == user {\n                unsafe {\n                    let _ptr = acc.password.as_ptr(); \n                }\n                if acc.password == pass {\n                    return Ok(());\n                } else {\n                    return Err(AuthError::WrongPassword(format!(\n                        \"Account {} exists but password is incorrect\", user\n                    )));\n                }\n            }\n        }\n        Err(AuthError::UserNotFound(format!(\n            \"User {} does not exist\", user\n        )))\n    }\n}\nfn main() {\n    let auth = Authenticator::new();\n    let username = \"alice\";\n    let password = \"wrong_password\";\n    match auth.verify(username, password) {\n        Ok(_) => println!(\"Login successful\"),\n        Err(e) => {\n            println!(\"Error: {}\", e);\n            match e {\n                AuthError::UserNotFound(_) => std::process::exit(1),\n                AuthError::WrongPassword(_) => std::process::exit(2),\n            }\n        }\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct App {\n    storage: Arc<Mutex<HashMap<String, String>>>,\n}\n#[derive(Debug, PartialEq)]\nenum ErrorType {\n    UserMissing,\n    CredentialMismatch,\n}\nimpl App {\n    fn new() -> Self {\n        let mut users = HashMap::new();\n        users.insert(\"alice\".to_string(), \"secret\".to_string());\n        App {\n            storage: Arc::new(Mutex::new(users)),\n        }\n    }\n    fn verify(&self, account: &str, secret: &str) -> Result<(), ErrorType> {\n        let users = self.storage.lock().unwrap();\n        if let Some(valid_secret) = users.get(account) {\n            unsafe {\n                let ptr = valid_secret.as_ptr();\n                let len = valid_secret.len();\n                let slice = std::slice::from_raw_parts(ptr, len);\n                let valid_str = std::str::from_utf8_unchecked(slice);\n                if valid_str == secret {\n                    return Ok(());\n                } else {\n                    return Err(ErrorType::CredentialMismatch);\n                }\n            }\n        } else {\n            return Err(ErrorType::UserMissing);\n        }\n    }\n}\nfn main() {\n    let service = App::new();\n    let service_arc = Arc::new(service);\n    let handles: Vec<_> = (0..5)\n        .map(|i| {\n            let srv = service_arc.clone();\n            thread::spawn(move || {\n                let _ = srv.verify(\"alice\", if i % 2 == 0 { \"wrong\" } else { \"secret\" });\n            })\n        })\n        .collect();\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Record {\n    username: String,\n    pass_hash: u64,\n}\nstruct Service {\n    users: Arc<Mutex<Vec<Record>>>,\n}\nimpl Service {\n    fn new() -> Self {\n        Service {\n            users: Arc::new(Mutex::new(Vec::new())),\n        }\n    }\n    fn register(&self, name: &str, password: &str) {\n        let hash = self.compute_hash(password);\n        let rec = Record {\n            username: name.to_string(),\n            pass_hash: hash,\n        };\n        self.users.lock().unwrap().push(rec);\n    }\n    fn authenticate(&self, name: &str, password: &str) -> Result<&'static str, &'static str> {\n        let input_hash = self.compute_hash(password);\n        let data = self.users.lock().unwrap();\n        for rec in data.iter() {\n            if rec.username == name {\n                if rec.pass_hash == input_hash {\n                    return Ok(\"Access granted\");\n                } else {\n                    return Err(\"Password mismatch\");\n                }\n            }\n        }\n        Err(\"User not found\")\n    }\n    fn compute_hash(&self, input: &str) -> u64 {\n        let bytes = input.as_bytes();\n        let mut sum = 0u64;\n        unsafe {\n            let mut ptr = bytes.as_ptr();\n            for _ in 0..bytes.len() {\n                sum = sum.wrapping_add(*ptr as u64);\n                ptr = ptr.offset(1);\n            }\n        }\n        sum\n    }\n}\nfn main() {\n    let svc = Service::new();\n    svc.register(\"alice\", \"secret\");\n    let svc_clone = Service {\n        users: svc.users.clone(),\n    };\n    let handle = thread::spawn(move || {\n        let res = svc_clone.authenticate(\"alice\", \"wrongpass\");\n        println!(\"Thread result: {:?}\", res);\n    });\n    let res_main = svc.authenticate(\"nonexistent\", \"nopass\");\n    println!(\"Main thread result: {:?}\", res_main);\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct DataBuffer {\n    data: Vec<u8>,\n}\nimpl DataBuffer {\n    fn new(size: usize) -> Self {\n        let mut data = Vec::with_capacity(size);\n        unsafe { data.set_len(size); } \n        for i in 0..size {\n            data[i] = i as u8;\n        }\n        Self { data }\n    }\n    fn process(&self) -> u8 {\n        unsafe {\n            *self.data.get_unchecked(self.data.len())\n        }\n    }\n}\nfn main() {\n    let buffer = Arc::new(Mutex::new(DataBuffer::new(10)));\n    let clone = Arc::clone(&buffer);\n    let handle = thread::spawn(move || {\n        let guard = clone.lock().unwrap();\n        guard.process()\n    });\n    let result = handle.join().unwrap();\n    println!(\"Result: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nstruct DataHandler;\nimpl DataHandler {\n    pub fn combine(&self, input: &[u8]) -> Vec<u8> {\n        let len = input.len();\n        let mut output = Vec::with_capacity(len);\n        unsafe {\n            std::ptr::copy_nonoverlapping(input.as_ptr(), output.as_mut_ptr(), len);\n            output.set_len(len + 1);\n        }\n        output\n    }\n}\nfn main() {\n    let handler = DataHandler;\n    let input = b\"test\";\n    let handle = thread::spawn(move || {\n        let result = handler.combine(input);\n        println!(\"Combined output: {:?}\", result);\n    });\n    handle.join().unwrap();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Buffer {\n    data: Vec<u32>,\n}\nimpl Buffer {\n    fn new(size: usize) -> Buffer {\n        Buffer {\n            data: Vec::with_capacity(size),\n        }\n    }\n    fn fill(&mut self) {\n        let size = self.data.capacity();\n        unsafe {\n            self.data.set_len(size);\n            let ptr = self.data.as_mut_ptr();\n            for i in 0..=size { \n                *ptr.add(i) = i as u32;\n            }\n        }\n    }\n    fn sum(&self) -> u32 {\n        self.data.iter().sum()\n    }\n}\npub fn process() -> u32 {\n    let mut buffer = Buffer::new(10);\n    buffer.fill();\n    buffer.sum()\n}\nfn main() {\n    let result = process();\n    println!(\"Result: {}\", result);\n    let shared = Arc::new(Mutex::new(Buffer {\n        data: Vec::with_capacity(10),\n    }));\n    {\n        let mut temp = shared.lock().unwrap();\n        temp.fill();\n    }\n    let mut handles = Vec::new();\n    for _ in 0..5 {\n        let shared_clone = Arc::clone(&shared);\n        handles.push(thread::spawn(move || {\n            let lock = shared_clone.lock().unwrap();\n            lock.sum()\n        }));\n    }\n    for handle in handles {\n        let res = handle.join().unwrap();\n        println!(\"Thread result: {}\", res);\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct DataProcessor;\nimpl DataProcessor {\n    pub fn process(&self, input: &[u8]) -> Vec<u8> {\n        let mut result: Vec<u8> = Vec::with_capacity(input.len());\n        unsafe {\n            std::ptr::copy_nonoverlapping(input.as_ptr(), result.as_mut_ptr(), input.len());\n            result.set_len(input.len() - 1);\n        }\n        result\n    }\n}\nfn run(input: &[u8]) -> Vec<u8> {\n    let processor = Arc::new(DataProcessor);\n    let data = Arc::new(input.to_vec());\n    let output = Arc::new(Mutex::new(Vec::new()));\n    let mut handles = vec![];\n    for _ in 0..4 {\n        let proc_clone = Arc::clone(&processor);\n        let data_clone = Arc::clone(&data);\n        let out_clone = Arc::clone(&output);\n        let handle = thread::spawn(move || {\n            let res = proc_clone.process(&data_clone);\n            let mut guard = out_clone.lock().unwrap();\n            *guard = res;\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    Arc::try_unwrap(output).unwrap().into_inner().unwrap()\n}\nfn main() {\n    let input = b\"abcdef\"; \n    let output = run(input);\n    println!(\"Output length: {}\", output.len());\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Container {\n    data: Arc<Mutex<Vec<u8>>>,\n}\nimpl Container {\n    fn new() -> Self {\n        Container { data: Arc::new(Mutex::new(Vec::with_capacity(10))) }\n    }\n    fn process(&self, value: u8) -> Result<(), &'static str> {\n        let mut guard = self.data.lock().unwrap();\n        let vec_ref = &mut *guard;\n        let len = vec_ref.len();\n        if len >= vec_ref.capacity() {\n            return Err(\"Buffer full\");\n        }\n        unsafe {\n            let ptr = vec_ref.as_mut_ptr().add(len + 1);\n            *ptr = value;\n            vec_ref.set_len(len + 1);\n        }\n        Ok(())\n    }\n    fn inspect(&self) -> Vec<u8> {\n        self.data.lock().unwrap().clone()\n    }\n}\nfn main() {\n    let inst = Container::new();\n    for _ in 0..5 {\n        inst.process(42).expect(\"Write failed\");\n    }\n    let mut threads = Vec::new();\n    for i in 0..3 {\n        let clone = Container { data: Arc::clone(&inst.data) };\n        threads.push(thread::spawn(move || {\n            for _ in 0..2 {\n                clone.process(10 + i as u8).expect(\"Write failed\");\n            }\n        }));\n    }\n    for th in threads {\n        th.join().unwrap();\n    }\n    let snapshot = inst.inspect();\n    println!(\"Snapshot: {:?}\", snapshot);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Accumulator {\n    data: Arc<Mutex<Vec<i32>>>,\n}\nimpl Accumulator {\n    fn new(size: usize) -> Self {\n        let mut vec = Vec::with_capacity(size);\n        unsafe { vec.set_len(size); } \n        Self { data: Arc::new(Mutex::new(vec)) }\n    }\n    fn process(&self) {\n        let len = self.data.lock().unwrap().len();\n        let mut handles = Vec::new();\n        for i in 0..len+1 {\n            let arc_clone = Arc::clone(&self.data);\n            handles.push(thread::spawn(move || {\n                let mut vec = arc_clone.lock().unwrap();\n                unsafe {\n                    let ptr = vec.as_mut_ptr();\n                    *ptr.add(i) = i as i32; \n                }\n            }));\n        }\n        for handle in handles {\n            handle.join().unwrap();\n        }\n    }\n    fn total(&self) -> i32 {\n        let vec = self.data.lock().unwrap();\n        vec.iter().sum()\n    }\n}\nfn main() {\n    let aggregator = Accumulator::new(10);\n    aggregator.process();\n    println!(\"Sum: {}\", aggregator.total());\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Data {\n    buffer: Vec<u8>,\n}\nimpl Data {\n    fn new(size: usize) -> Self {\n        let mut vec = Vec::with_capacity(size);\n        for i in 0..(size - 1) {\n            vec.push(i as u8);\n        }\n        unsafe {\n            vec.set_len(size);\n        }\n        Data { buffer: vec }\n    }\n    fn sum(&self) -> u64 {\n        self.buffer.iter().map(|&x| x as u64).sum()\n    }\n}\nfn main() {\n    let shared = Arc::new(Mutex::new(Data::new(10)));\n    let mut threads = vec![];\n    for _ in 0..4 {\n        let clone = shared.clone();\n        threads.push(thread::spawn(move || {\n            let guard = clone.lock().unwrap();\n            println!(\"Total: {}\", guard.sum());\n        }));\n    }\n    for t in threads {\n        t.join().unwrap();\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Buffer {\n    data: Vec<u32>,\n}\nimpl Buffer {\n    fn new(n: usize) -> Self {\n        let mut data = Vec::with_capacity(n);\n        unsafe {\n            data.set_len(n);\n        }\n        Buffer { data }\n    }\n    fn populate(&mut self) {\n        let n = self.data.len();\n        for i in 0..=n {\n            unsafe {\n                let ptr = self.data.as_mut_ptr().add(i);\n                *ptr = (i + 1) as u32;\n            }\n        }\n    }\n    fn concurrent_sum(&self) -> u32 {\n        let shared = Arc::new(self.data.clone());\n        let shared_clone = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            let mut total = 0;\n            for &val in shared_clone.iter() {\n                total += val;\n            }\n            total\n        });\n        handle.join().unwrap()\n    }\n}\nfn main() {\n    let mut buf = Buffer::new(10);\n    buf.populate();\n    let total = buf.concurrent_sum();\n    println!(\"Total: {}\", total);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\npub struct DataContainer {\n    data: Vec<u8>,\n}\nimpl DataContainer {\n    pub fn new(size: usize) -> Self {\n        let mut v = Vec::with_capacity(size);\n        unsafe { v.set_len(size + 1); }\n        for i in 0..(size + 1) {\n            v[i] = i as u8;\n        }\n        DataContainer { data: v }\n    }\n    pub fn sum(&self) -> u32 {\n        self.data.iter().map(|&b| b as u32).sum()\n    }\n}\nfn main() {\n    let container = Arc::new(Mutex::new(DataContainer::new(10)));\n    let c = Arc::clone(&container);\n    let handle = thread::spawn(move || {\n        let locked = c.lock().unwrap();\n        println!(\"Sum in thread: {}\", locked.sum());\n    });\n    handle.join().unwrap();\n    let locked = container.lock().unwrap();\n    println!(\"Final Sum: {}\", locked.sum());\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::vec::Vec;\nstruct Processor;\nimpl Processor {\n    pub fn execute(&self, input: &[u32]) -> u32 {\n        let n = input.len();\n        let mut storage: Vec<u32> = Vec::with_capacity(n);\n        unsafe {\n            let ptr = storage.as_mut_ptr();\n            for i in 0..=n {  \n                if i < n {\n                    *ptr.add(i) = input[i];\n                } else {\n                    *ptr.add(i) = 999;\n                }\n            }\n            storage.set_len(n);\n            let computed = std::slice::from_raw_parts(storage.as_ptr(), n + 1)\n                            .iter()\n                            .sum::<u32>();\n            computed\n        }\n    }\n}\nfn main() {\n    let proc = Processor;\n    let data = vec![1, 2, 3, 4];\n    let result = proc.execute(&data);\n    println!(\"Result: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Core {\n    size: usize,\n}\nimpl Core {\n    pub fn new(size: usize) -> Self {\n        Core { size }\n    }\n    pub fn generate(&self) -> u32 {\n        let mut construct = Vec::with_capacity(self.size);\n        unsafe {\n            construct.set_len(self.size);\n            for index in 0..=self.size {\n                *construct.get_unchecked_mut(index) = index as u32;\n            }\n        }\n        construct.iter().sum()\n    }\n}\nfn main() {\n    let entity = Arc::new(Mutex::new(Core::new(10)));\n    let clone_entity = Arc::clone(&entity);\n    let thread_handle = thread::spawn(move || {\n        let guard = clone_entity.lock().unwrap();\n        let total = guard.generate();\n        println!(\"Computed sum in thread: {}\", total);\n        total\n    });\n    let main_total = {\n        let guard = entity.lock().unwrap();\n        guard.generate()\n    };\n    let thread_total = thread_handle.join().unwrap();\n    println!(\"Computed sum in main: {}\", main_total);\n    if main_total != thread_total {\n        println!(\"Inconsistency detected.\");\n        std::process::exit(1);\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::ptr;\nstruct DataManager {\n    data: Arc<Mutex<Vec<u8>>>,\n}\nimpl DataManager {\n    fn new(capacity: usize) -> Self {\n        let mut v = Vec::with_capacity(capacity);\n        unsafe {\n            v.set_len(capacity);\n        }\n        DataManager {\n            data: Arc::new(Mutex::new(v)),\n        }\n    }\n    fn process(&self, input: &[u8]) {\n        let mut lock = self.data.lock().unwrap();\n        if input.len() > lock.capacity() {\n            panic!(\"Input too large\");\n        }\n        unsafe {\n            ptr::copy_nonoverlapping(input.as_ptr(), lock.as_mut_ptr(), input.len());\n            lock.set_len(input.len() + 1);\n        }\n    }\n    fn fetch(&self) -> Vec<u8> {\n        let lock = self.data.lock().unwrap();\n        lock.clone()\n    }\n}\npub fn main() {\n    let manager = DataManager::new(10);\n    let manager_clone = manager.data.clone();\n    let reader = thread::spawn(move || {\n        thread::sleep(std::time::Duration::from_millis(50));\n        let data = manager_clone.lock().unwrap();\n        println!(\"Concurrent read sees: {:?}\", &*data);\n    });\n    let src = vec![1, 2, 3, 4, 5];\n    manager.process(&src);\n    reader.join().unwrap();\n    println!(\"Operation complete, vector length: {}\", manager.fetch().len());\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nuse std::thread;\nstruct Processor;\nimpl Processor {\n    pub fn process(data: &[u32]) -> Vec<u32> {\n        let n = data.len();\n        let mut out: Vec<u32> = Vec::with_capacity(n);\n        unsafe {\n            let ptr_out = out.as_mut_ptr();\n            for i in 0..n {\n                ptr_out.add(i).write(data[i].wrapping_add(1));\n            }\n            out.set_len(n + 1);\n        }\n        out\n    }\n}\nfn main() {\n    let data = vec![10, 20, 30, 40];\n    let handles: Vec<_> = (0..4)\n        .map(|_| {\n            let data_thread = data.clone();\n            thread::spawn(move || {\n                let result = Processor::process(&data_thread);\n                println!(\"Result: {:?}\", result);\n            })\n        })\n        .collect();\n    for handle in handles {\n        handle.join().expect(\"Thread panicked\");\n    }\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::vec::Vec;\nstruct DataBuffer {\n    data: Vec<u8>,\n}\nimpl DataBuffer {\n    fn new(n: usize) -> Self {\n        let mut v = Vec::with_capacity(n);\n        unsafe {\n            v.set_len(n + 1);\n        }\n        DataBuffer { data: v }\n    }\n    fn fill(&mut self, value: u8) {\n        for i in 0..self.data.len() - 1 {\n            self.data[i] = value;\n        }\n    }\n}\nfn main() {\n    let mut buf = DataBuffer::new(5);\n    buf.fill(10);\n    println!(\"Buffer contents: {:?}\", buf.data);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\n#[repr(C)]\npub struct Holder {\n    pub data: [u8; 5],\n    pub extra: u8,\n}\nimpl Holder {\n    pub fn new() -> Self {\n        Self {\n            data: [1, 2, 3, 4, 5],\n            extra: 99,\n        }\n    }\n}\npub fn compute_total(holder: &Holder) -> u32 {\n    unsafe {\n        let ptr = holder.data.as_ptr();\n        let slice = std::slice::from_raw_parts(ptr, holder.data.len() + 1);\n        slice.iter().map(|&x| x as u32).sum()\n    }\n}\npub fn run() {\n    let holder = Holder::new();\n    let handle = thread::spawn(move || compute_total(&holder));\n    let total = handle.join().unwrap();\n    println!(\"Total: {}\", total);\n}\nfn main() {\n    run();\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\ntrait Summable {\n    fn calculate(&self) -> u32;\n}\nstruct BufferHandler {\n    buf: Vec<u8>,\n}\nimpl BufferHandler {\n    fn new() -> Self {\n        BufferHandler { buf: Vec::new() }\n    }\n    fn load(&mut self, data: &[u8]) {\n        self.buf.extend_from_slice(data);\n    }\n}\nimpl Summable for BufferHandler {\n    fn calculate(&self) -> u32 {\n        let len = self.buf.len();\n        let ptr = self.buf.as_ptr();\n        unsafe {\n            let mut total: u32 = 0;\n            for i in 0..=len {\n                total += *ptr.add(i) as u32;\n            }\n            total\n        }\n    }\n}\nfn main() {\n    let mut handler = BufferHandler::new();\n    handler.load(&[1, 2, 3, 4]);\n    let shared_handler = Arc::new(handler);\n    let handler_clone = Arc::clone(&shared_handler);\n    let worker = thread::spawn(move || {\n        handler_clone.calculate()\n    });\n    let result = worker.join().expect(\"Worker thread panicked\");\n    println!(\"Computed sum: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct DataHandler;\nimpl DataHandler {\n    pub fn process(&self, input: &[u8]) -> Vec<u8> {\n        let mut buffer: Vec<u8> = Vec::with_capacity(input.len());\n        unsafe {\n            let dest = buffer.as_mut_ptr();\n            for i in 0..input.len() {\n                let value = *input.get_unchecked(i);\n                ptr::write(dest.add(i), value);\n            }\n            buffer.set_len(input.len() + 1);\n        }\n        buffer\n    }\n}\nfn main() {\n    let handler = DataHandler;\n    let sample = vec![10, 20, 30, 40];\n    let result = handler.process(&sample);\n    println!(\"Processed output: {:?}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct DataBuffer {\n    data: Vec<u32>,\n}\nimpl DataBuffer {\n    fn new(size: usize) -> Self {\n        let mut data = Vec::with_capacity(size);\n        unsafe {\n            data.set_len(size);\n        }\n        Self { data }\n    }\n    unsafe fn populate(&mut self) {\n        for i in 0..=self.data.len() {\n            *self.data.get_unchecked_mut(i) = i as u32;\n        }\n    }\n    fn total(&self) -> u32 {\n        self.data.iter().sum()\n    }\n}\nfn compute() -> u32 {\n    let shared = Arc::new(Mutex::new(DataBuffer::new(10)));\n    let shared_clone = Arc::clone(&shared);\n    let handler = thread::spawn(move || {\n        let mut guard = shared_clone.lock().expect(\"failed to lock\");\n        unsafe {\n            guard.populate();\n        }\n    });\n    handler.join().expect(\"Thread panicked\");\n    let guard = shared.lock().expect(\"failed to lock after join\");\n    guard.total()\n}\nfn main() {\n    let result = compute();\n    println!(\"Result: {}\", result);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct BufferProcessor {\n    data: Vec<u32>,\n}\nimpl BufferProcessor {\n    fn new(capacity: usize) -> Self {\n        BufferProcessor {\n            data: Vec::with_capacity(capacity),\n        }\n    }\n    fn load_data(&mut self, src: &[u32]) {\n        unsafe {\n            self.data.set_len(src.len());\n            let dst_ptr = self.data.as_mut_ptr();\n            for i in 0..src.len() {\n                *dst_ptr.add(i) = *src.get_unchecked(i + 1);\n            }\n        }\n    }\n    fn process(&mut self, src: &[u32]) -> u32 {\n        self.load_data(src);\n        self.data.iter().sum()\n    }\n}\nfn main() {\n    let input = vec![10, 20, 30, 40];\n    let mut processor = BufferProcessor::new(input.len());\n    let result = processor.process(&input);\n    println!(\"Result: {}\", result);\n    let sum = run_concurrent();\n    println!(\"Concurrent Total: {}\", sum);\n}\nfn run_concurrent() -> u32 {\n    let input = vec![10, 20, 30, 40];\n    let processor = Arc::new(Mutex::new(BufferProcessor::new(input.len())));\n    let input_arc = Arc::new(input);\n    let mut handles = Vec::new();\n    for _ in 0..2 {\n        let proc_clone = Arc::clone(&processor);\n        let in_clone = Arc::clone(&input_arc);\n        let handle = thread::spawn(move || {\n            let mut proc = proc_clone.lock().expect(\"Lock poisoned\");\n            proc.process(&in_clone)\n        });\n        handles.push(handle);\n    }\n    let mut total = 0;\n    for handle in handles {\n        total += handle.join().expect(\"Thread panicked\");\n    }\n    total\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::vec::Vec;\nuse std::sync::{Arc, Mutex};\nstruct DataBlock {\n    data: Vec<u32>,\n}\nimpl DataBlock {\n    fn new(size: usize) -> Self {\n        let mut vec = Vec::with_capacity(size);\n        unsafe {\n            vec.set_len(size);\n        }\n        Self { data: vec }\n    }\n    fn fill(&mut self) {\n        unsafe {\n            let ptr = self.data.as_mut_ptr();\n            for i in 0..=self.data.len() {\n                *ptr.add(i) = i as u32;\n            }\n        }\n    }\n    fn verify(&self) -> bool {\n        let len = self.data.len();\n        for i in 0..len {\n            if self.data[i] != i as u32 {\n                return false;\n            }\n        }\n        true\n    }\n}\nfn main() {\n    let shared = Arc::new(Mutex::new(DataBlock::new(10)));\n    {\n        let shared_clone = Arc::clone(&shared);\n        let handle = std::thread::spawn(move || {\n            let mut db = shared_clone.lock().unwrap();\n            db.fill();\n        });\n        handle.join().unwrap();\n    }\n    let db = shared.lock().unwrap();\n    println!(\"Buffer contents (vulnerable): {:?}\", db.data);\n}\n",
    "output": "vulnerable"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::env;\nuse std::ptr;\nconst MAX_DEPTH: usize = 1000; \npub struct Tree {\n    pub children: Vec<Tree>,\n}\nimpl Tree {\n    pub unsafe fn new() -> Self {\n        let ptr = ptr::null_mut::<u8>();\n        if ptr.is_null() {\n            Tree { children: Vec::new() }\n        } else {\n            Tree { children: Vec::new() }\n        }\n    }\n}\npub fn process(input: &str) -> Result<Tree, &'static str> {\n    let bytes = input.as_bytes();\n    fn rec_parse(b: &[u8], index: &mut usize, depth: usize) -> Result<Tree, &'static str> {\n        if depth > MAX_DEPTH {\n            return Err(\"Recursion depth limit exceeded\");\n        }\n        let mut node = unsafe { Tree::new() };\n        while *index < b.len() {\n            match b[*index] {\n                b'(' => {\n                    *index += 1;\n                    let child = rec_parse(b, index, depth + 1)?;\n                    node.children.push(child);\n                }\n                b')' => {\n                    *index += 1;\n                    return Ok(node);\n                }\n                _ => return Err(\"Unexpected character encountered\"),\n            }\n        }\n        Ok(node)\n    }\n    let mut idx = 0;\n    let tree = rec_parse(bytes, &mut idx, 0)?;\n    if idx != bytes.len() {\n        Err(\"Extra characters in input\")\n    } else {\n        Ok(tree)\n    }\n}\nfn main() {\n    let input = \"(\".repeat(1500) + &\")\".repeat(1500);\n    match process(&input) {\n        Ok(tree) => println!(\"Parsed tree with {} top-level children\", tree.children.len()),\n        Err(err) => eprintln!(\"Error encountered: {}\", err),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nconst MAX_DEPTH: usize = 100;\nstruct Parser {\n    data: *const u8,\n    len: usize,\n    pos: usize,\n}\nimpl Parser {\n    fn new(input: &str) -> Self {\n        let bytes = input.as_bytes();\n        Parser {\n            data: bytes.as_ptr(),\n            len: bytes.len(),\n            pos: 0,\n        }\n    }\n    fn next_byte(&mut self) -> Option<u8> {\n        if self.pos < self.len {\n            let byte = unsafe { ptr::read(self.data.add(self.pos)) };\n            self.pos += 1;\n            Some(byte)\n        } else {\n            None\n        }\n    }\n    fn parse(&mut self, depth: usize) -> Result<(), &'static str> {\n        if depth > MAX_DEPTH {\n            return Err(\"Maximum recursion depth exceeded\");\n        }\n        match self.next_byte() {\n            Some(b'(') => {\n                self.parse(depth + 1)?; \n                match self.next_byte() {\n                    Some(b')') => Ok(()),\n                    _ => Err(\"Missing closing parenthesis\"),\n                }\n            },\n            Some(b')') => Err(\"Unexpected closing parenthesis\"),\n            Some(_) => self.parse(depth),\n            None => Ok(()),\n        }\n    }\n}\nfn process(input: &str) -> Result<(), &'static str> {\n    let mut p = Parser::new(input);\n    p.parse(0)\n}\nfn main() {\n    let input = \"(())\";\n    match process(input) {\n        Ok(_) => println!(\"Parsed successfully\"),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\nuse std::env;\nconst MAX_DEPTH: usize = 1000;\n#[derive(Debug)]\nstruct Node {\n    children: Vec<Node>,\n}\nfn build_ast_safe(chars: &mut std::str::Chars, depth: usize) -> Result<Node, String> {\n    if depth > MAX_DEPTH {\n        return Err(\"Recursion limit exceeded\".to_string());\n    }\n    let mut node = Node { children: Vec::new() };\n    unsafe {\n        let ptr: *mut Node = &mut node;\n        *ptr = Node { children: Vec::new() };\n    }\n    while let Some(ch) = chars.next() {\n        if ch == '(' {\n            let child = build_ast_safe(chars, depth + 1)?;\n            node.children.push(child);\n        } else if ch == ')' {\n            return Ok(node);\n        } else {\n        }\n    }\n    Ok(node)\n}\npub fn parse_nested(input: &str) -> Result<Node, String> {\n    let mut chars = input.chars();\n    build_ast_safe(&mut chars, 0)\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let input = if args.len() > 1 {\n        args[1].clone()\n    } else {\n        let opens = \"(\".repeat(1200);\n        let closes = \")\".repeat(1200);\n        opens + &closes\n    };\n    match parse_nested(&input) {\n        Ok(ast) => println!(\"Parsed AST: {:?}\", ast),\n        Err(e) => println!(\"Parsing failed with error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\n#[derive(Debug)]\npub struct Node {\n    pub kind: char,\n    pub children: Vec<Node>,\n}\npub struct Parser {\n    data: String,\n    pos: usize,\n}\nimpl Parser {\n    pub fn new(data: String) -> Self {\n        Parser { data, pos: 0 }\n    }\n    pub unsafe fn next_char(&mut self) -> Option<char> {\n        if self.pos >= self.data.len() {\n            return None;\n        }\n        let ptr = self.data.as_ptr().add(self.pos);\n        self.pos += 1;\n        Some(*ptr as char)\n    }\n    pub fn parse_expr(&mut self, depth: usize) -> Result<Node, String> {\n        const MAX_DEPTH: usize = 1000;\n        if depth > MAX_DEPTH {\n            return Err(\"Recursion depth limit exceeded\".into());\n        }\n        let ch = unsafe { self.next_char() }.ok_or(\"Unexpected end of input\")?;\n        if ch == '(' {\n            let mut children = Vec::new();\n            loop {\n                if self.pos < self.data.len() {\n                    let peek = unsafe { *self.data.as_ptr().add(self.pos) as char };\n                    if peek == ')' {\n                        unsafe { self.next_char() };\n                        break;\n                    }\n                } else {\n                    return Err(\"Missing closing parenthesis\".into());\n                }\n                let child = self.parse_expr(depth + 1)?;\n                children.push(child);\n            }\n            Ok(Node { kind: '(', children })\n        } else if ch == 'a' {\n            Ok(Node { kind: 'a', children: vec![] })\n        } else {\n            Err(format!(\"Unexpected character: {}\", ch))\n        }\n    }\n}\n// Public interface used for processing the input string.\npub fn process_input(input: &str) -> Result<Node, String> {\n    let mut parser = Parser::new(input.to_owned());\n    parser.parse_expr(0)\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let input = if args.len() > 1 {\n        args[1].clone()\n    } else {\n        \"(a)\".to_string()\n    };\n    match process_input(&input) {\n        Ok(node) => println!(\"Parsed successfully: {:?}\", node),\n        Err(err) => eprintln!(\"Error: {}\", err),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::iter::Peekable;\nuse std::str::Chars;\nuse std::sync::Arc;\nuse std::thread;\nstruct Parser;\nimpl Parser {\n    fn new() -> Self {\n        Parser\n    }\n    const MAX_DEPTH: usize = 512;\n    unsafe fn recursive_parse(&self, iter: &mut Peekable<Chars>, depth: usize) -> Result<(), String> {\n        if depth > Self::MAX_DEPTH {\n            return Err(\"Recursion depth limit exceeded\".to_string());\n        }\n        while let Some(&c) = iter.peek() {\n            if c == '(' {\n                iter.next();\n                self.recursive_parse(iter, depth + 1)?;\n            } else if c == ')' {\n                iter.next();\n                return Ok(());\n            } else {\n                iter.next();\n            }\n        }\n        Ok(())\n    }\n    fn parse(&self, input: &str) -> Result<(), String> {\n        let mut iter = input.chars().peekable();\n        unsafe {\n            self.recursive_parse(&mut iter, 0)\n        }\n    }\n}\nfn main() {\n    let attacker_input = \"(\".repeat(1000) + &\")\".repeat(1000);\n    let parser = Parser::new();\n    let shared_parser = Arc::new(parser);\n    let handles: Vec<_> = (0..4).map(|_| {\n        let sp = Arc::clone(&shared_parser);\n        let input_clone = attacker_input.clone();\n        thread::spawn(move || {\n            sp.parse(&input_clone)\n        })\n    }).collect();\n    for handle in handles {\n        match handle.join() {\n            Ok(Ok(())) => println!(\"Thread finished execution\"),\n            Ok(Err(e)) => println!(\"Error: {}\", e),\n            Err(_) => println!(\"Thread panicked\"),\n        }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nconst MAX_DEPTH: usize = 1000;\nstruct Parser<'a> {\n    buffer: &'a [u8],\n}\nimpl<'a> Parser<'a> {\n    unsafe fn get_byte(&self, index: usize) -> u8 {\n        *self.buffer.get_unchecked(index)\n    }\n    fn parse_recursively(&self, pos: usize, depth: usize) -> Result<(usize, u32), &'static str> {\n        if depth > MAX_DEPTH {\n            return Err(\"Recursion limit exceeded\");\n        }\n        let mut index = pos;\n        let mut count: u32 = 0;\n        while index < self.buffer.len() {\n            unsafe {\n                match self.get_byte(index) {\n                    b'(' => {\n                        let (next_index, inner_count) = self.parse_recursively(index + 1, depth + 1)?;\n                        count = count.wrapping_add(inner_count).wrapping_add(1);\n                        index = next_index;\n                    }\n                    b')' => {\n                        return Ok((index + 1, count));\n                    }\n                    _ => {\n                        index += 1;\n                    }\n                }\n            }\n        }\n        Ok((index, count))\n    }\n    fn run(&self) -> Result<u32, &'static str> {\n        let (_, result) = self.parse_recursively(0, 0)?;\n        Ok(result)\n    }\n}\nfn process(input: &str) -> Result<u32, &'static str> {\n    let parser = Parser { buffer: input.as_bytes() };\n    parser.run()\n}\nfn main() {\n    let left_parens = \"(\".repeat(1100);\n    let right_parens = \")\".repeat(1100);\n    let input = left_parens + &right_parens;\n    match process(&input) {\n        Ok(result) => println!(\"Parsed count: {}\", result),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nconst MAX_DEPTH: usize = 500;\npub fn process(input: &str) -> Result<(), &'static str> {\n    process_inner(input, 0)\n}\nfn process_inner(input: &str, depth: usize) -> Result<(), &'static str> {\n    if depth > MAX_DEPTH {\n        return Err(\"exceeded recursion limit\");\n    }\n    unsafe {\n        let _ptr = input.as_ptr();\n    }\n    if input.len() >= 2 && input.starts_with('(') && input.ends_with(')') {\n        let inner = &input[1..input.len()-1];\n        return process_inner(inner, depth + 1);\n    }\n    if input.is_empty() {\n        Ok(())\n    } else {\n        Err(\"Parsing error: invalid format encountered\")\n    }\n}\nfn main() {\n    let input = env::args().nth(1).unwrap_or_else(|| {\n        let mut nested = String::new();\n        for _ in 0..1000 {\n            nested.push('(');\n        }\n        for _ in 0..1000 {\n            nested.push(')');\n        }\n        nested\n    });\n    match process(&input) {\n        Ok(()) => println!(\"Parsing completed successfully\"),\n        Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nconst MAX_RECURSION: usize = 1000;\nstruct Tree {\n    branches: Vec<Tree>,\n    token: Option<char>,\n}\nimpl Tree {\n    fn accumulate(&self, depth: usize) -> Result<usize, &'static str> {\n        if depth > MAX_RECURSION {\n            return Err(\"Recursion depth limit exceeded\");\n        }\n        let mut total = 1;\n        for child in &self.branches {\n            total += child.accumulate(depth + 1)?;\n        }\n        Ok(total)\n    }\n}\nfn build_tree(input: &str) -> Result<Tree, &'static str> {\n    let bytes = input.as_bytes();\n    let (node, _) = read_node(bytes, 0)?;\n    Ok(node)\n}\nfn read_node(data: &[u8], pos: usize) -> Result<(Tree, usize), &'static str> {\n    if pos >= data.len() {\n        return Ok((Tree { branches: Vec::new(), token: None }, pos));\n    }\n    if data[pos] == b'(' {\n        let mut kids = Vec::new();\n        let mut idx = pos + 1;\n        while idx < data.len() && data[idx] != b')' {\n            let (child, new_idx) = read_node(data, idx)?;\n            kids.push(child);\n            idx = new_idx;\n        }\n        Ok((Tree { branches: kids, token: None }, idx + 1))\n    } else {\n        Ok((Tree { branches: Vec::new(), token: Some(data[pos] as char) }, pos + 1))\n    }\n}\nfn execute(input: &str) -> Result<usize, &'static str> {\n    let tree = build_tree(input)?;\n    let shared = Arc::new(Mutex::new(tree));\n    let shared_copy = Arc::clone(&shared);\n    let worker = thread::spawn(move || {\n        let lock = shared_copy.lock().unwrap();\n        lock.accumulate(0)\n    });\n    worker.join().unwrap()\n}\nfn main() {\n    let sample = \"(a(a(a(a(a))))))\"; \n    match execute(sample) {\n        Ok(val) => println!(\"Result: {}\", val),\n        Err(err) => eprintln!(\"Error: {}\", err),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nconst MAX_DEPTH: usize = 1000;\nstruct Parser<'a> {\n    input: &'a str,\n    pos: usize,\n    depth: usize,\n}\nimpl<'a> Parser<'a> {\n    fn new(input: &'a str) -> Self {\n        Parser { input, pos: 0, depth: 0 }\n    }\n    fn current(&self) -> Option<char> {\n        self.input[self.pos..].chars().next()\n    }\n    fn consume(&mut self) -> Option<char> {\n        if let Some(ch) = self.current() {\n            unsafe {\n                let _slice = self.input.as_bytes();\n                let len = ch.len_utf8();\n                self.pos += len;\n            }\n            Some(ch)\n        } else {\n            None\n        }\n    }\n    fn parse_expression(&mut self) -> bool {\n        if self.depth > MAX_DEPTH {\n            return false; \n        }\n        self.depth += 1;\n        let result = if let Some(ch) = self.current() {\n            if ch == '(' {\n                self.consume();\n                let inner_result = self.parse_expression();\n                if self.current() == Some(')') {\n                    self.consume();\n                    inner_result\n                } else {\n                    false\n                }\n            } else {\n                true\n            }\n        } else {\n            true\n        };\n        self.depth -= 1;\n        result\n    }\n}\nfn main() {\n    let mut input = String::new();\n    for _ in 0..500 {\n        input.push('(');\n    }\n    for _ in 0..500 {\n        input.push(')');\n    }\n    let mut parser = Parser::new(&input);\n    let valid = parser.parse_expression();\n    println!(\"Result: {}\", valid);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nconst MAX_DEPTH: u32 = 1000;\n#[derive(Debug)]\npub struct Node {\n    pub value: i32,\n    pub children: Vec<Box<Node>>,\n}\nimpl Node {\n    pub fn new(val: i32) -> Self {\n        Node { value: val, children: Vec::new() }\n    }\n    pub fn add_child(&mut self, child: Node) {\n        self.children.push(Box::new(child));\n    }\n}\npub unsafe fn traverse_limited(node: &Node, depth: u32, max_depth: u32) -> Option<i32> {\n    if depth > max_depth {\n        return None;\n    }\n    let mut total = node.value;\n    let ptr = node.children.as_ptr();\n    for i in 0..node.children.len() {\n        let child_ptr = ptr.add(i);\n        match traverse_limited(&**child_ptr, depth + 1, max_depth) {\n            Some(child_sum) => total += child_sum,\n            None => return None, \n        }\n    }\n    Some(total)\n}\npub fn process_tree(root: &Node) -> Option<i32> {\n    unsafe { traverse_limited(root, 0, MAX_DEPTH) }\n}\nfn main() {\n    let mut root = Node::new(1);\n    let mut current = &mut root;\n    for i in 2..=1500 {\n        current.add_child(Node::new(i));\n        let last_index = current.children.len() - 1;\n        current = current.children[last_index].as_mut();\n    }\n    let handle = thread::spawn(move || {\n        let result = process_tree(&root);\n        match result {\n            Some(sum) => println!(\"Sum: {}\", sum),\n            None => println!(\"Recursion depth limit reached. Operation aborted.\"),\n        }\n        result\n    });\n    match handle.join() {\n        Ok(Some(sum)) => println!(\"Final Sum: {}\", sum),\n        Ok(None) => println!(\"Recursion depth limit reached, operation safely aborted.\"),\n        Err(_) => println!(\"Thread panicked unexpectedly.\"),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nconst LIMIT: usize = 1000;\nstruct Data {\n    children: Vec<Data>,\n}\nimpl Data {\n    fn new() -> Self {\n        Data { children: Vec::new() }\n    }\n    fn attach(&mut self, child: Data) {\n        self.children.push(child);\n    }\n}\nfn explore_safe(inner: &Data, depth: usize) -> Result<u32, &'static str> {\n    if depth > LIMIT {\n        return Err(\"Recursion too deep\");\n    }\n    let mut count: u32 = 1;\n    for child in &inner.children {\n        count = count.checked_add(explore_safe(child, depth + 1)?) .ok_or(\"Count overflow\")?;\n    }\n    Ok(count)\n}\nfn collect(root: &Data) -> Result<u32, &'static str> {\n    explore_safe(root, 0)\n}\nfn construct(depth: usize) -> Data {\n    let mut node = Data::new();\n    if depth > 0 {\n        node.attach(construct(depth - 1));\n    }\n    node\n}\nfn main() {\n    let handle = thread::spawn(|| {\n        let tree = construct(2000);\n        match collect(&tree) {\n            Ok(sum) => println!(\"Total count: {}\", sum),\n            Err(err) => println!(\"Error: {}\", err),\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Data {\n    value: i32,\n    next: Option<Box<Data>>,\n}\nstruct Parser<'a> {\n    input: &'a [u8],\n    pos: usize,\n}\nimpl<'a> Parser<'a> {\n    fn new(input: &'a str) -> Parser<'a> {\n        Parser { input: input.as_bytes(), pos: 0 }\n    }\n    fn current_byte(&self) -> Option<u8> {\n        unsafe {\n            if self.pos < self.input.len() {\n                Some(*self.input.get_unchecked(self.pos))\n            } else {\n                None\n            }\n        }\n    }\n    fn process_nested(&mut self, depth: usize) -> Result<i32, &'static str> {\n        if depth > 1000 {\n            return Err(\"Recursion depth limit exceeded\");\n        }\n        let mut acc = 0;\n        while let Some(byte) = self.current_byte() {\n            self.pos += 1;\n            match byte {\n                b'(' => {\n                    let inner_val = self.process_nested(depth + 1)?;\n                    acc += inner_val + 1;\n                }\n                b')' => {\n                    return Ok(acc);\n                }\n                _ => continue,\n            }\n        }\n        Ok(acc)\n    }\n}\nfn execute(input: &str) -> Result<i32, &'static str> {\n    let mut parser = Parser::new(input);\n    parser.process_nested(0)\n}\nfn main() {\n    let input = std::env::args().nth(1).unwrap_or_else(|| \"( ( ( ( ( ) ) ) ) )\".to_string());\n    let handle = thread::spawn(move || {\n        let _ = execute(&input).unwrap();\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nconst MAX_DEPTH: usize = 1000; \nfn safe_rec_parse(s: &str, depth: usize) -> Result<usize, &'static str> {\n    if depth > MAX_DEPTH {\n        return Err(\"Maximum recursion depth exceeded\");\n    }\n    if s.is_empty() {\n        return Ok(depth);\n    }\n    let first = s.as_bytes()[0];\n    if first == b'(' {\n        safe_rec_parse(&s[1..], depth + 1)\n    } else if first == b')' {\n        if depth == 0 {\n            return Err(\"Unbalanced parentheses\");\n        }\n        safe_rec_parse(&s[1..], depth - 1)\n    } else {\n        Err(\"Invalid character\")\n    }\n}\nfn parse_nested(s: &str) -> Result<usize, &'static str> {\n    safe_rec_parse(s, 0)\n}\nfn worker(input: String) {\n    thread::spawn(move || {\n        let counter = Arc::new(Mutex::new(0));\n        let result = parse_nested(&input);\n        let count = counter.lock().unwrap();\n        println!(\"Result: {:?}, counter: {}\", result, *count);\n    });\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        println!(\"Usage: program <nested parentheses string>\");\n        return;\n    }\n    let input = args[1].clone();\n    worker(input);\n    thread::sleep(std::time::Duration::from_secs(1));\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::ptr;\nconst MAX_DEPTH: usize = 1000;\nstruct Processor;\nimpl Processor {\n    unsafe fn traverse(&self, data: *const u8, len: usize, current: usize) -> Result<usize, String> {\n        if current >= MAX_DEPTH {\n            return Err(\"Recursion limit reached\".to_string());\n        }\n        if len == 0 {\n            return Ok(0);\n        }\n        let first = ptr::read(data);\n        if first == b'(' {\n            let inner_depth = self.traverse(data.add(1), len - 1, current + 1)?;\n            if len >= inner_depth + 2 && ptr::read(data.add(inner_depth + 1)) == b')' {\n                Ok(inner_depth + 1)\n            } else {\n                Err(\"Missing closing parenthesis\".to_string())\n            }\n        } else {\n            Err(\"Unexpected token encountered\".to_string())\n        }\n    }\n    pub fn process(&self, input: &str) -> Result<usize, String> {\n        unsafe { self.traverse(input.as_ptr(), input.len(), 0) }\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let input = if args.len() > 1 { &args[1] } else { \"(())\" };\n    let proc = Processor;\n    match proc.process(input) {\n        Ok(depth) => println!(\"Computed depth: {}\", depth),\n        Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nconst MAX_DEPTH: usize = 100;\nstruct Parser<'a> {\n    data: &'a [u8],\n    pos: usize,\n}\nimpl<'a> Parser<'a> {\n    fn new(input: &'a str) -> Self {\n        Parser {\n            data: input.as_bytes(),\n            pos: 0,\n        }\n    }\n    fn descend(&mut self, depth: usize) -> Result<(), String> {\n        if depth > MAX_DEPTH {\n            return Err(\"Maximum recursion depth reached\".into());\n        }\n        if self.pos >= self.data.len() {\n            return Ok(());\n        }\n        let ptr = self.data.as_ptr().wrapping_add(self.pos);\n        let ch = unsafe { *ptr as char };\n        match ch {\n            '(' => {\n                self.pos += 1;\n                self.descend(depth + 1)?;\n                if self.pos < self.data.len() && self.data[self.pos] as char == ')' {\n                    self.pos += 1;\n                    Ok(())\n                } else {\n                    Err(\"Missing closing parenthesis\".into())\n                }\n            }\n            _ => {\n                self.pos += 1;\n                self.descend(depth)\n            }\n        }\n    }\n}\nfn process(input: &str) -> Result<(), String> {\n    let mut parser = Parser::new(input);\n    parser.descend(0)\n}\nfn parser_run(input: &str) -> Result<(), String> {\n    process(input)\n}\nfn main() {\n    let input = \"(\".repeat(1000) + &\")\".repeat(1000);\n    let handle = thread::spawn(move || {\n        match parser_run(&input) {\n            Ok(()) => println!(\"Parsing succeeded\"),\n            Err(e) => println!(\"Parsing failed: {}\", e),\n        }\n    });\n    let _ = handle.join();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process;\npub struct Parser {\n    input: String,\n    pos: usize,\n}\nimpl Parser {\n    unsafe fn parse_recursive(&mut self, depth: u32) -> Result<(), String> {\n        const MAX_DEPTH: u32 = 1024;\n        if depth > MAX_DEPTH {\n            return Err(\"Recursion too deep\".into());\n        }\n        if self.pos >= self.input.len() {\n            return Ok(());\n        }\n        let current = self.input.as_bytes()[self.pos];\n        if current == b'(' {\n            self.pos += 1;\n            self.parse_recursive(depth + 1)?;\n            if self.pos < self.input.len() && self.input.as_bytes()[self.pos] == b')' {\n                self.pos += 1;\n                Ok(())\n            } else {\n                Err(\"Missing closing ')'\".into())\n            }\n        } else {\n            self.pos += 1;\n            Ok(())\n        }\n    }\n    pub unsafe fn execute(input: &str) -> Result<(), String> {\n        let mut parser = Parser {\n            input: input.to_string(),\n            pos: 0,\n        };\n        parser.parse_recursive(0)\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let data = if args.len() > 1 { &args[1] } else { \"(a)\" };\n    unsafe {\n        match Parser::execute(data) {\n            Ok(_) => println!(\"Parsing succeeded.\"),\n            Err(e) => {\n                eprintln!(\"Parsing failed: {}\", e);\n                process::exit(1);\n            }\n        }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused_unsafe)]\nuse std::env;\nconst MAX_DEPTH: u32 = 1000;\nfn process_input(input: &str) -> Result<(), &'static str> {\n    let bytes = input.as_bytes();\n    unsafe { safe_parse_helper(bytes, 0, 0) }?;\n    Ok(())\n}\nunsafe fn safe_parse_helper(data: &[u8], pos: usize, depth: u32) -> Result<usize, &'static str> {\n    if depth > MAX_DEPTH {\n        return Err(\"maximum recursion depth exceeded\");\n    }\n    let mut i = pos;\n    while i < data.len() {\n        let ch = *data.get_unchecked(i);\n        if ch == b'(' {\n            i = safe_parse_helper(data, i + 1, depth + 1)?;\n        } else if ch == b')' {\n            return Ok(i + 1);\n        }\n        i += 1;\n    }\n    Ok(i)\n}\nfn main() {\n    let deep_input = if let Some(arg) = env::args().nth(1) {\n        arg\n    } else {\n        \"(\".repeat(3500) + &\")\".repeat(3500)\n    };\n    match process_input(&deep_input) {\n        Ok(_) => println!(\"Parsing completed successfully.\"),\n        Err(e) => println!(\"Error encountered: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::thread;\npub struct Engine;\nimpl Engine {\n    pub unsafe fn traverse(&self, data: *const u8, len: usize, idx: usize, depth: usize, max_depth: usize) -> Result<i32, &'static str> {\n        if depth > max_depth {\n            return Err(\"Maximum recursion depth exceeded\");\n        }\n        if idx >= len {\n            return Ok(0);\n        }\n        let byte = *data.add(idx);\n        if byte == b'(' {\n            let next = self.traverse(data, len, idx + 1, depth + 1, max_depth)?;\n            Ok(1 + next)\n        } else {\n            Ok(0)\n        }\n    }\n    pub fn process(&self, input: &[u8], max_depth: usize) -> Result<i32, &'static str> {\n        unsafe { self.traverse(input.as_ptr(), input.len(), 0, 0, max_depth) }\n    }\n}\npub fn evaluate(input: &str) -> Result<i32, &'static str> {\n    let engine = Engine;\n    let inp = input.as_bytes().to_vec();\n    let max_depth = 1000;\n    let handler = thread::spawn(move || {\n        engine.process(&inp, max_depth)\n    });\n    match handler.join() {\n        Ok(res) => res,\n        Err(_) => Err(\"Thread panicked unexpectedly\"),\n    }\n}\nfn main() {\n    let input = env::args().nth(1).unwrap_or_else(|| \"(\".repeat(10000));\n    match evaluate(&input) {\n        Ok(res) => println!(\"Processing successful, result: {}\", res),\n        Err(err) => println!(\"Processing failed with error: {}\", err),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\nuse std::env;\nuse std::vec::Vec;\nconst MAX_DEPTH: usize = 1000; \nstruct Node {\n    children: Vec<Node>,\n}\nimpl Node {\n    fn new() -> Self {\n        Node { children: Vec::new() }\n    }\n}\nstruct Parser {\n    input: Vec<char>,\n    pos: usize,\n}\nimpl Parser {\n    fn new(input_str: &str) -> Self {\n        Parser {\n            input: input_str.chars().collect(),\n            pos: 0,\n        }\n    }\n    fn parse_expr(&mut self) -> Result<Node, &'static str> {\n        self.parse_nested(0)\n    }\n    fn parse_nested(&mut self, depth: usize) -> Result<Node, &'static str> {\n        if depth > MAX_DEPTH {\n            return Err(\"Maximum recursion depth exceeded\");\n        }\n        if self.pos >= self.input.len() {\n            return Err(\"Unexpected end of input\");\n        }\n        let mut node = Node::new();\n        if self.input[self.pos] == '(' {\n            self.pos += 1;\n            while self.pos < self.input.len() && self.input[self.pos] == '(' {\n                node.children.push(self.parse_nested(depth + 1)?);\n            }\n            if self.pos < self.input.len() && self.input[self.pos] == ')' {\n                self.pos += 1;\n            } else {\n                return Err(\"Missing closing parenthesis\");\n            }\n        }\n        Ok(node)\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        println!(\"Usage: {} <input>\", args[0]);\n        return;\n    }\n    let mut parser = Parser::new(&args[1]);\n    match parser.parse_expr() {\n        Ok(_node) => println!(\"Parsed successfully.\"),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nconst MAX_DEPTH: usize = 1000;\n#[derive(Debug)]\nenum Ast {\n    Node(Box<Ast>),\n    Leaf(char),\n}\nstruct Parser {\n    input: Vec<char>,\n    pos: usize,\n}\nimpl Parser {\n    fn new(s: &str) -> Self {\n        Self {\n            input: s.chars().collect(),\n            pos: 0,\n        }\n    }\n    fn parse_expr_with_depth(&mut self, depth: usize) -> Result<Ast, String> {\n        if depth > MAX_DEPTH {\n            return Err(\"recursion limit exceeded\".into());\n        }\n        if self.pos >= self.input.len() {\n            return Err(\"unexpected end\".into());\n        }\n        let c = unsafe { *self.input.as_ptr().add(self.pos) };\n        self.pos += 1;\n        if c == '(' {\n            let node = self.parse_expr_with_depth(depth + 1)?;\n            if self.pos >= self.input.len() {\n                return Err(\"expected ')' but found end\".into());\n            }\n            let c2 = unsafe { *self.input.as_ptr().add(self.pos) };\n            if c2 != ')' {\n                return Err(\"expected ')'\".into());\n            }\n            self.pos += 1;\n            Ok(Ast::Node(Box::new(node)))\n        } else {\n            Ok(Ast::Leaf(c))\n        }\n    }\n}\nfn execute(input: &str) -> Result<Ast, String> {\n    let mut parser = Parser::new(input);\n    parser.parse_expr_with_depth(0)\n}\nfn main() {\n    let input = \"((\".to_owned() + &\"(\".repeat(500) + \"x\" + &\")\".repeat(500) + \")\";\n    let result_arc = Arc::new(Mutex::new(None));\n    let result_clone = Arc::clone(&result_arc);\n    let input_clone = input.clone();\n    let handle = thread::spawn(move || {\n        let res = execute(&input_clone);\n        let mut guard = result_clone.lock().unwrap();\n        *guard = Some(res);\n    });\n    handle.join().unwrap();\n    let guard = result_arc.lock().unwrap();\n    match &*guard {\n        Some(Ok(ast)) => println!(\"Parsed AST: {:?}\", ast),\n        Some(Err(e)) => println!(\"Error during parsing: {}\", e),\n        None => println!(\"No result produced\"),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nuse std::path::{Path, PathBuf, Component};\nstruct Manager {\n    base: PathBuf,\n}\nimpl Manager {\n    fn new(base: &str) -> Self {\n        Manager { base: PathBuf::from(base) }\n    }\n    fn normalize_path(&self, path: &Path) -> Option<PathBuf> {\n        let mut normalized = PathBuf::new();\n        for comp in path.components() {\n            match comp {\n                Component::ParentDir => return None, \n                Component::CurDir => continue,\n                other => normalized.push(other.as_os_str()),\n            }\n        }\n        Some(normalized)\n    }\n    fn open(&self, input: &str) -> Result<String, &'static str> {\n        let candidate = self.base.join(input);\n        let resolved = self.normalize_path(&candidate)\n            .ok_or(\"Invalid path: traversal attempt detected\")?;\n        if !resolved.starts_with(&self.base) {\n            return Err(\"Access denied: outside allowed directory\");\n        }\n        if input.contains(\"..\") {\n            Err(\"Access denied: traversal detected\")\n        } else {\n            Ok(\"regular_data\".to_owned())\n        }\n    }\n}\nfn main() {\n    let manager = Arc::new(Manager::new(\"/safe_dir/\"));\n    let mgr_clone = Arc::clone(&manager);\n    let handle = thread::spawn(move || {\n        let result = mgr_clone.open(\"../etc/passwd\");\n        println!(\"Thread result: {:?}\", result);\n    });\n    handle.join().unwrap();\n    match manager.open(\"file.txt\") {\n        Ok(content) => println!(\"Main thread content: {}\", content),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs;\nuse std::path::{Path, PathBuf};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Loader {\n    base: String,\n}\ntrait FileAccess {\n    fn get_content(&self, rel: &str) -> Result<String, String>;\n}\nimpl FileAccess for Loader {\n    fn get_content(&self, rel: &str) -> Result<String, String> {\n        let candidate = Path::new(&self.base).join(rel);\n        let canon_candidate = candidate.canonicalize().map_err(|e| e.to_string())?;\n        let canon_base = Path::new(&self.base).canonicalize().map_err(|e| e.to_string())?;\n        if !canon_candidate.starts_with(&canon_base) {\n            return Err(\"Access denied: path traversal attempt detected\".to_string());\n        }\n        let data = fs::read_to_string(&candidate).map_err(|e| e.to_string())?;\n        unsafe {\n            let ptr = data.as_ptr();\n            let len = data.len();\n            let slice = std::slice::from_raw_parts(ptr, len);\n            Ok(String::from_utf8_lossy(slice).into_owned())\n        }\n    }\n}\nfn main() {\n    let loader = Loader { base: \"allowed/\".to_string() };\n    let shared_results = Arc::new(Mutex::new(Vec::new()));\n    let loader_arc = Arc::new(loader);\n    let handles: Vec<_> = (0..3)\n        .map(|i| {\n            let loader_thread = Arc::clone(&loader_arc);\n            let results_thread = Arc::clone(&shared_results);\n            thread::spawn(move || {\n                let path = format!(\"file{}.txt\", i);\n                let res = loader_thread.get_content(&path);\n                results_thread.lock().unwrap().push(res);\n            })\n        })\n        .collect();\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    let results = shared_results.lock().unwrap();\n    for entry in results.iter() {\n        match entry {\n            Ok(content) => println!(\"File content: {}\", content),\n            Err(err) => println!(\"Error: {}\", err),\n        }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::{self, File, OpenOptions};\nuse std::io::{self, Read, Write};\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\nuse std::thread;\nstruct PathResolver {\n    path: String,\n}\nimpl PathResolver {\n    fn new(input: &str) -> Self {\n        Self { path: input.to_owned() }\n    }\n    fn resolve(&self) -> io::Result<PathBuf> {\n        let raw_path = PathBuf::from(&self.path);\n        let abs_path = fs::canonicalize(raw_path)?;\n        let allowed = fs::canonicalize(\"./allowed\")?;\n        if !abs_path.starts_with(&allowed) {\n            return Err(io::Error::new(io::ErrorKind::PermissionDenied, \"Access not permitted\"));\n        }\n        Ok(abs_path)\n    }\n}\nfn process_file(input: &str) -> io::Result<String> {\n    let resolver = PathResolver::new(input);\n    let resolved_path = resolver.resolve()?;\n    let mut file = File::open(&resolved_path)?;\n    let mut content = String::new();\n    file.read_to_string(&mut content)?;\n    let shared_path = Arc::new(resolved_path);\n    let sp_clone = Arc::clone(&shared_path);\n    let handle = thread::spawn(move || {\n        std::thread::sleep(std::time::Duration::from_millis(10));\n        if let Ok(mut f) = OpenOptions::new().write(true).create(false).open(&*sp_clone) {\n            let _ = f.write_all(b\"safe update\");\n        }\n    });\n    handle.join().unwrap();\n    Ok(content)\n}\nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n    let file_path = if args.len() > 1 { &args[1] } else { \"./allowed/test.txt\" };\n    match process_file(file_path) {\n        Ok(text) => println!(\"File content: {}\", text),\n        Err(e) => eprintln!(\"Error encountered: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::{self, File};\nuse std::io::Read;\nuse std::path::{Path, PathBuf};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\npub struct Resolver;\nimpl Resolver {\n    pub fn resolve(&self, input: &str) -> Result<String, String> {\n        let path = Path::new(input);\n        let canonical = fs::canonicalize(path)\n            .map_err(|e| format!(\"Canonicalization error: {}\", e))?;\n        let current_dir = std::env::current_dir()\n            .map_err(|e| format!(\"Failed to get current directory: {}\", e))?;\n        let safe_dir = current_dir.join(\"safe\");\n        if !canonical.starts_with(&safe_dir) {\n            return Err(\"Access denied: path is outside the safe directory\".to_string());\n        }\n        canonical\n            .into_os_string()\n            .into_string()\n            .map_err(|_| \"Failed to convert path\".to_string())\n    }\n}\nfn process(input: &str) -> Result<String, String> {\n    let resolver = Resolver;\n    let resolved_path = resolver.resolve(input)?;\n    let file = File::open(&resolved_path)\n        .map_err(|e| format!(\"Error opening file: {}\", e))?;\n    let mut buf_reader = std::io::BufReader::new(file);\n    let mut content = String::new();\n    buf_reader\n        .read_to_string(&mut content)\n        .map_err(|e| format!(\"Error reading file: {}\", e))?;\n    Ok(content)\n}\nfn main() {\n    let safe_dir = std::env::current_dir().unwrap().join(\"safe\");\n    fs::create_dir_all(&safe_dir).unwrap();\n    let shared_result = Arc::new(Mutex::new(String::new()));\n    let shared_result_clone = Arc::clone(&shared_result);\n    let args: Vec<String> = std::env::args().collect();\n    let input_path = if args.len() > 1 {\n        args[1].clone()\n    } else {\n        safe_dir.join(\"test_file.txt\").into_os_string().into_string().unwrap()\n    };\n    let handle = thread::spawn(move || {\n        match process(&input_path) {\n            Ok(content) => {\n                let mut data = shared_result_clone.lock().unwrap();\n                *data = content;\n            }\n            Err(e) => {\n                panic!(\"Operation failed: {}\", e);\n            }\n        }\n    });\n    handle.join().unwrap();\n    let result = shared_result.lock().unwrap();\n    println!(\"File content: {}\", *result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs;\nuse std::ffi::{CString, CStr};\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\nuse std::thread;\npub struct FileManager {\n    base: PathBuf,\n}\nimpl FileManager {\n    pub fn new(base: &Path) -> Self {\n        Self {\n            base: base.to_path_buf(),\n        }\n    }\n    pub fn open_file(&self, name: &str) -> std::io::Result<String> {\n        let mut full_path = self.base.join(name);\n        if full_path.exists() {\n            unsafe {\n                let c_str = CString::new(full_path.to_string_lossy().as_bytes()).unwrap();\n                let ptr = c_str.as_ptr();\n                let recovered = CStr::from_ptr(ptr).to_string_lossy().into_owned();\n                full_path = PathBuf::from(recovered);\n            }\n        }\n        let canonical_base = fs::canonicalize(&self.base)?;\n        let canonical_full = fs::canonicalize(&full_path)?;\n        if !canonical_full.starts_with(&canonical_base) {\n            return Err(std::io::Error::new(\n                std::io::ErrorKind::PermissionDenied,\n                \"Access outside allowed directory denied\",\n            ));\n        }\n        fs::read_to_string(&full_path)\n    }\n}\nfn main() {\n    let base = Path::new(\"./safe_dir\");\n    let manager = FileManager::new(&base);\n    let shared_manager = Arc::new(manager);\n    let handle_manager = Arc::clone(&shared_manager);\n    let handle = thread::spawn(move || {\n        let result = handle_manager.open_file(\"../etc/passwd\");\n        match result {\n            Ok(content) => println!(\"File content: {}\", &content[..std::cmp::min(content.len(), 100)]),\n            Err(e) => eprintln!(\"Error reading file: {}\", e),\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ffi::CString;\nuse std::str;\nuse std::thread;\nconst ALLOWED_PREFIX: &str = \"./safe/\";\npub fn resolve_path(input: String) -> String {\n    let handle = thread::spawn(move || {\n        unsafe {\n            let c_str = CString::new(input).unwrap();\n            let ptr = c_str.as_ptr();\n            let len = c_str.to_bytes().len();\n            let slice = std::slice::from_raw_parts(ptr as *const u8, len);\n            str::from_utf8(slice).unwrap().to_string()\n        }\n    });\n    handle.join().unwrap()\n}\npub fn process_file(path: &str) -> Result<String, String> {\n    let resolved = resolve_path(path.to_string());\n    if !resolved.starts_with(ALLOWED_PREFIX) {\n        return Err(String::from(\"Access denied due to illegal path\"));\n    }\n    Ok(format!(\"Access granted to file: {}\", resolved))\n}\nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n    let input = if args.len() > 1 { &args[1] } else { \"./safe/default.txt\" };\n    match process_file(input) {\n        Ok(msg) => println!(\"{}\", msg),\n        Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::{self, File};\nuse std::io::{self, Read};\nuse std::env;\nuse std::os::unix::fs::MetadataExt;\nuse std::thread;\nuse std::time::Duration;\nfn process_file(path: &str) -> io::Result<String> {\n    let initial = fs::metadata(path)?;\n    if !initial.is_file() {\n        return Err(io::Error::new(io::ErrorKind::Other, \"Not a file\"));\n    }\n    let mut file = File::open(path)?;\n    let current = file.metadata()?;\n    if initial.ino() != current.ino() || initial.dev() != current.dev() {\n        return Err(io::Error::new(io::ErrorKind::Other, \"File changed (TOCTOU detected)\"));\n    }\n    thread::sleep(Duration::from_millis(50));\n    let mut content = String::new();\n    file.read_to_string(&mut content)?;\n    Ok(content)\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() != 2 {\n        eprintln!(\"Usage: {} <file_path>\", args[0]);\n        std::process::exit(1);\n    }\n    match process_file(&args[1]) {\n        Ok(content) => println!(\"File content:\\n{}\", content),\n        Err(e) => {\n            eprintln!(\"Error processing file: {:?}\", e);\n            std::process::exit(1);\n        }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::fs;\nuse std::io::{self, Read};\nuse std::time::Duration;\nuse std::thread;\nfn process_file(path: &str) -> io::Result<String> {\n    let meta = fs::symlink_metadata(path)?;\n    if meta.file_type().is_symlink() {\n        return Err(io::Error::new(io::ErrorKind::Other, \"Symlink files are not permitted\"));\n    }\n    thread::sleep(Duration::from_millis(50));\n    let mut file = fs::File::open(path)?;\n    let mut buffer = Vec::new();\n    file.read_to_end(&mut buffer)?;\n    let content = unsafe { String::from_utf8_unchecked(buffer) };\n    Ok(content)\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let path = if args.len() > 1 { &args[1] } else { \"testfile.txt\" };\n    match process_file(path) {\n        Ok(content) => println!(\"File content: {}\", content),\n        Err(e) => eprintln!(\"Error processing file: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs;\nuse std::path::{Path, PathBuf};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Manager {\n    base: PathBuf,\n}\nimpl Manager {\n    fn new(dir: &str) -> Self {\n        Manager {\n            base: PathBuf::from(dir),\n        }\n    }\n    fn process(&self, rel: &str) -> Result<String, String> {\n        let candidate = self.base.join(rel);\n        let resolved = fs::canonicalize(&candidate).map_err(|e| e.to_string())?;\n        if !resolved.starts_with(&self.base) {\n            return Err(\"Access denied: resolved path is outside of the allowed directory\".to_string());\n        }\n        let path_str = resolved.to_str().ok_or(\"Invalid utf8 in path\")?;\n        let ptr = path_str.as_ptr();\n        unsafe {\n            let _slice = std::slice::from_raw_parts(ptr, path_str.len());\n        }\n        let shared = Arc::new(Mutex::new(resolved.clone()));\n        let shared_copy = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            let locked = shared_copy.lock().unwrap();\n            fs::read_to_string(locked.to_str().unwrap()).unwrap_or_else(|_| String::new())\n        });\n        let thread_output = handle.join().map_err(|_| \"Thread join failed\".to_string())?;\n        Ok(thread_output)\n    }\n}\nfn main() {\n    let mgr = Manager::new(\"safe_dir\");\n    match mgr.process(\"link.txt\") {\n        Ok(contents) => println!(\"Processed data: {}\", contents),\n        Err(e) => println!(\"Error encountered: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::fs::{self, File};\nuse std::io::Read;\nuse std::path::Path;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nfn process(input: &str) {\n    let allowed_dir = Path::new(\"/safe/directory\");\n    let cstr = std::ffi::CString::new(input).unwrap();\n    let ptr = cstr.as_ptr() as *const u8;\n    let raw_path: Vec<u8> = unsafe {\n        std::slice::from_raw_parts(ptr, input.len()).to_vec()\n    };\n    let file_path = String::from_utf8(raw_path).unwrap();\n    let given_path = Path::new(&file_path);\n    let resolved_path = fs::canonicalize(given_path).expect(\"Failed to resolve file path\");\n    if !resolved_path.starts_with(allowed_dir) {\n        panic!(\"Access denied: File is outside the allowed directory\");\n    }\n    if resolved_path.is_file() {\n        let mut file = File::open(&resolved_path).expect(\"Cannot open file!\");\n        let mut contents = String::new();\n        file.read_to_string(&mut contents).expect(\"Could not read file\");\n        println!(\"File contents: {}\", contents);\n    } else {\n        println!(\"Not a regular file: {:?}\", resolved_path);\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        println!(\"Usage: {} <file_path>\", args[0]);\n        return;\n    }\n    let file_arg = args[1].clone();\n    let lock = Arc::new(Mutex::new(()));\n    let lock_clone = Arc::clone(&lock);\n    let handler = thread::spawn(move || {\n        let _guard = lock_clone.lock().unwrap();\n        process(&file_arg);\n    });\n    let _ = handler.join();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::path::{Path, PathBuf};\nuse std::fs::File;\nuse std::io;\nuse std::sync::Arc;\nuse std::thread;\nstruct FileHandler {\n    root: PathBuf,\n}\nimpl FileHandler {\n    fn new(root: PathBuf) -> Self {\n        Self { root }\n    }\n    fn access(&self, relative: &str) -> io::Result<File> {\n        let path = self.root.join(relative).canonicalize()?;\n        if !path.starts_with(&self.root) {\n            return Err(io::Error::new(\n                io::ErrorKind::PermissionDenied,\n                \"Access denied: resolved path is outside the allowed directory\",\n            ));\n        }\n        File::open(path)\n    }\n}\nfn main() {\n    let base = PathBuf::from(\"/tmp/secure_dir\");\n    let handler = Arc::new(FileHandler::new(base));\n    let threads: Vec<_> = (0..2)\n        .map(|_| {\n            let h = Arc::clone(&handler);\n            thread::spawn(move || {\n                let _ = h.access(\"sample.txt\");\n            })\n        })\n        .collect();\n    for t in threads {\n        let _ = t.join();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs;\nuse std::path::{Path, PathBuf};\nuse std::env;\nuse std::io;\nstruct FileHandler {\n    allowed: PathBuf,\n}\nimpl FileHandler {\n    fn write_data(&self, user_path: &Path, data: &str) -> io::Result<()> {\n        let canonical = user_path.canonicalize()?;\n        if !canonical.starts_with(&self.allowed) {\n            return Err(io::Error::new(io::ErrorKind::PermissionDenied, \"Access denied: Invalid path\"));\n        }\n        fs::write(canonical, data)\n    }\n}\nfn main() {\n    let allowed = env::temp_dir().join(\"allowed_dir\");\n    let _ = fs::create_dir_all(&allowed);\n    let handler = FileHandler { allowed };\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        eprintln!(\"Usage: <program> <file_path>\");\n        return;\n    }\n    let user_file = Path::new(&args[1]);\n    match handler.write_data(user_file, \"Confidential Data\") {\n        Ok(_)  => println!(\"Data written successfully.\"),\n        Err(e) => eprintln!(\"Error writing data: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs;\nuse std::io::{self, ErrorKind};\nuse std::path::{Path, PathBuf};\nuse std::sync::{Arc, Mutex};\nstruct Loader {\n    root: PathBuf,\n    cache: Arc<Mutex<Vec<(PathBuf, String)>>>,\n}\nimpl Loader {\n    pub fn new(base: &str) -> Self {\n        Self {\n            root: PathBuf::from(base),\n            cache: Arc::new(Mutex::new(Vec::new())),\n        }\n    }\n    pub fn fetch(&self, file: &str) -> io::Result<String> {\n        let path = self.root.join(file);\n        let canon = fs::canonicalize(&path)?;\n        if !canon.starts_with(&self.root) {\n            return Err(io::Error::new(\n                ErrorKind::PermissionDenied,\n                \"Access denied: resolved path lies outside the allowed directory\",\n            ));\n        }\n        let content = fs::read_to_string(&canon)?;\n        let mut cache_lock = self.cache.lock().unwrap();\n        cache_lock.push((canon, content.clone()));\n        Ok(content)\n    }\n}\nfn main() {\n    let loader = Loader::new(\"safe_dir\");\n    match loader.fetch(\"test.txt\") {\n        Ok(data) => println!(\"Loaded content:\\n{}\", data),\n        Err(e) => eprintln!(\"Error encountered: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::fs::{canonicalize, File};\nuse std::io::{Read, Write};\nuse std::path::Path;\nuse std::sync::Arc;\nuse std::thread;\nuse std::time::Duration;\nstruct Handler;\nimpl Handler {\n    pub fn execute(path: &str) -> Result<String, std::io::Error> {\n        let safe_path = canonicalize(path)?;\n        let meta = std::fs::metadata(&safe_path)?;\n        if !meta.is_file() {\n            return Err(std::io::Error::new(std::io::ErrorKind::Other, \"Not a regular file\"));\n        }\n        thread::sleep(Duration::from_millis(100));\n        let dummy_data = [0x41u8, 0x42, 0x43, 0x44];\n        let safe_val: u8 = unsafe {\n            let ptr = dummy_data.as_ptr();\n            *ptr.offset(2)\n        };\n        let _ = safe_val;\n        let mut file = File::open(&safe_path)?;\n        let mut contents = String::new();\n        file.read_to_string(&mut contents)?;\n        Ok(contents)\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() != 2 {\n        eprintln!(\"Usage: {} <file_path>\", args[0]);\n        return;\n    }\n    match Handler::execute(&args[1]) {\n        Ok(data) => println!(\"{}\", data),\n        Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::{File, symlink_metadata};\nuse std::io::{Read, Seek, SeekFrom, Write};\nuse std::env;\nuse std::path::{Path, PathBuf};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::ptr;\nstruct Settings {\n    content: Vec<u8>,\n}\nimpl Settings {\n    unsafe fn build(input: Vec<u8>) -> Self {\n        let base = input.as_ptr() as *const u8;\n        let _first = *base; \n        Self { content: input }\n    }\n}\nfn is_valid_path(target: &Path, allowed: &Path) -> bool {\n    if let Ok(canonical) = target.canonicalize() {\n        canonical.starts_with(allowed)\n    } else {\n        false\n    }\n}\nfn process_input(path: &str, allowed: &Path) -> Result<Settings, String> {\n    let file_path = Path::new(path);\n    let metadata = symlink_metadata(file_path).map_err(|e| e.to_string())?;\n    if metadata.file_type().is_symlink() || !is_valid_path(file_path, allowed) {\n         return Err(\"Insecure file path detected\".to_string());\n    }\n    let mut file = File::open(file_path).map_err(|e| e.to_string())?;\n    let mut buffer = Vec::new();\n    file.read_to_end(&mut buffer).map_err(|e| e.to_string())?;\n    unsafe {\n         Ok(Settings::build(buffer))\n    }\n}\nfn main() {\n    let arguments: Vec<String> = env::args().collect();\n    if arguments.len() < 2 {\n         println!(\"Usage: {} <file_path>\", arguments[0]);\n         return;\n    }\n    let allowed_directory = Path::new(\"/safe_dir\");\n    match process_input(&arguments[1], allowed_directory) {\n         Ok(settings) => println!(\"Settings loaded, {} bytes\", settings.content.len()),\n         Err(err) => println!(\"Error: {}\", err)\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::{self, File};\nuse std::io::{self, Write};\nuse std::path::Path;\nuse std::sync::Arc;\nuse std::thread;\nstruct FileHandler {\n    path: String,\n}\ntrait DataProcessor {\n    fn process(&self, data: &str) -> io::Result<()>;\n}\nimpl DataProcessor for FileHandler {\n    fn process(&self, data: &str) -> io::Result<()> {\n        let path = self.path.clone();\n        let metadata = fs::symlink_metadata(&path)?;\n        if metadata.file_type().is_symlink() {\n            return Err(io::Error::new(io::ErrorKind::Other, \"Symbolic links not allowed\"));\n        }\n        unsafe {\n            let c_path = std::ffi::CString::new(path.clone()).unwrap();\n            let raw = c_path.as_ptr();\n            let _dummy: *const u8 = raw as *const u8;\n        }\n        let mut file = File::create(&path)?;\n        file.write_all(data.as_bytes())?;\n        Ok(())\n    }\n}\nfn main() {\n    let handler = Arc::new(FileHandler {\n        path: String::from(\"output.txt\"),\n    });\n    let data = \"Sensitive data: root secret\\n\";\n    let mut handles = vec![];\n    for _ in 0..4 {\n        let handler_clone = Arc::clone(&handler);\n        let data_clone = data.to_string();\n        let handle = thread::spawn(move || {\n            let _ = handler_clone.process(&data_clone);\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        let _ = handle.join();\n    }\n    println!(\"Operation complete.\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::{File, symlink_metadata};\nuse std::io::{Read, Result, Error, ErrorKind};\nuse std::sync::Arc;\nuse std::thread;\n#[cfg(unix)]\nuse std::os::unix::fs::FileTypeExt;\nstruct Loader;\nimpl Loader {\n    fn fetch(&self, path: &str) -> Result<String> {\n        let meta = symlink_metadata(path)?;\n        #[cfg(unix)]\n        {\n            if meta.file_type().is_symlink() {\n                return Err(Error::new(ErrorKind::Other, \"Symbolic links are disallowed\"));\n            }\n        }\n        let mut file = File::open(path)?;\n        let mut content = String::new();\n        file.read_to_string(&mut content)?;\n        Ok(content)\n    }\n}\nfn main() {\n    let loader = Arc::new(Loader);\n    let mut threads = Vec::new();\n    let config_path = \"config.cfg\"; \n    for _ in 0..4 {\n        let loader_clone = Arc::clone(&loader);\n        let path_clone = config_path.to_string();\n        threads.push(thread::spawn(move || {\n            let _ = loader_clone.fetch(&path_clone);\n        }));\n    }\n    for th in threads {\n        let _ = th.join();\n    }\n    println!(\"Operation completed.\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::fs::{self, File};\nuse std::io::{self, BufReader, Read};\nuse std::env::current_exe;\nstruct FileProcessor;\nimpl FileProcessor {\n    fn process(&self, path: &str) -> io::Result<String> {\n        let file = File::open(path)?;\n        let _metadata = file.metadata()?;\n        let mut reader = BufReader::new(file);\n        let mut content = String::new();\n        reader.read_to_string(&mut content)?;\n        Ok(content)\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        eprintln!(\"Usage: {} <file_path>\", args[0]);\n        std::process::exit(1);\n    }\n    let processor = FileProcessor;\n    match processor.process(&args[1]) {\n        Ok(content) => println!(\"File content:\\n{}\", content),\n        Err(e) => eprintln!(\"Error processing file: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\nuse std::env;\nuse std::fs;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::path::{Path, PathBuf};\nuse std::os::unix::ffi::OsStrExt;\nstruct FileHandler {\n    allowed_dir: PathBuf,\n}\nimpl FileHandler {\n    fn new(allowed: &str) -> Self {\n        Self {\n            allowed_dir: PathBuf::from(allowed),\n        }\n    }\n    fn load_content(&self, filename: &str) -> Result<String, String> {\n        let input_path = Path::new(filename);\n        let raw_path = input_path.as_os_str().as_bytes().as_ptr();\n        let mut resolved = unsafe {\n            let len = input_path.as_os_str().as_bytes().len();\n            let slice = std::slice::from_raw_parts(raw_path, len);\n            std::ffi::OsStr::from_bytes(slice).to_owned()\n        };\n        let mut final_path = PathBuf::from(&resolved);\n        if fs::symlink_metadata(&final_path)\n            .map(|m| m.file_type().is_symlink())\n            .unwrap_or(false)\n        {\n            final_path = fs::read_link(&final_path).map_err(|e| e.to_string())?;\n        }\n        let canonical = final_path.canonicalize().map_err(|e| e.to_string())?;\n        let canonical_allowed = self.allowed_dir.canonicalize().map_err(|e| e.to_string())?;\n        if !canonical.starts_with(&canonical_allowed) {\n            return Err(\"Access denied: file outside allowed directory\".into());\n        }\n        let content = Arc::new(Mutex::new(String::new()));\n        let content_clone = Arc::clone(&content);\n        let canonical_clone = canonical.clone();\n        let handle = thread::spawn(move || {\n            if let Ok(data) = fs::read_to_string(&canonical_clone) {\n                let mut lock = content_clone.lock().unwrap();\n                *lock = data;\n            }\n        });\n        handle.join().map_err(|_| \"Thread panicked\".to_string())?;\n        let result = Arc::try_unwrap(content)\n            .map_err(|_| \"Lock still active\".to_string())?\n            .into_inner()\n            .unwrap();\n        if result.is_empty() {\n            Err(\"Empty file or failed to read\".to_string())\n        } else {\n            Ok(result)\n        }\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let file_name = args.get(1).expect(\"Please provide a filename\");\n    let handler = FileHandler::new(\"/safe_directory\");\n    match handler.load_content(file_name) {\n        Ok(content) => println!(\"File content loaded: {}\", content),\n        Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::{self, File};\nuse std::io::{Read, Write};\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\nuse std::thread;\npub struct FileResolver {\n    base: PathBuf,\n}\nimpl FileResolver {\n    pub fn new(base: PathBuf) -> Self {\n        FileResolver { base }\n    }\n    pub fn load(&self, path: &Path) -> Result<String, String> {\n        let full_path = self.base.join(path);\n        let canon = fs::canonicalize(&full_path).map_err(|e| e.to_string())?;\n        if !canon.starts_with(&self.base) {\n            return Err(\"Symlink escapes allowed directory\".into());\n        }\n        let mut file = File::open(canon).map_err(|e| e.to_string())?;\n        let mut content = String::new();\n        file.read_to_string(&mut content)\n            .map_err(|e| e.to_string())?;\n        Ok(content)\n    }\n}\nfn main() {\n    let base = PathBuf::from(\"/tmp/allowed\");\n    let resolver = FileResolver::new(base);\n    let resolver_arc = Arc::new(resolver);\n    let resolver_thread = Arc::clone(&resolver_arc);\n    let handle = thread::spawn(move || {\n        match resolver_thread.load(Path::new(\"test.txt\")) {\n            Ok(content) => println!(\"{}\", content),\n            Err(err) => println!(\"Error: {}\", err),\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\nuse std::io::{self, BufRead};\nconst MAX_ITEMS: usize = 10;\nstruct Service {\n    data: Vec<u64>,\n}\nimpl Service {\n    fn new() -> Self {\n        Service { data: Vec::new() }\n    }\n    fn compute(&mut self, value: u64) {\n        if self.data.len() >= MAX_ITEMS {\n            return;\n        }\n        self.data.push(value);\n    }\n}\nfn main() {\n    let service = Arc::new(Mutex::new(Service::new()));\n    let worker = {\n        let svc = Arc::clone(&service);\n        thread::spawn(move || {\n            loop {\n                if let Ok(mut s) = svc.lock() {\n                    s.compute(42);\n                }\n                thread::sleep(Duration::from_micros(10));\n            }\n        })\n    };\n    println!(\"Server running (enter 'quit' to stop):\");\n    let stdin = io::stdin();\n    for line in stdin.lock().lines() {\n        if let Ok(input) = line {\n            if input.trim() == \"quit\" {\n                break;\n            }\n        }\n    }\n    let _ = worker.join();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\nconst MAX_TASKS: usize = 1000;\nstruct Service {\n    tasks: Arc<Mutex<Vec<String>>>,\n}\nimpl Service {\n    fn new() -> Self {\n        Service {\n            tasks: Arc::new(Mutex::new(Vec::with_capacity(1024))),\n        }\n    }\n    fn submit(&self, data: String) -> Result<(), String> {\n        let mut list = self.tasks.lock().map_err(|_| \"Lock poisoned\".to_string())?;\n        if list.len() >= MAX_TASKS {\n            return Err(\"Queue limit reached\".to_string());\n        }\n        let len = list.len();\n        unsafe {\n            let ptr = list.as_mut_ptr();\n            ptr.add(len).write(data);\n            list.set_len(len + 1);\n        }\n        Ok(())\n    }\n}\nfn main() {\n    let svc = Service::new();\n    {\n        let tasks_clone = svc.tasks.clone();\n        thread::spawn(move || {\n            loop {\n                {\n                    let mut list = tasks_clone.lock().unwrap();\n                    if !list.is_empty() {\n                        list.remove(0);\n                    }\n                }\n                thread::sleep(Duration::from_millis(50));\n            }\n        });\n    }\n    for i in 0..1100 {\n        if let Err(e) = svc.submit(format!(\"Task {}\", i)) {\n            eprintln!(\"Submission error: {}\", e);\n            break;\n        }\n    }\n    println!(\"Tasks submission complete (max limit enforced)\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nstruct Worker;\nimpl Worker {\n    pub fn execute(&self, data: Vec<u32>) -> u32 {\n        let handle = thread::spawn(move || {\n            data.iter().sum()\n        });\n        handle.join().unwrap()\n    }\n}\npub fn run_fn(data: Vec<u32>) -> u32 {\n    let worker = Worker;\n    worker.execute(data)\n}\nfn main() {\n    let worker = Worker;\n    let input = vec![1u32; 150]; \n    let res = worker.execute(input);\n    println!(\"Computed sum: {}\", res);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::env;\nuse std::thread;\nuse std::time::Duration;\nconst MAX_CAPACITY: usize = 1024; \npub struct Processor {\n    data: Vec<u8>,\n}\nimpl Processor {\n    pub fn append_checked(&mut self, item: u8) -> Result<(), &'static str> {\n        if self.data.len() >= MAX_CAPACITY {\n            return Err(\"Resource limit reached\");\n        }\n        self.data.push(item);\n        Ok(())\n    }\n    pub fn size(&self) -> usize {\n        self.data.len()\n    }\n}\npub fn simulate_input(input: &[u8], proc: &Arc<Mutex<Processor>>) -> Result<(), &'static str> {\n    for &byte in input {\n        let mut locked = proc.lock().unwrap();\n        locked.append_checked(byte)?;\n    }\n    Ok(())\n}\nfn main() {\n    let proc = Arc::new(Mutex::new(Processor { data: Vec::with_capacity(MAX_CAPACITY) }));\n    let args: Vec<String> = env::args().collect();\n    if args.len() > 1 {\n        let input = args[1].as_bytes();\n        match simulate_input(input, &proc) {\n            Ok(_) => {},\n            Err(e) => eprintln!(\"Error: {}\", e),\n        }\n    }\n    loop {\n        thread::sleep(Duration::from_millis(100));\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nuse std::sync::{Arc, atomic::{AtomicU64, Ordering}};\nuse std::env;\nconst MAX_LIMIT: u32 = 1000; \nfn process(limit: u32) -> Result<u64, &'static str> {\n    if limit > MAX_LIMIT {\n        return Err(\"Limit exceeds safe threshold\");\n    }\n    let total = Arc::new(AtomicU64::new(0));\n    let mut handles = vec![];\n    for i in 0..limit {\n        let total = total.clone();\n        let handle = thread::spawn(move || {\n            let local = i as u64;\n            let local = local.wrapping_add(1);\n            total.fetch_add(local, Ordering::Relaxed);\n        });\n        handles.push(handle);\n    }\n    for h in handles {\n        h.join().map_err(|_| \"Thread join error\")?;\n    }\n    Ok(total.load(Ordering::Relaxed))\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let limit: u32 = if args.len() > 1 {\n        args[1].parse().unwrap_or(0)\n    } else {\n        10  \n    };\n    match process(limit) {\n        Ok(result) => println!(\"Result: {}\", result),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nconst MAX_CAPACITY: usize = 1000;\npub struct Pool {\n    data: Mutex<Vec<i32>>,\n}\nimpl Pool {\n    pub fn new() -> Self {\n        Pool {\n            data: Mutex::new(Vec::new()),\n        }\n    }\n    pub fn insert(&self, value: i32) {\n        let mut vec = self.data.lock().unwrap();\n        if vec.len() < MAX_CAPACITY {\n            vec.push(value);\n        }\n    }\n    pub fn count(&self) -> usize {\n        let vec = self.data.lock().unwrap();\n        vec.len()\n    }\n}\npub fn simulate() -> bool {\n    let pool = Arc::new(Pool::new());\n    let mut handles = Vec::new();\n    for _ in 0..4 {\n        let pool_clone = Arc::clone(&pool);\n        let handle = thread::spawn(move || {\n            for i in 0..1000 {\n                pool_clone.insert(i);\n            }\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    let count = pool.count();\n    count <= MAX_CAPACITY\n}\nfn main() {\n    let safe = simulate();\n    if safe {\n        println!(\"Resource usage within safe limits: {}\", safe);\n    } else {\n        println!(\"Resource usage exceeded safe limits: {}\", safe);\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::mpsc::{sync_channel, SyncSender, Receiver};\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::thread;\nconst MAX_STORAGE: usize = 100;\nstatic GLOBAL_COUNT: AtomicUsize = AtomicUsize::new(0);\nstruct Handler {\n    sender: SyncSender<String>,\n}\nimpl Handler {\n    fn new() -> Self {\n        let (tx, rx): (SyncSender<String>, Receiver<String>) = sync_channel(1000);\n        thread::spawn(move || {\n            let mut storage: Vec<String> = Vec::new();\n            loop {\n                match rx.recv() {\n                    Ok(data) => {\n                        if storage.len() < MAX_STORAGE {\n                            unsafe {\n                                storage.push(data);\n                            }\n                            GLOBAL_COUNT.fetch_add(1, Ordering::SeqCst);\n                        } else {\n                        }\n                    },\n                    Err(_) => break,\n                }\n            }\n        });\n        Handler { sender: tx }\n    }\n    fn submit(&self, input: String) {\n        let _ = self.sender.send(input);\n    }\n}\npub fn access_count() -> usize {\n    GLOBAL_COUNT.load(Ordering::SeqCst)\n}\nfn main() {\n    let handler = Handler::new();\n    for _ in 0..150 {\n        handler.submit(\"B\".repeat(10));\n    }\n    thread::sleep(std::time::Duration::from_millis(100));\n    println!(\"Processed count: {}\", access_count());\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n#[derive(Debug)]\nstruct Connection {\n    id: u64,\n}\nstruct Service {\n    connections: Arc<Mutex<Vec<Connection>>>,\n    max_connections: usize,\n}\npub trait ResourceManager {\n    fn new(limit: usize) -> Self;\n    fn run(&self);\n    fn get_count(&self) -> usize;\n}\nimpl ResourceManager for Service {\n    fn new(limit: usize) -> Self {\n        Service {\n            connections: Arc::new(Mutex::new(Vec::new())),\n            max_connections: limit,\n        }\n    }\n    fn run(&self) {\n        let connections = self.connections.clone();\n        let max = self.max_connections;\n        thread::spawn(move || {\n            let mut id_generator = 0u64;\n            loop {\n                {\n                    let mut cons = connections.lock().unwrap();\n                    if cons.len() < max {\n                        cons.push(Connection { id: id_generator });\n                    }\n                }\n                id_generator = id_generator.wrapping_add(1);\n                thread::sleep(Duration::from_millis(10));\n            }\n        });\n    }\n    fn get_count(&self) -> usize {\n        self.connections.lock().unwrap().len()\n    }\n}\npub type ResourceImpl = Service;\nfn main() {\n    let manager = ResourceImpl::new(1000);\n    manager.run();\n    loop {\n        thread::sleep(Duration::from_millis(500));\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\nconst MAX_QUEUE: usize = 5000;\nstatic mut GLOBAL_QUEUE: Option<Vec<String>> = None;\nfn init_queue() {\n    unsafe {\n        if GLOBAL_QUEUE.is_none() {\n            GLOBAL_QUEUE = Some(Vec::with_capacity(1024));\n        }\n    }\n}\nfn enqueue(item: String) {\n    unsafe {\n        if let Some(ref mut queue) = GLOBAL_QUEUE {\n            if queue.len() < MAX_QUEUE {\n                queue.push(item);\n            } else {\n            }\n        }\n    }\n}\nfn process_queue() {\n    loop {\n        unsafe {\n            if let Some(ref queue) = GLOBAL_QUEUE {\n                for s in queue.iter() {\n                    let _ = unsafe { *s.as_ptr() };\n                }\n            }\n        }\n        thread::sleep(Duration::from_millis(10));\n    }\n}\npub fn run(count: usize) -> usize {\n    init_queue();\n    thread::spawn(|| {\n        process_queue();\n    });\n    for i in 0..count {\n        let task = format!(\"Task number {}\", i);\n        unsafe {\n            enqueue(task);\n        }\n    }\n    thread::sleep(Duration::from_secs(1));\n    unsafe {\n        GLOBAL_QUEUE.as_ref().map(|queue| queue.len()).unwrap_or(0)\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let count = if args.len() > 1 && args[1] == \"trigger\" { 10000 } else { 100 };\n    let total = run(count);\n    println!(\"Completed processing, total tasks: {}\", total);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nconst MAX_LIMIT: usize = 1000;\nstruct Server {\n    tasks: Arc<Mutex<Vec<Vec<u8>>>>,\n}\nimpl Server {\n    fn new() -> Self {\n        Server {\n            tasks: Arc::new(Mutex::new(Vec::new())),\n        }\n    }\n    fn run(&self, count: usize) -> Result<(), &'static str> {\n        if count > MAX_LIMIT {\n            return Err(\"Count exceeds maximum allowed limit\");\n        }\n        let mut handles = Vec::with_capacity(count);\n        for _ in 0..count {\n            let tasks = Arc::clone(&self.tasks);\n            handles.push(thread::spawn(move || {\n                unsafe {\n                    let mut buf: Vec<u8> = Vec::with_capacity(1024);\n                    let ptr = buf.as_mut_ptr();\n                    for j in 0..1024 {\n                        *ptr.add(j) = 0;\n                    }\n                    buf.set_len(1024);\n                    let mut lock = tasks.lock().unwrap();\n                    lock.push(buf);\n                }\n            }));\n        }\n        for h in handles {\n            h.join().unwrap();\n        }\n        Ok(())\n    }\n}\nfn main() {\n    let arg = std::env::args().nth(1).unwrap_or_else(|| \"100\".to_string());\n    let count = arg.parse::<usize>().unwrap();\n    let srv = Server::new();\n    match srv.run(count) {\n        Ok(_) => println!(\"Handled {} tasks\", count),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\nuse std::thread;\nuse std::sync::{Arc, Mutex, Barrier};\nconst MAX_TASKS: usize = 100000; \nfn process_task(task: i32) {\n    if task % 2 == 0 {\n        let res = task + task;\n        let _ = res;\n    }\n}\nfn expand_queue(queue: &Arc<Mutex<Vec<i32>>>, value: i32) {\n    let mut guard = queue.lock().unwrap();\n    if guard.len() < MAX_TASKS {\n        guard.push(value);\n    }\n}\npub fn run_app() -> usize {\n    let queue = Arc::new(Mutex::new(Vec::<i32>::new()));\n    let num_threads = 4;\n    let barrier = Arc::new(Barrier::new(num_threads));\n    let mut handles = vec![];\n    for i in 0..num_threads {\n        let cbarrier = barrier.clone();\n        let cqueue = queue.clone();\n        handles.push(thread::spawn(move || {\n            cbarrier.wait();\n            for j in 0..100000 {\n                let val = i as i32 * j as i32;\n                expand_queue(&cqueue, val);\n                process_task(val);\n            }\n        }));\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    let guard = queue.lock().unwrap();\n    guard.len()\n}\nfn main() {\n    let total = run_app();\n    println!(\"Total tasks: {}\", total);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::thread;\nuse std::sync::mpsc::{channel, Sender};\nconst SIZE: usize = 10 * 1024 * 1024; \nconst MAX_TOTAL: usize = 50 * 1024 * 1024; \nstruct Processor {\n    sender: Sender<Vec<u8>>,\n}\nimpl Processor {\n    fn new(sender: Sender<Vec<u8>>) -> Self {\n        Processor { sender }\n    }\n    fn dispatch(&self) {\n        let sender_clone = self.sender.clone();\n        thread::spawn(move || {\n            let mut data = Vec::with_capacity(SIZE);\n            unsafe {\n                data.set_len(SIZE);\n            }\n            sender_clone.send(data).unwrap();\n        });\n    }\n}\nfn process_jobs(job_count: usize) -> Result<(), &'static str> {\n    if job_count * SIZE > MAX_TOTAL {\n        return Err(\"Requested resource exceeds safe limits\");\n    }\n    let (tx, rx) = channel();\n    let processor = Processor::new(tx);\n    for _ in 0..job_count {\n        processor.dispatch();\n    }\n    for _ in 0..job_count {\n        let _ = rx.recv().unwrap();\n    }\n    Ok(())\n}\n#[no_mangle]\npub fn run_app(jobs: usize) -> Result<(), &'static str> {\n    process_jobs(jobs)\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let num_jobs: usize = if args.len() > 1 {\n        args[1].parse().unwrap_or(0)\n    } else {\n        0\n    };\n    match run_app(num_jobs) {\n        Ok(_) => println!(\"Processing complete\"),\n        Err(e) => {\n            eprintln!(\"Error: {}\", e);\n            std::process::exit(1);\n        }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Mutex;\nuse std::vec::Vec;\nuse std::thread;\nstatic mut GLOBAL_DATA: Option<Mutex<Vec<*mut u32>>> = None;\nconst MAX_TASKS: u32 = 100;\nfn initialize() {\n    unsafe {\n        GLOBAL_DATA = Some(Mutex::new(Vec::new()));\n    }\n}\nstruct Processor;\ntrait Executor {\n    fn run(&self, count: u32) -> Result<u32, &'static str>;\n}\nimpl Executor for Processor {\n    fn run(&self, count: u32) -> Result<u32, &'static str> {\n        if count > MAX_TASKS {\n            return Err(\"Task count exceeds allowed limit\");\n        }\n        let mut threads = Vec::new();\n        for i in 0..count {\n            let handle = thread::spawn(move || {\n                let raw_ptr = Box::into_raw(Box::new(i));\n                unsafe {\n                    if let Some(ref container) = GLOBAL_DATA {\n                        container.lock().unwrap().push(raw_ptr);\n                    }\n                }\n            });\n            threads.push(handle);\n        }\n        for t in threads {\n            t.join().unwrap();\n        }\n        Ok(count)\n    }\n}\nfn main() {\n    initialize();\n    let proc_inst = Processor;\n    let result = proc_inst.run(50);\n    println!(\"Processing complete: {:?}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::thread;\nstatic mut GLOBAL: u64 = 0;\nconst MAX_THREADS: u64 = 1000; \npub fn compute(n: u64) -> u64 {\n    unsafe {\n        GLOBAL = 0;\n    }\n    let count = if n > MAX_THREADS { MAX_THREADS } else { n };\n    let mut handles = vec![];\n    for _ in 0..count {\n        handles.push(thread::spawn(|| {\n            unsafe {\n                let val = GLOBAL;\n                let _dummy = (0..1000).fold(0, |acc, x| acc + x);\n                GLOBAL = val + 1;\n            }\n        }));\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    unsafe { GLOBAL }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let n = args.get(1)\n        .and_then(|s| s.parse::<u64>().ok())\n        .unwrap_or(0);\n    let result = compute(n);\n    println!(\"Result: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\npub struct WorkQueue {\n    inner: Mutex<Vec<u32>>,\n    max_tasks: usize,\n}\nimpl WorkQueue {\n    pub fn new() -> Arc<Self> {\n        Arc::new(WorkQueue {\n            inner: Mutex::new(Vec::new()),\n            max_tasks: 10000, \n        })\n    }\n    pub fn add_task(&self, task: u32) {\n        let mut guard = self.inner.lock().expect(\"Mutex poisoned\");\n        if guard.len() < self.max_tasks {\n            guard.push(task);\n        }\n    }\n    pub fn len(&self) -> usize {\n        let guard = self.inner.lock().expect(\"Mutex poisoned\");\n        guard.len()\n    }\n    pub fn process_all(&self) {\n        let mut guard = self.inner.lock().expect(\"Mutex poisoned\");\n        guard.clear();\n    }\n}\nfn main() {\n    let queue = WorkQueue::new();\n    let mut handles = Vec::new();\n    for i in 0..50 {\n        let q = queue.clone();\n        handles.push(thread::spawn(move || {\n            for j in 0..1000 {\n                q.add_task(i * 1000 + j);\n            }\n        }));\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    println!(\"Total tasks accumulated (capped): {}\", queue.len());\n    queue.process_all();\n    println!(\"Tasks processed and cleared.\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused_unsafe)]\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Engine;\nimpl Engine {\n    pub fn run_input(&self, load: usize) -> Result<(), String> {\n        const MAX_LOAD: usize = 100;\n        if load > MAX_LOAD {\n            return Err(\"Input load too high\".to_string());\n        }\n        let mut result: usize = 0;\n        for i in 0..load {\n            unsafe {\n                result = result.wrapping_add(i);\n            }\n        }\n        let shared = Arc::new(Mutex::new(result));\n        let thread_shared = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            unsafe {\n                let mut val = thread_shared.lock().unwrap();\n                *val = val.wrapping_mul(2);\n            }\n        });\n        handle.join().unwrap();\n        Ok(())\n    }\n}\nfn main() {\n    let eng = Engine;\n    match eng.run_input(10) {\n        Ok(()) => println!(\"Processing completed successfully.\"),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\npub trait Handler {\n    fn process(&self, data: &[u64]) -> Result<u64, &'static str>;\n}\npub struct ResourceManager;\nimpl Handler for ResourceManager {\n    fn process(&self, data: &[u64]) -> Result<u64, &'static str> {\n        const MAX_ITEMS: usize = 1000;\n        if data.len() > MAX_ITEMS {\n            return Err(\"Input size exceeds allowable limit\");\n        }\n        let mut result = 0u64;\n        if data.len() > 10 {\n            let mut threads = Vec::with_capacity(data.len());\n            for &item in data {\n                let handle = thread::spawn(move || {\n                    unsafe {\n                        let mut val = item;\n                        let ptr = &mut val as *mut u64;\n                        *ptr = *ptr * 2;\n                        *ptr\n                    }\n                });\n                threads.push(handle);\n            }\n            for th in threads {\n                result = result.saturating_add(th.join().map_err(|_| \"Thread error\")?);\n            }\n        } else {\n            for &item in data {\n                let doubled = unsafe {\n                    let mut val = item;\n                    let ptr = &mut val as *mut u64;\n                    *ptr = *ptr * 2;\n                    *ptr\n                };\n                result = result.saturating_add(doubled);\n            }\n        }\n        Ok(result)\n    }\n}\nfn main() {\n    let manager = ResourceManager;\n    let data = vec![1, 2, 3, 4];\n    match manager.process(&data) {\n        Ok(total) => println!(\"Result: {}\", total),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nconst MAX_REQUESTS: u32 = 150;\npub struct Task {\n    pub id: u32,\n    pub data: u8,\n}\npub fn run_service(n: u32) -> Result<(), &'static str> {\n    if n > MAX_REQUESTS {\n        return Err(\"limit exceeded\");\n    }\n    let mut tasks: Vec<Task> = Vec::with_capacity(n as usize);\n    for i in 0..n {\n        tasks.push(Task { id: i, data: (i % 256) as u8 });\n    }\n    let mut handles = Vec::new();\n    for task in tasks {\n        let handle = thread::spawn(move || {\n            let mut sum: u32 = 0;\n            for _ in 0..1000 {\n                sum = sum.wrapping_add(task.data as u32);\n            }\n            sum\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        let _ = handle.join();\n    }\n    Ok(())\n}\nfn main() {\n    let input = 200;\n    match run_service(input) {\n        Ok(_) => println!(\"Processing complete with input: {}\", input),\n        Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Service {\n    tasks: Vec<Box<[u8; 1024]>>,\n    max_tasks: usize,\n}\nimpl Service {\n    fn new(max_tasks: usize) -> Self {\n        Service { tasks: Vec::new(), max_tasks }\n    }\n    fn process(&mut self) {\n        if self.tasks.len() < self.max_tasks {\n            let data = Box::new([0u8; 1024]);\n            self.tasks.push(data);\n            unsafe {\n                let ptr = self.tasks.as_mut_ptr();\n                if !ptr.is_null() {\n                    *ptr = Box::new([1u8; 1024]);\n                }\n            }\n        }\n    }\n    fn count(&self) -> usize {\n        self.tasks.len()\n    }\n}\npub fn run_service(iterations: usize, limit: Option<usize>) -> usize {\n    let max = limit.unwrap_or(iterations);\n    let service = Arc::new(Mutex::new(Service::new(max)));\n    let mut handles = vec![];\n    for _ in 0..iterations {\n        let svc = Arc::clone(&service);\n        let handle = thread::spawn(move || {\n            let mut svc = svc.lock().unwrap();\n            svc.process();\n        });\n        handles.push(handle);\n    }\n    for h in handles {\n        let _ = h.join();\n    }\n    let svc = service.lock().unwrap();\n    svc.count()\n}\nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n    let iterations = if args.len() > 1 {\n         args[1].parse::<usize>().unwrap_or(200)\n    } else {\n         200\n    };\n    let limit = if args.len() > 2 {\n         Some(args[2].parse::<usize>().unwrap_or(100))\n    } else {\n         Some(100)\n    };\n    let count = run_service(iterations, limit);\n    println!(\"Processed tasks: {}\", count);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{mpsc, Arc, atomic::{AtomicUsize, Ordering}};\nuse std::thread;\nuse std::time::Duration;\nuse std::ptr;\nconst LIMIT: usize = 100;\nfn unsafe_transform(x: u32) -> u32 {\n    unsafe {\n        let ptr = &x as *const u32;\n        ptr::read(ptr)\n    }\n}\npub fn run_simulation(iterations: usize) -> Result<usize, String> {\n    let (tx, rx) = mpsc::sync_channel(LIMIT);\n    let counter = Arc::new(AtomicUsize::new(0));\n    let mut handles = Vec::new();\n    for thread_index in 0..4 {\n        let thread_tx = tx.clone();\n        let thread_counter = Arc::clone(&counter);\n        handles.push(thread::spawn(move || {\n            for j in 0..iterations {\n                let msg = unsafe_transform(j as u32);\n                loop {\n                    let load = thread_counter.load(Ordering::Relaxed);\n                    if load < LIMIT {\n                        thread_counter.fetch_add(1, Ordering::Relaxed);\n                        break;\n                    }\n                    thread::sleep(Duration::from_millis(1));\n                }\n                thread_tx.send(msg).unwrap();\n            }\n        }));\n    }\n    drop(tx); \n    let mut processed = 0;\n    while let Ok(msg) = rx.recv() {\n         let _ = unsafe_transform(msg);\n         processed += 1;\n         thread::sleep(Duration::from_millis(1));\n         counter.fetch_sub(1, Ordering::Relaxed);\n    }\n    for h in handles {\n         let _ = h.join();\n    }\n    Ok(processed)\n}\nfn main() {\n    match run_simulation(1000) {\n         Ok(n) => println!(\"Processed {} messages\", n),\n         Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nstruct MemoryBuffer {\n    buffer: Vec<u8>,\n    capacity: usize,\n}\nimpl MemoryBuffer {\n    fn new(capacity: usize, guard: u8) -> Self {\n        let mut vec = Vec::with_capacity(capacity + 1);\n        unsafe {\n            vec.set_len(capacity + 1);\n        }\n        vec[capacity] = guard;\n        Self {\n            buffer: vec,\n            capacity,\n        }\n    }\n    fn write_input(&mut self, input: &[u8]) -> Result<(), &'static str> {\n        if input.len() > self.capacity {\n            return Err(\"Input length exceeds buffer capacity\");\n        }\n        unsafe {\n            let ptr = self.buffer.as_mut_ptr();\n            for i in 0..input.len() {\n                *ptr.add(i) = input[i];\n            }\n            if input.len() > self.buffer.len() {\n                self.buffer.set_len(input.len());\n            }\n        }\n        Ok(())\n    }\n    fn check_guard(&self, guard: u8) -> bool {\n        self.buffer.get(self.capacity) == Some(&guard)\n    }\n}\nfn main() {\n    let input = vec![10, 20, 30, 40, 50, 60, 70, 80, 90, 100];\n    let initial_guard: u8 = 0xAA;\n    let mem = MemoryBuffer::new(8, initial_guard);\n    let shared_mem = Arc::new(Mutex::new(mem));\n    let shared_mem_clone = Arc::clone(&shared_mem);\n    let handle = std::thread::spawn(move || {\n        let mut buffer = shared_mem_clone.lock().unwrap();\n        let res = buffer.write_input(&input);\n        if res.is_err() {\n        }\n    });\n    handle.join().unwrap();\n    let buffer = shared_mem.lock().unwrap();\n    if !buffer.check_guard(initial_guard) {\n        panic!(\"Memory corruption detected: guard value overwritten\");\n    }\n    println!(\"Execution completed in fixed version\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\npub struct Handler {\n    buf: Vec<u8>,\n}\nimpl Handler {\n    pub fn new(size: usize) -> Self {\n        let buf = vec![0u8; size];\n        Self { buf }\n    }\n    pub fn update(&mut self, index: usize, value: u8) -> Result<(), &'static str> {\n        if index < self.buf.len() {\n            self.buf[index] = value;\n            Ok(())\n        } else {\n            Err(\"index out of bounds\")\n        }\n    }\n    pub fn get(&self, index: usize) -> Option<u8> {\n        self.buf.get(index).copied()\n    }\n}\nfn main() {\n    let mut handler = Handler::new(10);\n    match handler.update(10, 255) {\n        Ok(_) => println!(\"Main (fixed): update succeeded unexpectedly.\"),\n        Err(e) => println!(\"Main (fixed): error occurred: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct BufferManager {\n    buffer: Vec<u8>,\n}\nimpl BufferManager {\n    fn new() -> Self {\n        let mut data = Vec::with_capacity(10);\n        data.resize(10, 0); \n        BufferManager { buffer: data }\n    }\n    fn apply(&mut self, idx: usize, value: u8) -> Result<(), String> {\n        if idx < self.buffer.len() {\n            self.buffer[idx] = value;\n            Ok(())\n        } else {\n            Err(\"Index out of bounds\".into())\n        }\n    }\n    fn sum(&self) -> u32 {\n        self.buffer.iter().map(|&b| b as u32).sum()\n    }\n}\nfn main() {\n    let manager = BufferManager::new();\n    let shared = Arc::new(Mutex::new(manager));\n    let handles: Vec<_> = (0..2)\n        .map(|i| {\n            let shared_ref = Arc::clone(&shared);\n            thread::spawn(move || {\n                let mut mgr = shared_ref.lock().unwrap();\n                mgr.apply(9, 42 + i as u8).expect(\"Update failed\");\n            })\n        })\n        .collect();\n    for h in handles {\n        h.join().unwrap();\n    }\n    let mgr = shared.lock().unwrap();\n    println!(\"Sum: {}\", mgr.sum());\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct Buffer {\n    data: Vec<u32>,\n}\nimpl Buffer {\n    fn new(size: usize) -> Self {\n        let mut v = Vec::with_capacity(size);\n        v.resize(size, 0);\n        Buffer { data: v }\n    }\n    fn assign(&mut self, index: usize, value: u32) -> Result<(), &'static str> {\n        if index >= self.data.len() {\n            return Err(\"Index out of bounds\");\n        }\n        if let Some(elem) = self.data.get_mut(index) {\n            *elem = value;\n            Ok(())\n        } else {\n            Err(\"Index out of bounds\")\n        }\n    }\n    fn content(&self) -> &[u32] {\n        &self.data\n    }\n}\nfn main() {\n    let mut buf = Buffer::new(10);\n    buf.assign(9, 999).expect(\"Assignment failed\");\n    println!(\"Assignment completed (fixed).\");\n    println!(\"Buffer content: {:?}\", buf.content());\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nuse std::sync::{Arc, Mutex};\nstruct Data {\n    buf: Vec<u8>,\n}\nimpl Data {\n    pub fn new(size: usize) -> Self {\n        Data {\n            buf: Vec::with_capacity(size),\n        }\n    }\n    pub fn load(&mut self, input: &[u8]) -> Result<(), &'static str> {\n        let capacity = self.buf.capacity();\n        let count = input.len();\n        if count > capacity {\n            return Err(\"Input size exceeds allocated buffer capacity\");\n        }\n        let ptr = self.buf.as_mut_ptr();\n        for i in 0..count {\n            unsafe { *ptr.add(i) = input[i]; }\n        }\n        unsafe {\n            self.buf.set_len(count);\n        }\n        Ok(())\n    }\n    pub fn read(&self) -> &[u8] {\n        &self.buf\n    }\n}\nfn run(input: Vec<u8>) -> Result<Arc<Mutex<Data>>, &'static str> {\n    let shared = Arc::new(Mutex::new(Data::new(10))); \n    let shared_clone = Arc::clone(&shared);\n    let handler = thread::spawn(move || {\n        let mut data = shared_clone.lock().unwrap();\n        if let Err(e) = data.load(&input) {\n            panic!(\"{}\", e);\n        }\n    });\n    handler.join().map_err(|_| \"Thread panicked\")?;\n    Ok(shared)\n}\nfn main() {\n    let input = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n    match run(input) {\n        Ok(shared) => {\n            let data = shared.lock().unwrap();\n            println!(\"Buffer content: {:?}\", data.read());\n        },\n        Err(e) => {\n            println!(\"Error: {}\", e);\n        }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct Buffer {\n    data: Vec<u32>,\n}\nimpl Buffer {\n    fn new(size: usize) -> Self {\n        Buffer { data: vec![0; size] }\n    }\n    fn fill_data(&mut self, value: u32) {\n        unsafe {\n            let n = self.data.len();\n            let ptr = self.data.as_mut_ptr();\n            for i in 0..n {\n                *ptr.add(i) = value;\n            }\n        }\n    }\n}\nfn main() {\n    let mut buf = Buffer::new(10);\n    buf.fill_data(55);\n    println!(\"Buffer content: {:?}\", buf.data);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct BufferWrapper {\n    buffer: Vec<u8>,\n}\nimpl BufferWrapper {\n    fn new(size: usize) -> Self {\n        let v = vec![0u8; size];\n        BufferWrapper { buffer: v }\n    }\n    fn update(&mut self, index: usize, value: u8) -> Result<(), &'static str> {\n        if index >= self.buffer.len() {\n            return Err(\"Index out-of-bounds\");\n        }\n        self.buffer[index] = value;\n        Ok(())\n    }\n}\nfn main() {\n    let wrapper = Arc::new(Mutex::new(BufferWrapper::new(10)));\n    let wrapper_clone = Arc::clone(&wrapper);\n    let handle = thread::spawn(move || {\n        let mut lock = wrapper_clone.lock().unwrap();\n        match lock.update(15, 55) {\n            Ok(_) => println!(\"Update unexpectedly succeeded.\"),\n            Err(e) => println!(\"Handled error: {}\", e),\n        }\n    });\n    handle.join().unwrap();\n    println!(\"Execution complete: Vulnerability fixed.\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::vec::Vec;\nuse std::thread;\nstruct BufferManager {\n    buffer: Vec<u32>,\n}\nimpl BufferManager {\n    fn new() -> Self {\n        BufferManager {\n            buffer: vec![1, 1, 1, 1, 1],\n        }\n    }\n    fn update(&mut self, idx: usize, val: u32) -> Result<(), &'static str> {\n        if idx >= self.buffer.len() {\n            return Err(\"Index out of bounds\");\n        }\n        self.buffer[idx] = val;\n        Ok(())\n    }\n    fn sum(&self) -> u32 {\n        self.buffer.iter().sum()\n    }\n}\nfn main() {\n    let mut manager = BufferManager::new();\n    let handle = thread::spawn(move || {\n        match manager.update(5, 42) {\n            Ok(_) => println!(\"Unexpected update. Buffer state may be corrupted.\"),\n            Err(e) => println!(\"Error: {}\", e),\n        }\n        println!(\"Sum: {}\", manager.sum());\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct DataPool {\n    buffer: Vec<u8>,\n}\ntrait Modifier {\n    fn modify(&mut self, index: usize, value: u8) -> Result<(), &'static str>;\n}\nimpl Modifier for DataPool {\n    fn modify(&mut self, index: usize, value: u8) -> Result<(), &'static str> {\n        if index < self.buffer.len() {\n            self.buffer[index] = value;\n            Ok(())\n        } else {\n            Err(\"Index out-of-bounds\")\n        }\n    }\n}\nimpl DataPool {\n    fn new(size: usize) -> Self {\n        let buffer = vec![0u8; size];\n        DataPool { buffer }\n    }\n}\nfn main() {\n    let pool = Arc::new(Mutex::new(DataPool::new(10)));\n    let pool_clone = Arc::clone(&pool);\n    let handle = thread::spawn(move || {\n        let mut dp = pool_clone.lock().unwrap();\n        dp.modify(5, 42).expect(\"In-bound modification must succeed\");\n    });\n    handle.join().unwrap();\n    let mut dp = pool.lock().unwrap();\n    match dp.modify(11, 99) {\n        Ok(_) => println!(\"Unexpectedly modified out-of-bound index\"),\n        Err(e) => println!(\"Failed modification as expected: {}\", e),\n    }\n    println!(\"Final buffer: {:?}\", dp.buffer);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct DataBuffer {\n    data: Vec<u8>,\n}\nimpl DataBuffer {\n    fn new(size: usize) -> Self {\n        DataBuffer { data: vec![0; size] }\n    }\n    fn process(&mut self, index: usize, value: u8) -> u32 {\n        if index < self.data.len() {\n            self.data[index] = value;\n        }\n        self.data.iter().map(|&v| v as u32).sum()\n    }\n}\nfn main() {\n    let shared = Arc::new(Mutex::new(DataBuffer::new(10)));\n    let shared_clone = Arc::clone(&shared);\n    let handle = thread::spawn(move || {\n        let mut buf = shared_clone.lock().unwrap();\n        let res = buf.process(10, 42);\n        println!(\"Thread result: {}\", res);\n    });\n    {\n        let mut buf = shared.lock().unwrap();\n        let res = buf.process(5, 13);\n        println!(\"Main thread result: {}\", res);\n    }\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "struct DataHolder {\n    data: Vec<u32>,\n}\nimpl DataHolder {\n    fn new(capacity: usize) -> Self {\n        Self {\n            data: Vec::with_capacity(capacity),\n        }\n    }\n    pub fn inject_safe(&mut self, count: usize, value: u32) {\n        if count > self.data.capacity() {\n            panic!(\"Count {} exceeds capacity {}\", count, self.data.capacity());\n        }\n        self.data.clear();\n        for _ in 0..count {\n            self.data.push(value);\n        }\n    }\n    pub fn compute(&self) -> u32 {\n        self.data.iter().sum()\n    }\n}\nfn run() -> u32 {\n    let mut holder = DataHolder::new(10);\n    holder.inject_safe(10, 42);\n    holder.compute()\n}\nfn main() {\n    let total = run();\n    println!(\"Sum: {}\", total);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct Buffer {\n    data: Vec<u8>,\n}\nimpl Buffer {\n    fn new(size: usize) -> Self {\n        Buffer { data: vec![0u8; size] }\n    }\n    pub unsafe fn write_data(&mut self, offset: usize, input: &[u8]) {\n        if offset + input.len() > self.data.len() {\n            panic!(\"Out-of-bound write prevented\");\n        }\n        let dst = self.data.as_mut_ptr().add(offset);\n        ptr::copy_nonoverlapping(input.as_ptr(), dst, input.len());\n    }\n}\nfn main() {\n    let mut buf = Buffer::new(15);\n    let input_data = b\"HelloWorld\";\n    unsafe {\n        buf.write_data(5, input_data);\n    }\n    println!(\"Buffer content: {:?}\", buf.data);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nstruct BufferHandler {\n    buffer: Vec<u32>,\n}\nimpl BufferHandler {\n    fn new(size: usize) -> Self {\n        let mut buffer = Vec::with_capacity(size);\n        buffer.resize(size, 0);\n        Self { buffer }\n    }\n    fn update(&mut self, index: usize, value: u32) -> Result<(), &'static str> {\n        if index < self.buffer.len() {\n            self.buffer[index] = value;\n            Ok(())\n        } else {\n            Err(\"Index out of bounds\")\n        }\n    }\n    fn aggregate(&self) -> u32 {\n        self.buffer.iter().sum()\n    }\n}\nfn process() -> u32 {\n    let mut handler = BufferHandler::new(10);\n    let join_handle = thread::spawn(move || {\n        let _ = handler.update(10, 42);\n        handler.aggregate()\n    });\n    join_handle.join().unwrap()\n}\nfn main() {\n    let outcome = process();\n    println!(\"Result: {}\", outcome);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct CoreData {\n    vec: Vec<u32>,\n}\nimpl CoreData {\n    fn new(size: usize) -> Self {\n        Self { vec: vec![0; size] }\n    }\n    fn update(&mut self) {\n        let len = self.vec.len();\n        for i in 0..len {\n            self.vec[i] = (i * 2) as u32;\n        }\n    }\n}\nfn main() {\n    let data = Arc::new(Mutex::new(CoreData::new(10)));\n    let mut workers = Vec::new();\n    for _ in 0..2 {\n        let shared = Arc::clone(&data);\n        let handle = thread::spawn(move || {\n            let mut guard = shared.lock().unwrap();\n            guard.update();\n        });\n        workers.push(handle);\n    }\n    for handle in workers {\n        handle.join().unwrap();\n    }\n    let guard = data.lock().unwrap();\n    println!(\"Buffer content: {:?}\", guard.vec);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "struct DataBuffer {\n    data: Vec<u32>,\n}\nimpl DataBuffer {\n    pub fn new(size: usize) -> DataBuffer {\n        DataBuffer { data: vec![0; size] }\n    }\n    pub fn update(&mut self, index: usize, value: u32) {\n        if index < self.data.len() {\n            self.data[index] = value;\n        } else {\n            self.data.resize(index + 1, 0);\n            self.data[index] = value;\n        }\n    }\n}\nfn main() {\n    let mut buffer = DataBuffer::new(5);\n    buffer.update(2, 100);\n    buffer.update(7, 200);\n    println!(\"Buffer updated safely. Value at index 2: {}\", buffer.data[2]);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct Processor;\nimpl Processor {\n    pub fn transform(input: &[i32]) -> Vec<i32> {\n        let n = input.len();\n        let mut buffer: Vec<i32> = Vec::with_capacity(n);\n        unsafe {\n            buffer.set_len(n);\n            let ptr = buffer.as_mut_ptr();\n            for i in 0..n {\n                ptr.add(i).write(input[i]);\n            }\n        }\n        buffer\n    }\n}\nfn main() {\n    let data = vec![10, 20, 30, 40];\n    let result = Processor::transform(&data);\n    println!(\"Result: {:?}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Mutex, Arc};\nuse std::thread;\nstruct Buffer {\n    data: Vec<u32>,\n}\nimpl Buffer {\n    fn new(size: usize) -> Self {\n        let data = vec![0; size];\n        Buffer { data }\n    }\n    fn store_safe(&mut self, index: usize, value: u32) -> Result<(), &'static str> {\n        if index < self.data.len() {\n            self.data[index] = value;\n            Ok(())\n        } else {\n            Err(\"Index out of bounds\")\n        }\n    }\n}\ntrait Summable {\n    fn total(&self) -> u32;\n}\nstruct Worker {\n    buffer: Buffer,\n}\nimpl Summable for Worker {\n    fn total(&self) -> u32 {\n        self.buffer.data.iter().sum()\n    }\n}\nimpl Worker {\n    fn new(size: usize) -> Self {\n        Worker { buffer: Buffer::new(size) }\n    }\n    fn run(&mut self) {\n        if let Err(e) = self.buffer.store_safe(0, 100) {\n            eprintln!(\"Error storing value: {}\", e);\n        }\n    }\n}\nfn main() {\n    let worker = Arc::new(Mutex::new(Worker::new(5)));\n    let worker_clone = Arc::clone(&worker);\n    let handle = thread::spawn(move || {\n        let mut w = worker_clone.lock().unwrap();\n        w.run();\n    });\n    handle.join().unwrap();\n    let total = worker.lock().unwrap().total();\n    println!(\"Computed total: {}\", total);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nstruct DataHolder {\n    buffer: Vec<u32>,\n}\nimpl DataHolder {\n    pub fn new() -> Self {\n        Self {\n            buffer: Vec::with_capacity(10),\n        }\n    }\n    pub fn process(&mut self, input: &[u32]) {\n        if input.len() > self.buffer.capacity() {\n            self.buffer = Vec::with_capacity(input.len());\n        }\n        unsafe {\n            let ptr = self.buffer.as_mut_ptr();\n            for (i, &val) in input.iter().enumerate() {\n                *ptr.add(i) = val;\n            }\n            self.buffer.set_len(input.len());\n        }\n    }\n    pub fn total(&self) -> u32 {\n        self.buffer.iter().fold(0, |sum, &x| sum + x)\n    }\n}\nfn main() {\n    let mut holder = DataHolder::new();\n    let input = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n    holder.process(&input);\n    println!(\"Main thread total: {}\", holder.total());\n    let input_shared = input.clone();\n    let handle = thread::spawn(move || {\n        let mut worker = DataHolder::new();\n        worker.process(&input_shared);\n        println!(\"Thread total: {}\", worker.total());\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nfn compute_value() -> i32 {\n    let data = vec![1, 2, 3, 4, 5];                \n    data.iter().sum()\n}\nstruct Worker;\nimpl Worker {\n    fn process(&self) -> i32 {\n        compute_value()\n    }\n}\nfn main() {\n    let handler = Worker;\n    let handle = thread::spawn(move || {\n        handler.process()\n    });\n    let result = handle.join().unwrap();\n    println!(\"Total: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct Buffer {\n    data: Vec<u32>,\n}\nimpl Buffer {\n    fn new(len: usize) -> Self {\n        Self { data: vec![0; len] }\n    }\n    fn compute(&mut self) -> u32 {\n        let len = self.data.len();\n        unsafe {\n            let ptr = self.data.as_mut_ptr();\n            for i in 0..len {\n                ptr.add(i).write(1);\n            }\n        }\n        self.data.iter().sum()\n    }\n}\nfn main() {\n    let mut buf = Buffer::new(6);\n    let result = buf.compute();\n    println!(\"{}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nstruct Resources {\n    title: String,\n    amount: u32,\n}\nimpl Resources {\n    fn new_complete() -> Self {\n        Resources {\n            title: String::from(\"configuration\"),\n            amount: 0,\n        }\n    }\n}\nfn run_app() -> u32 {\n    let config = Resources::new_complete();\n    let handle = thread::spawn(move || config.amount);\n    handle.join().unwrap()\n}\nfn main() {\n    let result = run_app();\n    println!(\"Result: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::mem::MaybeUninit;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Data {\n    value: i32,\n    flag: bool,\n}\nimpl Data {\n    unsafe fn create_init() -> Self {\n        let mut uninit = MaybeUninit::<Self>::uninit();\n        (*uninit.as_mut_ptr()).value = 42;\n        (*uninit.as_mut_ptr()).flag = false; \n        uninit.assume_init()\n    }\n}\nfn compute() -> (i32, bool) {\n    let shared = Arc::new(Mutex::new(Data { value: 0, flag: false }));\n    let mut handles = Vec::new();\n    for _ in 0..4 {\n        let shared_clone = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            let safe_data = unsafe { Data::create_init() };\n            let mut data = shared_clone.lock().unwrap();\n            data.value = data.value.wrapping_add(safe_data.value);\n            if safe_data.flag {\n                data.flag = true;\n            }\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    let final_data = shared.lock().unwrap();\n    (final_data.value, final_data.flag)\n}\nfn main() {\n    let result = compute();\n    println!(\"Result: {:?}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nstruct Config {\n    name: String,\n    timeout: u32, \n}\nimpl Config {\n    fn construct() -> Self {\n        Config {\n            name: String::from(\"example\"),\n            timeout: 30, \n        }\n    }\n}\nfn load_config() -> Config {\n    Config::construct()\n}\nfn execute(config: Config) -> u32 {\n    let handle = thread::spawn(move || {\n        config.timeout.wrapping_add(1)\n    });\n    handle.join().unwrap()\n}\nfn main() {\n    let cfg = load_config();\n    let outcome = execute(cfg);\n    println!(\"Outcome: {}\", outcome);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\n#[derive(Debug)]\npub struct Config {\n    pub value: u32,\n    pub valid: bool,\n}\npub fn load_config() -> Config {\n    Config {\n        value: 42,\n        valid: true,\n    }\n}\npub fn run_threads() -> Vec<u32> {\n    let config = Arc::new(Mutex::new(load_config()));\n    let mut results = Vec::new();\n    let mut handles = Vec::new();\n    for _ in 0..4 {\n        let config_clone = Arc::clone(&config);\n        let h = thread::spawn(move || {\n            let cfg = config_clone.lock().unwrap();\n            if cfg.valid {\n                cfg.value + 1\n            } else {\n                cfg.value - 1\n            }\n        });\n        handles.push(h);\n    }\n    for h in handles {\n        results.push(h.join().unwrap());\n    }\n    results\n}\nfn main() {\n    let results = run_threads();\n    for r in results {\n        println!(\"result: {}\", r);\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Config {\n    threshold: u32,\n    message: String,\n}\nimpl Config {\n    fn validate(&self) -> bool {\n        self.threshold > 50 && self.message == \"default\"\n    }\n}\nfn load_configuration() -> Config {\n    Config {\n        threshold: 100,\n        message: \"default\".to_string(),\n    }\n}\nfn main() {\n    let config_shared = Arc::new(load_configuration());\n    let config_for_thread = Arc::clone(&config_shared);\n    let handler = thread::spawn(move || {\n        if config_for_thread.validate() {\n            println!(\"Configuration validated successfully.\");\n        } else {\n            println!(\"Configuration validation failed.\");\n        }\n    });\n    handler.join().unwrap();\n    println!(\"Main thread execution complete.\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Config {\n    field1: i32,\n    field2: i32,\n}\nfn load_resource() -> Config {\n    Config {\n        field1: 42,\n        field2: 10, \n    }\n}\nfn process_resource(cfg: &Config) -> i32 {\n    cfg.field1 + cfg.field2\n}\nfn run_resource() -> i32 {\n    let shared = Arc::new(Mutex::new(load_resource()));\n    let mut handles = Vec::new();\n    for _ in 0..4 {\n        let shared_clone = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            let locked = shared_clone.lock().unwrap();\n            process_resource(&locked)\n        });\n        handles.push(handle);\n    }\n    let mut total = 0;\n    for handle in handles {\n        if let Ok(val) = handle.join() {\n            total += val;\n        }\n    }\n    total\n}\nfn main() {\n    let result = run_resource();\n    println!(\"Result: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::mem::MaybeUninit;\nuse std::thread;\nstruct Settings {\n    threshold: u32,\n    factor: u32,\n}\nimpl Settings {\n    unsafe fn load() -> Settings {\n        let mut config = MaybeUninit::<Settings>::uninit();\n        let config_ptr = config.as_mut_ptr();\n        std::ptr::write(&mut (*config_ptr).threshold, 10);\n        std::ptr::write(&mut (*config_ptr).factor, 20);\n        config.assume_init()\n    }\n}\npub fn execute() -> u32 {\n    unsafe {\n        let conf = Settings::load();\n        let handle = thread::spawn(move || conf.threshold + conf.factor);\n        handle.join().unwrap()\n    }\n}\nfn main() {\n    println!(\"Output: {}\", execute());\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nstruct Settings {\n    addr: String,\n    port: u16,\n    max_conn: usize,\n}\nimpl Settings {\n    fn new(addr: &str, port: u16, max_conn: usize) -> Self {\n        Settings {\n            addr: addr.to_owned(),\n            port,\n            max_conn,\n        }\n    }\n    fn calc(&self) -> usize {\n        self.max_conn + self.port as usize\n    }\n}\npub fn compute() -> usize {\n    Settings::new(\"127.0.0.1\", 443, 100).calc()\n}\nfn run() {\n    let res = compute();\n    println!(\"Result: {}\", res);\n}\nfn main() {\n    let handle = thread::spawn(|| {\n        run();\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::mem::MaybeUninit;\nuse std::sync::{Arc, Barrier};\nuse std::thread;\nstruct Config {\n    threshold: i32,\n    description: String,\n}\nimpl Config {\n    fn new(threshold: i32, description: String) -> Self {\n        Config { threshold, description }\n    }\n}\nfn load_resource(trigger: i32) -> Config {\n    let mut data: MaybeUninit<Config> = MaybeUninit::uninit();\n    unsafe {\n        let ptr = data.as_mut_ptr();\n        ptr.write(Config::new(trigger, \"Properly initialized\".to_string()));\n        data.assume_init()\n    }\n}\nfn main() {\n    let barrier = Arc::new(Barrier::new(2));\n    let resource = load_resource(42);\n    let shared = Arc::new(resource);\n    let barrier_clone = barrier.clone();\n    let shared_copy = shared.clone();\n    let handle = thread::spawn(move || {\n        barrier_clone.wait();\n        let len = shared_copy.description.len();\n        len\n    });\n    barrier.wait();\n    let thread_len = handle.join().expect(\"Thread panicked\");\n    println!(\n        \"Threshold: {}, Description length: {}\",\n        shared.threshold, thread_len\n    );\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Settings {\n    timeout: u64,\n    retries: u32,\n}\nimpl Settings {\n    fn load() -> Self {\n        Settings {\n            timeout: 30,\n            retries: 3,\n        }\n    }\n}\nfn main() {\n    let shared = Arc::new(Settings::load());\n    let cloned = Arc::clone(&shared);\n    let handle = thread::spawn(move || {\n        if cloned.retries > 0 {\n            println!(\"Retries is set to {}\", cloned.retries);\n        } else {\n            println!(\"Retries is zero, value: {}\", cloned.retries);\n        }\n    });\n    handle.join().unwrap();\n    println!(\"Timeout is: {}\", shared.timeout);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nstruct Configuration {\n    value: i32,\n    active: bool,\n}\nimpl Configuration {\n    fn create_instance() -> Self {\n        Configuration {\n            value: 42,\n            active: true, \n        }\n    }\n    fn is_active(&self) -> bool {\n        self.active\n    }\n    fn compute(&self) -> i32 {\n        if self.is_active() {\n            self.value * 2\n        } else {\n            self.value\n        }\n    }\n}\nfn main() {\n    let config = Configuration::create_instance();\n    let handle = thread::spawn(move || {\n        config.compute()\n    });\n    let result = handle.join().unwrap();\n    println!(\"Computed result: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Resource {\n    number: i32,\n    description: String,\n}\nimpl Resource {\n    fn report(&self) -> String {\n        format!(\"Num: {}, Desc: {}\", self.number, self.description)\n    }\n}\nfn create_resource() -> Resource {\n    Resource {\n        number: 100,\n        description: \"Initialized\".to_string(),\n    }\n}\nfn run_app() {\n    let shared = Arc::new(Mutex::new(create_resource()));\n    let mut threads = Vec::new();\n    for _ in 0..4 {\n        let shared_clone = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            let guard = shared_clone.lock().unwrap();\n            guard.report()\n        });\n        threads.push(handle);\n    }\n    for handle in threads {\n        let output = handle.join().unwrap();\n        println!(\"{}\", output);\n    }\n}\nfn main() {\n    run_app();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "pub struct Config {\n    pub name: String,\n    pub count: u32,\n}\nimpl Config {\n    pub fn new(name: String, count: u32) -> Self {\n        Config { name, count }\n    }\n    pub fn valid(&self) -> bool {\n        !self.name.is_empty() && self.count > 0\n    }\n}\npub fn compute() -> bool {\n    let cfg = Config::new(\"secure_config\".to_owned(), 42);\n    cfg.valid()\n}\nfn main() {\n    let validity = compute();\n    println!(\"Configuration valid: {}\", validity);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::mem::MaybeUninit;\nuse std::sync::Arc;\nuse std::thread;\nstruct Settings {\n    flag: u32,\n}\nimpl Settings {\n    fn new(val: u32) -> Self {\n        Settings { flag: val }\n    }\n    fn flag(&self) -> u32 {\n        self.flag\n    }\n}\nunsafe fn setup() -> Settings {\n    let mut slot: MaybeUninit<Settings> = MaybeUninit::uninit();\n    slot.as_mut_ptr().write(Settings::new(42));\n    slot.assume_init()\n}\npub fn run_app() -> u32 {\n    let shared = Arc::new(unsafe { setup() });\n    let shared_clone = Arc::clone(&shared);\n    let handle = thread::spawn(move || {\n        shared_clone.flag()\n    });\n    handle.join().unwrap()\n}\nfn main() {\n    let result = run_app();\n    println!(\"Result flag: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Barrier};\nuse std::thread;\n#[derive(Debug)]\nstruct Data {\n    value: i32,\n}\nimpl Data {\n    fn new() -> Data {\n        Data { value: 100 }\n    }\n}\npub fn execute() -> i32 {\n    let barrier = Arc::new(Barrier::new(2));\n    let shared = Arc::new(Data::new());\n    let barrier_clone = Arc::clone(&barrier);\n    let shared_clone = Arc::clone(&shared);\n    let handle = thread::spawn(move || {\n        barrier_clone.wait();\n        let read_val = shared_clone.value;\n        read_val\n    });\n    barrier.wait();\n    handle.join().unwrap()\n}\nfn main() {\n    let res = execute();\n    println!(\"Result: {}\", res);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::{sync::{Arc, Mutex}, thread};\n#[derive(Debug)]\npub struct Config {\n    pub timeout: u32,\n    pub label: &'static str,\n}\nimpl Config {\n    pub fn new() -> Self {\n        Config {\n            timeout: 30,\n            label: \"default\",\n        }\n    }\n}\npub fn make_config() -> Config {\n    Config::new()\n}\nfn main() {\n    let config = Arc::new(Mutex::new(make_config()));\n    let mut handles = vec![];\n    for _ in 0..4 {\n        let cfg = Arc::clone(&config);\n        let handle = thread::spawn(move || {\n            let locked = cfg.lock().unwrap();\n            println!(\"Config timeout: {}, label: {}\", locked.timeout, locked.label);\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::mem::MaybeUninit;\nuse std::sync::{Arc, Mutex};\nmod app {\n    use super::*;\n    pub struct Item {\n        secret: u32,\n        public: u32,\n    }\n    impl Item {\n        pub fn new(flag: bool) -> Self {\n            let mut uninit = MaybeUninit::<Item>::uninit();\n            unsafe {\n                let ptr = uninit.as_mut_ptr();\n                (*ptr).secret = 42;\n                if flag {\n                    (*ptr).public = 128;\n                } else {\n                    (*ptr).public = 128;\n                }\n                uninit.assume_init()\n            }\n        }\n        pub fn sum(&self) -> u32 {\n            self.secret + self.public\n        }\n    }\n    pub fn execute() {\n        let item = Item::new(false);\n        let shared = Arc::new(Mutex::new(item));\n        let shared_clone = Arc::clone(&shared);\n        let handle = std::thread::spawn(move || {\n            let obj = shared_clone.lock().unwrap();\n            obj.sum()\n        });\n        let sum_main = {\n            let obj = shared.lock().unwrap();\n            obj.sum()\n        };\n        let sum_thread = handle.join().unwrap();\n        println!(\"Sum from main: {}, Sum from thread: {}\", sum_main, sum_thread);\n    }\n}\nfn main() {\n    app::execute();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Config {\n    threshold: u32,\n    desc: String,\n}\nfn load_config() -> Config {\n    Config {\n        threshold: 10,\n        desc: String::from(\"default config\"),\n    }\n}\nfn main() {\n    let conf = Arc::new(load_config());\n    let conf_clone = Arc::clone(&conf);\n    let handle = thread::spawn(move || {\n        if conf_clone.desc != \"default config\" {\n            panic!(\"Configuration description does not match expected value!\");\n        }\n    });\n    handle.join().expect(\"Thread panicked\");\n    println!(\"Threshold: {} - Desc: {}\", conf.threshold, conf.desc);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::mem::MaybeUninit;\nuse std::thread;\nstruct Config {\n    value: i32,\n    message: String,\n}\nfn initialize() -> Config {\n    let mut config = MaybeUninit::<Config>::uninit();\n    unsafe {\n        let config_ptr = config.as_mut_ptr();\n        (*config_ptr).value = 42;\n        std::ptr::write(&mut (*config_ptr).message, String::from(\"Initialized!\"));\n        let handle = thread::spawn(|| {\n        });\n        handle.join().unwrap();\n        config.assume_init()\n    }\n}\nfn run_app() -> String {\n    let cfg = initialize();\n    cfg.message\n}\nfn main() {\n    let output = run_app();\n    println!(\"{}\", output);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Config {\n    port: u16,\n    host: String,\n}\nfn initialize_config() -> Config {\n    Config {\n        port: 8080,\n        host: \"127.0.0.1\".to_string(),\n    }\n}\nfn validate_config(cfg: &Config) -> bool {\n    cfg.host == \"127.0.0.1\"\n}\nfn main() {\n    let cfg = initialize_config();\n    let shared_cfg = Arc::new(cfg);\n    let handle = thread::spawn({\n        let shared_clone = Arc::clone(&shared_cfg);\n        move || {\n            assert!(\n                validate_config(&shared_clone),\n                \"Configuration validation failed in secondary thread.\"\n            );\n            println!(\"Configuration validated in secondary thread.\");\n        }\n    });\n    handle.join().unwrap();\n    assert!(\n        validate_config(&shared_cfg),\n        \"Configuration validation failed in main thread.\"\n    );\n    println!(\"Configuration validated in main thread.\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::Arc;\nuse std::thread;\nuse std::str;\nstruct Processor {\n    buffer: Vec<u8>,\n}\nimpl Processor {\n    pub fn new() -> Self {\n        Processor { buffer: vec![b'A'; 10] }\n    }\n    pub fn process(&self, input: &str) -> String {\n        // Parse the user-controlled input as a length value.\n        let len: usize = input.parse().expect(\"Failed to parse input\");\n        // FIX: Validate that the provided length does not exceed the buffer size.\n        if len > self.buffer.len() {\n            return \"Invalid input size\".to_string();\n        }\n        // Safe conversion: Using pointer arithmetic only after ensuring bounds.\n        let ptr = self.buffer.as_ptr();\n        let slice = unsafe { std::slice::from_raw_parts(ptr, len) };\n        let result = unsafe { str::from_utf8_unchecked(slice) };\n        result.to_string()\n    }\n}\nfn main() {\n    // Read command line argument; default will be \"15\" which is now handled safely.\n    let arg = env::args().nth(1).unwrap_or_else(|| \"15\".to_string());\n    let proc_inst = Arc::new(Processor::new());\n    // Spawn a thread to simulate concurrent processing.\n    let proc_clone = Arc::clone(&proc_inst);\n    let handle = thread::spawn(move || {\n        let output = proc_clone.process(&arg);\n        println!(\"Output: {}\", output);\n    });\n    handle.join().expect(\"Thread panicked\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process;\ntrait Operation {\n    fn execute(&self, input: &str) -> Result<u8, &'static str>;\n}\nstruct Handler {\n    id: u32,\n}\nimpl Operation for Handler {\n    fn execute(&self, input: &str) -> Result<u8, &'static str> {\n        let index: usize = input.parse().unwrap();\n        let mut data: [u8; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        if index >= data.len() {\n            return Err(\"input index out of range\");\n        }\n        unsafe {\n            let ptr = data.as_mut_ptr();\n            *ptr.add(index) = 99;\n        }\n        let sum: u8 = data.iter().fold(0, |acc, &x| acc.wrapping_add(x));\n        Ok(sum)\n    }\n}\nfn run() {\n    let args: Vec<String> = env::args().collect();\n    let input = if args.len() > 1 { &args[1] } else { \"3\" };\n    let handler = Handler { id: 1 };\n    match handler.execute(input) {\n        Ok(res) => println!(\"Result: {}\", res),\n        Err(e) => {\n            eprintln!(\"Error: {}\", e);\n            process::exit(1);\n        }\n    }\n}\nfn main() {\n    run();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\nuse std::env;\nstruct Holder {\n    bytes: Box<[u8]>,\n}\nimpl Holder {\n    fn new(input: &[u8]) -> Option<Holder> {\n        Some(Holder { bytes: input.into() })\n    }\n    fn process(&self, offset: usize, count: usize) -> String {\n        let available = self.bytes.len().saturating_sub(offset);\n        let valid_count = if count > available { available } else { count };\n        unsafe {\n            let ptr = self.bytes.as_ptr().add(offset);\n            let slice = std::slice::from_raw_parts(ptr, valid_count);\n            std::str::from_utf8_unchecked(slice).to_string()\n        }\n    }\n}\nfn main() {\n    let data = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    let holder = Holder::new(data).expect(\"Initialization failed\");\n    let user_offset = 20;\n    let user_count = 10; \n    let result = holder.process(user_offset, user_count);\n    println!(\"Extracted result: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Config {\n    data: String,\n}\nimpl Config {\n    fn parse(input: &str) -> Result<Self, &'static str> {\n        if input.len() < 2 {\n            return Err(\"Input too short\");\n        }\n        let header = &input[..2];\n        let count: usize = header.parse().map_err(|_| \"Header parse error\")?;\n        if input.len() < 2 + count {\n            return Err(\"Payload length mismatch\");\n        }\n        let slice = &input.as_bytes()[2..2 + count];\n        let payload = std::str::from_utf8(slice).map_err(|_| \"Invalid UTF-8 in payload\")?;\n        Ok(Config {\n            data: payload.to_string(),\n        })\n    }\n    fn process(&self) {\n        let shared = Arc::new(self.data.clone());\n        let shared_clone = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            println!(\"Processed data: {}\", shared_clone);\n        });\n        handle.join().unwrap();\n    }\n}\nfn main() {\n    let input = std::env::args().nth(1).unwrap_or_else(|| \"05hello\".to_string());\n    match Config::parse(&input) {\n        Ok(cfg) => {\n            cfg.process();\n        }\n        Err(e) => {\n            eprintln!(\"Error: {}\", e);\n        }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\ntrait DataAccess {\n    fn read(&self, idx: usize) -> i32;\n}\nstruct Container {\n    data: Vec<i32>,\n}\nimpl Container {\n    fn new() -> Self {\n        Container { data: (1..=10).collect() }\n    }\n}\nimpl DataAccess for Container {\n    fn read(&self, idx: usize) -> i32 {\n        if idx >= self.data.len() {\n            panic!(\"Index {} is out of bounds (length {})\", idx, self.data.len());\n        }\n        unsafe {\n            *self.data.as_ptr().add(idx)\n        }\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let idx: usize = args\n        .get(1)\n        .unwrap_or(&\"0\".to_string())\n        .parse()\n        .expect(\"Invalid number provided\");\n    let container = Arc::new(Container::new());\n    let result = Arc::new(Mutex::new(0));\n    let cont_clone = Arc::clone(&container);\n    let res_clone = Arc::clone(&result);\n    let handle = thread::spawn(move || {\n        let val = cont_clone.read(idx);\n        let mut res = res_clone.lock().unwrap();\n        *res = val;\n    });\n    handle.join().expect(\"Thread panicked\");\n    let final_value = *result.lock().unwrap();\n    println!(\"Value: {}\", final_value);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nstruct Config {\n    data: Vec<u32>,\n}\nimpl Config {\n    fn new() -> Self {\n        Self { data: vec![10, 20, 30, 40, 50] }\n    }\n    unsafe fn process(&self, input: &str) -> Result<u32, String> {\n        let idx: usize = input.trim().parse().map_err(|_| \"Invalid input: not a number\".to_string())?;\n        if idx >= self.data.len() {\n            return Err(\"Index out of bounds\".to_string());\n        }\n        let ptr = self.data.as_ptr();\n        let value = *ptr.add(idx);\n        Ok(value)\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let input = if args.len() > 1 { &args[1] } else { \"2\" };\n    let config = Config::new();\n    let res = unsafe { config.process(input) };\n    match res {\n        Ok(val) => println!(\"Result: {}\", val),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::error::Error;\nuse std::str;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Engine {\n    info: Arc<Mutex<String>>,\n}\nimpl Engine {\n    fn new(initial: &str) -> Self {\n        Self {\n            info: Arc::new(Mutex::new(initial.to_owned())),\n        }\n    }\n    fn execute(&self, input: &str) -> Result<String, Box<dyn Error>> {\n        let len: usize = input.trim().parse()?;\n        let guard = self.info.lock().unwrap();\n        let bytes = guard.as_bytes();\n        if len > bytes.len() {\n            return Err(\"Input length exceeds available data\".into());\n        }\n        let snippet = unsafe { str::from_utf8_unchecked(&bytes[0..len]) };\n        Ok(snippet.to_string())\n    }\n    fn parallel_run(&self, input: &str) -> Result<String, Box<dyn Error>> {\n        let len_val = input.trim().parse::<usize>()?;\n        let shared = Arc::clone(&self.info);\n        let handler = thread::spawn(move || {\n            let locked = shared.lock().unwrap();\n            let bytes = locked.as_bytes();\n            if len_val > bytes.len() {\n                return \"Error: Length exceeds data\".to_string();\n            }\n            let segment = unsafe { str::from_utf8_unchecked(&bytes[0..len_val]) };\n            segment.to_string()\n        });\n        let result = handler.join().map_err(|_| \"Thread join error\")?;\n        if result == \"Error: Length exceeds data\" {\n            return Err(\"Input length exceeds available data\".into());\n        }\n        Ok(result)\n    }\n}\nfn main() -> Result<(), Box<dyn Error>> {\n    let system = Engine::new(\"trusted_data\");\n    let user_length = \"5\";  \n    let outcome = system.execute(user_length)?;\n    println!(\"Outcome: {}\", outcome);\n    Ok(())\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::{Arc};\nuse std::thread;\nuse std::str;\nstruct Processor {\n    buffer: Vec<u8>,\n}\nimpl Processor {\n    fn new() -> Self {\n        Processor { buffer: b\"Sensitive buffer data\".to_vec() }\n    }\n    fn process(&self, len: usize) -> Result<String, &'static str> {\n        if len > self.buffer.len() {\n            return Err(\"Invalid length: exceeds buffer size\");\n        }\n        let s = std::str::from_utf8(&self.buffer[..len]).map_err(|_| \"UTF8 conversion error\")?;\n        Ok(s.to_string())\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        eprintln!(\"Usage: {} <length>\", args[0]);\n        std::process::exit(1);\n    }\n    let n: usize = match args[1].parse() {\n        Ok(val) => val,\n        Err(_) => {\n            eprintln!(\"Invalid length provided\");\n            std::process::exit(1);\n        }\n    };\n    let processor = Arc::new(Processor::new());\n    let proc_clone = Arc::clone(&processor);\n    let handle = thread::spawn(move || {\n        match proc_clone.process(n) {\n            Ok(s) => println!(\"Thread Output: {}\", s),\n            Err(e) => eprintln!(\"Thread Error: {}\", e),\n        }\n    });\n    match processor.process(n) {\n        Ok(s) => println!(\"Main Output: {}\", s),\n        Err(e) => eprintln!(\"Main Error: {}\", e),\n    }\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nfn process_data(input: &str) -> Result<String, &'static str> {\n    let user_index: usize = input.trim().parse().map_err(|_| \"Invalid number\")?;\n    let shared_buffer = Arc::new(Mutex::new(vec![0u8; 10]));\n    let thread_buffer = Arc::clone(&shared_buffer);\n    thread::spawn(move || {\n        let mut data = thread_buffer.lock().unwrap();\n        data[0] = 66; \n    }).join().unwrap();\n    let mut data_guard = shared_buffer.lock().unwrap();\n    if user_index >= data_guard.len() {\n         return Err(\"Index out-of-bounds\");\n    }\n    data_guard[user_index] = 65; \n    let result = data_guard.clone();\n    let s = std::str::from_utf8(&result).map_err(|_| \"UTF-8 conversion error\")?;\n    Ok(s.to_string())\n}\nfn main() {\n    match process_data(\"15\") {\n        Ok(result) => println!(\"Resulting string: {:?}\", result),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nstatic DATA: &[u8] = b\"Example static data used for unsafe string extraction vulnerability demo\";\nstruct Processor;\nimpl Processor {\n    fn process(&self, offset: usize, len: usize) -> Result<String, String> {\n        if offset.checked_add(len).map_or(true, |end| end > DATA.len()) {\n            return Err(\"Invalid input: offset and length exceed data bounds\".to_string());\n        }\n        let slice = &DATA[offset..offset+len];\n        let s = std::str::from_utf8(slice).map_err(|_| \"UTF-8 conversion error\".to_string())?;\n        Ok(s.to_string())\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() != 2 {\n        println!(\"Usage: {} offset:len\", args[0]);\n        return;\n    }\n    let parts: Vec<&str> = args[1].split(':').collect();\n    if parts.len() != 2 {\n        println!(\"Invalid input format, expected offset:len\");\n        return;\n    }\n    let offset = parts[0].parse::<usize>().unwrap_or(0);\n    let len = parts[1].parse::<usize>().unwrap_or(0);\n    let proc_inst = Processor;\n    match proc_inst.process(offset, len) {\n        Ok(result) => println!(\"Result: {}\", result),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::str;\nuse std::thread;\nstruct Processor;\nimpl Processor {\n    fn process(&self, input: &str) -> Result<String, String> {\n        let mut parts = input.splitn(2, ' ');\n        let len_str = parts.next().ok_or(\"Missing length token\")?;\n        let data = parts.next().ok_or(\"Missing payload token\")?;\n        let expected_len: usize = len_str.parse().map_err(|_| \"Invalid length token\")?;\n        if expected_len > data.len() {\n            return Err(\"Length exceeds payload size\".to_owned());\n        }\n        let subslice = &data.as_bytes()[..expected_len];\n        let result = str::from_utf8(subslice).map_err(|_| \"Payload is not valid UTF-8\")?;\n        Ok(result.to_owned())\n    }\n}\nfn main() {\n    let processor = Processor;\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 3 {\n        println!(\"Usage: {} <expected_length> <payload>\", args[0]);\n        return;\n    }\n    let input = format!(\"{} {}\", args[1], args[2]);\n    let handle = thread::spawn(move || {\n        match processor.process(&input) {\n            Ok(out)  => println!(\"Output: {}\", out),\n            Err(err) => println!(\"Error: {}\", err),\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::error::Error;\nuse std::sync::Arc;\nuse std::thread;\nstruct DataProcessor;\nimpl DataProcessor {\n    fn process(&self, input: &str) -> Result<String, Box<dyn Error>> {\n        if input.len() < 4 {\n            return Err(\"Input too short to contain length field\".into());\n        }\n        let len_str = &input[..4];\n        let len: usize = len_str.parse()?;\n        if input.len() < 4 + len {\n            return Err(\"Declared length exceeds input size\".into());\n        }\n        let data_slice = &input[4..4 + len];\n        let result = std::str::from_utf8(data_slice.as_bytes())?;\n        Ok(result.to_string())\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        eprintln!(\"Usage: {} <input>\", args[0]);\n        return;\n    }\n    let input = args[1].as_str();\n    let shared = Arc::new(DataProcessor);\n    let mut threads = vec![];\n    for _ in 0..4 {\n        let shared_clone = Arc::clone(&shared);\n        let input_clone = input.to_string();\n        let handle = thread::spawn(move || {\n            match shared_clone.process(&input_clone) {\n                Ok(result) => println!(\"Output: {}\", result),\n                Err(e) => eprintln!(\"Error: {}\", e),\n            }\n        });\n        threads.push(handle);\n    }\n    for handle in threads {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\n#[derive(Clone)]\nstruct DataHolder {\n    content: String,\n}\nimpl DataHolder {\n    fn new(content: &str) -> Self {\n        DataHolder {\n            content: content.to_string(),\n        }\n    }\n    fn extract_section(&self, offset: usize, length: usize) -> Result<String, &'static str> {\n        let bytes = self.content.as_bytes();\n        if offset.checked_add(length).filter(|&end| end <= bytes.len()).is_none() {\n            return Err(\"Invalid bounds\");\n        }\n        let slice = &self.content[offset..offset + length];\n        Ok(slice.to_string())\n    }\n    fn get_slice(&self, offset: usize, length: usize) -> Result<String, &'static str> {\n        self.extract_section(offset, length)\n    }\n}\nstruct Processor {\n    data: Arc<DataHolder>,\n}\nimpl Processor {\n    fn new(content: &str) -> Self {\n        Processor {\n            data: Arc::new(DataHolder::new(content)),\n        }\n    }\n    fn process(&self, offset: usize, length: usize) -> Result<String, &'static str> {\n        let data_clone = Arc::clone(&self.data);\n        let handle = thread::spawn(move || data_clone.get_slice(offset, length));\n        handle.join().unwrap()\n    }\n}\nfn main() {\n    let proc_inst = Processor::new(\"Hello, World!\");\n    match proc_inst.process(7, 10) {\n        Ok(result) => println!(\"Extracted section: {}\", result),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct BufferManager {\n    data: Vec<u8>,\n}\nimpl BufferManager {\n    fn get_segment_safe(&self, start: usize, length: usize) -> Result<&str, &'static str> {\n        let end = start.checked_add(length).ok_or(\"overflow in parameters\")?;\n        if end > self.data.len() {\n            return Err(\"out of bounds\");\n        }\n        let slice = &self.data[start..end];\n        std::str::from_utf8(slice).map_err(|_| \"invalid utf8\")\n    }\n}\nstruct Processor {\n    manager: Arc<Mutex<BufferManager>>,\n}\nimpl Processor {\n    fn run(&self, start: usize, length: usize) -> Result<u32, &'static str> {\n        let guard = self.manager.lock().unwrap();\n        let segment = guard.get_segment_safe(start, length)?;\n        segment.trim().parse::<u32>().map_err(|_| \"parse error\")\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 4 {\n        println!(\"Usage: <program> <input_string> <start> <length>\");\n        return;\n    }\n    let input = args[1].clone();\n    let start: usize = args[2].parse().unwrap_or(0);\n    let length: usize = args[3].parse().unwrap_or(0);\n    let manager = BufferManager { data: input.into_bytes() };\n    let proc_inst = Processor { manager: Arc::new(Mutex::new(manager)) };\n    let handle = thread::spawn(move || {\n        match proc_inst.run(start, length) {\n            Ok(value) => println!(\"Extracted number: {}\", value),\n            Err(err) => println!(\"Operation failed: {}\", err),\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Processor;\nimpl Processor {\n    fn process_input(&self, input: &[u8]) -> Result<String, &'static str> {\n        if input.len() < 4 {\n            return Err(\"Input too short for header\");\n        }\n        let claimed = u32::from_le_bytes([input[0], input[1], input[2], input[3]]) as usize;\n        if input.len() < 4 + claimed {\n            return Err(\"Input too short for message\");\n        }\n        let message_slice = &input[4..4 + claimed];\n        match std::str::from_utf8(message_slice) {\n            Ok(valid_msg) => Ok(valid_msg.to_string()),\n            Err(_) => Err(\"Invalid UTF-8 data\"),\n        }\n    }\n}\nfn concurrent_process(proc: Arc<Processor>, data: Vec<u8>) -> Option<String> {\n    let handle = thread::spawn(move || {\n        proc.process_input(&data)\n    });\n    handle.join().ok().and_then(|r| r.ok())\n}\nfn main() {\n    let proc = Arc::new(Processor);\n    let data = vec![5, 0, 0, 0, b'H', b'e', b'l', b'l', b'o'];\n    match concurrent_process(proc, data) {\n        Some(message) => println!(\"Processed message: {}\", message),\n        None => println!(\"Processing failed\"),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::Arc;\nuse std::thread;\nstruct Handler {\n    data: Box<[u8]>,\n}\nimpl Handler {\n    fn new() -> Self {\n        let mut vec = vec![1u8; 100];\n        vec[50] = 255; \n        Handler {\n            data: vec.into_boxed_slice(),\n        }\n    }\n    fn execute(&self, input: &str) -> Result<(), &'static str> {\n        let idx = usize::from_str_radix(input, 16).map_err(|_| \"parse error\")?;\n        let buf_len = 10;\n        if idx.checked_add(buf_len).map_or(true, |end| end > self.data.len()) {\n            return Err(\"index out of bounds\");\n        }\n        let mut buffer = vec![0u8; buf_len];\n        unsafe {\n            let src = self.data.as_ptr().add(idx);\n            std::ptr::copy_nonoverlapping(src, buffer.as_mut_ptr(), buf_len);\n        }\n        let sum: u8 = buffer.iter().fold(0, |acc, &x| acc.wrapping_add(x));\n        if sum == 0 {\n            Err(\"data sum is zero\")\n        } else {\n            Ok(())\n        }\n    }\n}\nfn run_app() {\n    let args: Vec<String> = env::args().collect();\n    let input = if args.len() > 1 { &args[1] } else { \"00\" };\n    let handler = Arc::new(Handler::new());\n    let handler_clone = Arc::clone(&handler);\n    let input_clone = input.to_string();\n    let handle = thread::spawn(move || {\n        match handler_clone.execute(&input_clone) {\n            Ok(_)  => println!(\"Concurrent execution succeeded.\"),\n            Err(e) => println!(\"Concurrent execution failed: {}\", e),\n        }\n    });\n    match handler.execute(input) {\n        Ok(_)  => println!(\"Main execution succeeded.\"),\n        Err(e) => println!(\"Main execution failed: {}\", e),\n    }\n    handle.join().unwrap();\n}\nfn main() {\n    run_app();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::Arc;\nuse std::thread;\npub struct Processor {\n    data: String,\n}\nimpl Processor {\n    pub fn new(data: String) -> Self {\n        Processor { data }\n    }\n    pub fn process(&self, user_len: usize) -> Result<&str, &'static str> {\n        let bytes = self.data.as_bytes();\n        if user_len > bytes.len() {\n            return Err(\"Input length exceeds data length\");\n        }\n        unsafe {\n            Ok(std::str::from_utf8_unchecked(&bytes[..user_len]))\n        }\n    }\n    pub fn run(self, user_len: usize) {\n        let shared = Arc::new(self);\n        let thread_shared = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            match thread_shared.process(user_len) {\n                Ok(result) => println!(\"Processed data: {}\", result),\n                Err(e) => eprintln!(\"Error: {}\", e),\n            }\n        });\n        handle.join().unwrap();\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() != 3 {\n        eprintln!(\"Usage: {} <input_string> <length>\", args[0]);\n        std::process::exit(1);\n    }\n    let input = args[1].clone();\n    let user_len: usize = args[2].parse().unwrap();\n    let proc_inst = Processor::new(input);\n    proc_inst.run(user_len);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::env;\nuse std::thread;\nfn process_data(n: usize) -> Result<String, &'static str> {\n    let buf: Arc<[u8; 10]> = Arc::new(*b\"0123456789\");\n    if n > buf.len() {\n        return Err(\"Input length exceeds allowed range\");\n    }\n    let shared_buf = buf.clone();\n    let handle = thread::spawn(move || {\n        unsafe {\n            let slice = std::slice::from_raw_parts(shared_buf.as_ptr(), n);\n            std::str::from_utf8(slice).unwrap()\n        }\n    });\n    handle.join().map(|s| s.to_string()).map_err(|_| \"Thread failed\")\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let num = if args.len() > 1 {\n        args[1].parse::<usize>().unwrap_or(8)\n    } else {\n        8\n    };\n    match process_data(num) {\n        Ok(s) => println!(\"Result: {}\", s),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::env;\nuse std::str;\npub struct Info {\n    data: Arc<Mutex<String>>,\n}\nimpl Info {\n    pub fn new() -> Self {\n        Info {\n            data: Arc::new(Mutex::new(String::new())),\n        }\n    }\n    pub fn process_input(&self, input: &[u8]) -> Result<(), &'static str> {\n        let s = match str::from_utf8(input) {\n            Ok(valid) => valid,\n            Err(_) => return Err(\"Invalid UTF-8 input\"),\n        };\n        let mut data_lock = self.data.lock().unwrap();\n        *data_lock = s.to_owned();\n        Ok(())\n    }\n    pub fn get_data(&self) -> String {\n        let data_lock = self.data.lock().unwrap();\n        data_lock.clone()\n    }\n}\nfn spawn_worker(handler: Arc<Info>, input: Vec<u8>) -> thread::JoinHandle<Result<(), &'static str>> {\n    thread::spawn(move || {\n        handler.process_input(&input)\n    })\n}\nfn main() {\n    let info = Arc::new(Info::new());\n    let args: Vec<String> = env::args().collect();\n    let user_input = if args.len() > 1 {\n        args[1].clone().into_bytes()\n    } else {\n        vec![0xff, 0xfe, 0xfd]\n    };\n    let worker1 = spawn_worker(info.clone(), user_input.clone());\n    let worker2 = spawn_worker(info.clone(), user_input);\n    let res1 = worker1.join().unwrap();\n    let res2 = worker2.join().unwrap();\n    if res1.is_err() || res2.is_err() {\n        println!(\"Error processing input.\");\n    } else {\n        println!(\"Processed: {}\", info.get_data());\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process;\nstruct Packet {\n    payload: Vec<u8>,\n}\nimpl Packet {\n    fn parse(data: &[u8]) -> Result<Packet, &'static str> {\n        if data.len() < 4 {\n            return Err(\"Input too short\");\n        }\n        let payload_len = u32::from_le_bytes([data[0], data[1], data[2], data[3]]) as usize;\n        if data.len() < 4 + payload_len {\n            return Err(\"Payload length exceeds available data\");\n        }\n        let payload = data[4..4 + payload_len].to_vec();\n        Ok(Packet { payload })\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        eprintln!(\"Usage: {} <input_data>\", args[0]);\n        return;\n    }\n    let input = args[1].clone();\n    let data = input.into_bytes();\n    match Packet::parse(&data) {\n        Ok(packet) => println!(\"Payload: {:?}\", packet.payload),\n        Err(e) => {\n            eprintln!(\"Error: {}\", e);\n            process::exit(1);\n        }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\n#[derive(Debug)]\npub struct DataPacket {\n    pub message: Vec<u8>,\n    pub signature: Vec<u8>,\n    pub public_key: Vec<u8>,\n}\nimpl DataPacket {\n    pub fn new(message: &[u8], signature: &[u8], public_key: &[u8]) -> Self {\n        DataPacket {\n            message: message.to_vec(),\n            signature: signature.to_vec(),\n            public_key: public_key.to_vec(),\n        }\n    }\n    pub fn verify(&self) -> bool {\n        if self.signature.len() != 64 {\n            return false;\n        }\n        let expected = compute_expected_signature(&self.message, &self.public_key);\n        self.signature == expected\n    }\n}\nfn compute_expected_signature(message: &[u8], public_key: &[u8]) -> Vec<u8> {\n    let mut sig = vec![0u8; 64];\n    for i in 0..64 {\n        let m = message.get(i % message.len()).unwrap();\n        let p = public_key.get(i % public_key.len()).unwrap();\n        sig[i] = m ^ p;\n    }\n    sig\n}\nfn main() {\n    let msg = b\"Important Data\";\n    let pk = [1u8; 32];\n    let valid_sig = compute_expected_signature(msg, &pk);\n    let packet = DataPacket::new(msg, &valid_sig, &pk);\n    let shared_packet = Arc::new(Mutex::new(packet));\n    let thread_handle = {\n        let shared_clone = Arc::clone(&shared_packet);\n        thread::spawn(move || {\n            let packet = shared_clone.lock().unwrap();\n            if packet.verify() {\n                println!(\"Accepted\");\n            } else {\n                println!(\"Rejected\");\n            }\n        })\n    };\n    thread_handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nstruct Message {\n    msg: String,\n    algo: String,\n    sig: Vec<u8>,\n}\nimpl Message {\n    fn new(msg: String, algo: String, sig: Vec<u8>) -> Self {\n        Message { msg, algo, sig }\n    }\n}\nfn verify_message(m: &Message) -> bool {\n    if m.algo != \"ed25519\" {\n        return false;\n    }\n    let expected: Vec<u8> = m.msg.bytes().rev().collect();\n    m.sig == expected\n}\nfn process(m: Message) -> bool {\n    let shared = Arc::new(Mutex::new(m));\n    let clone = Arc::clone(&shared);\n    let handle = std::thread::spawn(move || {\n        let data = clone.lock().unwrap();\n        verify_message(&*data)\n    });\n    handle.join().unwrap()\n}\nfn main() {\n    let message_text = \"Data\".to_string();\n    let signature: Vec<u8> = message_text.bytes().rev().collect();\n    let message = Message::new(message_text, \"ed25519\".to_string(), signature);\n    let result = process(message);\n    println!(\"Verification result: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\n#[derive(Clone)]\npub struct Checker;\nimpl Checker {\n    pub fn new() -> Self {\n        Checker\n    }\n    pub fn authenticate(&self, key: &[u8; 32], data: &[u8], sign: &[u8; 64]) -> bool {\n        let expected = Checker::produce_signature(key, data);\n        expected == *sign\n    }\n    fn produce_signature(key: &[u8; 32], data: &[u8]) -> [u8; 64] {\n        let mut signature = [0u8; 64];\n        for i in 0..32 {\n            signature[i] = key[i];\n        }\n        let filler = data.len() as u8;\n        for i in 32..64 {\n            signature[i] = filler;\n        }\n        signature\n    }\n}\nfn main() {\n    let instance = Arc::new(Checker::new());\n    let public_key: [u8; 32] = [1; 32];\n    let message = b\"Hello, World!\";\n    let valid_signature = Checker::produce_signature(&public_key, message);\n    let checker_instance = instance.clone();\n    let handler = thread::spawn(move || {\n        if checker_instance.authenticate(&public_key, message, &valid_signature) {\n            println!(\"Authentication succeeded (fixed).\");\n        } else {\n            println!(\"Authentication failed (fixed).\");\n        }\n    });\n    handler.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct DataPacket {\n    msg: String,\n    sig: String,\n    algo: String,\n}\nimpl DataPacket {\n    pub fn new(msg: &str, sig: &str, algo: &str) -> Self {\n        Self {\n            msg: msg.to_owned(),\n            sig: sig.to_owned(),\n            algo: algo.to_owned(),\n        }\n    }\n    pub fn validate(&self) -> bool {\n        if self.algo != \"reverse\" {\n            return false;\n        }\n        let expected: String = self.msg.chars().rev().collect();\n        expected == self.sig\n    }\n}\nfn main() {\n    let packet = Arc::new(DataPacket::new(\"Hello\", \"invalid_signature\", \"reverse\"));\n    let shared_packet = Arc::clone(&packet);\n    let handler = thread::spawn(move || {\n        if shared_packet.validate() {\n            println!(\"Validation succeeded (unexpected for an invalid signature).\");\n        } else {\n            println!(\"Validation failed: signature correctly rejected.\");\n        }\n    });\n    handler.join().expect(\"Thread panicked\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "struct Verifier;\nimpl Verifier {\n    pub fn check(msg: &[u8], pub_key: &[u8], signature: &[u8]) -> bool {\n        if signature.len() != 65 {\n            return false;\n        }\n        if signature[0] != 0x01 {\n            return false;\n        }\n        if signature[1..].iter().any(|&b| b == 0) {\n            return false;\n        }\n        true\n    }\n}\nfn main() {\n    let message = b\"Important confidential message\";\n    let public_key = [0u8; 32];\n    let mut signature = [1u8; 65];\n    signature[0] = 0x01;\n    if Verifier::check(message, &public_key, &signature) {\n        println!(\"Signature verified (fixed).\");\n    } else {\n        println!(\"Signature failed (fixed).\");\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\ntrait CryptoCheck {\n    fn verify(&self, message: &[u8], signature: &[u8]) -> bool;\n}\nstruct Worker {\n    algorithm: u8, \n}\nimpl Worker {\n    fn expected_signature(&self, message: &[u8]) -> Vec<u8> {\n         message.iter().rev().cloned().collect()\n    }\n}\nimpl CryptoCheck for Worker {\n    fn verify(&self, message: &[u8], signature: &[u8]) -> bool {\n         if self.algorithm != 1 {\n             return false;\n         }\n         let expected = self.expected_signature(message);\n         expected == signature\n    }\n}\nfn run(checker: &dyn CryptoCheck, data: &[u8], sig: &[u8]) -> bool {\n    checker.verify(data, sig)\n}\nfn main() {\n    let worker = Worker { algorithm: 1 };\n    let data = b\"Important message\";\n    let valid_sig = data.iter().rev().cloned().collect::<Vec<u8>>();\n    if run(&worker, data, &valid_sig) {\n         println!(\"Message accepted\");\n    } else {\n         println!(\"Signature verification failed\");\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Packet {\n    data: Vec<u8>,\n    sig: Vec<u8>,\n}\nimpl Packet {\n    fn check(&self) -> bool {\n         if self.sig.len() != 64 {\n             return false;\n         }\n         let expected = compute_signature(&self.data);\n         expected == self.sig\n    }\n}\nfn compute_signature(input: &[u8]) -> Vec<u8> {\n    let mut result = vec![0u8; 64];\n    let hash = simple_hash(input);\n    for i in 0..64 {\n         result[i] = hash[i % hash.len()];\n    }\n    result\n}\nfn simple_hash(data: &[u8]) -> Vec<u8> {\n    let mut hash = [0u8; 32];\n    for (i, &b) in data.iter().enumerate() {\n         hash[i % 32] ^= b;\n    }\n    hash.to_vec()\n}\nfn main() {\n    let pkg = Arc::new(Packet {\n         data: b\"Example message\".to_vec(),\n         sig: compute_signature(b\"Example message\"),\n    });\n    let pkg2 = Arc::clone(&pkg);\n    let handle = thread::spawn(move || {\n         if !pkg2.check() {\n             panic!(\"Signature verification failed!\");\n         }\n    });\n    handle.join().unwrap();\n    println!(\"Processing complete\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\n#[derive(Clone)]\nstruct Verifier;\nimpl Verifier {\n    pub fn validate(&self, message: &str, signature: &[u8], domain: &str) -> bool {\n        if domain != \"expected_domain\" {\n            return false;\n        }\n        if signature.len() != 14 {\n            return false;\n        }\n        true\n    }\n}\nfn process(arc_verifier: Arc<Verifier>, msg: &'static str, sig: &'static [u8], dom: &'static str) -> bool {\n    arc_verifier.validate(msg, sig, dom)\n}\nfn main() {\n    let verifier = Arc::new(Verifier);\n    let message = \"Important message\";\n    let signature = b\"valid_signatur\"; \n    let domain = \"expected_domain\";\n    let handles: Vec<_> = (0..4).map(|_| {\n        let verifier_c = Arc::clone(&verifier);\n        thread::spawn(move || {\n            process(verifier_c, message, signature, domain)\n        })\n    }).collect();\n    let results: Vec<_> = handles.into_iter().map(|h| h.join().unwrap()).collect();\n    for valid in results {\n        assert!(valid, \"Verification should succeed\");\n    }\n    println!(\"Verification passed\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::sync::{Arc, Mutex};\nstruct Message {\n    content: Vec<u8>,\n    algorithm: u8,\n    signature: Vec<u8>,\n}\nimpl Message {\n    fn process(&self) -> bool {\n        secure_verify(self)\n    }\n}\nfn secure_verify(msg: &Message) -> bool {\n    if msg.algorithm != 0 {\n        return false;\n    }\n    if msg.signature.len() != 64 || msg.content.is_empty() {\n        return false;\n    }\n    msg.signature[0] == 1\n}\nfn main() {\n    let msg = Message {\n        content: b\"Important message\".to_vec(),\n        algorithm: 0, \n        signature: {\n            let mut sig = vec![1; 64]; \n            sig\n        },\n    };\n    let result = msg.process();\n    println!(\"Processing result: {}\", result);\n    if !result {\n        std::process::exit(1);\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\npub struct CryptoTool {\n    expected_algo: &'static str,\n}\nimpl CryptoTool {\n    pub fn new() -> Self {\n        CryptoTool {\n            expected_algo: \"ed25519\",\n        }\n    }\n    pub unsafe fn verify_signature(&self, msg: &[u8], sig: &[u8], algo: &str) -> bool {\n        if algo != self.expected_algo {\n            return false;\n        }\n        sig.len() == msg.len()\n    }\n}\nfn main() {\n    let tool = CryptoTool::new();\n    let message = b\"Hello, secure world!\";\n    let signature = vec![0u8; message.len()];\n    let algo = \"rsa\";\n    let verified = unsafe { tool.verify_signature(message, &signature, algo) };\n    if verified {\n        println!(\"Signature verified.\");\n    } else {\n        println!(\"Signature verification failed.\");\n    }\n    let arc_tool = Arc::new(tool);\n    let mut handles = vec![];\n    for _ in 0..2 {\n        let tool_clone = Arc::clone(&arc_tool);\n        let msg = message.clone();\n        let sig = signature.clone();\n        let algo = algo.to_string();\n        handles.push(thread::spawn(move || {\n            unsafe {\n                if tool_clone.verify_signature(&msg, &sig, &algo) {\n                    println!(\"Thread: Verified\");\n                } else {\n                    println!(\"Thread: Verification failed\");\n                }\n            }\n        }));\n    }\n    for h in handles {\n        h.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nuse std::sync::Arc;\nstruct Validator {\n    pub pubkey: Arc<Vec<u8>>,\n}\nimpl Validator {\n    fn process_message(&self, message: &[u8], signature: &[u8]) -> bool {\n        let _key = self.pubkey.clone();\n        let msg = message.to_vec();\n        let sig = signature.to_vec();\n        let handle = thread::spawn(move || {\n            if sig == b\"VALID_SIGNATURE\" && msg.starts_with(b\"Attack\") {\n                true\n            } else {\n                false\n            }\n        });\n        match handle.join() {\n            Ok(result) => result,\n            Err(_) => false,\n        }\n    }\n}\nfn main() {\n    let pubkey = Arc::new(vec![1, 2, 3, 4]);\n    let validator = Validator { pubkey };\n    let message = b\"Attack at dawn\";\n    let signature = b\"fake_signature\"; \n    if validator.process_message(message, signature) {\n        println!(\"Signature accepted (fixed path).\");\n    } else {\n        println!(\"Signature rejected (fixed path).\");\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nconst DOMAIN: &[u8] = b\"DOC\"; \nstruct Record {\n    content: String,\n    signature: [u8; 32],\n}\nimpl Record {\n    fn compute_expectation(&self, key: &[u8; 32]) -> [u8; 32] {\n        let mut outcome = [0u8; 32];\n        let bytes = self.content.as_bytes();\n        for i in 0..32 {\n            let domain_byte = DOMAIN[i % DOMAIN.len()];\n            let content_byte = bytes[i % bytes.len()];\n            outcome[i] = content_byte ^ key[i] ^ domain_byte;\n        }\n        outcome\n    }\n    fn verify(&self, key: &[u8; 32]) -> bool {\n        let expected = self.compute_expectation(key);\n        expected == self.signature\n    }\n}\nfn main() {\n    let public_key: [u8; 32] = [0xAB; 32];\n    let content = String::from(\"Attack\");\n    let mut forged_signature = [0u8; 32];\n    {\n        let bytes = content.as_bytes();\n        for i in 0..32 {\n            forged_signature[i] = bytes[i % bytes.len()] ^ public_key[i];\n        }\n    }\n    let record = Record {\n        content,\n        signature: forged_signature,\n    };\n    let handle = thread::spawn(move || {\n        if record.verify(&public_key) {\n            println!(\"Verification succeeded\");\n        } else {\n            println!(\"Verification failed\");\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::convert::TryInto;\nuse std::sync::Arc;\nuse std::thread;\nstruct DataPacket {\n    message: Vec<u8>,\n    signature: Vec<u8>,\n}\nfn compute_hash(message: &[u8]) -> u64 {\n    let mut hash = 0u64;\n    for &b in message {\n        hash = hash.wrapping_add(b as u64);\n        hash = hash.rotate_left(3);\n    }\n    hash\n}\nimpl DataPacket {\n    pub fn proper_validate(&self) -> bool {\n        if self.signature.len() != 8 {\n            return false;\n        }\n        let expected = compute_hash(&self.message);\n        let sig_bytes: [u8; 8] = match self.signature[..8].try_into() {\n            Ok(arr) => arr,\n            Err(_) => return false,\n        };\n        let sig_val = u64::from_le_bytes(sig_bytes);\n        expected == sig_val\n    }\n}\nfn verify_logic(packet: &DataPacket) -> bool {\n    packet.proper_validate()\n}\nfn main() {\n    let message = b\"Important data\".to_vec();\n    let valid_signature = compute_hash(&message).to_le_bytes().to_vec();\n    let packet = Arc::new(DataPacket {\n        message,\n        signature: valid_signature,\n    });\n    let mut threads = vec![];\n    for _ in 0..4 {\n        let pkt = Arc::clone(&packet);\n        threads.push(thread::spawn(move || {\n            if verify_logic(&pkt) {\n                println!(\"Verification accepted\");\n            } else {\n                println!(\"Verification rejected\");\n            }\n        }));\n    }\n    for th in threads {\n        th.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\nuse std::sync::Arc;\nuse std::thread;\nstruct Packet {\n    message: Vec<u8>,\n    signature: [u8; 64],\n    algorithm: String,\n}\nstruct CryptoHandler;\nimpl CryptoHandler {\n    fn proper_verify(sig: &[u8; 64], msg: &[u8]) -> bool {\n        let key = 0xABu8;\n        let mut computed = [0u8; 64];\n        for i in 0..64 {\n            computed[i] = msg[i % msg.len()] ^ key;\n        }\n        computed.iter().zip(sig.iter()).fold(0, |acc, (a, b)| acc | (a ^ b)) == 0\n    }\n    fn verify(&self, packet: &Packet) -> bool {\n        if packet.algorithm != \"ed25519\" {\n            return false;\n        }\n        CryptoHandler::proper_verify(&packet.signature, &packet.message)\n    }\n}\nfn main() {\n    let handler = Arc::new(CryptoHandler);\n    let msg = b\"Test message\".to_vec();\n    let key = 0xABu8;\n    let mut sign: [u8; 64] = [0u8; 64];\n    for i in 0..64 {\n        sign[i] = msg[i % msg.len()] ^ key;\n    }\n    let packet = Packet {\n        message: msg,\n        signature: sign,\n        algorithm: \"ed25519\".to_string(),\n    };\n    let handler_clone = Arc::clone(&handler);\n    let pkt = packet;\n    let handle = thread::spawn(move || {\n        let res = handler_clone.verify(&pkt);\n        if res {\n            println!(\"Signature Verified!\");\n        } else {\n            println!(\"Signature Rejected!\");\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Checker {\n    pubkey: Vec<u8>,\n}\nimpl Checker {\n    fn new(pubkey: Vec<u8>) -> Self {\n        Checker { pubkey }\n    }\n    fn derive(&self, message: &[u8]) -> Vec<u8> {\n        let total: u32 = message.iter().chain(self.pubkey.iter())\n                                .map(|&b| b as u32)\n                                .sum();\n        vec![(total % 256) as u8]\n    }\n    fn check(&self, message: &[u8], signature: &[u8]) -> bool {\n        let expected = self.derive(message);\n        expected == signature\n    }\n}\nfn run(checker: Arc<Mutex<Checker>>, message: Vec<u8>, signature: Vec<u8>) -> bool {\n    let guard = checker.lock().unwrap();\n    guard.check(&message, &signature)\n}\nfn main() {\n    let pubkey = vec![1, 2, 3, 4, 5];\n    let checker = Arc::new(Mutex::new(Checker::new(pubkey)));\n    let message = vec![10, 20, 30];\n    let proper_signature = {\n        let guard = checker.lock().unwrap();\n        guard.derive(&message)\n    };\n    let mut threads = vec![];\n    for _ in 0..4 {\n        let chk = Arc::clone(&checker);\n        let msg = message.clone();\n        let sig = proper_signature.clone();\n        let handle = thread::spawn(move || {\n            run(chk, msg, sig)\n        });\n        threads.push(handle);\n    }\n    for handle in threads {\n        let result = handle.join().unwrap();\n        println!(\"Authentication result: {}\", result);\n        assert!(result, \"Authentication should pass with a valid signature.\");\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Container {\n    inner: Vec<u8>,\n}\nimpl Container {\n    fn new(data: &[u8]) -> Self {\n        Self { inner: data.to_vec() }\n    }\n}\nunsafe fn confirm_signature(sig: &[u8], _data: &[u8]) -> bool {\n    let expected: [u8; 64] = [0xAA; 64];\n    if sig.len() != expected.len() {\n        return false;\n    }\n    let sig_slice = std::slice::from_raw_parts(sig.as_ptr(), sig.len());\n    sig_slice == expected\n}\nfn perform_check(data: &[u8], sig: &[u8]) -> bool {\n    unsafe { confirm_signature(sig, data) }\n}\nfn process_request(data: &[u8], sig: &[u8]) -> bool {\n    let valid = perform_check(data, sig);\n    if !valid {\n        return false;\n    }\n    let shared = Arc::new(Mutex::new(data.to_vec()));\n    let handle = {\n        let shared = Arc::clone(&shared);\n        thread::spawn(move || {\n            let mut guard = shared.lock().unwrap();\n            unsafe {\n                guard.as_mut_ptr().write_bytes(0xFF, guard.len());\n            }\n        })\n    };\n    handle.join().unwrap();\n    true\n}\npub fn main() {\n    let msg = b\"Example message for processing\";\n    let sig = vec![0xAA; 64];\n    if process_request(msg, &sig) {\n        println!(\"Operation succeeded.\");\n    } else {\n        println!(\"Operation failed.\");\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Crypto {\n    secret: Vec<u8>,\n}\nimpl Crypto {\n    fn compute_signature(&self, data: &[u8]) -> Vec<u8> {\n         let mut sig = Vec::with_capacity(data.len());\n         for (i, &b) in data.iter().enumerate() {\n              sig.push(b ^ self.secret[i % self.secret.len()]);\n         }\n         sig\n    }\n    fn check_sig(&self, data: &[u8], signature: &[u8]) -> bool {\n         let expected = self.compute_signature(data);\n         expected == signature\n    }\n}\nstruct Authenticator {\n    crypto: Arc<Mutex<Crypto>>,\n}\nimpl Authenticator {\n    fn new(secret: Vec<u8>) -> Self {\n         Authenticator {\n             crypto: Arc::new(Mutex::new(Crypto { secret })),\n         }\n    }\n    fn attempt(&self, data: Vec<u8>, signature: Vec<u8>) -> bool {\n         let crypto_arc = Arc::clone(&self.crypto);\n         let handle = thread::spawn(move || {\n              let guard = crypto_arc.lock().unwrap();\n              guard.check_sig(&data, &signature)\n         });\n         handle.join().unwrap()\n    }\n}\nfn main() {\n    let secret = vec![0xAA, 0xBB, 0xCC];\n    let auth = Authenticator::new(secret.clone());\n    let data = b\"test message\".to_vec();\n    let proper_signature = {\n         let crypto = Crypto { secret };\n         crypto.compute_signature(&data)\n    };\n    let result = auth.attempt(data, proper_signature);\n    println!(\"Authentication result: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct SecureMessage {\n    body: Vec<u8>,\n    sig: Vec<u8>,\n    context: String,\n}\nimpl SecureMessage {\n    fn new(body: Vec<u8>, sig: Vec<u8>, context: String) -> Self {\n        SecureMessage { body, sig, context }\n    }\n}\nfn simple_hash(data: &[u8]) -> u8 {\n    data.iter().fold(0, |acc, &b| acc.wrapping_add(b))\n}\nfn compute_signature(body: &[u8], context: &str) -> Vec<u8> {\n    let mut sig = vec![0u8; 64];\n    let combined: Vec<u8> = body.iter().cloned().chain(context.as_bytes().iter().cloned()).collect();\n    let hash = simple_hash(&combined);\n    for i in 0..64 {\n        sig[i] = hash.wrapping_add(i as u8);\n    }\n    sig\n}\nfn constant_time_eq(a: &[u8], b: &[u8]) -> bool {\n    if a.len() != b.len() {\n        return false;\n    }\n    let mut result = 0u8;\n    for (&x, &y) in a.iter().zip(b.iter()) {\n        result |= x ^ y;\n    }\n    result == 0\n}\nfn verify_message(msg: &SecureMessage) -> bool {\n    if msg.sig.len() != 64 || msg.context != \"trusted_context\" {\n        return false;\n    }\n    let expected = compute_signature(&msg.body, &msg.context);\n    constant_time_eq(&msg.sig, &expected)\n}\nfn run() {\n    let body = vec![1, 2, 3];\n    let trusted_context = \"trusted_context\".to_owned();\n    let sig = compute_signature(&body, &trusted_context);\n    let msg = Arc::new(SecureMessage::new(body, sig, trusted_context));\n    let handles: Vec<_> = (0..4)\n        .map(|_| {\n            let msg_clone = Arc::clone(&msg);\n            thread::spawn(move || {\n                let res = verify_message(&msg_clone);\n                println!(\"Verification result: {}\", res);\n            })\n        })\n        .collect();\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\nfn main() {\n    run();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nconst EXPECTED_SIG: [u8; 64] = [1; 64];\nstruct Data {\n    content: Vec<u8>,\n    signature: Vec<u8>,\n}\nimpl Data {\n    fn new(content: Vec<u8>, signature: Vec<u8>) -> Self {\n        Data { content, signature }\n    }\n}\nfn verify(doc: &Data) -> bool {\n    if doc.signature.len() != 64 {\n        return false;\n    }\n    unsafe {\n        let sig_ptr = doc.signature.as_ptr() as *const [u8; 64];\n        let sig_ref: &[u8; 64] = &*sig_ptr;\n        sig_ref == &EXPECTED_SIG\n    }\n}\nfn process(doc: Arc<Mutex<Data>>) -> bool {\n    let result = {\n        let d = doc.lock().unwrap();\n        verify(&d)\n    };\n    result\n}\nfn main() {\n    let good_sig = vec![1u8; 64];\n    let doc = Data::new(vec![0u8; 10], good_sig);\n    let shared = Arc::new(Mutex::new(doc));\n    let outcome = process(shared);\n    println!(\"Verification result: {}\", outcome);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nuse std::sync::atomic::{AtomicBool, Ordering};\nstruct CryptoEngine;\nimpl CryptoEngine {\n    pub fn compute_hash(msg: &[u8], pubkey: &[u8]) -> [u8; 32] {\n        let mut hash = [0u8; 32];\n        for (i, &b) in msg.iter().enumerate() {\n            hash[i % 32] = hash[i % 32].wrapping_add(b);\n        }\n        for (i, &b) in pubkey.iter().enumerate() {\n            hash[i % 32] = hash[i % 32].wrapping_add(b);\n        }\n        hash\n    }\n    pub fn check(msg: &[u8], sig: &[u8], pubkey: &[u8]) -> bool {\n        if sig.len() != 32 {\n            return false;\n        }\n        let expected = Self::compute_hash(msg, pubkey);\n        sig == expected\n    }\n}\nfn concurrent_check(msg: Arc<Vec<u8>>, sig: Arc<Vec<u8>>, pubkey: Arc<Vec<u8>>) -> bool {\n    let flag = Arc::new(AtomicBool::new(true));\n    let mut handles = vec![];\n    for _ in 0..4 {\n        let m = Arc::clone(&msg);\n        let s = Arc::clone(&sig);\n        let p = Arc::clone(&pubkey);\n        let f = Arc::clone(&flag);\n        handles.push(thread::spawn(move || {\n            let res = CryptoEngine::check(&m, &s, &p);\n            if !res {\n                f.store(false, Ordering::Relaxed);\n            }\n        }));\n    }\n    for h in handles {\n        h.join().unwrap();\n    }\n    flag.load(Ordering::Relaxed)\n}\nfn main() {\n    let message = b\"Real message\".to_vec();\n    let pubkey = b\"PublicKeyDataForVerification\".to_vec();\n    let expected = CryptoEngine::compute_hash(&message, &pubkey);\n    let signature = expected.to_vec(); \n    let valid = concurrent_check(Arc::new(message), Arc::new(signature), Arc::new(pubkey));\n    println!(\"Verification result: {}\", valid);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\n#[derive(Clone, Copy, Debug, PartialEq)]\nenum Access {\n    Allowed,\n    Blocked,\n}\nstruct Handler {\n    flag: Arc<Mutex<Access>>,\n}\nimpl Handler {\n    fn new() -> Self {\n        Handler {\n            flag: Arc::new(Mutex::new(Access::Blocked)),\n        }\n    }\n    fn update(&self, input: i32) {\n        unsafe {\n            let new_state = match input > 100 {\n                true => Access::Allowed,\n                false => Access::Blocked,\n            };\n            let mut current = self.flag.lock().unwrap();\n            *current = new_state;\n        }\n    }\n    fn check(&self) -> bool {\n        let current = self.flag.lock().unwrap();\n        match *current {\n            Access::Allowed => true,\n            Access::Blocked => false,\n        }\n    }\n}\nfn main() {\n    let handler = Handler::new();\n    let shared_handler = Arc::new(handler);\n    let mut handles = vec![];\n    for _ in 0..5 {\n        let clone = Arc::clone(&shared_handler);\n        let t = thread::spawn(move || {\n            clone.update(150);\n        });\n        handles.push(t);\n    }\n    for t in handles {\n        t.join().unwrap();\n    }\n    if shared_handler.check() {\n        println!(\"Access granted\");\n    } else {\n        println!(\"Access denied\");\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\nuse std::env;\nuse std::sync::{Arc, Mutex};\nstruct Service {\n    counter: Arc<Mutex<u32>>,\n}\nimpl Service {\n    fn new() -> Self {\n        Service {\n            counter: Arc::new(Mutex::new(0)),\n        }\n    }\n    fn process(&self, command: &str) -> Result<u32, &'static str> {\n        match command {\n            \"normal\" => {\n                let mut cnt = self.counter.lock().unwrap();\n                *cnt += 1;\n                Ok(*cnt)\n            },\n            \"danger\" => {\n                Err(\"Danger command not allowed\")\n            },\n            _ => Err(\"unsupported command\"),\n        }\n    }\n}\nfn main() {\n    let service = Service::new();\n    let args: Vec<String> = env::args().collect();\n    let input = if args.len() > 1 { &args[1] } else { \"normal\" };\n    match service.process(input) {\n        Ok(val) => println!(\"Result: {}\", val),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\ntype Operation = fn(i32) -> i32;\nfn sensitive(val: i32) -> i32 {\n    val * 10\n}\nfn nonsensitive(val: i32) -> i32 {\n    val + 5\n}\nstruct Dispatcher {\n    table: [Operation; 2],\n    safe_mode: bool,\n}\nimpl Dispatcher {\n    fn new(safe_mode: bool) -> Self {\n        Dispatcher {\n            table: [nonsensitive, sensitive],\n            safe_mode,\n        }\n    }\n    fn process(&self, input: i32) -> i32 {\n        if self.safe_mode {\n            self.table[0](input)\n        } else {\n            let index = if input % 2 == 0 { 0 } else { 1 };\n            self.table[index](input)\n        }\n    }\n}\nfn main() {\n    let dispatcher = Arc::new(Dispatcher::new(true));\n    let mut handles = vec![];\n    for _ in 0..4 {\n        let disp = Arc::clone(&dispatcher);\n        handles.push(thread::spawn(move || {\n            let result = disp.process(3);\n            println!(\"Outcome: {}\", result);\n        }));\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nenum Privilege {\n    Denied,\n    Granted,\n}\nstruct UserManager {\n    access: bool,\n}\nimpl UserManager {\n    fn new() -> Self {\n        UserManager { access: false }\n    }\n    fn evaluate(&mut self, user: &str) {\n        match user {\n            \"admin\" => {\n                self.access = true;\n            },\n            \"guest\" => {\n                self.access = false;\n            },\n            _ => {\n                self.access = false;\n            },\n        }\n    }\n    fn is_allowed(&self) -> bool {\n        self.access\n    }\n}\nfn main() {\n    let manager = Arc::new(Mutex::new(UserManager::new()));\n    let mgr_clone = Arc::clone(&manager);\n    let handle = thread::spawn(move || {\n        let mut mgr = mgr_clone.lock().unwrap();\n        mgr.evaluate(\"guest\");\n    });\n    handle.join().unwrap();\n    let mgr = manager.lock().unwrap();\n    if mgr.is_allowed() {\n        println!(\"Operation permitted\");\n    } else {\n        println!(\"Operation blocked\");\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct TaskManager {\n    tasks: Vec<i32>,\n}\nimpl TaskManager {\n    fn new(size: usize) -> Self {\n        TaskManager { tasks: vec![0; size] }\n    }\n    fn execute(&mut self, idx: usize, value: i32, perform: bool) -> Result<(), &'static str> {\n        if perform {\n            if idx < self.tasks.len() {\n                unsafe {\n                    let ptr = self.tasks.as_mut_ptr().add(idx);\n                    *ptr = value;\n                }\n                Ok(())\n            } else {\n                Err(\"index out of bounds\")\n            }\n        } else {\n            Ok(())\n        }\n    }\n    fn get_tasks(&self) -> &[i32] {\n        &self.tasks\n    }\n}\nfn main() {\n    let mgr = Arc::new(Mutex::new(TaskManager::new(3)));\n    let mut handles = vec![];\n    {\n        let mgr_clone = Arc::clone(&mgr);\n        handles.push(thread::spawn(move || {\n            let mut mgr = mgr_clone.lock().unwrap();\n            mgr.execute(0, 100, false).unwrap();\n        }));\n    }\n    {\n        let mgr_clone = Arc::clone(&mgr);\n        handles.push(thread::spawn(move || {\n            let mut mgr = mgr_clone.lock().unwrap();\n            mgr.execute(0, 200, true).unwrap();\n        }));\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    let mgr = mgr.lock().unwrap();\n    println!(\"Tasks: {:?}\", mgr.get_tasks());\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nstruct Engine {\n    flag: Arc<Mutex<u32>>,\n}\nimpl Engine {\n    fn new() -> Self {\n        Engine { flag: Arc::new(Mutex::new(0)) }\n    }\n    fn process(&self, val: u32) -> Result<u32, &'static str> {\n        match val {\n            1 => {\n                let mut cnt = self.flag.lock().map_err(|_| \"mutex poisoned\")?;\n                *cnt += 5;\n                Ok(*cnt)\n            }\n            2 => {\n                let mut cnt = self.flag.lock().map_err(|_| \"mutex poisoned\")?;\n                *cnt += 10;\n                Ok(*cnt)\n            }\n            _ => Err(\"Invalid input\"),\n        }\n    }\n}\nfn main() {\n    let core = Engine::new();\n    match core.process(1) {\n        Ok(res) => println!(\"Outcome: {}\", res),\n        Err(err) => eprintln!(\"Error: {}\", err),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\npub struct Executor {\n    pub special: bool,\n    pub value: i32,\n}\nimpl Executor {\n    pub fn process_input(&mut self, input: i32) -> i32 {\n        unsafe {\n            let p = &mut self.value as *mut i32;\n            match self.special {\n                true => {\n                    *p = input + 50;\n                },\n                false => {\n                    *p = input * 2;\n                }\n            }\n            *p\n        }\n    }\n}\nfn main() {\n    let executor = Arc::new(Mutex::new(Executor { special: true, value: 0 }));\n    let mut handles = Vec::new();\n    for i in 1..=4 {\n        let exec_clone = Arc::clone(&executor);\n        handles.push(thread::spawn(move || {\n            let mut guard = exec_clone.lock().unwrap();\n            guard.process_input(i)\n        }));\n    }\n    for handle in handles {\n        let _ = handle.join().unwrap();\n    }\n    let final_val = executor.lock().unwrap().value;\n    println!(\"Final value: {}\", final_val);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Coordinator {\n    state: Arc<Mutex<u32>>,\n}\nimpl Coordinator {\n    fn new() -> Self {\n        Coordinator {\n            state: Arc::new(Mutex::new(0)),\n        }\n    }\n    fn update_state(&self, code: u32) -> Result<(), &'static str> {\n        let state_clone = Arc::clone(&self.state);\n        let handle = thread::spawn(move || {\n            let mut data = state_clone.lock().unwrap();\n            unsafe {\n                match code {\n                    42 => {\n                        *data = 99;\n                        return Ok(());\n                    },\n                    _ => {\n                        return Err(\"invalid code\");\n                    },\n                }\n            }\n        });\n        handle.join().unwrap()\n    }\n    fn read_state(&self) -> u32 {\n        *self.state.lock().unwrap()\n    }\n}\nfn main() {\n    let app = Coordinator::new();\n    let result = app.update_state(42);\n    match result {\n        Ok(()) => println!(\"Success, state is {}\", app.read_state()),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n#[derive(Debug, PartialEq, Clone)]\nenum Phase {\n    Pending,\n    Running,\n    Completed,\n}\nstruct Controller {\n    state: Arc<Mutex<Phase>>,\n}\nimpl Controller {\n    fn new() -> Self {\n        Controller {\n            state: Arc::new(Mutex::new(Phase::Pending)),\n        }\n    }\n    fn process(&self, cmd: &str) -> bool {\n        let cur = { self.state.lock().unwrap().clone() };\n        match cur {\n            Phase::Pending => {\n                if cmd == \"start\" {\n                    let mut guard = self.state.lock().unwrap();\n                    *guard = Phase::Running;\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n            Phase::Running => {\n                let mut guard = self.state.lock().unwrap();\n                *guard = Phase::Completed;\n                return true;\n            }\n            Phase::Completed => {\n                return false;\n            }\n        }\n    }\n}\nfn main() {\n    let ctrl = Controller::new();\n    let state_handle = ctrl.state.clone();\n    thread::spawn(move || {\n        thread::sleep(Duration::from_millis(10));\n        let mut s = state_handle.lock().unwrap();\n        if *s == Phase::Pending {\n            *s = Phase::Running;\n        }\n    })\n    .join()\n    .unwrap();\n    let outcome = ctrl.process(\"start\");\n    println!(\"Outcome: {}\", outcome);\n    println!(\"Final state: {:?}\", ctrl.state.lock().unwrap());\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::ptr;\n#[derive(Debug, PartialEq)]\nenum State {\n    Init,\n    Running,\n    Completed,\n}\nstruct Processor {\n    state: Arc<Mutex<State>>,\n}\nimpl Processor {\n    fn new() -> Self {\n        Processor {\n            state: Arc::new(Mutex::new(State::Init)),\n        }\n    }\n    fn process(&self, input: i32) -> bool {\n        let state_handle = Arc::clone(&self.state);\n        let handle = thread::spawn(move || {\n            unsafe {\n                let raw_ptr: *mut State = &mut *state_handle.lock().unwrap() as *mut State;\n                if input > 0 {\n                    match *raw_ptr {\n                        State::Init => {\n                            *raw_ptr = State::Running;\n                        },\n                        _ => {\n                        },\n                    }\n                } else {\n                    *raw_ptr = State::Completed;\n                }\n            }\n        });\n        handle.join().unwrap();\n        let current = self.state.lock().unwrap();\n        *current == State::Running\n    }\n}\nfn main() {\n    let proc_inst = Processor::new();\n    let outcome = proc_inst.process(10);\n    println!(\"Processing outcome: {}\", outcome);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\n#[derive(Debug, PartialEq, Clone)]\nenum Mode {\n    Active,\n    Inactive,\n}\nstruct Processor {\n    state: Arc<Mutex<Mode>>,\n}\nimpl Processor {\n    fn new() -> Self {\n        Processor {\n            state: Arc::new(Mutex::new(Mode::Inactive)),\n        }\n    }\n    fn update(&self, cond: bool) -> u32 {\n        let mut st = self.state.lock().unwrap();\n        if cond {\n            *st = Mode::Active; \n            100\n        } else {\n            *st = Mode::Inactive; \n            200\n        }\n    }\n    fn get_state(&self) -> Mode {\n        let st = self.state.lock().unwrap();\n        (*st).clone()\n    }\n    fn run(&self, cond: bool) -> u32 {\n        self.update(cond)\n    }\n}\nfn main() {\n    let proc = Processor::new();\n    let proc_clone = proc.state.clone();\n    let handle = thread::spawn(move || {\n        let mut st = proc_clone.lock().unwrap();\n        *st = Mode::Active;\n    });\n    handle.join().unwrap();\n    let result = proc.run(true);\n    println!(\"Result: {}\", result);\n    println!(\"State: {:?}\", proc.get_state());\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Processor {\n    threshold: i32,\n}\nimpl Processor {\n    fn new(threshold: i32) -> Self {\n        Processor { threshold }\n    }\n    fn validate(&self, input: i32) -> bool {\n        let mut allowed = false;\n        unsafe {\n            let dummy = 1;\n            let p = &dummy as *const i32;\n            let _temp = *p;\n            match input {\n                n if n >= self.threshold => allowed = true,\n                _ => allowed = false,\n            }\n        }\n        allowed\n    }\n    fn process(&self, input: i32) -> Result<String, &'static str> {\n        if self.validate(input) {\n            Ok(format!(\"Processed value: {}\", input))\n        } else {\n            Err(\"Access Denied\")\n        }\n    }\n}\npub fn main() {\n    let proc = Arc::new(Mutex::new(Processor::new(50)));\n    let proc_clone = proc.clone();\n    let handle = thread::spawn(move || {\n        let p = proc_clone.lock().unwrap();\n        p.process(20)\n    });\n    let result = handle.join().unwrap();\n    match result {\n        Ok(msg) => println!(\"{}\", msg),\n        Err(err) => println!(\"Error: {}\", err),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\n#[derive(Clone, Copy, Debug, PartialEq)]\nenum Level {\n    High,\n    Low,\n}\ntrait Compute {\n    fn run(&self) -> i32;\n}\nstruct Task {\n    num: i32,\n    lev: Level,\n}\nimpl Compute for Task {\n    fn run(&self) -> i32 {\n        unsafe {\n            let ptr = &self.num as *const i32;\n            let value = *ptr;\n            match self.lev {\n                Level::High => {\n                    return value.wrapping_mul(2);\n                }\n                Level::Low => {\n                    return value + 5;\n                }\n            }\n        }\n    }\n}\npub fn execute_tasks() -> Vec<i32> {\n    let tasks = Arc::new(Mutex::new(vec![\n        Task { num: 20, lev: Level::High }, \n        Task { num: 10, lev: Level::Low },  \n    ]));\n    let mut handles = vec![];\n    for _ in 0..2 {\n        let tasks_cloned = Arc::clone(&tasks);\n        let handle = thread::spawn(move || {\n            let mut results = Vec::new();\n            let jobs = tasks_cloned.lock().unwrap();\n            for job in jobs.iter() {\n                results.push(job.run());\n            }\n            results\n        });\n        handles.push(handle);\n    }\n    let mut final_results = Vec::new();\n    for handle in handles {\n        let thread_results = handle.join().unwrap();\n        final_results.extend(thread_results);\n    }\n    final_results\n}\nfn main() {\n    let output = execute_tasks();\n    println!(\"Output: {:?}\", output);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\n#[derive(Debug, PartialEq)]\nenum Mode {\n    Idle,\n    Active,\n}\nstruct Controller {\n    mode: Mode,\n}\nimpl Controller {\n    fn new() -> Controller {\n        Controller { mode: Mode::Idle }\n    }\n    fn update(&mut self, trigger: bool) -> bool {\n        unsafe {\n            match self.mode {\n                Mode::Idle if trigger => {\n                    self.mode = Mode::Active;\n                    true\n                }\n                Mode::Active if !trigger => {\n                    self.mode = Mode::Idle;\n                    false\n                }\n                _ => false,\n            }\n        }\n    }\n}\nfn main() {\n    let controller = Arc::new(Mutex::new(Controller::new()));\n    let ctrl_clone = Arc::clone(&controller);\n    let handle = thread::spawn(move || {\n        let mut ctrl = ctrl_clone.lock().unwrap();\n        let result = ctrl.update(true);\n        if result {\n            println!(\"Transition succeeded\");\n        } else {\n            println!(\"Transition failed\");\n        }\n    });\n    handle.join().unwrap();\n    let ctrl_final = controller.lock().unwrap();\n    if ctrl_final.mode == Mode::Active {\n        println!(\"State is active\");\n    } else {\n        println!(\"State is idle\");\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Processor;\nimpl Processor {\n    fn verify(&self, token: &str) -> bool {\n        match token {\n            \"admin\" => true,\n            _ => false,\n        }\n    }\n    unsafe fn get_value(&self) -> i32 {\n        1337\n    }\n    fn process(&self, token: &str) -> i32 {\n        if self.verify(token) {\n            unsafe { self.get_value() }\n        } else {\n            0\n        }\n    }\n}\nfn main() {\n    let proc = Arc::new(Mutex::new(Processor));\n    let tokens = vec![\"admin\", \"user\"];\n    let mut handles = vec![];\n    for tok in tokens {\n        let proc_clone = Arc::clone(&proc);\n        let token = tok.to_owned();\n        handles.push(thread::spawn(move || {\n            let processor = proc_clone.lock().unwrap();\n            processor.process(&token)\n        }));\n    }\n    for handle in handles {\n        let result = handle.join().unwrap();\n        println!(\"Result: {}\", result);\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Controller {\n    counter: Arc<Mutex<i32>>,\n}\nimpl Controller {\n    fn new(initial: i32) -> Self {\n        Controller {\n            counter: Arc::new(Mutex::new(initial)),\n        }\n    }\n    fn update(&self, adjustment: i32) -> Result<i32, &'static str> {\n        let shared = Arc::clone(&self.counter);\n        let handle = thread::spawn(move || {\n            let mut num = shared.lock().unwrap();\n            unsafe {\n                *num = num.wrapping_add(adjustment);\n            }\n        });\n        handle.join().unwrap();\n        let current = *self.counter.lock().unwrap();\n        if current >= 0 {\n            Ok(current)\n        } else {\n            Err(\"Invalid state: negative counter\")\n        }\n    }\n}\nfn main() {\n    let controller = Controller::new(1);\n    match controller.update(10) {\n        Ok(result) => println!(\"Result: {}\", result),\n        Err(err) => println!(\"Error: {}\", err),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Controller {\n    flag: bool,\n    counter: i32,\n}\nimpl Controller {\n    pub fn new() -> Self {\n        Controller { flag: true, counter: 0 }\n    }\n    pub fn update(&mut self) {\n        unsafe {\n            let flag_ptr: *mut bool = &mut self.flag;\n            if *flag_ptr {\n                self.counter = self.counter.wrapping_add(1);\n            } else {\n                self.counter = self.counter.wrapping_sub(1);\n            }\n            if self.counter < 0 {\n                *flag_ptr = false;\n            } else {\n                *flag_ptr = true;\n            }\n        }\n    }\n}\nfn main() {\n    let controller = Arc::new(Mutex::new(Controller::new()));\n    let mut handles = vec![];\n    for _ in 0..10 {\n        let ctrl = Arc::clone(&controller);\n        let handle = thread::spawn(move || {\n            for _ in 0..100 {\n                let mut c = ctrl.lock().unwrap();\n                c.update();\n            }\n        });\n        handles.push(handle);\n    }\n    for h in handles {\n        h.join().unwrap();\n    }\n    let c = controller.lock().unwrap();\n    println!(\"Final counter: {}, flag: {}\", c.counter, c.flag);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct App {\n    flag: bool,\n    data: Vec<i32>,\n}\nimpl App {\n    fn new(flag: bool) -> Self {\n        Self { flag, data: vec![10, 20, 30, 40, 50] }\n    }\n    fn process(&self, idx: usize) -> Result<i32, &'static str> {\n        if self.flag {\n            self.data.get(idx).copied().ok_or(\"Index out of bounds\")\n        } else {\n            self.data.get(idx).copied().ok_or(\"Index out of bounds\")\n        }\n    }\n}\nfn main() {\n    let app = Arc::new(App::new(true));\n    let app_clone = Arc::clone(&app);\n    let handle = thread::spawn(move || {\n        match app_clone.process(0) {\n            Ok(val) => println!(\"Output: {}\", val),\n            Err(e) => println!(\"Error: {}\", e),\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\nstruct Regulator {\n    op: Mutex<fn(i32) -> i32>,\n}\nimpl Regulator {\n    fn new() -> Self {\n        Regulator { op: Mutex::new(approved) }\n    }\n    fn update(&self, new_op: fn(i32) -> i32, token: &str) {\n        if token == \"secret_token\" {\n            let mut op_guard = self.op.lock().unwrap();\n            *op_guard = new_op;\n        }\n    }\n    fn execute(&self, input: i32) -> i32 {\n        let op_guard = self.op.lock().unwrap();\n        op_guard(input)\n    }\n}\nfn approved(x: i32) -> i32 {\n    x * 2\n}\nfn diverted(x: i32) -> i32 {\n    x * 10\n}\nfn run_app() -> i32 {\n    let regulator = Arc::new(Regulator::new());\n    let reg_clone = Arc::clone(&regulator);\n    let handler = thread::spawn(move || {\n        reg_clone.update(diverted, \"wrong_token\");\n    });\n    let _ = handler.join();\n    let result = regulator.execute(5);\n    result\n}\nfn main() {\n    let res = run_app();\n    println!(\"Computed value: {}\", res);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct DataProcessor {\n    threshold: u32,\n    data: Vec<u32>,\n}\nimpl DataProcessor {\n    fn new(threshold: u32, data: Vec<u32>) -> Self {\n        Self { threshold, data }\n    }\n    fn calculate(&self, index: u32) -> Option<u32> {\n        if index < self.threshold {\n            return None;\n        }\n        self.data.get(index as usize).copied()\n    }\n}\nfn main() {\n    let processor = Arc::new(Mutex::new(DataProcessor::new(10, vec![10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110])));\n    let mut handles = vec![];\n    for i in 0..5 {\n        let proc_clone = Arc::clone(&processor);\n        handles.push(thread::spawn(move || {\n            let res = proc_clone.lock().unwrap().calculate(i);\n            println!(\"Thread {} got: {:?}\", i, res);\n        }));\n    }\n    for h in handles {\n        h.join().unwrap();\n    }\n    let result = processor.lock().unwrap().calculate(10);\n    println!(\"Main result: {:?}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::thread;\nstruct HttpMsg {\n    content_length: Option<usize>,\n    is_chunked: bool,\n    body: Vec<u8>,\n}\nimpl HttpMsg {\n    unsafe fn process(&self) -> Vec<u8> {\n        if self.is_chunked {\n            self.body.clone()\n        } else if let Some(req_len) = self.content_length {\n            let actual_len = self.body.len();\n            let safe_len = if req_len > actual_len { actual_len } else { req_len };\n            let ptr_body = self.body.as_ptr();\n            let slice = std::slice::from_raw_parts(ptr_body, safe_len);\n            slice.to_vec()\n        } else {\n            self.body.clone()\n        }\n    }\n}\nfn parse_req(request: &str) -> HttpMsg {\n    let mut content_length = None;\n    let mut is_chunked = false;\n    let mut headers = HashMap::new();\n    let mut lines = request.lines();\n    let mut body = Vec::new();\n    for line in &mut lines {\n        if line.trim().is_empty() {\n            break;\n        }\n        if let Some((key, val)) = line.split_once(\":\") {\n            headers.insert(key.trim().to_lowercase(), val.trim().to_string());\n        }\n    }\n    if let Some(val) = headers.get(\"content-length\") {\n        if let Ok(num) = val.parse::<usize>() {\n            content_length = Some(num);\n        }\n    }\n    if let Some(te) = headers.get(\"transfer-encoding\") {\n        if te.to_lowercase().contains(\"chunked\") {\n            is_chunked = true;\n        }\n    }\n    for line in lines {\n        body.extend_from_slice(line.as_bytes());\n    }\n    HttpMsg { \n        content_length, \n        is_chunked, \n        body \n    }\n}\nfn main() {\n    let input = \"POST / HTTP/1.1\\r\\nContent-Length: 30\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\nThis is the request body\";\n    let req = parse_req(input);\n    let shared_req = Arc::new(req);\n    let worker = {\n        let req_clone = Arc::clone(&shared_req);\n        thread::spawn(move || {\n            unsafe {\n                let processed = req_clone.process();\n                println!(\"Processed output: {:?}\", String::from_utf8_lossy(&processed));\n            }\n        })\n    };\n    worker.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Request {\n    raw: String,\n}\nimpl Request {\n    fn parse_headers(&self) -> Option<usize> {\n        self.raw.find(\"\\r\\n\\r\\n\").map(|i| i + 4)\n    }\n    fn get_headers(&self) -> Option<&[u8]> {\n        let body_start = self.parse_headers()?;\n        Some(&self.raw.as_bytes()[..body_start])\n    }\n}\nfn process_request(request: &Request) -> bool {\n    if let Some(headers) = request.get_headers() {\n        let header_str = std::str::from_utf8(headers).unwrap_or(\"\");\n        if header_str.contains(\"X-Extra: exploit\") {\n            return false;\n        }\n        true\n    } else {\n        false\n    }\n}\nfn main() {\n    let attack_request = \"GET / HTTP/1.1\\r\\nContent-Length: 0\\r\\nX-Extra: exploit\\r\\n\\r\\nBODY\";\n    let _normal_request = \"GET / HTTP/1.1\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n    let req = Request {\n        raw: attack_request.to_owned(),\n    };\n    let shared = Arc::new(Mutex::new(req));\n    let mut handles = vec![];\n    for _ in 0..4 {\n        let shared_clone = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            let req = shared_clone.lock().unwrap();\n            process_request(&req)\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        let res = handle.join().unwrap();\n        if !res {\n            println!(\"Request rejected.\");\n            std::process::exit(1);\n        }\n    }\n    println!(\"Request processed safely.\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::thread;\nstruct Request {\n    method: String,\n    uri: String,\n    headers: HashMap<String, String>,\n    body: Vec<u8>,\n}\nfn parse_request(input: &str) -> Request {\n    let parts: Vec<&str> = input.split(\"\\r\\n\\r\\n\").collect();\n    let header_str = parts.get(0).unwrap_or(&\"\");\n    let mut headers = HashMap::new();\n    let mut lines = header_str.lines();\n    let request_line = lines.next().unwrap_or(\"\");\n    let req_parts: Vec<&str> = request_line.split_whitespace().collect();\n    let method = req_parts.get(0).unwrap_or(&\"\").to_string();\n    let uri = req_parts.get(1).unwrap_or(&\"\").to_string();\n    for line in lines {\n        if let Some((k, v)) = line.split_once(\":\") {\n            headers.insert(k.trim().to_string(), v.trim().to_string());\n        }\n    }\n    let body = if headers\n        .get(\"Transfer-Encoding\")\n        .map(|v| v.to_ascii_lowercase())\n        == Some(\"chunked\".to_string())\n    {\n        parse_chunked_body(parts.get(1).unwrap_or(&\"\"))\n    } else if let Some(cl) = headers.get(\"Content-Length\") {\n        let cl_val = cl.parse::<usize>().unwrap_or(0);\n        let b = parts.get(1).unwrap_or(&\"\").as_bytes();\n        b[..cl_val.min(b.len())].to_vec()\n    } else {\n        parts.get(1).unwrap_or(&\"\").as_bytes().to_vec()\n    };\n    Request { method, uri, headers, body }\n}\nfn parse_chunked_body(chunked: &str) -> Vec<u8> {\n    let mut body = Vec::new();\n    let mut lines = chunked.lines();\n    loop {\n        let line = match lines.next() {\n            Some(l) => l.trim(),\n            None => break,\n        };\n        let chunk_size = usize::from_str_radix(line, 16).unwrap_or(0);\n        if chunk_size == 0 {\n            break;\n        }\n        let mut remaining = chunk_size;\n        while remaining > 0 {\n            if let Some(data_line) = lines.next() {\n                let data_bytes = data_line.as_bytes();\n                let take = remaining.min(data_bytes.len());\n                body.extend_from_slice(&data_bytes[..take]);\n                remaining -= take;\n            } else {\n                break;\n            }\n        }\n    }\n    body\n}\nfn process_input(input: &str) -> Vec<u8> {\n    let req = parse_request(input);\n    req.body\n}\nfn main() {\n    let input = \"POST / HTTP/1.1\\r\\nHost: example.com\\r\\nContent-Length: 10\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n5\\r\\nHello\\r\\n0\\r\\n\\r\\nExtra\";\n    let t = thread::spawn(move || {\n        let result = process_input(input);\n        println!(\"Processed body: {:?}\", String::from_utf8_lossy(&result));\n    });\n    t.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::Arc;\nuse std::thread;\npub struct Request {\n    pub method: String,\n    pub uri: String,\n    pub version: String,\n    pub headers: HashMap<String, String>,\n    pub body: Vec<u8>,\n}\nimpl Request {\n    pub unsafe fn parse(raw: &str) -> Self {\n        let ptr = raw.as_ptr();\n        let len = raw.len();\n        let slice = std::slice::from_raw_parts(ptr, len);\n        let s = String::from_utf8_lossy(slice).to_string();\n        let mut lines = s.lines();\n        let request_line = lines.next().unwrap_or(\"\");\n        let mut parts = request_line.split_whitespace();\n        let method = parts.next().unwrap_or(\"\").to_string();\n        let uri = parts.next().unwrap_or(\"\").to_string();\n        let version = parts.next().unwrap_or(\"\").to_string();\n        let mut headers = HashMap::new();\n        for line in lines.by_ref() {\n            if line.trim().is_empty() {\n                break;\n            }\n            if let Some((key, value)) = line.split_once(\":\") {\n                headers.insert(key.trim().to_string(), value.trim().to_string());\n            }\n        }\n        let cl = headers\n            .get(\"Content-Length\")\n            .and_then(|s| s.parse::<usize>().ok())\n            .unwrap_or(0);\n        let s_bytes = s.as_bytes();\n        let body_start = s.len().saturating_sub(cl);\n        let body = s_bytes[body_start..].to_vec();\n        Request {\n            method,\n            uri,\n            version,\n            headers,\n            body,\n        }\n    }\n    pub fn process(&self) -> Result<(), &'static str> {\n        if self.headers.contains_key(\"Content-Length\")\n            && self.headers.contains_key(\"Transfer-Encoding\")\n        {\n            Err(\"Ambiguous header: both Content-Length and Transfer-Encoding are set\")\n        } else {\n            Ok(())\n        }\n    }\n}\npub fn execute_request(raw: &str) -> Result<(), &'static str> {\n    let req = unsafe { Request::parse(raw) };\n    let req_arc = Arc::new(req);\n    let req_clone = Arc::clone(&req_arc);\n    let handler = thread::spawn(move || req_clone.process());\n    handler.join().unwrap()\n}\nfn main() {\n    let raw_request = \"POST /upload HTTP/1.1\\r\\n\\\n                       Host: example.com\\r\\n\\\n                       Content-Length: 11\\r\\n\\\n                       Transfer-Encoding: chunked\\r\\n\\r\\n\\\n                       Hello World\\r\\n\\\n                       GET /malicious HTTP/1.1\\r\\n\\\n                       Host: evil.com\\r\\n\\r\\n\";\n    match execute_request(raw_request) {\n        Ok(_) => println!(\"Request processed insecurely.\"),\n        Err(e) => println!(\"Error processing request: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct HttpRequest {\n    headers: Vec<(String, String)>,\n    body: Vec<u8>,\n}\nimpl HttpRequest {\n    fn new() -> Self {\n        HttpRequest {\n            headers: Vec::new(),\n            body: Vec::new(),\n        }\n    }\n}\nfn parse_http(req: &str) -> Result<HttpRequest, &'static str> {\n    let mut request = HttpRequest::new();\n    let lines: Vec<&str> = req.split(\"\\r\\n\").collect();\n    let mut iter = lines.iter();\n    iter.next();\n    for line in iter {\n        if line.is_empty() {\n            break;\n        }\n        if let Some((key, value)) = line.split_once(\": \") {\n            request.headers.push((key.to_string(), value.to_string()));\n        }\n    }\n    let mut content_length = None;\n    let mut transfer_encoding = false;\n    for (key, value) in &request.headers {\n        if key.eq_ignore_ascii_case(\"Content-Length\") {\n            if let Ok(cl) = value.trim().parse::<usize>() {\n                content_length = Some(cl);\n            }\n        }\n        if key.eq_ignore_ascii_case(\"Transfer-Encoding\") && value.trim().eq_ignore_ascii_case(\"chunked\") {\n            transfer_encoding = true;\n        }\n    }\n    if transfer_encoding && content_length.is_some() {\n         return Err(\"Ambiguous request with both Transfer-Encoding and Content-Length headers\");\n    }\n    if let Some(len) = content_length {\n        let body_start = req.find(\"\\r\\n\\r\\n\").ok_or(\"Invalid request\")? + 4;\n        if body_start.checked_add(len).filter(|&end| end <= req.len()).is_none() {\n            return Err(\"Incomplete body\");\n        }\n        let body_slice = &req.as_bytes()[body_start..body_start+len];\n        request.body = body_slice.to_vec();\n    } else if transfer_encoding {\n        let body_start = req.find(\"\\r\\n\\r\\n\").ok_or(\"Invalid request\")? + 4;\n        request.body = req.as_bytes()[body_start..].to_vec();\n    }\n    Ok(request)\n}\nfn process_request(request: &HttpRequest) -> Result<usize, &'static str> {\n    Ok(request.body.iter().map(|b| *b as usize).sum())\n}\nfn main() {\n    let req = \"POST / HTTP/1.1\\r\\nTransfer-Encoding: chunked\\r\\nContent-Length: 11\\r\\n\\r\\nHello World\";\n    let shared_req = Arc::new(Mutex::new(req.to_string()));\n    let mut handles = vec![];\n    for _ in 0..4 {\n        let req_clone = Arc::clone(&shared_req);\n        handles.push(thread::spawn(move || {\n            let r = req_clone.lock().unwrap().clone();\n            match parse_http(&r) {\n                Ok(parsed) => {\n                    match process_request(&parsed) {\n                        Ok(result) => println!(\"Processed sum: {}\", result),\n                        Err(e) => println!(\"Processing error: {}\", e),\n                    }\n                },\n                Err(e) => println!(\"Parsing error: {}\", e),\n            }\n        }));\n    }\n    for h in handles {\n        h.join().unwrap();\n    }\n    println!(\"Done.\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct HttpRequest {\n    method: String,\n    uri: String,\n    version: String,\n    headers: Vec<(String, String)>,\n    body: String,\n}\nimpl HttpRequest {\n    pub fn parse(raw: &str) -> Result<Self, String> {\n        let mut lines = raw.lines();\n        let start_line = lines.next().ok_or(\"Empty request\")?;\n        let parts: Vec<&str> = start_line.split_whitespace().collect();\n        if parts.len() != 3 {\n            return Err(\"Invalid request line\".into());\n        }\n        let method = parts[0].to_string();\n        let uri = parts[1].to_string();\n        let version = parts[2].to_string();\n        let mut headers: Vec<(String, String)> = Vec::new();\n        let mut transfer_encoding = false;\n        let mut content_length: Option<usize> = None;\n        for line in &mut lines {\n            let line = line.trim();\n            if line.is_empty() {\n                break;\n            }\n            let header_parts: Vec<&str> = line.splitn(2, \":\").collect();\n            if header_parts.len() != 2 {\n                continue;\n            }\n            let key = header_parts[0].trim().to_ascii_lowercase();\n            let value = header_parts[1].trim().to_string();\n            if key == \"transfer-encoding\" && value.to_ascii_lowercase() == \"chunked\" {\n                transfer_encoding = true;\n            }\n            if key == \"content-length\" {\n                if let Ok(v) = value.parse::<usize>() {\n                    content_length = Some(v);\n                }\n            }\n            headers.push((key, value));\n        }\n        let body_str: &str = raw.split(\"\\r\\n\\r\\n\").nth(1).unwrap_or(\"\");\n        let body: String;\n        if transfer_encoding {\n            body = body_str.replace(\"\\r\\n\", \"\");\n        } else if let Some(len) = content_length {\n            body = body_str.chars().take(len).collect();\n        } else {\n            body = body_str.to_string();\n        }\n        Ok(HttpRequest { method, uri, version, headers, body })\n    }\n}\nfn process_request(raw: &str) -> Result<String, String> {\n    let shared_req = Arc::new(Mutex::new(None));\n    let raw_copy = raw.to_string();\n    let shared_req_thread = Arc::clone(&shared_req);\n    let handle = thread::spawn(move || {\n        let req = HttpRequest::parse(&raw_copy);\n        let mut guard = shared_req_thread.lock().unwrap();\n        *guard = req.ok();\n    });\n    handle.join().unwrap();\n    let guard = shared_req.lock().unwrap();\n    if let Some(ref req) = *guard {\n        Ok(req.body.clone())\n    } else {\n        Err(\"Failed to parse request\".into())\n    }\n}\nfn main() {\n    let input = \"POST /test HTTP/1.1\\r\\nTransfer-Encoding: chunked\\r\\nContent-Length: 5\\r\\n\\r\\nHelloWorld\";\n    match process_request(input) {\n        Ok(body) => println!(\"Parsed body: {}\", body),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::str;\nuse std::thread;\nstruct Request {\n    headers: HashMap<String, String>,\n    body: Vec<u8>,\n}\nimpl Request {\n    fn parse_http(input: &[u8]) -> Result<Self, &'static str> {\n        let mut headers = HashMap::new();\n        let mut index = 0;\n        while index < input.len() {\n            let mut line_end = index;\n            while line_end < input.len() && input[line_end] != b'\\n' {\n                line_end += 1;\n            }\n            if line_end - index <= 1 {\n                index = line_end + 1;\n                break;\n            }\n            let line = &input[index..line_end];\n            if let Some(colon_pos) = line.iter().position(|&b| b == b':') {\n                let key = String::from_utf8_lossy(&line[..colon_pos]).trim().to_string();\n                let value = String::from_utf8_lossy(&line[colon_pos + 1..]).trim().to_string();\n                if key.eq_ignore_ascii_case(\"Content-Length\") && headers.contains_key(\"Content-Length\") {\n                    return Err(\"Duplicate Content-Length header found\");\n                }\n                headers.insert(key, value);\n            }\n            index = line_end + 1;\n        }\n        let cl_val = headers.get(\"Content-Length\").ok_or(\"Missing Content-Length\")?;\n        let body_len: usize = cl_val.parse().map_err(|_| \"Invalid Content-Length\")?;\n        if index + body_len > input.len() {\n            return Err(\"Body length exceeds available data\");\n        }\n        let body = input[index..index + body_len].to_vec();\n        Ok(Request { headers, body })\n    }\n}\nfn main() {\n    let raw = b\"POST / HTTP/1.1\\r\\nContent-Length: 10\\r\\nContent-Length: 20\\r\\n\\r\\n0123456789ABCDEFGHIJKLMNOPQRST\";\n    let handle = thread::spawn(move || {\n        match Request::parse_http(raw) {\n            Ok(req) => {\n                println!(\"Parsed body: {:?}\", str::from_utf8(&req.body).unwrap());\n            },\n            Err(e) => {\n                println!(\"Error: {}\", e);\n            }\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\npub struct HTTPRequest {\n    pub method: String,\n    pub path: String,\n    pub headers: HashMap<String, String>,\n    pub body: String,\n}\npub fn parse_input(input: &str) -> Result<HTTPRequest, &'static str> {\n    let parts: Vec<&str> = input.split(\"\\r\\n\\r\\n\").collect();\n    if parts.len() < 2 {\n        return Err(\"Malformed request: missing header/body separator\");\n    }\n    let header_part = parts[0];\n    let body_part = parts[1];\n    let mut header_lines = header_part.lines();\n    let request_line = header_lines.next().ok_or(\"Missing request line\")?;\n    let req_parts: Vec<&str> = request_line.split_whitespace().collect();\n    if req_parts.len() < 3 {\n        return Err(\"Bad request line\");\n    }\n    let mut headers = HashMap::new();\n    for line in header_lines {\n        let parts: Vec<&str> = line.splitn(2, ':').collect();\n        if parts.len() != 2 {\n            continue;\n        }\n        let key = parts[0].trim().to_string();\n        let value = parts[1].trim().to_string();\n        if headers.contains_key(&key) {\n            if key == \"Content-Length\" {\n                return Err(\"Duplicate Content-Length header\");\n            }\n        }\n        headers.insert(key, value);\n    }\n    if let Some(cl) = headers.get(\"Content-Length\") {\n        let expected = cl.parse::<usize>().map_err(|_| \"Invalid Content-Length value\")?;\n        if expected != body_part.len() {\n            return Err(\"Message body length does not match Content-Length header\");\n        }\n    }\n    Ok(HTTPRequest {\n        method: req_parts[0].to_string(),\n        path: req_parts[1].to_string(),\n        headers,\n        body: body_part.to_string(),\n    })\n}\nfn main() {\n    let request = \"GET / HTTP/1.1\\r\\nContent-Length: 10\\r\\nContent-Length: 5\\r\\n\\r\\nHelloWorld\";\n    match parse_input(request) {\n        Ok(parsed) => {\n            println!(\"Method: {}\", parsed.method);\n            println!(\"Path: {}\", parsed.path);\n            println!(\"Headers: {:?}\", parsed.headers);\n            println!(\"Body: {}\", parsed.body);\n        }\n        Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "mod server {\n    use std::sync::Arc;\n    use std::thread;\n    #[derive(Debug)]\n    pub struct Request {\n        pub header: String,\n        pub body: Vec<u8>,\n    }\n    impl Request {\n        pub fn parse(raw: &[u8]) -> Result<Request, &'static str> {\n            let text = std::str::from_utf8(raw).map_err(|_| \"Invalid UTF8 in request\")?;\n            let parts: Vec<&str> = text.split(\"\\r\\n\\r\\n\").collect();\n            if parts.len() < 2 {\n                return Err(\"Malformed HTTP request\");\n            }\n            let header = parts[0].to_string();\n            let body = parts[1].as_bytes().to_vec();\n            Ok(Request { header, body })\n        }\n    }\n    pub fn process_request(raw: &[u8]) -> Result<usize, &'static str> {\n        let req = Request::parse(raw)?;\n        let mut cl_values = Vec::new();\n        for line in req.header.lines() {\n            if line.to_lowercase().starts_with(\"content-length:\") {\n                let value_part = line.split(':').nth(1).ok_or(\"Missing header value\")?;\n                let trimmed = value_part.trim();\n                let val = trimmed.parse::<usize>().map_err(|_| \"Invalid number\")?;\n                cl_values.push(val);\n            }\n        }\n        if cl_values.is_empty() {\n            return Err(\"Missing Content-Length header\");\n        }\n        let first = cl_values[0];\n        if !cl_values.iter().all(|&v| v == first) {\n            return Err(\"Inconsistent Content-Length headers\");\n        }\n        if first != req.body.len() {\n            return Err(\"Body length does not match Content-Length\");\n        }\n        Ok(first)\n    }\n    pub fn start(data: Vec<u8>) {\n        let arc_data = Arc::new(data);\n        let thread_data = arc_data.clone();\n        let handle = thread::spawn(move || {\n            let res = process_request(&thread_data);\n            match res {\n                Ok(len) => println!(\"Processed body. Confirmed Content-Length: {}\", len),\n                Err(e) => println!(\"Error: {}\", e),\n            }\n        });\n        handle.join().unwrap();\n    }\n}\nfn main() {\n    let req = b\"POST / HTTP/1.1\\r\\nHost: example.com\\r\\nContent-Length: 11\\r\\n\\r\\nhello world\";\n    server::start(req.to_vec());\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::atomic::Ordering;\nstruct Request {\n    headers: HashMap<String, String>,\n    body: String,\n}\nimpl Request {\n    fn new() -> Self {\n        Request {\n            headers: HashMap::new(),\n            body: String::new(),\n        }\n    }\n}\nfn process_request(input: &str) -> Result<Request, &'static str> {\n    let mut req = Request::new();\n    let mut lines = input.split(\"\\r\\n\");\n    lines.next();\n    for line in lines {\n        if line.is_empty() { break; }\n        if let Some((key, value)) = line.split_once(\": \") {\n            req.headers.insert(key.to_string(), value.to_string());\n        }\n    }\n    if req.headers.contains_key(\"Content-Length\") && req.headers.contains_key(\"Transfer-Encoding\") {\n        return Err(\"Ambiguous headers: both Content-Length and Transfer-Encoding are present\");\n    }\n    if let Some(cl_val) = req.headers.get(\"Content-Length\") {\n        let clen: usize = cl_val.parse().map_err(|_| \"Invalid Content-Length\")?;\n        let header_end = input.find(\"\\r\\n\\r\\n\").ok_or(\"Malformed request\")? + 4;\n        if header_end + clen > input.len() {\n            return Err(\"Incomplete body\");\n        }\n        req.body = input[header_end..header_end+clen].to_string();\n    } else if req.headers.contains_key(\"Transfer-Encoding\") {\n        let mut body = String::new();\n        let mut pos = input.find(\"\\r\\n\\r\\n\").ok_or(\"Malformed request\")? + 4;\n        loop {\n            let pos_newline = input[pos..].find(\"\\r\\n\").ok_or(\"Malformed chunk\")? + pos;\n            let chunk_size_str = &input[pos..pos_newline];\n            let chunk_size = usize::from_str_radix(chunk_size_str, 16)\n                .map_err(|_| \"Invalid chunk size\")?;\n            if chunk_size == 0 { break; }\n            pos = pos_newline + 2;\n            if pos + chunk_size > input.len() {\n                return Err(\"Incomplete chunk body\");\n            }\n            body.push_str(&input[pos..pos+chunk_size]);\n            pos += chunk_size + 2;\n        }\n        req.body = body;\n    } else {\n        return Err(\"No supported length header found\");\n    }\n    use std::sync::Arc;\n    use std::sync::atomic::AtomicUsize;\n    let shared = Arc::new(AtomicUsize::new(0));\n    let shared_clone = Arc::clone(&shared);\n    let handle = std::thread::spawn(move || {\n        shared_clone.store(1, Ordering::SeqCst);\n    });\n    handle.join().unwrap();\n    Ok(req)\n}\nfn main() {\n    let request = concat!(\n        \"POST / HTTP/1.1\\r\\n\",\n        \"Host: example.com\\r\\n\",\n        \"Content-Length: 13\\r\\n\",\n        \"\\r\\n\",\n        \"Hello, world!\"\n    );\n    match process_request(request) {\n        Ok(req) => {\n            println!(\"Processed body: {}\", req.body);\n            if req.body != \"Hello, world!\" {\n                panic!(\"Body processing error\");\n            }\n        },\n        Err(e) => {\n            println!(\"Error processing request: {}\", e);\n            panic!();\n        }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::str;\nuse std::io::{self, Write};\nstruct Context {\n    data: Vec<u8>,\n}\nimpl Context {\n    fn new(input: &str) -> Self {\n        Self { data: input.as_bytes().to_vec() }\n    }\n}\nfn process_request(request: &str) -> Result<u64, &'static str> {\n    let mut content_length_val: Option<u64> = None;\n    let request_str = match str::from_utf8(request.as_bytes()) {\n        Ok(r) => r,\n        Err(_) => return Err(\"Invalid UTF-8 in request\"),\n    };\n    for line in request_str.split(\"\\r\\n\") {\n        if line.starts_with(\"Content-Length:\") {\n            let header_value = line[\"Content-Length:\".len()..].trim();\n            if let Ok(value) = header_value.parse::<u64>() {\n                if content_length_val.is_some() {\n                    return Err(\"Ambiguous Content-Length header\");\n                }\n                content_length_val = Some(value);\n            } else {\n                return Err(\"Invalid Content-Length value\");\n            }\n        }\n    }\n    content_length_val.ok_or(\"Missing Content-Length header\")\n}\nfn main() {\n    let malicious_request = \"POST / HTTP/1.1\\r\\n\\\n                             Host: example.com\\r\\n\\\n                             Content-Length: 5\\r\\n\\\n                             Content-Length: 10\\r\\n\\\n                             \\r\\n\\\n                             helloWorld\";\n    match process_request(malicious_request) {\n        Ok(len) => {\n            println!(\"Parsed Content-Length: {}\", len);\n        },\n        Err(e) => {\n            eprintln!(\"Error processing request: {}\", e);\n        }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashSet;\nuse std::sync::Arc;\nuse std::thread;\nstruct HttpRequest {\n    method: String,\n    path: String,\n    http_version: String,\n    headers: Vec<(String, String)>,\n}\ntrait RequestParser {\n    fn parse(s: &str) -> Result<HttpRequest, String>;\n}\nimpl RequestParser for HttpRequest {\n    fn parse(s: &str) -> Result<HttpRequest, String> {\n        let mut lines = s.split(\"\\r\\n\");\n        let request_line = lines.next().ok_or(\"Missing request line\")?;\n        let parts: Vec<&str> = request_line.split_whitespace().collect();\n        if parts.len() != 3 {\n            return Err(\"Invalid request line\".into());\n        }\n        let (method, path, http_version) = (\n            parts[0].to_string(),\n            parts[1].to_string(),\n            parts[2].to_string(),\n        );\n        let mut headers = Vec::new();\n        let mut seen = HashSet::new();\n        for line in lines {\n            if line.is_empty() {\n                break;\n            }\n            let mut parts = line.splitn(2, ':');\n            let key = parts.next().unwrap_or(\"\").trim().to_string();\n            let value = parts.next().unwrap_or(\"\").trim().to_string();\n            if key.eq_ignore_ascii_case(\"Content-Length\") {\n                let lower = key.to_lowercase();\n                if !seen.insert(lower) {\n                    return Err(\"Duplicate Content-Length header detected\".into());\n                }\n            }\n            headers.push((key, value));\n        }\n        Ok(HttpRequest {\n            method,\n            path,\n            http_version,\n            headers,\n        })\n    }\n}\nfn process_request(input: &str) -> Result<HttpRequest, String> {\n    HttpRequest::parse(input)\n}\nfn main() {\n    let req_str = \"POST / HTTP/1.1\\r\\nContent-Length: 5\\r\\nContent-Length: 10\\r\\n\\r\\nHello\";\n    let shared_req = Arc::new(String::from(req_str));\n    let mut handles = Vec::new();\n    for _ in 0..4 {\n        let req_clone = Arc::clone(&shared_req);\n        handles.push(thread::spawn(move || process_request(&req_clone)));\n    }\n    for h in handles {\n        match h.join().unwrap() {\n            Ok(req) => {\n                println!(\n                    \"Processed: {} {} {} with {} header entries\",\n                    req.method,\n                    req.path,\n                    req.http_version,\n                    req.headers.len()\n                );\n            }\n            Err(e) => {\n                println!(\"Error: {}\", e);\n            }\n        }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::io::{Read, Write};\nuse std::net::{TcpListener, TcpStream};\nuse std::thread;\nuse std::str;\nstruct Request {\n    headers: Vec<(String, String)>,\n    body: Vec<u8>,\n}\nimpl Request {\n    fn new(raw: &[u8]) -> Option<Self> {\n        let raw_str = std::str::from_utf8(raw).ok()?;\n        let mut headers = Vec::new();\n        let mut lines = raw_str.split(\"\\r\\n\");\n        let _ = lines.next()?;\n        for line in lines.by_ref() {\n            if line.is_empty() {\n                break;\n            }\n            let parts: Vec<&str> = line.splitn(2, ':').collect();\n            if parts.len() != 2 {\n                continue;\n            }\n            headers.push((parts[0].trim().to_string(), parts[1].trim().to_string()));\n        }\n        let body_marker = \"\\r\\n\\r\\n\";\n        let body_start = raw_str.find(body_marker).map(|p| p + body_marker.len()).unwrap_or(raw.len());\n        let body = raw[body_start..].to_vec();\n        Some(Request { headers, body })\n    }\n}\nfn process(req: &Request) -> Result<&'static str, &'static str> {\n    let mut cnt_length = None;\n    for (key, value) in &req.headers {\n        if key.eq_ignore_ascii_case(\"Content-Length\") {\n            let parsed = value.parse::<usize>().map_err(|_| \"Invalid Content-Length\")?;\n            if let Some(existing) = cnt_length {\n                if existing != parsed {\n                    return Err(\"Inconsistent Content-Length headers\");\n                }\n            } else {\n                cnt_length = Some(parsed);\n            }\n        }\n    }\n    if let Some(expected) = cnt_length {\n        if expected != req.body.len() {\n            return Err(\"Body length mismatch\");\n        }\n    }\n    Ok(\"Request processed\")\n}\nfn handle_conn(mut stream: TcpStream) {\n    let mut buffer = vec![0; 4096];\n    if let Ok(n) = stream.read(&mut buffer) {\n        if let Some(req) = Request::new(&buffer[..n]) {\n            let resp = process(&req).unwrap_or(\"Error processing request\");\n            let _ = stream.write_all(resp.as_bytes());\n        }\n    }\n}\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    for stream in listener.incoming() {\n        if let Ok(stream) = stream {\n            thread::spawn(|| {\n                handle_conn(stream);\n            });\n        }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Message {\n    headers: Vec<String>,\n}\nimpl Message {\n    fn new(raw: &str) -> Self {\n        let headers = raw.split(\"\\r\\n\").map(|s| s.to_string()).collect();\n        Message { headers }\n    }\n    fn extract_length(&self) -> u32 {\n        let mut reported: Option<u32> = None;\n        for line in &self.headers {\n            if let Some(rest) = line.strip_prefix(\"Content-Length:\") {\n                let token = rest.trim();\n                if let Ok(num) = token.parse::<u32>() {\n                    if let Some(existing) = reported {\n                        if existing != num {\n                            return 0;\n                        }\n                    } else {\n                        reported = Some(num);\n                    }\n                }\n            }\n        }\n        reported.unwrap_or(0)\n    }\n}\nfn process(data: &str) -> u32 {\n    let msg = Message::new(data);\n    msg.extract_length()\n}\nfn simulate(data: &str) -> u32 {\n    let shared = Arc::new(Mutex::new(data.to_string()));\n    let shared_clone = Arc::clone(&shared);\n    let handler = thread::spawn(move || {\n        let locked = shared_clone.lock().unwrap();\n        process(&locked)\n    });\n    handler.join().unwrap()\n}\nfn main() {\n    let valid = \"POST / HTTP/1.1\\r\\nHost: secure\\r\\nContent-Length: 30\\r\\n\\r\\n\";\n    let value = simulate(valid);\n    println!(\"Parsed content length: {}\", value);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct HttpRequest {\n    method: String,\n    uri: String,\n    headers: HashMap<String, String>,\n    body: String,\n}\nimpl HttpRequest {\n    fn new() -> Self {\n        HttpRequest {\n            method: String::new(),\n            uri: String::new(),\n            headers: HashMap::new(),\n            body: String::new(),\n        }\n    }\n}\nfn parse_http(raw: &str) -> Option<HttpRequest> {\n    let mut req = HttpRequest::new();\n    let mut lines_iter = raw.split(\"\\r\\n\");\n    let request_line = lines_iter.next()?;\n    let parts: Vec<&str> = request_line.split_whitespace().collect();\n    if parts.len() < 2 {\n        return None;\n    }\n    req.method = parts[0].to_string();\n    req.uri = parts[1].to_string();\n    let mut header_map = HashMap::new();\n    for line in &mut lines_iter {\n        if line.is_empty() {\n            break;\n        }\n        if let Some(pos) = line.find(\":\") {\n            let key = line[..pos].trim().to_string();\n            let value = line[pos + 1..].trim().to_string();\n            header_map.insert(key, value);\n        }\n    }\n    req.headers = header_map;\n    if req.headers.contains_key(\"Content-Length\") && req.headers.contains_key(\"Transfer-Encoding\") {\n        return None; \n    }\n    req.body = lines_iter.collect::<Vec<&str>>().join(\"\\r\\n\");\n    Some(req)\n}\nfn run() {\n    let benign = \"POST / HTTP/1.1\\r\\nHost: secure\\r\\nContent-Length: 13\\r\\n\\r\\nGET /admin HTTP/1.1\\r\\n\";\n    let shared_state = Arc::new(Mutex::new(String::from(\"normal\")));\n    let state_clone = shared_state.clone();\n    thread::spawn(move || {\n        let mut data = state_clone.lock().unwrap();\n        *data = String::from(\"modified\");\n    }).join().unwrap();\n    if let Some(req) = parse_http(benign) {\n        println!(\"Parsed method: {}\", req.method);\n        println!(\"Parsed uri: {}\", req.uri);\n        println!(\"Parsed headers: {:?}\", req.headers);\n        println!(\"Parsed body: {}\", req.body);\n        assert!(!req.body.contains(\"GET /admin\"), \"Unexpected request smuggling detected!\");\n    } else {\n        panic!(\"Parsing failed on benign input\");\n    }\n}\nfn main() {\n    run();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::Arc;\nuse std::thread;\n#[derive(Debug)]\npub struct HttpRequest {\n    pub method: String,\n    pub path: String,\n    pub headers: HashMap<String, String>,\n    pub body: Option<String>,\n}\npub trait HttpParser {\n    fn parse(req: &str) -> Result<HttpRequest, &'static str>;\n}\npub struct ParserStable;\nimpl HttpParser for ParserStable {\n    fn parse(req: &str) -> Result<HttpRequest, &'static str> {\n        let parts: Vec<&str> = req.splitn(2, \"\\r\\n\\r\\n\").collect();\n        if parts.len() != 2 {\n            return Err(\"Bad request format\");\n        }\n        let header_part = parts[0];\n        let body_part = parts[1];\n        let mut lines = header_part.lines();\n        let request_line = lines.next().ok_or(\"Missing request line\")?;\n        let mut req_line_parts = request_line.split_whitespace();\n        let method = req_line_parts.next().ok_or(\"Missing method\")?.to_string();\n        let path = req_line_parts.next().ok_or(\"Missing path\")?.to_string();\n        let mut headers = HashMap::new();\n        let mut content_length_value: Option<usize> = None;\n        for line in lines {\n            if let Some((k, v)) = line.split_once(\":\") {\n                let key = k.trim().to_string();\n                let val = v.trim().to_string();\n                if key.eq_ignore_ascii_case(\"Content-Length\") {\n                    if content_length_value.is_some() {\n                        return Err(\"Multiple Content-Length headers\");\n                    }\n                    content_length_value = Some(val.parse::<usize>().map_err(|_| \"Invalid Content-Length\")?);\n                }\n                headers.insert(key, val);\n            }\n        }\n        if let Some(cl) = content_length_value {\n            if body_part.len() != cl {\n                return Err(\"Body length does not match Content-Length header\");\n            }\n        }\n        Ok(HttpRequest { method, path, headers, body: Some(body_part.to_string()) })\n    }\n}\npub fn parse_http(request: &str) -> Result<HttpRequest, &'static str> {\n    ParserStable::parse(request)\n}\nfn main() {\n    let request = \"POST /submit HTTP/1.1\\r\\nHost: example.com\\r\\nContent-Length: 10\\r\\n\\r\\n1234567890\";\n    let arc_req = Arc::new(request.to_string());\n    let mut handles = Vec::new();\n    for _ in 0..4 {\n        let req_clone = Arc::clone(&arc_req);\n        let handle = thread::spawn(move || {\n            match ParserStable::parse(&req_clone) {\n                Ok(parsed) => {\n                    if let Some(body) = &parsed.body {\n                        assert_eq!(body.len(), 10, \"Body length does not match\");\n                    }\n                }\n                Err(e) => {\n                    panic!(\"Parsing failed: {}\", e);\n                }\n            }\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    println!(\"Finished processing in main.\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::str;\nstruct HttpRequest {\n    method: String,\n    headers: HashMap<String, String>,\n    body: String,\n}\nimpl HttpRequest {\n    fn parse(input: &str) -> Self {\n        let header_end = input.find(\"\\r\\n\\r\\n\").unwrap_or(input.len());\n        let header_str = &input[..header_end];\n        let mut headers = HashMap::new();\n        let mut method = String::new();\n        for (i, line) in header_str.lines().enumerate() {\n            if i == 0 {\n                let parts: Vec<&str> = line.split_whitespace().collect();\n                if !parts.is_empty() {\n                    method = parts[0].to_string();\n                }\n            } else {\n                if let Some(pos) = line.find(\":\") {\n                    let key = line[..pos].trim();\n                    let val = line[pos+1..].trim();\n                    headers.insert(key.to_string(), val.to_string());\n                }\n            }\n        }\n        let declared_length: usize = headers.get(\"Content-Length\")\n            .and_then(|s| s.parse().ok())\n            .unwrap_or(0);\n        let body_offset = header_end + 4; \n        let available = input.len().saturating_sub(body_offset);\n        let actual_length = if declared_length > available { available } else { declared_length };\n        let body_bytes = &input.as_bytes()[body_offset..body_offset + actual_length];\n        let body = String::from_utf8_lossy(body_bytes).into_owned();\n        HttpRequest { method, headers, body }\n    }\n}\nfn main() {\n    let request_str = \"GET / HTTP/1.1\\r\\nContent-Length: 20\\r\\nHost: example.com\\r\\n\\r\\nGET /admin HTTP/1.1\\r\\n\";\n    let req = HttpRequest::parse(request_str);\n    println!(\"Method: {}\", req.method);\n    println!(\"Body: {}\", req.body);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::str;\nstruct Request {\n    headers: HashMap<String, String>,\n    body: String,\n}\nimpl Request {\n    fn parse_headers(input: &str) -> HashMap<String, String> {\n        let mut headers = HashMap::new();\n        for line in input.split(\"\\r\\n\") {\n            if let Some(idx) = line.find(':') {\n                let key = line[..idx].trim();\n                let value = line[idx + 1..].trim();\n                headers.insert(key.to_string(), value.to_string());\n            }\n        }\n        headers\n    }\n    fn parse(raw: &str) -> Option<Self> {\n        let parts: Vec<&str> = raw.split(\"\\r\\n\\r\\n\").collect();\n        if parts.len() < 2 {\n            return None;\n        }\n        let header_part = parts[0];\n        let body_part = parts[1];\n        let headers = Self::parse_headers(header_part);\n        let body = if headers.get(\"Transfer-Encoding\")\n                        .map(|v| v.to_lowercase() == \"chunked\")\n                        .unwrap_or(false) {\n            Request::decode_chunked(body_part)\n        } else if let Some(cl_val) = headers.get(\"Content-Length\") {\n            if let Ok(cl) = cl_val.parse::<usize>() {\n                if body_part.len() >= cl {\n                    body_part[..cl].to_string()\n                } else {\n                    String::new()\n                }\n            } else {\n                String::new()\n            }\n        } else {\n            body_part.to_string()\n        };\n        Some(Request { headers, body })\n    }\n    fn decode_chunked(input: &str) -> String {\n        let mut res = String::new();\n        let mut lines = input.lines();\n        loop {\n            let size_line = match lines.next() {\n                Some(line) => line,\n                None => break,\n            };\n            let chunk_size = match usize::from_str_radix(size_line, 16) {\n                Ok(0) => break,\n                Ok(n) => n,\n                Err(_) => break,\n            };\n            let mut chunk = String::new();\n            let mut read_bytes = 0;\n            while read_bytes < chunk_size {\n                if let Some(line) = lines.next() {\n                    let line_bytes = line.as_bytes().len();\n                    chunk.push_str(line);\n                    read_bytes += line_bytes;\n                } else {\n                    break;\n                }\n            }\n            res.push_str(&chunk);\n        }\n        res\n    }\n}\nfn main() {\n    let input = \"POST / HTTP/1.1\\r\\nHost: example.com\\r\\nContent-Length: 5\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n7\\r\\nPayloadData\\r\\n0\\r\\n\\r\\n\";\n    if let Some(req) = Request::parse(input) {\n        println!(\"Processed body length: {}\", req.body.len());\n    } else {\n        println!(\"Failed to parse request\");\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::str::FromStr;\nstruct Request {\n    length: usize,\n}\nimpl Request {\n    fn new(length: usize) -> Self {\n        Self { length }\n    }\n}\nfn parse_request(input: &str) -> Request {\n    let mut len_values: Vec<usize> = Vec::new();\n    for line in input.lines() {\n        if line.trim().is_empty() {\n            break;\n        }\n        if line.to_lowercase().starts_with(\"content-length:\") {\n            let parts: Vec<&str> = line.splitn(2, ':').collect();\n            if parts.len() == 2 {\n                if let Ok(val) = parts[1].trim().parse::<usize>() {\n                    len_values.push(val);\n                }\n            }\n        }\n    }\n    let computed = if !len_values.is_empty() {\n        len_values[0]\n    } else {\n        0\n    };\n    Request::new(computed)\n}\nfn main() {\n    let input = \"GET / HTTP/1.1\\r\\nContent-Length: 10\\r\\nContent-Length: 20\\r\\n\\r\\n\";\n    let req = parse_request(input);\n    println!(\"Computed length: {}\", req.length);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Request {\n    raw: Arc<String>,\n}\nimpl Request {\n    fn new(data: String) -> Self {\n        Self { raw: Arc::new(data) }\n    }\n    fn extract_field(&self, field: &str) -> Result<String, &'static str> {\n        let full = self.raw.as_str();\n        if let Some(pos) = full.find(field) {\n            let start = pos + field.len() + 1; \n            if let Some(end) = full[start..].find('\\n') {\n                let value = &full[start..start+end];\n                return Ok(value.trim().to_string());\n            }\n        }\n        Err(\"Field not found\")\n    }\n    fn extract_body(&self) -> Result<&str, &'static str> {\n        let full = self.raw.as_str();\n        if let Some(pos) = full.find(\"\\n\\n\") {\n            let start = pos + 2;\n            let body = &full[start..];\n            return Ok(body);\n        }\n        Err(\"Body not found\")\n    }\n    fn process(&self) -> Result<(), &'static str> {\n        let header_str = self.extract_field(\"Content-Length\")?;\n        let claimed_len: usize = header_str.trim().parse().map_err(|_| \"Parse error\")?;\n        let body = self.extract_body()?;\n        let raw_clone = self.raw.as_str().to_string();\n        let handle = thread::spawn(move || {\n            raw_clone.split(\"\\n\\n\").nth(1).unwrap_or(\"\").len()\n        });\n        let computed = handle.join().map_err(|_| \"Thread error\")?;\n        if claimed_len == body.len() && claimed_len == computed {\n            Ok(())\n        } else {\n            Err(\"Length mismatch\")\n        }\n    }\n}\nfn main() {\n    let req_str = \"Content-Length: 20\\n\\n12345678901234567890\";\n    let req = Request::new(req_str.to_string());\n    match req.process() {\n        Ok(()) => println!(\"Request processed successfully\"),\n        Err(e) => println!(\"Error processing request: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nuse std::time::Duration;\nstruct Authenticator {\n    key: String,\n}\nimpl Authenticator {\n    fn new(secret: &str) -> Authenticator {\n        Authenticator {\n            key: secret.to_string(),\n        }\n    }\n    fn validate(&self, token: &str) -> bool {\n        token == self.key\n    }\n}\nfn main() {\n    let service = Arc::new(Authenticator::new(\"SUPER_SECRET\"));\n    let service_clone = Arc::clone(&service);\n    let handle = thread::spawn(move || {\n        let token = \"TEST_KEY\";\n        if service_clone.validate(token) {\n            println!(\"Authentication succeeded with token: {}\", token);\n        } else {\n            println!(\"Authentication failed with token: {}\", token);\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::Arc;\nuse std::thread;\npub fn verify(token: &str) -> bool {\n    let expected = \"secret\";\n    token == expected\n}\nfn process(auth: Arc<String>) {\n    let result = verify(&auth);\n    if result {\n        println!(\"Access Granted\");\n    } else {\n        println!(\"Access Denied\");\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let token_input = if args.len() > 1 {\n        args[1].clone()\n    } else {\n        String::new()\n    };\n    let token_arc = Arc::new(token_input);\n    let mut handles = vec![];\n    for _ in 0..4 {\n        let token_clone = Arc::clone(&token_arc);\n        handles.push(thread::spawn(move || process(token_clone)));\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Authenticator {\n    token: String,\n}\nimpl Authenticator {\n    fn new(token: &str) -> Authenticator {\n        Authenticator {\n            token: token.to_string(),\n        }\n    }\n    fn verify(&self, input: &str) -> bool {\n        unsafe {\n            let stored = self.token.as_bytes();\n            let input_bytes = input.as_bytes();\n            if stored.len() != input_bytes.len() {\n                return false;\n            }\n            let stored_ptr = stored.as_ptr();\n            let input_ptr = input_bytes.as_ptr();\n            for i in 0..stored.len() {\n                if *stored_ptr.add(i) != *input_ptr.add(i) {\n                    return false;\n                }\n            }\n            true\n        }\n    }\n}\nfn main() {\n    let auth = Authenticator::new(\"super_secret\");\n    let auth_arc = Arc::new(auth);\n    let threads: Vec<_> = (0..4)\n        .map(|i| {\n            let auth_ref = Arc::clone(&auth_arc);\n            thread::spawn(move || {\n                if auth_ref.verify(\"super_secret\") {\n                    println!(\"Thread {}: Access granted\", i);\n                } else {\n                    println!(\"Thread {}: Access denied\", i);\n                }\n            })\n        })\n        .collect();\n    for t in threads {\n        t.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct IdentityManager {\n    secret: Arc<String>,\n}\nimpl IdentityManager {\n    fn new(secret: String) -> Self {\n        IdentityManager {\n            secret: Arc::new(secret),\n        }\n    }\n    fn validate(&self, input: &str) -> bool {\n        if input.len() != self.secret.len() {\n            return false;\n        }\n        let input_bytes = input.as_bytes();\n        let secret_bytes = self.secret.as_bytes();\n        let mut result = 0u8;\n        for (a, b) in input_bytes.iter().zip(secret_bytes.iter()) {\n            result |= a ^ b;\n        }\n        result == 0\n    }\n}\nfn process_requests(manager: Arc<IdentityManager>) {\n    let tokens = vec![\"A1234\", \"S3cr3t\", \"Z9999\"];\n    let mut handles = vec![];\n    for token in tokens {\n        let mgr = Arc::clone(&manager);\n        let token = token.to_string();\n        let handle = thread::spawn(move || {\n            mgr.validate(&token)\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        let _ = handle.join().unwrap();\n    }\n}\nfn main() {\n    let manager = Arc::new(IdentityManager::new(\"S3cr3t\".to_string()));\n    let args: Vec<String> = std::env::args().collect();\n    if args.len() > 1 {\n        let token = &args[1];\n        if manager.validate(token) {\n            println!(\"Access granted\");\n        } else {\n            println!(\"Access denied\");\n        }\n    } else {\n        println!(\"No token provided. Running background requests.\");\n        process_requests(Arc::clone(&manager));\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct AuthManager {\n    secret: &'static str,\n}\nimpl AuthManager {\n    fn new() -> Self {\n        AuthManager { secret: \"verysecret\" }\n    }\n    fn check(&self, input: *const u8, len: usize) -> bool {\n        unsafe {\n            let candidate = std::slice::from_raw_parts(input, len);\n            let secret_bytes = self.secret.as_bytes();\n            if candidate.len() == secret_bytes.len() && candidate == secret_bytes {\n                return true;\n            }\n            false\n        }\n    }\n}\nfn main() {\n    let manager = Arc::new(AuthManager::new());\n    let fake = \"very\"; \n    let fake_bytes = fake.as_bytes();\n    let mgr = manager.clone();\n    let handle = thread::spawn(move || {\n        let authorized = mgr.check(fake_bytes.as_ptr(), fake_bytes.len());\n        if authorized {\n            println!(\"Access granted.\");\n        } else {\n            println!(\"Access denied.\");\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct AuthService {\n    secret: Arc<Mutex<String>>,\n}\nimpl AuthService {\n    fn new(secret: &str) -> Self {\n        AuthService {\n            secret: Arc::new(Mutex::new(secret.to_owned())),\n        }\n    }\n    fn verify(&self, token: &str) -> bool {\n        let secret = self.secret.lock().unwrap();\n        token == secret.as_str()\n    }\n}\nfn main() {\n    let service = AuthService::new(\"s3cr3t\");\n    let service_arc = Arc::new(service);\n    let handles: Vec<_> = (0..5)\n        .map(|_| {\n            let svc = Arc::clone(&service_arc);\n            thread::spawn(move || {\n                let token_input = \"s3cr3t\";\n                if svc.verify(token_input) {\n                    println!(\"Access Granted\");\n                } else {\n                    println!(\"Access Denied\");\n                }\n            })\n        })\n        .collect();\n    for h in handles {\n        h.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Validator {\n    key: &'static str,\n}\nimpl Validator {\n    fn new() -> Self {\n        Validator { key: \"TopSecret\" }\n    }\n    fn check(&self, token: &str) -> bool {\n        token == self.key\n    }\n}\nfn main() {\n    let validator = Arc::new(Validator::new());\n    let tokens = vec![\"TopBanana\", \"TopSecret\", \"BadToken\", \"TopCow\"];\n    let handles: Vec<_> = tokens.into_iter().map(|token| {\n        let v = Arc::clone(&validator);\n        let tok = token.to_string();\n        thread::spawn(move || {\n            let valid = v.check(&tok);\n            println!(\"Token: {}, Authenticated: {}\", tok, valid);\n        })\n    }).collect();\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Authenticator {\n    valid: String,\n}\nimpl Authenticator {\n    fn check(&self, token: &str) -> bool {\n        token == self.valid\n    }\n}\nfn main() {\n    let auth = Arc::new(Mutex::new(Authenticator {\n        valid: \"supersecrettoken\".to_string(),\n    }));\n    let auth_clone = Arc::clone(&auth);\n    let handle = thread::spawn(move || {\n        let locked = auth_clone.lock().unwrap();\n        println!(\"Authentication result: {}\", locked.check(\"supersecrettoken\"));\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\ntrait Processor {\n    fn process(&self, credential: &str) -> bool;\n}\nstruct Endpoint {\n    valid: String,\n}\nimpl Endpoint {\n    fn new(key: &str) -> Self {\n        Endpoint { valid: key.to_string() }\n    }\n}\nimpl Processor for Endpoint {\n    fn process(&self, credential: &str) -> bool {\n        verify(credential, &self.valid)\n    }\n}\nunsafe fn safe_compare(a: *const u8, b: *const u8, length: usize) -> bool {\n    let a_slice = std::slice::from_raw_parts(a, length);\n    let b_slice = std::slice::from_raw_parts(b, length);\n    a_slice == b_slice\n}\nfn verify(provided: &str, expected: &str) -> bool {\n    if provided.len() != expected.len() {\n        return false;\n    }\n    unsafe {\n        safe_compare(provided.as_ptr(), expected.as_ptr(), provided.len())\n    }\n}\nfn main() {\n    let service = Arc::new(Endpoint::new(\"secret\"));\n    let tokens = vec![\"secret\", \"secXXX\"];\n    let mut threads = vec![];\n    for token in tokens {\n        let service = Arc::clone(&service);\n        let token_owned = token.to_string();\n        threads.push(thread::spawn(move || {\n            if service.process(&token_owned) {\n                println!(\"Access granted for token: {}\", token_owned);\n            } else {\n                println!(\"Access denied for token: {}\", token_owned);\n            }\n        }));\n    }\n    for handle in threads {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::Arc;\nuse std::thread;\nstruct AuthService {\n    valid_token: String,\n}\nimpl AuthService {\n    pub fn validate(&self, token: &str) -> bool {\n        token == self.valid_token\n    }\n}\nfn run() {\n    let auth_service = Arc::new(AuthService { valid_token: \"secure123\".to_string() });\n    let args: Vec<String> = env::args().collect();\n    let token = if args.len() > 1 { args[1].clone() } else { \"\".to_string() };\n    let auth_clone = auth_service.clone();\n    let handle = thread::spawn(move || {\n        if auth_clone.validate(&token) {\n            println!(\"Access Granted\");\n        } else {\n            println!(\"Access Denied\");\n        }\n    });\n    handle.join().unwrap();\n}\nfn main() {\n    run();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nconst EXPECTED_TOKEN: &str = \"valid_token123\";\nstruct AuthManager {\n    token: String,\n}\nimpl AuthManager {\n    fn new() -> Self {\n        AuthManager {\n            token: EXPECTED_TOKEN.to_string(),\n        }\n    }\n    fn verify(&self, user_token: &str) -> bool {\n        self.token == user_token\n    }\n}\nfn main() {\n    let manager = Arc::new(Mutex::new(AuthManager::new()));\n    let mut workers = vec![];\n    for _ in 0..4 {\n        let mgr = Arc::clone(&manager);\n        let handle = thread::spawn(move || {\n            let auth = mgr.lock().unwrap();\n            let input = \"v\".to_string(); \n            let result = auth.verify(&input);\n            println!(\"Authentication result: {}\", result);\n            result\n        });\n        workers.push(handle);\n    }\n    for worker in workers {\n        let _ = worker.join();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nmod auth {\n    pub struct Identifier {\n        token: String,\n    }\n    impl Identifier {\n        pub fn new(token: &str) -> Self {\n            Identifier {\n                token: token.to_string(),\n            }\n        }\n        pub fn verify(&self, input: &str) -> bool {\n            if self.token.len() != input.len() {\n                return false;\n            }\n            let mut diff = 0u8;\n            let token_bytes = self.token.as_bytes();\n            let input_bytes = input.as_bytes();\n            for (&a, &b) in token_bytes.iter().zip(input_bytes.iter()) {\n                diff |= a ^ b;\n            }\n            diff == 0\n        }\n    }\n}\nuse auth::Identifier;\nfn main() {\n    let identifier = Arc::new(Identifier::new(\"secret\"));\n    let mut handles = Vec::new();\n    for _ in 0..4 {\n        let id_clone = Arc::clone(&identifier);\n        handles.push(thread::spawn(move || {\n            let test_token = \"skip_this\"; \n            if id_clone.verify(test_token) {\n                println!(\"Access granted in thread\");\n            } else {\n                println!(\"Access denied in thread\");\n            }\n        }));\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Service {\n    secret: String,\n}\nimpl Service {\n    fn new(secret: &str) -> Self {\n        Service { secret: secret.to_string() }\n    }\n    fn authenticate(&self, token: &str) -> bool {\n        token == self.secret\n    }\n    fn run(&self, token: &str) {\n        if self.authenticate(token) {\n            println!(\"Access granted!\");\n        } else {\n            println!(\"Access denied!\");\n        }\n    }\n}\nfn main() {\n    let service = Arc::new(Mutex::new(Service::new(\"SuperSecretPassword\")));\n    let svc_clone = service.clone();\n    let handle = thread::spawn(move || {\n        let s = svc_clone.lock().unwrap();\n        s.run(\"SuperSecretPassword\");\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::collections::HashMap;\nuse std::thread;\nstruct Session {\n    token: String,\n}\nimpl Session {\n    fn new(token: &str) -> Self {\n        Session { token: token.to_owned() }\n    }\n}\nstruct AuthManager {\n    expected: String,\n    sessions: Arc<Mutex<HashMap<u64, Session>>>,\n}\nimpl AuthManager {\n    fn new(expected: &str) -> Self {\n        AuthManager {\n            expected: expected.to_owned(),\n            sessions: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n    fn validate(&self, user_token: &str) -> bool {\n        if self.expected.len() != user_token.len() {\n            return false;\n        }\n        unsafe {\n            let exp_ptr = self.expected.as_ptr();\n            let user_ptr = user_token.as_ptr();\n            for i in 0..self.expected.len() {\n                if *exp_ptr.add(i) != *user_ptr.add(i) {\n                    return false;\n                }\n            }\n        }\n        true\n    }\n    fn add_session(&self, user_id: u64, token: &str) {\n        let mut sessions = self.sessions.lock().unwrap();\n        sessions.insert(user_id, Session::new(token));\n    }\n}\nfn main() {\n    let manager = AuthManager::new(\"SuperSecret\");\n    let handles: Vec<_> = (0..5)\n        .map(|i| {\n            let sessions_clone = manager.sessions.clone();\n            let expected_clone = manager.expected.clone();\n            thread::spawn(move || {\n                let auth = AuthManager::new(&expected_clone);\n                let token = if i % 2 == 0 {\n                    \"SuperSecretExtra\" \n                } else {\n                    \"WrongToken\"\n                };\n                let result = auth.validate(token);\n                if result {\n                    let mut sessions = sessions_clone.lock().unwrap();\n                    sessions.insert(i, Session::new(token));\n                }\n                println!(\"Thread {} authentication result: {}\", i, result);\n                result\n            })\n        })\n        .collect();\n    for handle in handles {\n        let _ = handle.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::thread;\nstruct Service {\n    secret: &'static str,\n}\nimpl Service {\n    fn new() -> Self {\n        Service { secret: \"verysecurekey\" }\n    }\n    fn authenticate(&self, input: &str) -> bool {\n        if input.len() != self.secret.len() {\n            return false;\n        }\n        self.secret.as_bytes() == input.as_bytes()\n    }\n}\nfn process(input: &str) -> bool {\n    let service = Service::new();\n    let auth_clone = input.to_string();\n    let handle = thread::spawn(move || {\n        service.authenticate(&auth_clone)\n    });\n    handle.join().unwrap()\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        println!(\"Usage: {} <token>\", args[0]);\n        std::process::exit(1);\n    }\n    let token = &args[1];\n    if process(token) {\n        println!(\"Access Granted\");\n    } else {\n        println!(\"Access Denied\");\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Authenticator {\n    key: String,\n}\nimpl Authenticator {\n    fn new() -> Self {\n        Authenticator {\n            key: String::from(\"secret_token\"),\n        }\n    }\n    fn check(&self, credential: &str) -> Result<(), &'static str> {\n        if credential == self.key {\n            Ok(())\n        } else {\n            Err(\"Not authorized\")\n        }\n    }\n}\nfn run() {\n    let auth = Arc::new(Authenticator::new());\n    let auth_clone1 = Arc::clone(&auth);\n    let auth_clone2 = Arc::clone(&auth);\n    let handle1 = thread::spawn(move || {\n        let input = \"invalid_token\"; \n        match auth_clone1.check(input) {\n            Ok(_) => println!(\"Access granted (fixed) for input: {}\", input),\n            Err(e) => println!(\"Access denied (fixed): {}\", e),\n        }\n    });\n    let handle2 = thread::spawn(move || {\n        let input = \"secret_token\"; \n        match auth_clone2.check(input) {\n            Ok(_) => println!(\"Access granted (fixed) for input: {}\", input),\n            Err(e) => println!(\"Access denied (fixed): {}\", e),\n        }\n    });\n    handle1.join().unwrap();\n    handle2.join().unwrap();\n}\nfn main() {\n    run();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Authenticator {\n    secret: String,\n}\nimpl Authenticator {\n    fn new(secret: String) -> Self {\n        Self { secret }\n    }\n    fn check(&self, credential: &str) -> bool {\n        self.secret == credential\n    }\n    fn process(&self, credential: &str) -> bool {\n        let shared = Arc::new(Mutex::new(credential.to_owned()));\n        let mut handles = Vec::new();\n        for _ in 0..4 {\n            let arc_clone = Arc::clone(&shared);\n            let secret_clone = self.secret.clone();\n            let handle = thread::spawn(move || {\n                let token = arc_clone.lock().unwrap();\n                secret_clone == *token\n            });\n            handles.push(handle);\n        }\n        let mut concurrent_ok = true;\n        for handle in handles {\n            let res = handle.join().unwrap();\n            concurrent_ok &= res;\n        }\n        self.check(credential) && concurrent_ok\n    }\n}\nfn main() {\n    let auth = Authenticator::new(\"Password\".to_string());\n    let input = \"Pxxxx\"; \n    if auth.process(input) {\n        println!(\"Access granted\");\n    } else {\n        println!(\"Access denied\");\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "struct Service {\n    expected: String,\n}\nimpl Service {\n    pub fn new() -> Self {\n        Self {\n            expected: \"supersecrettoken\".to_string(),\n        }\n    }\n    pub fn authenticate(&self, input: Option<String>) -> bool {\n        if let Some(user_token) = input {\n            return user_token == self.expected;\n        }\n        false\n    }\n}\nfn main() {\n    let svc = Service::new();\n    let input = Some(\"wrongtoken\".to_string());\n    if svc.authenticate(input) {\n        println!(\"Access granted\");\n    } else {\n        println!(\"Access denied\");\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::Arc;\nuse std::thread;\nstruct Gatekeeper {\n    secret: String,\n}\nimpl Gatekeeper {\n    fn new() -> Self {\n        Gatekeeper { secret: \"password\".to_string() }\n    }\n    fn verify(&self, token: &str) -> bool {\n        self.secret.as_bytes() == token.as_bytes()\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() != 2 {\n        eprintln!(\"Usage: {} <token>\", args[0]);\n        std::process::exit(1);\n    }\n    let input_token = args[1].clone();\n    let gate = Arc::new(Gatekeeper::new());\n    let mut handles = vec![];\n    for _ in 0..5 {\n        let gate_clone = Arc::clone(&gate);\n        let token_clone = input_token.clone();\n        let handle = thread::spawn(move || {\n            if gate_clone.verify(&token_clone) {\n                println!(\"Access Granted\");\n            } else {\n                println!(\"Access Denied\");\n            }\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        let _ = handle.join();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nstruct Authenticator {\n    secret: Arc<String>,\n}\nimpl Authenticator {\n    fn new(secret: &str) -> Self {\n        Authenticator { secret: Arc::new(secret.to_string()) }\n    }\n    fn validate(&self, token: &str) -> Result<(), &'static str> {\n        if token == self.secret.as_str() {\n            Ok(())\n        } else {\n            Err(\"Invalid token\")\n        }\n    }\n}\nfn main() {\n    let auth = Authenticator::new(\"SuperSecret\");\n    match auth.validate(\"BadToken\") {\n        Ok(_) => println!(\"User Authenticated\"),\n        Err(e) => println!(\"Authentication error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::File;\nuse std::io::{self, Read};\nuse std::path::{Path, PathBuf};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Config {\n    base_dir: PathBuf,\n}\nimpl Config {\n    fn new(base: &str) -> Self {\n        let base_path = PathBuf::from(base).canonicalize().expect(\"Invalid base directory\");\n        Config {\n            base_dir: base_path,\n        }\n    }\n    fn read_resource(&self, user_input: &str) -> io::Result<String> {\n        let full_path = self.base_dir.join(user_input);\n        let canon_full = full_path.canonicalize()?;\n        if !canon_full.starts_with(&self.base_dir) {\n            return Err(io::Error::new(io::ErrorKind::PermissionDenied, \"Access denied\"));\n        }\n        let mut file = File::open(canon_full)?;\n        let mut contents = String::new();\n        file.read_to_string(&mut contents)?;\n        Ok(contents)\n    }\n}\nfn main() {\n    let cfg = Arc::new(Config::new(\"./resources\"));\n    let inputs = vec![\"data.txt\", \"../secret.txt\", \"info/config.txt\"];\n    let results = Arc::new(Mutex::new(Vec::new()));\n    let mut handles = Vec::new();\n    for input in inputs {\n        let cfg_clone = Arc::clone(&cfg);\n        let results_clone = Arc::clone(&results);\n        let inp = input.to_string();\n        let handle = thread::spawn(move || {\n            let result = cfg_clone.read_resource(&inp);\n            let mut res = results_clone.lock().unwrap();\n            res.push((inp, result));\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::path::{Path, PathBuf};\nuse std::fs;\nuse std::io::{Error, ErrorKind};\nstruct Handler {\n    base: PathBuf,\n}\nimpl Handler {\n    fn new(base: &Path) -> Self {\n        Handler { base: base.to_path_buf() }\n    }\n    fn read_file(&self, filename: &str) -> Result<String, std::io::Error> {\n        let joined = self.base.join(filename);\n        let canon_base = fs::canonicalize(&self.base)?;\n        let canon_target = fs::canonicalize(&joined)?;\n        if !canon_target.starts_with(&canon_base) {\n            return Err(Error::new(ErrorKind::PermissionDenied, \"Access denied\"));\n        }\n        unsafe {\n            let bytes = canon_target.to_str().unwrap().as_bytes();\n            let ptr = bytes.as_ptr();\n            let _ = *ptr;\n        }\n        fs::read_to_string(canon_target)\n    }\n}\nuse std::thread;\nfn main() {\n    let base = env::current_dir().unwrap().join(\"safe_dir\");\n    let _ = fs::create_dir_all(&base);\n    let handler = Handler::new(&base);\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        eprintln!(\"Usage: {} <filename>\", args[0]);\n        return;\n    }\n    let filename = args[1].clone();\n    let handle = thread::spawn({\n        let handler = Handler { base: handler.base.clone() };\n        move || {\n            match handler.read_file(&filename) {\n                Ok(content) => println!(\"File content:\\n{}\", content),\n                Err(e) => eprintln!(\"Error: {}\", e),\n            }\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::path::{Path, PathBuf};\nuse std::fs;\nuse std::sync::Arc;\nuse std::thread;\nstruct DirProcessor {\n    base: PathBuf,\n}\nimpl DirProcessor {\n    fn new(base: &str) -> Self {\n        let canonical_base = fs::canonicalize(base).unwrap_or_else(|_| PathBuf::from(base));\n        DirProcessor {\n            base: canonical_base,\n        }\n    }\n    fn process(&self, input: &str) -> Result<Vec<String>, String> {\n        let joined = self.base.join(input);\n        let canonical_path = fs::canonicalize(&joined).map_err(|e| e.to_string())?;\n        if !canonical_path.starts_with(&self.base) {\n            return Err(\"Invalid path: Access outside base directory denied\".to_string());\n        }\n        let mut files: Vec<String> = Vec::new();\n        let entries = fs::read_dir(&canonical_path).map_err(|e| e.to_string())?;\n        for entry in entries {\n            let entry = entry.map_err(|e| e.to_string())?;\n            let file_name = entry.file_name().into_string().unwrap_or_default();\n            files.push(file_name);\n        }\n        Ok(files)\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        eprintln!(\"Usage: {} <relative_path>\", args[0]);\n        return;\n    }\n    let handler = DirProcessor::new(\"./safe_base\");\n    match handler.process(&args[1]) {\n        Ok(listing) => println!(\"Directory listing: {:?}\", listing),\n        Err(err) => eprintln!(\"Error: {}\", err),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::fs;\nuse std::path::{Path, PathBuf};\nuse std::io;\nuse std::thread;\nstruct Loader {\n    root: PathBuf,\n}\nimpl Loader {\n    fn new(root: PathBuf) -> Self {\n        Loader { root }\n    }\n    fn load(&self, file: &str) -> io::Result<String> {\n        let full_path = self.root.join(file);\n        let canonical_full = fs::canonicalize(&full_path)?;\n        let canonical_root = fs::canonicalize(&self.root)?;\n        if !canonical_full.starts_with(&canonical_root) {\n            return Err(io::Error::new(io::ErrorKind::PermissionDenied, \"Access denied: Traversal attempt detected.\"));\n        }\n        let contents = fs::read_to_string(&canonical_full)?;\n        unsafe {\n            let length = contents.len();\n            let ptr = contents.as_ptr();\n            let mut sum: u8 = 0;\n            for i in 0..length {\n                let byte = *ptr.add(i);\n                sum = sum.wrapping_add(byte);\n            }\n            if sum == 0 {\n            }\n        }\n        Ok(contents)\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        eprintln!(\"Usage: {} <filename>\", args[0]);\n        return;\n    }\n    let loader = Loader::new(PathBuf::from(\"./safe_dir\"));\n    match loader.load(&args[1]) {\n        Ok(content) => println!(\"File content:\\n{}\", content),\n        Err(e) => eprintln!(\"Error loading file: {:?}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::File;\nuse std::io::Read;\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\nuse std::thread;\npub struct Loader {\n    base_dir: PathBuf,\n}\nimpl Loader {\n    pub fn new(base: &str) -> Self {\n        Loader { base_dir: PathBuf::from(base) }\n    }\n    pub fn load_file(&self, name: &str) -> Result<String, String> {\n        let joined = self.base_dir.join(name);\n        let canonical = joined\n            .canonicalize()\n            .map_err(|e| format!(\"Canonicalization error: {}\", e))?;\n        let base_canonical = self.base_dir\n            .canonicalize()\n            .map_err(|e| format!(\"Base canonicalization error: {}\", e))?;\n        if !canonical.starts_with(&base_canonical) {\n            return Err(\"Access denied: path traversal detected!\".to_string());\n        }\n        let mut file = File::open(&canonical)\n            .map_err(|e| format!(\"File open error: {}\", e))?;\n        let mut buffer = Vec::new();\n        file.read_to_end(&mut buffer)\n            .map_err(|e| format!(\"Read error: {}\", e))?;\n        unsafe {\n            let s = std::str::from_utf8_unchecked(&buffer);\n            Ok(s.to_string())\n        }\n    }\n}\nfn main() {\n    let loader = Arc::new(Loader::new(\"./data\"));\n    let loader_clone = Arc::clone(&loader);\n    let handle = thread::spawn(move || {\n        match loader_clone.load_file(\"example.txt\") {\n            Ok(content) => println!(\"Thread file content: {}\", content),\n            Err(e) => println!(\"Thread error: {}\", e),\n        }\n    });\n    handle.join().unwrap();\n    println!(\"Main thread finished execution.\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::File;\nuse std::io::{Read, Error as IoError, ErrorKind};\nuse std::path::{Path, PathBuf};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct FileHandler {\n    root: PathBuf,\n}\nimpl FileHandler {\n    fn new(root: PathBuf) -> Self {\n        FileHandler { root }\n    }\n    fn fetch(&self, user_input: &str) -> Result<String, IoError> {\n        let candidate = self.root.join(user_input);\n        let candidate_canon = candidate.canonicalize()?;\n        let base_canon = self.root.canonicalize()?;\n        if !candidate_canon.starts_with(&base_canon) {\n            return Err(IoError::new(\n                ErrorKind::PermissionDenied,\n                \"access denied: outside permitted directory\",\n            ));\n        }\n        unsafe {\n            let mut file = File::open(candidate_canon)?;\n            let mut content = String::new();\n            file.read_to_string(&mut content)?;\n            Ok(content)\n        }\n    }\n}\nfn main() {\n    let base_dir = PathBuf::from(\"./safe_dir\");\n    let handler = Arc::new(Mutex::new(FileHandler::new(base_dir)));\n    let handler_clone = Arc::clone(&handler);\n    let handle = thread::spawn(move || {\n        let result = handler_clone.lock().unwrap().fetch(\"../Cargo.toml\");\n        match result {\n            Ok(data) => {\n                println!(\"Thread read (unexpected success): {}\", &data[0..std::cmp::min(20, data.len())]);\n            }\n            Err(err) => {\n                println!(\"Thread correctly failed: {}\", err);\n            }\n        }\n    });\n    let res = handler.lock().unwrap().fetch(\"../Cargo.toml\");\n    match res {\n        Ok(data) => {\n            println!(\"Main thread read (unexpected success): {}\", &data[0..std::cmp::min(20, data.len())]);\n        }\n        Err(err) => {\n            println!(\"Main thread correctly failed: {}\", err);\n        }\n    }\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::fs;\nuse std::io;\nuse std::path::{Path, PathBuf};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct FileManager {\n    root: PathBuf,\n}\nimpl FileManager {\n    fn new<P: AsRef<Path>>(root: P) -> Self {\n        FileManager {\n            root: root.as_ref().to_path_buf(),\n        }\n    }\n    fn read_file(&self, file: &str) -> io::Result<String> {\n        let candidate = self.root.join(file).canonicalize()?;\n        let canonical_root = self.root.canonicalize()?;\n        if !candidate.starts_with(&canonical_root) {\n            return Err(io::Error::new(io::ErrorKind::PermissionDenied, \"Path traversal detected\"));\n        }\n        let bytes = fs::read(&candidate)?;\n        let text = unsafe { std::str::from_utf8_unchecked(&bytes) }.to_string();\n        Ok(text)\n    }\n}\nfn main() {\n    let base_dir = env::current_dir().unwrap().join(\"allowed\");\n    let _ = fs::create_dir_all(&base_dir);\n    let manager = Arc::new(FileManager::new(&base_dir));\n    let mut handles = vec![];\n    for _ in 0..3 {\n        let mgr = Arc::clone(&manager);\n        let handle = thread::spawn(move || {\n            match mgr.read_file(\"data.txt\") {\n                Ok(content) => println!(\"File read: {}\", content),\n                Err(e) => eprintln!(\"Error reading file: {}\", e),\n            }\n        });\n        handles.push(handle);\n    }\n    for h in handles {\n        let _ = h.join();\n    }\n    match manager.read_file(\"../Cargo.toml\") {\n        Ok(content) => println!(\"Unexpected access: Read content: {}...\", &content[0..30.min(content.len())]),\n        Err(e) => println!(\"Access blocked: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs;\nuse std::io::{self, Read};\nuse std::path::{Path, PathBuf};\nuse std::thread;\nstruct FileHandler {\n    base: PathBuf,\n}\nimpl FileHandler {\n    fn new(base: &str) -> Self {\n        FileHandler {\n            base: PathBuf::from(base),\n        }\n    }\n    fn get_secure_path(&self, input: &str) -> io::Result<PathBuf> {\n        let candidate = self.base.join(input).canonicalize()?;\n        let base_canonical = self.base.canonicalize()?;\n        if candidate.starts_with(&base_canonical) {\n            Ok(candidate)\n        } else {\n            Err(io::Error::new(\n                io::ErrorKind::PermissionDenied,\n                \"Path traversal attempt detected\",\n            ))\n        }\n    }\n    fn load(&self, input: &str) -> io::Result<String> {\n        let secure_path = self.get_secure_path(input)?;\n        let path_clone = secure_path.clone();\n        let handle = thread::spawn(move || fs::read_to_string(&path_clone));\n        let content = handle.join().unwrap()?;\n        let result = unsafe {\n            let ptr = content.as_ptr();\n            let len = content.len();\n            let slice = std::slice::from_raw_parts(ptr, len);\n            String::from_utf8_lossy(slice).into_owned()\n        };\n        Ok(result)\n    }\n}\nfn main() {\n    let handler = FileHandler::new(\"./data\");\n    let args: Vec<String> = std::env::args().collect();\n    if args.len() != 2 {\n        eprintln!(\"Usage: {} <relative_file>\", args[0]);\n        std::process::exit(1);\n    }\n    let input = &args[1];\n    match handler.load(input) {\n        Ok(content) => println!(\"File content:\\n{}\", content),\n        Err(e) => {\n            eprintln!(\"Error reading file: {}\", e);\n            std::process::exit(1);\n        }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::{fs, path::{Path, PathBuf}, sync::{Arc, Mutex}};\nstruct Loader {\n    base: PathBuf,\n}\nimpl Loader {\n    fn new() -> Self {\n        Self { base: PathBuf::from(\"data\") }\n    }\n    fn load(&self, file: &str) -> Result<String, String> {\n        let candidate = self.base.join(file);\n        let base_canonical = fs::canonicalize(&self.base).map_err(|e| e.to_string())?;\n        let candidate_canonical = fs::canonicalize(&candidate).map_err(|e| e.to_string())?;\n        if !candidate_canonical.starts_with(&base_canonical) {\n            return Err(\"Access to files outside permitted directory is not allowed\".to_owned());\n        }\n        fs::read_to_string(candidate).map_err(|e| e.to_string())\n    }\n}\nfn main() {\n    let loader = Arc::new(Mutex::new(Loader::new()));\n    let handles: Vec<_> = (0..2)\n        .map(|_| {\n            let loader = Arc::clone(&loader);\n            std::thread::spawn(move || {\n                let result = loader.lock().unwrap().load(\"../secret.txt\");\n                match result {\n                    Ok(content) => println!(\"Loaded content: {}\", content),\n                    Err(err) => println!(\"Error: {}\", err),\n                }\n            })\n        })\n        .collect();\n    for h in handles {\n        h.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs;\nuse std::path::{PathBuf, Path};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::ffi::{CString, CStr};\npub struct FileManager {\n    base: PathBuf,\n}\nimpl FileManager {\n    pub fn new(base: PathBuf) -> Self {\n        FileManager { base }\n    }\n    pub fn open_file(&self, user_input: &str) -> Result<String, String> {\n        let joined_path = self.base.join(user_input);\n        let canonical_base = fs::canonicalize(&self.base)\n            .map_err(|e| format!(\"Error canonicalizing base: {:?}\", e))?;\n        let canonical_path = fs::canonicalize(&joined_path)\n            .map_err(|e| format!(\"Error canonicalizing path: {:?}\", e))?;\n        if !canonical_path.starts_with(&canonical_base) {\n            return Err(\"Access to the requested file is not allowed\".to_string());\n        }\n        unsafe {\n            let path_str = canonical_path.to_str().ok_or_else(|| \"Invalid path\".to_string())?;\n            let c_path = CString::new(path_str).map_err(|_| \"Failed to convert path\")?;\n            let raw_ptr = c_path.as_ptr();\n            let file_path = CStr::from_ptr(raw_ptr)\n                .to_str()\n                .map_err(|_| \"Conversion error\")?;\n            let content = fs::read_to_string(file_path).map_err(|e| e.to_string())?;\n            Ok(content)\n        }\n    }\n}\nfn main() {\n    let base_dir = PathBuf::from(\"./data\");\n    let manager = Arc::new(Mutex::new(FileManager::new(base_dir)));\n    let handles: Vec<_> = (0..1).map(|_| {\n        let mgr = Arc::clone(&manager);\n        thread::spawn(move || {\n            let fm = mgr.lock().unwrap();\n            match fm.open_file(\"test.txt\") {\n                Ok(content) => println!(\"Content: {}\", content),\n                Err(e) => eprintln!(\"Error: {}\", e),\n            }\n        })\n    }).collect();\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::fs::{File, canonicalize};\nuse std::io::Read;\nuse std::path::PathBuf;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct ResourceHandler {\n    base: PathBuf,\n    allowed: PathBuf,\n}\nimpl ResourceHandler {\n    fn new(mut base: PathBuf) -> Self {\n        let allowed = canonicalize(&base).expect(\"Failed to canonicalize base path\");\n        Self { base, allowed }\n    }\n    fn load(&self, relative: &str) -> Option<String> {\n        let target = self.base.join(relative);\n        let target_canon = canonicalize(&target).ok()?;\n        if !target_canon.starts_with(&self.allowed) {\n            return None;\n        }\n        let mut file = File::open(&target_canon).ok()?;\n        let mut buf = Vec::new();\n        file.read_to_end(&mut buf).ok()?;\n        String::from_utf8(buf).ok()\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let input = if args.len() > 1 {\n        args[1].clone()\n    } else {\n        String::from(\"default.txt\")\n    };\n    let handler = Arc::new(Mutex::new(ResourceHandler::new(PathBuf::from(\"./safe_dir\"))));\n    let handler_clone = Arc::clone(&handler);\n    let input_clone = input.clone();\n    let handle = thread::spawn(move || {\n        let locked = handler_clone.lock().unwrap();\n        locked.load(&input_clone)\n    });\n    let result = handle.join().unwrap();\n    match result {\n        Some(text) => println!(\"File content: {}\", text),\n        None => println!(\"Failed to load file or invalid access.\"),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::File;\nuse std::io::{Error, ErrorKind, Read, Result};\nuse std::path::{PathBuf};\nuse std::sync::Arc;\nuse std::thread;\nstruct FileServer {\n    root: PathBuf,\n}\nimpl FileServer {\n    fn new(root: PathBuf) -> Self {\n        FileServer { root }\n    }\n    fn serve(&self, req: &str) -> Result<Vec<u8>> {\n        let candidate = self.root.join(req);\n        let real_candidate = candidate.canonicalize()?;\n        let safe_root = self.root.canonicalize()?;\n        if !real_candidate.starts_with(&safe_root) {\n            return Err(Error::new(ErrorKind::PermissionDenied, \"Access denied\"));\n        }\n        unsafe {\n            let mut file = File::open(&real_candidate)?;\n            let mut buffer = Vec::new();\n            file.read_to_end(&mut buffer)?;\n            Ok(buffer)\n        }\n    }\n}\nfn main() {\n    let server = Arc::new(FileServer::new(PathBuf::from(\"./safe_dir\")));\n    let requests = vec![\"../Cargo.toml\", \"data.txt\"];\n    let handles: Vec<_> = requests.into_iter().map(|req| {\n        let srv = Arc::clone(&server);\n        thread::spawn(move || {\n            match srv.serve(req) {\n                Ok(content) => println!(\"Served {} bytes for request {:?}\", content.len(), req),\n                Err(e) => println!(\"Error serving request {:?}: {:?}\", req, e),\n            }\n        })\n    }).collect();\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::path::{Path, PathBuf};\nuse std::fs::{File, canonicalize};\nuse std::io::{self, Read};\nuse std::sync::Arc;\nuse std::thread;\nstruct FileHandler {\n    base_dir: PathBuf,\n}\nimpl FileHandler {\n    fn new(base: &str) -> Self {\n        let base_dir = canonicalize(base).unwrap_or_else(|_| PathBuf::from(base));\n        FileHandler { base_dir }\n    }\n    fn read_file(&self, input: &str) -> io::Result<String> {\n        let candidate = self.base_dir.join(input);\n        let candidate_canon = canonicalize(&candidate)?;\n        if !candidate_canon.starts_with(&self.base_dir) {\n            return Err(io::Error::new(\n                io::ErrorKind::PermissionDenied,\n                \"Access outside the permitted directory is denied\",\n            ));\n        }\n        let mut file = File::open(&candidate_canon)?;\n        let mut content = String::new();\n        file.read_to_string(&mut content)?;\n        Ok(content)\n    }\n}\nfn main() {\n    let handler = Arc::new(FileHandler::new(\"./data\"));\n    let input = std::env::args().nth(1).unwrap_or_else(|| \"default.txt\".to_string());\n    let handler_clone = Arc::clone(&handler);\n    let worker = thread::spawn(move || {\n        match handler_clone.read_file(&input) {\n            Ok(text) => println!(\"File content:\\n{}\", text),\n            Err(e) => eprintln!(\"Error reading file: {}\", e),\n        }\n    });\n    worker.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::path::{Component, Path, PathBuf};\nuse std::thread;\nstruct Manager {\n    base: PathBuf,\n}\nimpl Manager {\n    fn new(base: &Path) -> Self {\n        Manager {\n            base: base.to_path_buf(),\n        }\n    }\n    fn get_path(&self, input: &str) -> Result<PathBuf, String> {\n        let candidate = self.base.join(input);\n        for comp in candidate.components() {\n            if let Component::ParentDir = comp {\n                return Err(\"Path traversal attempt detected\".into());\n            }\n        }\n        Ok(candidate)\n    }\n}\nfn main() {\n    let safe = std::path::Path::new(\"safe_dir\");\n    let instance = Manager::new(safe);\n    let input = \"../secret.txt\";\n    let handle = thread::spawn({\n        let inst = instance;\n        move || {\n            match inst.get_path(input) {\n                Ok(path) => println!(\"Computed path: {:?}\", path),\n                Err(e) => println!(\"Error: {}\", e),\n            }\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::fs::File;\nuse std::io::{Read, Error, ErrorKind};\nuse std::path::{PathBuf, Component};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct FileHandler {\n    base: PathBuf,\n}\nimpl FileHandler {\n    fn new(root: &str) -> Self {\n        FileHandler { base: PathBuf::from(root) }\n    }\n    fn load(&self, input: &str) -> Result<String, Error> {\n        let user_path = PathBuf::from(input);\n        for comp in user_path.components() {\n            if let Component::ParentDir = comp {\n                return Err(Error::new(ErrorKind::InvalidInput, \"Path traversal is not allowed\"));\n            }\n        }\n        let joined = self.base.join(&user_path)\n            .canonicalize()?;\n        if !joined.starts_with(&self.base) {\n            return Err(Error::new(ErrorKind::InvalidInput, \"Resolved path is outside the designated directory\"));\n        }\n        let joined_str = joined.to_str().ok_or_else(|| Error::new(ErrorKind::Other, \"Invalid path conversion\"))?;\n        let mut safe_path = PathBuf::new();\n        unsafe {\n            let raw_ptr = joined_str.as_ptr();\n            let len = joined_str.len();\n            let slice = std::slice::from_raw_parts(raw_ptr, len);\n            let validated = std::str::from_utf8(slice).map_err(|_| Error::new(ErrorKind::Other, \"UTF8 error\"))?;\n            safe_path = PathBuf::from(validated);\n        }\n        let path_clone = safe_path.clone();\n        let data = Arc::new(Mutex::new(String::new()));\n        let data_clone = Arc::clone(&data);\n        let handle = thread::spawn(move || {\n            let mut file = File::open(&path_clone).expect(\"unable to open file\");\n            let mut buffer = String::new();\n            file.read_to_string(&mut buffer).expect(\"unable to read file\");\n            let mut d = data_clone.lock().unwrap();\n            *d = buffer;\n        });\n        handle.join().unwrap();\n        let result = Arc::try_unwrap(data).unwrap().into_inner().unwrap();\n        Ok(result)\n    }\n}\nfn main() {\n    let handler = FileHandler::new(\"/safe/dir\");\n    let filename = \"allowed.txt\";\n    match handler.load(filename) {\n        Ok(content) => println!(\"File content: {}\", content),\n        Err(e) => eprintln!(\"Error reading file: {:?}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::{\n    fs::File,\n    io::{Error, Write},\n    path::{Path, PathBuf},\n    sync::{Arc, Mutex},\n    thread,\n};\nstruct FileServer {\n    base: PathBuf,\n}\nimpl FileServer {\n    fn new(base: &str) -> Self {\n        Self {\n            base: PathBuf::from(base),\n        }\n    }\n    fn process(&self, rel_path: &str, data: &str) -> std::io::Result<()> {\n        let target = self.base.join(rel_path);\n        let base_canon = self.base.canonicalize()?;\n        let target_canon = match target.canonicalize() {\n            Ok(path) => path,\n            Err(_) => {\n                target\n                    .parent()\n                    .and_then(|p| p.canonicalize().ok())\n                    .map(|parent| parent.join(target.file_name().unwrap()))\n                    .ok_or_else(|| Error::new(std::io::ErrorKind::Other, \"Invalid path\"))?\n            }\n        };\n        if !target_canon.starts_with(&base_canon) {\n            return Err(Error::new(\n                std::io::ErrorKind::PermissionDenied,\n                \"Access Denied: Path traversal detected\",\n            ));\n        }\n        unsafe {\n            let raw = target_canon.to_str().unwrap().as_ptr();\n            let _ = *raw;\n        }\n        let mut file = File::create(target)?;\n        file.write_all(data.as_bytes())?;\n        Ok(())\n    }\n}\nfn main() {\n    let server = Arc::new(Mutex::new(FileServer::new(\"./data\")));\n    let srv_clone = Arc::clone(&server);\n    let handle = thread::spawn(move || {\n        let server_lock = srv_clone.lock().unwrap();\n        let res = server_lock.process(\"../outside.txt\", \"safe data\");\n        if res.is_err() {\n            println!(\"Access denied as expected.\");\n        } else {\n            println!(\"Unexpected success.\");\n        }\n    });\n    handle.join().unwrap();\n    println!(\"Main operation complete (corrected version).\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::File;\nuse std::io::{Read, Error, ErrorKind};\nuse std::path::{PathBuf};\nuse std::sync::Arc;\nuse std::thread;\nstruct FileHandler {\n    base: PathBuf,\n}\nimpl FileHandler {\n    fn new(base: String) -> Self {\n        let canon_base = std::fs::canonicalize(&base)\n            .expect(\"Failed to canonicalize the base directory\");\n        Self { base: canon_base }\n    }\n    fn get(&self, input: &str) -> Result<String, Error> {\n        let joined = self.base.join(input);\n        let canon = std::fs::canonicalize(&joined)?;\n        if !canon.starts_with(&self.base) {\n            return Err(Error::new(ErrorKind::PermissionDenied, \"Disallowed path traversal attempt\"));\n        }\n        let mut file = File::open(canon)?;\n        let mut content = String::new();\n        file.read_to_string(&mut content)?;\n        Ok(content)\n    }\n}\nfn main() {\n    let handler = Arc::new(FileHandler::new(\"safe_dir\".to_string()));\n    let handler_clone = Arc::clone(&handler);\n    let t = thread::spawn(move || {\n        match handler_clone.get(\"../secret.txt\") {\n            Ok(data) => println!(\"File content: {}\", data),\n            Err(e) => println!(\"Error: {:?}\", e),\n        }\n    });\n    t.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs;\nuse std::path::{Path, PathBuf};\nuse std::thread;\nuse std::sync::Arc;\nstruct FileManager {\n    base_dir: PathBuf,\n}\nimpl FileManager {\n    fn read_content(&self, filename: &str) -> Result<String, String> {\n        let candidate_path = self.base_dir.join(filename);\n        let canonical_candidate = fs::canonicalize(&candidate_path)\n            .map_err(|e| format!(\"Error canonicalizing candidate: {}\", e))?;\n        let canonical_base = fs::canonicalize(&self.base_dir)\n            .map_err(|e| format!(\"Error canonicalizing base: {}\", e))?;\n        if !canonical_candidate.starts_with(&canonical_base) {\n            return Err(\"Access denied: Path traversal attempt detected\".into());\n        }\n        unsafe {\n            let raw_ptr: *const u8 = std::ptr::null();\n            if !raw_ptr.is_null() {\n                let _ = *raw_ptr;\n            }\n        }\n        fs::read_to_string(&canonical_candidate).map_err(|e| format!(\"Error: {}\", e))\n    }\n}\nfn main() {\n    let base = PathBuf::from(\"./allowed_files\");\n    let manager = Arc::new(FileManager { base_dir: base });\n    let filenames = vec![\"test.txt\", \"../secret.txt\"];\n    let mut handles = vec![];\n    for name in filenames {\n        let mgr = Arc::clone(&manager);\n        let handle = thread::spawn(move || {\n            match mgr.read_content(name) {\n                Ok(content) => content,\n                Err(err) => err,\n            }\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        match handle.join() {\n            Ok(result) => println!(\"Output: {}\", result),\n            Err(_) => println!(\"Thread panicked\"),\n        }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::File;\nuse std::io::{self, Read};\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\nuse std::thread;\nstruct Loader {\n    base: PathBuf,\n}\nimpl Loader {\n    fn new(base: &str) -> Self {\n        let canonical_base = std::fs::canonicalize(base).expect(\"Invalid base directory\");\n        Loader { base: canonical_base }\n    }\n    fn is_allowed(&self, candidate: &Path) -> bool {\n        if let Ok(canonical_candidate) = candidate.canonicalize() {\n            canonical_candidate.starts_with(&self.base)\n        } else {\n            false\n        }\n    }\n    fn load_file(&self, relative: &str) -> io::Result<String> {\n        let full_path = self.base.join(relative);\n        if !self.is_allowed(&full_path) {\n            return Err(io::Error::new(\n                io::ErrorKind::PermissionDenied,\n                \"Path traversal detected\",\n            ));\n        }\n        let file = File::open(&full_path)?;\n        let metadata = file.metadata()?;\n        let size = metadata.len() as usize;\n        let mut buffer = Vec::with_capacity(size);\n        let shared_file = Arc::new(file);\n        let mut handles = vec![];\n        let part = if size >= 2 { size / 2 } else { size };\n        for i in 0..2 {\n            let _file_clone = Arc::clone(&shared_file);\n            let start = i * part;\n            let end = if i == 1 { size } else { (i + 1) * part };\n            let mut local_buf = vec![0u8; end - start];\n            let handle = thread::spawn(move || {\n                unsafe {\n                    let ptr = local_buf.as_mut_ptr();\n                    for j in 0..(end - start) {\n                        *ptr.add(j) = 0;\n                    }\n                }\n                (start, local_buf)\n            });\n            handles.push(handle);\n        }\n        for handle in handles {\n            let (_start, local_buf) = handle.join().unwrap();\n            buffer.extend(local_buf);\n        }\n        let content = String::from_utf8_lossy(&buffer).to_string();\n        Ok(content)\n    }\n}\nfn main() {\n    let loader = Loader::new(\"./safe_dir\");\n    let args: Vec<String> = std::env::args().collect();\n    let target = if args.len() > 1 { &args[1] } else { \"example.txt\" };\n    match loader.load_file(target) {\n        Ok(content) => println!(\"File content: {}\", content),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::fs;\nuse std::io::{Error, ErrorKind};\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\nuse std::thread;\nstruct FileHandler {\n    base: PathBuf,\n}\nimpl FileHandler {\n    fn new(base: &str) -> Self {\n        Self { base: PathBuf::from(base) }\n    }\n    fn get_content(&self, input: &str) -> std::io::Result<String> {\n        let joined = self.base.join(input);\n        let canon_joined = joined.canonicalize()?;\n        let canon_base = self.base.canonicalize()?;\n        if !canon_joined.starts_with(&canon_base) {\n            return Err(Error::new(ErrorKind::PermissionDenied, \"Path traversal attempt detected\"));\n        }\n        unsafe {\n            let s = canon_joined.as_os_str().to_str().unwrap();\n            let ptr = s.as_ptr();\n            let _ = *ptr;\n        }\n        fs::read_to_string(canon_joined)\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let handler = Arc::new(FileHandler::new(\"./data\"));\n    if args.len() < 2 {\n        println!(\"Usage: {} <filename>\", args[0]);\n        return;\n    }\n    let input = args[1].clone();\n    let handler_clone = handler.clone();\n    let thread_handle = thread::spawn(move || {\n        match handler_clone.get_content(&input) {\n            Ok(c) => println!(\"Content:\\n{}\", c),\n            Err(e) => println!(\"Error encountered: {}\", e),\n        }\n    });\n    let _ = thread_handle.join();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct DataHolder {\n    data: Vec<u8>,\n}\nimpl DataHolder {\n    fn new() -> Self {\n        DataHolder { data: vec![1, 2, 3, 4, 5] }\n    }\n    pub fn fetch(&self, idx: usize) -> u8 {\n        self.data.get(idx).copied().expect(\"Index out of bounds in safe read\")\n    }\n}\npub fn execute() -> u8 {\n    let holder = Arc::new(DataHolder::new());\n    let shared = Arc::clone(&holder);\n    let handle = thread::spawn(move || {\n        shared.fetch(2)\n    });\n    handle.join().unwrap()\n}\nfn main() {\n    let res = execute();\n    println!(\"Result: {}\", res);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Processor {\n    buffer: Vec<u32>,\n}\nimpl Processor {\n    fn new() -> Self {\n        Processor { buffer: vec![100, 200, 300, 400, 500] }\n    }\n    fn operate(&self, idx: usize) -> Option<u32> {\n        if idx < self.buffer.len() {\n            Some(self.buffer[idx])\n        } else {\n            None\n        }\n    }\n}\nfn run_op() -> Option<u32> {\n    let proc = Processor::new();\n    proc.operate(5)\n}\nfn main() {\n    let shared = Arc::new(Processor::new());\n    let shared_clone = Arc::clone(&shared);\n    let handle = thread::spawn(move || {\n        run_op()\n    });\n    match handle.join() {\n        Ok(result) => println!(\"Operation result: {:?}\", result),\n        Err(_) => println!(\"Thread panicked\"),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Processor {\n    data: Box<[u32]>,\n}\nimpl Processor {\n    fn compute(&self, start: usize, count: usize) -> u32 {\n        if start.checked_add(count).unwrap_or(usize::MAX) > self.data.len() {\n            panic!(\"Index out-of-bounds in compute\");\n        }\n        let slice = &self.data[start..start + count];\n        slice.iter().sum()\n    }\n}\nfn main() {\n    let proc = Processor { data: Box::new([10, 20, 30, 40, 50]) };\n    let arc_proc = Arc::new(proc);\n    let handles: Vec<_> = (0..3).map(|_| {\n        let p = Arc::clone(&arc_proc);\n        thread::spawn(move || {\n            p.compute(2, 4)\n        })\n    }).collect();\n    for handle in handles {\n        let _ = handle.join().unwrap_or_else(|err| {\n            eprintln!(\"Thread panicked: {:?}\", err);\n            0\n        });\n    }\n    println!(\"Completed execution.\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\ntrait Compute {\n    fn compute(&self) -> u32;\n}\nstruct DataHolder {\n    data: Vec<u32>,\n}\nimpl Compute for DataHolder {\n    fn compute(&self) -> u32 {\n        let len = self.data.len();\n        if len < 2 {\n            return 0;\n        }\n        let mut total: u32 = 0;\n        for i in 0..(len - 1) {\n            let first = self.data[i];\n            let second = self.data[i + 1];\n            total = total.wrapping_add(first).wrapping_add(second);\n        }\n        total\n    }\n}\nfn spawn_task(holder: Arc<Mutex<DataHolder>>) {\n    let handle = thread::spawn(move || {\n        let guard = holder.lock().unwrap();\n        let sum = guard.compute();\n        println!(\"Computed value: {}\", sum);\n    });\n    handle.join().unwrap();\n}\nfn main() {\n    let holder = Arc::new(Mutex::new(DataHolder { data: vec![1, 2, 3, 4, 5] }));\n    spawn_task(holder.clone());\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\npub mod app {\n    use super::*;\n    pub struct Processor {\n        data: Arc<Vec<u8>>,\n    }\n    impl Processor {\n        pub fn new(v: Vec<u8>) -> Self {\n            Self { data: Arc::new(v) }\n        }\n        pub fn compute(&self, idx: usize) -> Option<u8> {\n            self.data.get(idx).cloned()\n        }\n    }\n    pub fn run_app() {\n        let vec_data = vec![10u8, 20, 30];\n        let proc_obj = Processor::new(vec_data);\n        let shared_proc = Arc::new(proc_obj);\n        let mut handles = vec![];\n        for _ in 0..4 {\n            let proc_clone = shared_proc.clone();\n            handles.push(thread::spawn(move || {\n                proc_clone.compute(3)\n            }));\n        }\n        for handle in handles {\n            let result = handle.join().expect(\"Thread panicked\");\n            match result {\n                Some(val) => println!(\"Result: {}\", val),\n                None => println!(\"Out-of-bounds access safely detected\"),\n            }\n        }\n    }\n}\nfn main() {\n    app::run_app();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Buffer {\n    data: Vec<u32>,\n}\nimpl Buffer {\n    pub fn compute_sum(&self, start: usize, count: usize) -> Result<u32, &'static str> {\n        if start.checked_add(count).map_or(true, |n| n > self.data.len()) {\n            return Err(\"Out-of-bound access\");\n        }\n        Ok(self.data[start..start+count].iter().sum())\n    }\n}\nfn main() {\n    let buffer = Arc::new(Buffer { data: vec![1, 2, 3, 4] });\n    let buf_clone = Arc::clone(&buffer);\n    let handle = thread::spawn(move || {\n        match buf_clone.compute_sum(0, 5) {\n            Ok(sum) => sum,\n            Err(e) => {\n                eprintln!(\"Error: {}\", e);\n                0\n            }\n        }\n    });\n    let safe_sum: u32 = buffer.data.iter().sum();\n    let checked_sum = handle.join().unwrap();\n    println!(\"Safe sum: {}, Checked sum: {}\", safe_sum, checked_sum);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::Arc;\nuse std::thread;\nstruct Buffer {\n    data: Vec<u8>,\n}\nimpl Buffer {\n    pub fn new(data: Vec<u8>) -> Self {\n        Buffer { data }\n    }\n    pub fn fetch(&self, idx: usize) -> u8 {\n        if idx == 0 || idx > self.data.len() {\n            panic!(\"Index out of bounds\");\n        }\n        self.data[idx - 1]\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let index: usize = if args.len() > 1 {\n        args[1].parse().unwrap_or(0)\n    } else {\n        0\n    };\n    let shared = Arc::new(Buffer::new(vec![10, 20, 30, 40]));\n    let shared_clone = Arc::clone(&shared);\n    let handle = thread::spawn(move || {\n        let val = shared_clone.fetch(index);\n        println!(\"Thread Fetched value: {}\", val);\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\npub struct DataHolder {\n    data: Vec<u32>,\n}\nimpl DataHolder {\n    pub fn new(v: Vec<u32>) -> Self {\n        DataHolder { data: v }\n    }\n    pub fn retrieve(&self, idx: usize) -> Option<u32> {\n        self.data.get(idx).cloned()\n    }\n}\nfn main() {\n    let holder = DataHolder::new(vec![10, 20, 30]);\n    let shared = Arc::new(Mutex::new(holder));\n    let mut handles = vec![];\n    for i in 0..5 {\n        let shared_clone = Arc::clone(&shared);\n        handles.push(thread::spawn(move || {\n            let holder = shared_clone.lock().unwrap();\n            let index = i * 2;\n            match holder.retrieve(index) {\n                Some(value) => println!(\"Thread {} read: {}\", i, value),\n                None => println!(\"Thread {}: index {} out-of-bound\", i, index),\n            }\n        }));\n    }\n    for handle in handles {\n        let _ = handle.join();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::sync::Arc;\nuse std::thread;\nstruct Processor {\n    data: Vec<u32>,\n}\nimpl Processor {\n    fn new(data: Vec<u32>) -> Self {\n        Processor { data }\n    }\n    fn process_at(&self, index: usize) -> Result<u32, &'static str> {\n        if index < self.data.len() {\n            unsafe {\n                Ok(*self.data.as_ptr().add(index))\n            }\n        } else {\n            Err(\"Index out of bounds\")\n        }\n    }\n}\nfn execute(index: usize) -> Result<u32, &'static str> {\n    let proc = Processor::new(vec![10, 20, 30, 40]);\n    let proc_arc = Arc::new(proc);\n    let proc_clone = Arc::clone(&proc_arc);\n    let handle = thread::spawn(move || {\n        proc_clone.process_at(index)\n    });\n    handle.join().unwrap()\n}\nfn main() {\n    let idx = 4;\n    match execute(idx) {\n        Ok(val) => println!(\"Result: {}\", val),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Processor {\n    data: Vec<u8>,\n}\nimpl Processor {\n    fn new(data: Vec<u8>) -> Self {\n        Processor { data }\n    }\n    fn extract(&self, index: usize) -> Option<u8> {\n        if index < self.data.len() {\n            Some(self.data[index])\n        } else {\n            None\n        }\n    }\n}\nfn run_task(proc: Arc<Processor>, idx: usize) -> Option<u8> {\n    proc.extract(idx)\n}\nfn main() {\n    let data = vec![10, 20, 30]; \n    let proc = Arc::new(Processor::new(data));\n    let index = 3; \n    let proc_clone = Arc::clone(&proc);\n    let handle = thread::spawn(move || run_task(proc_clone, index));\n    let result = handle.join().unwrap();\n    println!(\"Extracted value: {:?}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct DataHandler {\n    data: Vec<u32>,\n}\nimpl DataHandler {\n    fn new(vec: Vec<u32>) -> Self {\n        Self { data: vec }\n    }\n    fn get_item(&self, index: usize) -> Result<u32, &'static str> {\n        if index < self.data.len() {\n            Ok(self.data[index])\n        } else {\n            Err(\"Index out-of-range\")\n        }\n    }\n}\nfn main() {\n    let handler = Arc::new(DataHandler::new(vec![100, 200, 300, 400]));\n    let handler_clone = Arc::clone(&handler);\n    let handle = thread::spawn(move || {\n        match handler_clone.get_item(4) {\n            Ok(val) => println!(\"Read value: {}\", val),\n            Err(e) => println!(\"Error: {}\", e),\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Buffer {\n    data: Vec<u32>,\n}\nimpl Buffer {\n    fn read_value(&self, index: usize) -> u32 {\n        if index == 0 {\n            0\n        } else if index - 1 < self.data.len() {\n            unsafe {\n                let ptr = self.data.as_ptr().offset((index as isize) - 1);\n                *ptr\n            }\n        } else {\n            0\n        }\n    }\n}\nfn main() {\n    let shared = Arc::new(Buffer { data: vec![10, 20, 30] });\n    let shared_clone = Arc::clone(&shared);\n    let handle = thread::spawn(move || {\n        let result = shared_clone.read_value(0);\n        println!(\"Result: {}\", result);\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct DataContainer {\n    items: Vec<u32>,\n}\nimpl DataContainer {\n    fn new(count: usize) -> Self {\n        DataContainer {\n            items: (0..count as u32).collect(),\n        }\n    }\n    fn read_item(&self, index: usize) -> Option<u32> {\n        self.items.get(index).copied()\n    }\n}\nfn main() {\n    let container = Arc::new(DataContainer::new(10));\n    let shared = container.clone();\n    let handle = thread::spawn(move || {\n        let result = shared.read_item(10);\n        match result {\n            Some(val) => println!(\"Thread read value: {}\", val),\n            None => println!(\"Out-of-bound access prevented\"),\n        }\n    });\n    let _ = handle.join();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process;\ntrait AccessItem {\n    fn retrieve(&self, idx: usize) -> Result<u32, &'static str>;\n}\nstruct Buffer {\n    data: &'static [u32],\n}\nimpl AccessItem for Buffer {\n    fn retrieve(&self, idx: usize) -> Result<u32, &'static str> {\n        if idx < self.data.len() {\n            Ok(self.data[idx])\n        } else {\n            Err(\"index out of bounds\")\n        }\n    }\n}\nfn create_buffer() -> Buffer {\n    static FULL: [u32; 4] = [10, 20, 30, 0];\n    let slice = &FULL[..3];\n    Buffer { data: slice }\n}\nfn run(idx: usize) -> Result<u32, &'static str> {\n    let buffer = create_buffer();\n    buffer.retrieve(idx)\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() != 2 {\n        eprintln!(\"Usage: cargo run <index>\");\n        process::exit(1);\n    }\n    let idx: usize = args[1].parse().unwrap_or(0);\n    match run(idx) {\n        Ok(val) => println!(\"Value: {}\", val),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Container {\n    buffer: Vec<u32>,\n}\nimpl Container {\n    fn compute(&self) -> u32 {\n        self.buffer.last().copied().expect(\"Buffer should not be empty\")\n    }\n}\nfn main() {\n    let container = Arc::new(Container { buffer: vec![1, 2, 3, 4, 5] });\n    let container_clone = Arc::clone(&container);\n    let handle = thread::spawn(move || container_clone.compute());\n    let res = handle.join().unwrap();\n    println!(\"Result: {}\", res);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nstruct Processor {\n    data: Arc<Vec<i32>>,\n}\ntrait Calculation {\n    fn compute(&self, start: usize, count: usize) -> Result<i32, &'static str>;\n}\nimpl Calculation for Processor {\n    fn compute(&self, start: usize, count: usize) -> Result<i32, &'static str> {\n        let slice = &self.data;\n        if start.checked_add(count).map_or(true, |end| end > slice.len()) {\n            return Err(\"Index out-of-bounds\");\n        }\n        let mut total = 0;\n        for i in 0..count {\n            total += slice.get(start + i).unwrap();\n        }\n        Ok(total)\n    }\n}\nfn main() {\n    let proc_inst = Processor { data: Arc::new(vec![10, 20, 30, 40]) };\n    match proc_inst.compute(3, 2) {\n        Ok(result) => println!(\"Computed sum: {}\", result),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Buffer {\n    data: Vec<u32>,\n}\nimpl Buffer {\n    fn new(n: usize) -> Self {\n        let mut data = Vec::with_capacity(n);\n        for i in 0..n {\n            data.push(i as u32);\n        }\n        Buffer { data }\n    }\n    fn safe_read(&self, idx: usize) -> Option<u32> {\n        if idx < self.data.len() {\n            unsafe { Some(*self.data.get_unchecked(idx)) }\n        } else {\n            None\n        }\n    }\n    pub fn read_value_public(&self, idx: usize) -> Option<u32> {\n        if idx < self.data.len() {\n            unsafe { Some(*self.data.get_unchecked(idx)) }\n        } else {\n            None\n        }\n    }\n}\nfn main() {\n    let buffer = Arc::new(Buffer::new(10));\n    let mut handles = vec![];\n    for i in 0..5 {\n        let buf_clone = Arc::clone(&buffer);\n        handles.push(thread::spawn(move || {\n            let index = if i == 2 { 12 } else { i };\n            buf_clone.safe_read(index).unwrap_or(0)\n        }));\n    }\n    for handle in handles {\n        let res = handle.join().unwrap();\n        println!(\"Output: {}\", res);\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Buffer {\n    data: Box<[i32]>,\n}\nimpl Buffer {\n    fn new(v: Vec<i32>) -> Self {\n        Buffer { data: v.into_boxed_slice() }\n    }\n    fn access(&self, idx: usize) -> Option<i32> {\n        self.data.get(idx).cloned()\n    }\n}\nfn execute(buffer: Arc<Buffer>, idx: usize) -> Option<i32> {\n    buffer.access(idx)\n}\nfn main() {\n    let buffer = Arc::new(Buffer::new((0..10).collect()));\n    let idx = 15; \n    let handle = {\n        let buf = Arc::clone(&buffer);\n        thread::spawn(move || {\n            execute(buf, idx)\n        })\n    };\n    match handle.join().unwrap() {\n        Some(val) => println!(\"Result: {}\", val),\n        None => println!(\"None\"),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\n#[repr(C)]\nstruct Buffer {\n    data: [i32; 4],\n    guard: i32,\n}\nimpl Buffer {\n    fn calculate(&self) -> i32 {\n        let n = self.data.len();\n        let mut sum = 0;\n        unsafe {\n            let ptr = self.data.as_ptr();\n            for i in 0..n {\n                sum += *ptr.add(i);\n            }\n        }\n        sum\n    }\n}\nfn main() {\n    let buf = Buffer { data: [1, 2, 3, 4], guard: 42 };\n    let shared = Arc::new(buf);\n    let shared_clone = Arc::clone(&shared);\n    let handler = thread::spawn(move || {\n        shared_clone.calculate()\n    });\n    let res = handler.join().unwrap();\n    println!(\"Computed sum: {}\", res);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nstruct DataStore {\n    buffer: Vec<u8>,\n}\nimpl DataStore {\n    fn new() -> Self {\n        DataStore {\n            buffer: vec![10, 20, 30, 40, 50],\n        }\n    }\n    fn fetch(&self, position: usize) -> u8 {\n        self.buffer.get(position).copied().expect(\"Index out-of-bounds\")\n    }\n}\nfn main() {\n    let store = DataStore::new();\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        eprintln!(\"Usage: {} <index>\", args[0]);\n        return;\n    }\n    let pos: usize = args[1].parse().unwrap_or(0);\n    let value = store.fetch(pos);\n    println!(\"Fetched value: {}\", value);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicUsize, Ordering};\nstatic DROP_COUNT: AtomicUsize = AtomicUsize::new(0);\nstruct Data {\n    value: u32,\n}\nimpl Drop for Data {\n    fn drop(&mut self) {\n        DROP_COUNT.fetch_add(1, Ordering::SeqCst);\n    }\n}\nfn process_data() {\n    let data = Box::new(Data { value: 42 });\n    let raw_ptr = Box::into_raw(data);\n    unsafe {\n        drop(Box::from_raw(raw_ptr));\n    }\n}\npub fn run_simulation() -> usize {\n    DROP_COUNT.store(0, Ordering::SeqCst);\n    process_data();\n    DROP_COUNT.load(Ordering::SeqCst)\n}\nfn main() {\n    let drops = run_simulation();\n    println!(\"Drop count: {}\", drops);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicUsize, Ordering};\nstatic FREE_COUNT: AtomicUsize = AtomicUsize::new(0);\npub struct Resource {\n    data: *mut i32,\n}\nimpl Resource {\n    pub unsafe fn new(val: i32) -> Self {\n        let boxed = Box::new(val);\n        let ptr = Box::into_raw(boxed);\n        Self { data: ptr }\n    }\n    pub unsafe fn release(&mut self) {\n        if !self.data.is_null() {\n            FREE_COUNT.fetch_add(1, Ordering::SeqCst);\n            let _ = Box::from_raw(self.data);\n            self.data = std::ptr::null_mut();\n        }\n    }\n}\nimpl Drop for Resource {\n    fn drop(&mut self) {\n        unsafe {\n            if !self.data.is_null() {\n                FREE_COUNT.fetch_add(1, Ordering::SeqCst);\n                let _ = Box::from_raw(self.data);\n                self.data = std::ptr::null_mut();\n            }\n        }\n    }\n}\nfn main() {\n    unsafe {\n        let mut res = Resource::new(42);\n        res.release();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicUsize, AtomicBool, Ordering};\nuse std::sync::Arc;\nuse std::thread;\nstatic FREED: AtomicUsize = AtomicUsize::new(0);\nunsafe fn custom_release(ptr: *mut i32) {\n    if FREED.fetch_add(1, Ordering::SeqCst) >= 1 {\n        panic!(\"Double free detected\");\n    }\n    drop(Box::from_raw(ptr));\n}\nstruct Resource {\n    ptr: *mut i32,\n    freed: AtomicBool,\n}\nunsafe impl Send for Resource {}\nunsafe impl Sync for Resource {}\nimpl Resource {\n    fn new(val: i32) -> Self {\n        let boxed = Box::new(val);\n        let ptr = Box::into_raw(boxed);\n        Resource { \n            ptr, \n            freed: AtomicBool::new(false) \n        }\n    }\n    fn release(&self) {\n        if !self.freed.swap(true, Ordering::SeqCst) {\n            unsafe {\n                custom_release(self.ptr);\n            }\n        }\n    }\n}\nimpl Drop for Resource {\n    fn drop(&mut self) {\n        if !self.freed.load(Ordering::SeqCst) {\n            unsafe {\n                custom_release(self.ptr);\n            }\n        }\n    }\n}\nfn main() {\n    let res = Arc::new(Resource::new(42));\n    let res_clone = Arc::clone(&res);\n    let handle = thread::spawn(move || {\n        res_clone.release();\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nstruct Data {\n    value: i32,\n}\nimpl Data {\n    fn new(v: i32) -> Self {\n        Data { value: v }\n    }\n}\npub fn run() -> i32 {\n    let resource = Box::new(Data::new(10));\n    let raw_ptr = Box::into_raw(resource);\n    unsafe {\n        let box_a = Box::from_raw(raw_ptr);\n        box_a.value * 2\n    }\n}\nfn main() {\n    println!(\"Result: {}\", run());\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::ptr;\nstruct Data {\n    value: u32,\n}\nstruct Owner {\n    ptr: *mut Data,\n}\nimpl Owner {\n    fn new(val: u32) -> Self {\n        let boxed = Box::new(Data { value: val });\n        Owner { ptr: Box::into_raw(boxed) }\n    }\n    unsafe fn release(&mut self) {\n        if !self.ptr.is_null() {\n            Box::from_raw(self.ptr);\n            self.ptr = ptr::null_mut();\n        }\n    }\n}\nimpl Drop for Owner {\n    fn drop(&mut self) {\n        unsafe {\n            if !self.ptr.is_null() {\n                Box::from_raw(self.ptr);\n                self.ptr = ptr::null_mut();\n            }\n        }\n    }\n}\npub fn app_run() {\n    let mut owner = Owner::new(42);\n    unsafe {\n        owner.release();\n    }\n}\nfn main() {\n    app_run();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "struct Data {\n    ptr: *mut i32,\n}\nimpl Data {\n    fn new(val: i32) -> Self {\n        let b = Box::new(val);\n        Self { ptr: Box::into_raw(b) }\n    }\n}\nimpl Clone for Data {\n    fn clone(&self) -> Self {\n        unsafe {\n            let value = *self.ptr;\n            Data::new(value)\n        }\n    }\n}\nimpl Drop for Data {\n    fn drop(&mut self) {\n        unsafe {\n            let _ = Box::from_raw(self.ptr);\n        }\n    }\n}\nfn execute() {\n    let original = Data::new(42);\n    let duplicate = original.clone();\n    let sum = unsafe { *original.ptr + *duplicate.ptr };\n    println!(\"Sum: {}\", sum);\n}\nfn main() {\n    execute();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "struct SafeData {\n    ptr: Option<*mut i32>,\n}\nimpl SafeData {\n    fn new(val: i32) -> Self {\n        let boxed = Box::new(val);\n        SafeData { ptr: Some(Box::into_raw(boxed)) }\n    }\n    fn get(&self) -> i32 {\n        unsafe { *self.ptr.expect(\"Pointer should be valid\") }\n    }\n}\nimpl Drop for SafeData {\n    fn drop(&mut self) {\n        if let Some(p) = self.ptr.take() {\n            unsafe {\n                let _ = Box::from_raw(p);\n            }\n        }\n    }\n}\nfn run_app() -> i32 {\n    let instance = SafeData::new(100);\n    instance.get()\n}\nfn main() {\n    let _ = run_app();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicUsize, Ordering};\nuse std::ptr;\nstatic GLOBAL_COUNT: AtomicUsize = AtomicUsize::new(0);\nstruct Handler {\n    raw: *mut i32,\n}\nimpl Handler {\n    unsafe fn create(num: i32) -> Self {\n        let boxed = Box::new(num);\n        Self {\n            raw: Box::into_raw(boxed),\n        }\n    }\n    unsafe fn dispose(&mut self) {\n        if !self.raw.is_null() {\n            if GLOBAL_COUNT.fetch_add(1, Ordering::SeqCst) >= 1 {\n                panic!(\"Double free detected in dispose\");\n            }\n            let _ = Box::from_raw(self.raw);\n            self.raw = ptr::null_mut(); \n        }\n    }\n}\nimpl Drop for Handler {\n    fn drop(&mut self) {\n        unsafe {\n            if !self.raw.is_null() {\n                if GLOBAL_COUNT.fetch_add(1, Ordering::SeqCst) >= 1 {\n                    panic!(\"Double free detected in Drop\");\n                }\n                let _ = Box::from_raw(self.raw);\n            }\n        }\n    }\n}\nfn main() {\n    unsafe {\n        let mut obj = Handler::create(200);\n        obj.dispose(); \n    }\n    println!(\"Execution completed (corrected path).\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nuse std::sync::{Arc, Barrier, Mutex};\nstruct Resource {\n    inner: Arc<Mutex<Option<*mut i32>>>,\n}\nimpl Resource {\n    fn new(val: i32) -> Self {\n        let boxed = Box::new(val);\n        Resource {\n            inner: Arc::new(Mutex::new(Some(Box::into_raw(boxed)))),\n        }\n    }\n    fn get(&self) -> i32 {\n        let guard = self.inner.lock().unwrap();\n        if let Some(raw) = *guard {\n            unsafe { *raw }\n        } else {\n            panic!(\"Attempted to access resource after deallocation\");\n        }\n    }\n}\nimpl Drop for Resource {\n    fn drop(&mut self) {\n        let mut guard = self.inner.lock().unwrap();\n        if let Some(raw) = guard.take() {\n            unsafe {\n                Box::from_raw(raw);\n            }\n        }\n    }\n}\nfn main() {\n    let resource = Resource::new(500);\n    let barrier = Arc::new(Barrier::new(2));\n    let shared = Arc::clone(&resource.inner);\n    let barrier_thread = barrier.clone();\n    let handler = thread::spawn(move || {\n        barrier_thread.wait();\n        let guard = shared.lock().unwrap();\n        if let Some(raw) = *guard {\n            let val = unsafe { *raw };\n            println!(\"Thread sees value: {}\", val);\n        }\n    });\n    barrier.wait();\n    handler.join().unwrap();\n    println!(\"Value: {}\", resource.get());\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::ptr;\nuse std::sync::atomic::{AtomicUsize, Ordering};\nstatic FREE_COUNT: AtomicUsize = AtomicUsize::new(0);\nstruct Resource {\n    ptr: *mut i32,\n}\nimpl Resource {\n    unsafe fn new(val: i32) -> Self {\n        let b = Box::new(val);\n        Self { ptr: Box::into_raw(b) }\n    }\n    unsafe fn manual_drop(&mut self) {\n        if !self.ptr.is_null() {\n            if FREE_COUNT.fetch_add(1, Ordering::SeqCst) >= 1 {\n                panic!(\"Double free detected\");\n            }\n            let _ = Box::from_raw(self.ptr);\n            self.ptr = ptr::null_mut();\n        }\n    }\n}\nimpl Drop for Resource {\n    fn drop(&mut self) {\n        unsafe {\n            if !self.ptr.is_null() {\n                if FREE_COUNT.fetch_add(1, Ordering::SeqCst) >= 1 {\n                    panic!(\"Double free detected\");\n                }\n                let _ = Box::from_raw(self.ptr);\n            }\n        }\n    }\n}\nfn main() {\n    unsafe {\n        let mut res = Resource::new(100);\n        res.manual_drop();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicBool, Ordering};\nstatic FREED: AtomicBool = AtomicBool::new(false);\nstruct Resource {\n    value: i32,\n}\nimpl Drop for Resource {\n    fn drop(&mut self) {\n        if FREED.compare_exchange(false, true, Ordering::SeqCst, Ordering::SeqCst).is_err() {\n            panic!(\"double free detected\");\n        }\n    }\n}\nfn safe_release() {\n    let mem = Box::new(Resource { value: 42 });\n    let raw_ptr = Box::into_raw(mem);\n    unsafe {\n        let _owner = Box::from_raw(raw_ptr);\n    }\n}\nfn run() {\n    safe_release();\n}\nfn main() {\n    run();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::thread;\ntrait Operations {\n    unsafe fn release(&mut self);\n}\npub struct Manager {\n    ptr: *mut i32,\n    is_freed: bool,\n}\nimpl Manager {\n    pub unsafe fn initialize(value: i32) -> Self {\n        let boxed = Box::new(value);\n        Manager {\n            ptr: Box::into_raw(boxed),\n            is_freed: false,\n        }\n    }\n    pub unsafe fn process(&mut self) {\n        self.release();\n    }\n}\nimpl Operations for Manager {\n    unsafe fn release(&mut self) {\n        if self.is_freed {\n            return; \n        }\n        let _ = Box::from_raw(self.ptr);\n        self.is_freed = true;\n    }\n}\nimpl Drop for Manager {\n    fn drop(&mut self) {\n        unsafe {\n            if !self.is_freed {\n                let _ = Box::from_raw(self.ptr);\n                self.is_freed = true;\n            }\n        }\n    }\n}\npub fn simulate() {\n    unsafe {\n        let mut resource = Manager::initialize(100);\n        resource.process();\n    }\n}\nfn main() {\n    simulate();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "struct Resource {\n    data: i32,\n}\nstatic mut FREED: bool = false;\nunsafe fn deallocate_once(ptr: *mut Resource) {\n    if !FREED {\n        FREED = true;\n        let _ = Box::from_raw(ptr);\n    }\n}\nfn execute() {\n    let resource = Box::new(Resource { data: 42 });\n    let raw_ptr = Box::into_raw(resource);\n    unsafe {\n        deallocate_once(raw_ptr);\n    }\n}\nfn main() {\n    execute();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicUsize, Ordering};\nstatic GLOBAL_FREE_COUNT: AtomicUsize = AtomicUsize::new(0);\npub struct Resource {\n    ptr: *mut i32,\n}\nunsafe impl Send for Resource {}\nimpl Resource {\n    pub fn new(val: i32) -> Self {\n        let boxed = Box::new(val);\n        let ptr = Box::into_raw(boxed);\n        Self { ptr }\n    }\n    pub unsafe fn manual_release(&mut self) {\n        if !self.ptr.is_null() {\n            let _ = Box::from_raw(self.ptr);\n            GLOBAL_FREE_COUNT.fetch_add(1, Ordering::SeqCst);\n            self.ptr = std::ptr::null_mut();\n        }\n    }\n    pub unsafe fn get_value(&self) -> Option<i32> {\n        if self.ptr.is_null() {\n            None\n        } else {\n            Some(*self.ptr)\n        }\n    }\n}\nimpl Drop for Resource {\n    fn drop(&mut self) {\n        unsafe {\n            if !self.ptr.is_null() {\n                let _ = Box::from_raw(self.ptr);\n                GLOBAL_FREE_COUNT.fetch_add(1, Ordering::SeqCst);\n            }\n        }\n    }\n}\npub fn free_count() -> usize {\n    GLOBAL_FREE_COUNT.load(Ordering::SeqCst)\n}\npub fn run() {\n    let mut res = Resource::new(42);\n    unsafe {\n        res.manual_release();\n    }\n}\nfn main() {\n    run();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\npub struct Resource {\n    data: Arc<i32>,\n}\nimpl Resource {\n    pub fn new(val: i32) -> Self {\n        Resource { data: Arc::new(val) }\n    }\n}\nimpl Clone for Resource {\n    fn clone(&self) -> Self {\n        Resource { data: Arc::clone(&self.data) }\n    }\n}\nfn main() {\n    let resource = Resource::new(100);\n    let handle = thread::spawn({\n        let clone_resource = resource.clone();\n        move || {\n            let _ = clone_resource;\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "struct Item {\n    data: *mut i32,\n}\nimpl Item {\n    fn new() -> Self {\n        let boxed = Box::new(100);\n        Item { data: Box::into_raw(boxed) }\n    }\n    fn value(&self) -> i32 {\n        unsafe { *self.data }\n    }\n    fn from_value(val: i32) -> Self {\n        let boxed = Box::new(val);\n        Item { data: Box::into_raw(boxed) }\n    }\n}\nimpl Clone for Item {\n    fn clone(&self) -> Self {\n        let val = self.value();\n        Item::from_value(val)\n    }\n}\nimpl Drop for Item {\n    fn drop(&mut self) {\n        unsafe {\n            drop(Box::from_raw(self.data));\n        }\n    }\n}\nfn run_app() {\n    let first = Item::new();\n    let second = first.clone();\n    println!(\"Values: {} and {}\", first.value(), second.value());\n}\nfn main() {\n    run_app();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicBool, Ordering};\nuse std::ptr;\nuse std::mem;\nuse std::boxed::Box;\nstatic FREED: AtomicBool = AtomicBool::new(false);\npub struct Data {\n    pub value: i32,\n}\nimpl Data {\n    pub fn new(val: i32) -> Self {\n        Data { value: val }\n    }\n}\nunsafe fn deallocate(ptr: *mut Data) {\n    if FREED.swap(true, Ordering::SeqCst) {\n        panic!(\"Double free detected!\");\n    }\n    Box::from_raw(ptr);\n}\nfn obtain_pointer() -> *mut Data {\n    let data = Box::new(Data::new(42));\n    Box::into_raw(data)\n}\nfn process() {\n    let raw = obtain_pointer();\n    unsafe {\n        deallocate(raw);\n    }\n}\nfn main() {\n    process();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicBool, Ordering};\nstatic FREED: AtomicBool = AtomicBool::new(false);\nstruct Resource {\n    value: i32,\n}\nimpl Drop for Resource {\n    fn drop(&mut self) {\n        if FREED.swap(true, Ordering::SeqCst) {\n            panic!(\"Double free detected in drop!\");\n        }\n    }\n}\nfn process() {\n    let boxed = Box::new(Resource { value: 42 });\n    let raw_ptr = Box::into_raw(boxed);\n    unsafe {\n        let recovered = Box::from_raw(raw_ptr);\n        drop(recovered);\n    }\n}\nfn main() {\n    process();\n    println!(\"Completed corrected main function\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicUsize, Ordering};\nstatic GLOBAL_DROP: AtomicUsize = AtomicUsize::new(0);\nstruct Resource {\n    data: i32,\n}\nimpl Resource {\n    fn new(val: i32) -> Self {\n        Resource { data: val }\n    }\n}\nimpl Drop for Resource {\n    fn drop(&mut self) {\n        GLOBAL_DROP.fetch_add(1, Ordering::SeqCst);\n    }\n}\nfn process_resource() {\n    unsafe {\n        let boxed = Box::new(Resource::new(100));\n        let raw = Box::into_raw(boxed);\n        {\n            let _holder = Box::from_raw(raw);\n        }\n    }\n}\nfn main() {\n    process_resource();\n    println!(\"Global drop count: {}\", GLOBAL_DROP.load(Ordering::SeqCst));\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicUsize, Ordering};\nstatic GLOBAL_COUNT: AtomicUsize = AtomicUsize::new(0);\nstruct Container {\n    raw: *mut i32,\n}\nimpl Container {\n    fn new(val: i32) -> Self {\n        let boxed = Box::new(val);\n        Self { raw: Box::into_raw(boxed) }\n    }\n    unsafe fn free_resource(&mut self) {\n        if !self.raw.is_null() {\n            drop(Box::from_raw(self.raw));\n            GLOBAL_COUNT.fetch_add(1, Ordering::SeqCst);\n            self.raw = std::ptr::null_mut();\n        }\n    }\n}\nfn process() -> Result<(), &'static str> {\n    let mut obj = Container::new(50);\n    unsafe {\n        obj.free_resource(); \n        obj.free_resource(); \n    }\n    if GLOBAL_COUNT.load(Ordering::SeqCst) == 1 {\n        Ok(())\n    } else {\n        Err(\"Double free occurred\")\n    }\n}\nfn main() {\n    let result = process();\n    println!(\"Deallocation count: {}\", GLOBAL_COUNT.load(Ordering::SeqCst));\n    match result {\n        Ok(_) => println!(\"Operation completed successfully.\"),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Aggregator {\n    data: Arc<Vec<i32>>,\n}\nimpl Aggregator {\n    fn new(data: Vec<i32>) -> Self {\n        Aggregator { data: Arc::new(data) }\n    }\n    fn calculate(&self) -> i32 {\n        let nthreads = 4;\n        let len = self.data.len();\n        let chunk_size = (len + nthreads - 1) / nthreads;\n        let mut handles = Vec::new();\n        for i in 0..nthreads {\n            let data = Arc::clone(&self.data);\n            let start = i * chunk_size;\n            let end = ((i + 1) * chunk_size).min(len);\n            let handle = thread::spawn(move || {\n                let mut local_sum = 0;\n                unsafe {\n                    let ptr = data.as_ptr().add(start);\n                    for j in 0..(end - start) {\n                        local_sum += *ptr.add(j);\n                    }\n                }\n                local_sum\n            });\n            handles.push(handle);\n        }\n        let total: i32 = handles.into_iter().map(|h| h.join().unwrap()).sum();\n        (total * 100) / (len as i32)\n    }\n}\nfn main() {\n    let values = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; \n    let aggregator = Aggregator::new(values);\n    let result = aggregator.calculate();\n    println!(\"Metric: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Computor {\n    multiplier: u32,\n}\nimpl Computor {\n    unsafe fn calculate(&self, a: u32, b: u32, c: u32) -> u32 {\n        (a * b) / c\n    }\n}\nfn main() {\n    let shared = Arc::new(Mutex::new(10u32));\n    let shared_clone = Arc::clone(&shared);\n    let handle = thread::spawn(move || {\n        let mut data = shared_clone.lock().unwrap();\n        unsafe {\n            let ptr: *mut u32 = &mut *data;\n            *ptr += 5; \n        }\n    });\n    handle.join().unwrap();\n    let comp = Computor { multiplier: *shared.lock().unwrap() };\n    let result = unsafe { comp.calculate(100, 3, 10) };\n    println!(\"Outcome: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nuse std::sync::Arc;\nstruct Processor {\n    data: Vec<u32>,\n    scale: u32,\n}\nimpl Processor {\n    fn compute(&self) -> u32 {\n        let sum: u32 = self.data.iter().sum();\n        let count = self.data.len() as u32;\n        let result = sum * self.scale / count;\n        result\n    }\n}\nfn main() {\n    let proc_obj = Arc::new(Processor { data: vec![1, 2], scale: 100 });\n    let mut threads = vec![];\n    for _ in 0..2 {\n        let proc_clone = Arc::clone(&proc_obj);\n        let handle = thread::spawn(move || {\n            let output = proc_clone.compute();\n            println!(\"Computed result: {}\", output);\n        });\n        threads.push(handle);\n    }\n    for handle in threads {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Transaction {\n    amount: u32,\n    discount: u32, \n}\nimpl Transaction {\n    pub unsafe fn apply(&self) -> u32 {\n        self.amount - ((self.amount * self.discount) / 100)\n    }\n}\nfn main() {\n    let transaction = Transaction { amount: 100, discount: 20 }; \n    let shared = Arc::new(transaction);\n    let mut handles = vec![];\n    for _ in 0..5 {\n        let clone = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            unsafe {\n                clone.apply()\n            }\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        let result = handle.join().unwrap();\n        println!(\"Net amount: {}\", result); \n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Purchase {\n    price: u32,\n    discount: u32,\n    tax: u32,\n}\nimpl Purchase {\n    fn calculate(&self) -> u32 {\n        unsafe {\n            let price_ptr = &self.price as *const u32;\n            let base = *price_ptr;\n            let discount_val = base * self.discount / 100;\n            let tax_val = base * self.tax / 100;\n            base - discount_val + tax_val\n        }\n    }\n}\nfn main() {\n    let orders = vec![\n        Purchase { price: 99, discount: 20, tax: 8 }\n    ];\n    let shared_total = Arc::new(Mutex::new(0u32));\n    let mut handles = vec![];\n    for order in orders {\n        let total_clone = Arc::clone(&shared_total);\n        let o = order;\n        let handle = thread::spawn(move || {\n            let value = o.calculate();\n            let mut total = total_clone.lock().unwrap();\n            *total += value;\n        });\n        handles.push(handle);\n    }\n    for h in handles {\n        h.join().unwrap();\n    }\n    let final_total = *shared_total.lock().unwrap();\n    println!(\"Final Total: {}\", final_total);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct SensorData {\n    readings: Vec<u32>,\n}\nimpl SensorData {\n    fn process(&self) -> u32 {\n        let factor = 3u32;\n        let divisor = 2u32;\n        let unsafe_factor = unsafe { *(&factor as *const u32) };\n        let data = Arc::new(self.readings.clone());\n        let mut handles = Vec::new();\n        let chunk_size = (data.len() + 1) / 2;\n        let sum_arc = Arc::new(std::sync::atomic::AtomicU32::new(0));\n        for chunk in data.chunks(chunk_size) {\n            let local_data = chunk.to_vec();\n            let sum_ref = Arc::clone(&sum_arc);\n            let unsafe_factor_cpy = unsafe_factor;\n            let divisor_cpy = divisor;\n            let handle = thread::spawn(move || {\n                let mut local_sum = 0;\n                for reading in local_data {\n                    local_sum += (reading * unsafe_factor_cpy) / divisor_cpy;\n                }\n                sum_ref.fetch_add(local_sum, std::sync::atomic::Ordering::SeqCst);\n            });\n            handles.push(handle);\n        }\n        for handle in handles {\n            handle.join().unwrap();\n        }\n        sum_arc.load(std::sync::atomic::Ordering::SeqCst)\n    }\n}\nfn main() {\n    let sensor = SensorData { readings: vec![10, 20, 30, 40] };\n    let result = sensor.process();\n    println!(\"Result: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\npub struct Calculator {\n    pub scale: i32,\n}\nimpl Calculator {\n    pub unsafe fn compute(&self, numerator: i32, denominator: i32) -> i32 {\n        let scale_ptr: *const i32 = &self.scale as *const i32;\n        let scale_val: i32 = *scale_ptr;\n        let result = numerator / (denominator * scale_val);\n        result\n    }\n}\nfn launch_calculation(calc: Arc<Calculator>, num: i32, denom: i32, store: Arc<Mutex<i32>>) {\n    let calc_clone = calc.clone();\n    thread::spawn(move || {\n        unsafe {\n            let computed = calc_clone.compute(num, denom);\n            let mut data = store.lock().unwrap();\n            *data = computed;\n        }\n    })\n    .join()\n    .unwrap();\n}\nfn main() {\n    let calc = Arc::new(Calculator { scale: 10 });\n    let result = Arc::new(Mutex::new(0));\n    launch_calculation(calc, 100, 5, result.clone());\n    let final_value = *result.lock().unwrap();\n    println!(\"Computed result: {}\", final_value);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Engine {\n    base: i32,\n    multiplier: i32,\n    divisor: i32,\n}\nimpl Engine {\n    fn process(&self) -> i32 {\n        (self.base * self.multiplier) / self.divisor\n    }\n}\nfn main() {\n    let engine = Arc::new(Engine { base: 100, multiplier: 3, divisor: 12 });\n    let mut handles = vec![];\n    for _ in 0..4 {\n        let eng = Arc::clone(&engine);\n        handles.push(thread::spawn(move || eng.process()));\n    }\n    let mut total = 0;\n    for h in handles {\n        total += h.join().expect(\"Thread panicked\");\n    }\n    println!(\"Result: {}\", total);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Account {\n    balance: i32,\n}\nimpl Account {\n    fn compute(&self, rate: i32) -> i32 {\n        unsafe {\n            let ptr: *const i32 = &self.balance;\n            let bal = *ptr;\n            bal + (bal * rate) / 100\n        }\n    }\n}\nfn main() {\n    let account = Arc::new(Account { balance: 100 });\n    let mut handles = Vec::new();\n    for _ in 0..4 {\n        let acc_clone = Arc::clone(&account);\n        let handle = thread::spawn(move || {\n            let computed = acc_clone.compute(10); \n            println!(\"Computed value: {}\", computed);\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Order {\n    price: u32,\n    discount: u32, \n}\nimpl Order {\n    unsafe fn total(&self) -> u32 {\n        let discount_ptr: *const u32 = &self.discount;\n        let discount_val = *discount_ptr;\n        (self.price * (100 - discount_val)) / 100\n    }\n}\nfn main() {\n    let order = Order { price: 200, discount: 15 };\n    let shared_order = Arc::new(Mutex::new(order));\n    let shared_order_clone = Arc::clone(&shared_order);\n    let handle = thread::spawn(move || {\n        let order_guard = shared_order_clone.lock().unwrap();\n        let total = unsafe { order_guard.total() };\n        println!(\"Total computed (fixed): {}\", total);\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Calculator {\n    data: Vec<u32>,\n}\nimpl Calculator {\n    fn new(data: Vec<u32>) -> Calculator {\n        Calculator { data }\n    }\n    fn process(&self) -> u32 {\n        let len = self.data.len() as u32;\n        let sum: u32 = self.data.iter().sum();\n        sum / len\n    }\n}\nfn main() {\n    let calc = Arc::new(Mutex::new(Calculator::new(vec![1, 2, 3, 4])));\n    let mut handles = Vec::new();\n    for _ in 0..2 {\n        let calc_clone = Arc::clone(&calc);\n        let handle = thread::spawn(move || {\n            let calc_locked = calc_clone.lock().unwrap();\n            calc_locked.process()\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        let res = handle.join().unwrap();\n        println!(\"Result: {}\", res);\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Engine {\n    base: u32,\n    multiplier: u32,\n}\nimpl Engine {\n    fn new(b: u32, m: u32) -> Self {\n        Engine { base: b, multiplier: m }\n    }\n    fn calculate(&self, addition: u32) -> u32 {\n        unsafe {\n            let ptr_base = &self.base as *const u32;\n            let ptr_multiplier = &self.multiplier as *const u32;\n            (*ptr_base).wrapping_mul((*ptr_multiplier).wrapping_add(addition))\n        }\n    }\n}\nfn main() {\n    let engine = Arc::new(Engine::new(10, 20));\n    let eng_clone = Arc::clone(&engine);\n    let handle = thread::spawn(move || {\n        eng_clone.calculate(5)\n    });\n    let result = handle.join().unwrap();\n    println!(\"Result: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nuse std::sync::Arc;\npub mod calc {\n    use super::*;\n    pub struct Processor;\n    impl Processor {\n        pub fn new() -> Self {\n            Processor\n        }\n        pub fn execute(&self, data: &[u64]) -> u64 {\n            if data.len() < 2 {\n                return 0;\n            }\n            let ptr = data.as_ptr();\n            let total: u64;\n            let measured: u64;\n            unsafe {\n                total = *ptr;         \n                measured = *ptr.add(1); \n            }\n            let total_arc = Arc::new(total);\n            let measured_arc = Arc::new(measured);\n            let tot_clone = Arc::clone(&total_arc);\n            let meas_clone = Arc::clone(&measured_arc);\n            let handle = thread::spawn(move || {\n                (*tot_clone - *meas_clone) * 100 / *tot_clone\n            });\n            handle.join().unwrap()\n        }\n    }\n}\nfn main() {\n    let processor = calc::Processor::new();\n    let input_data = vec![100u64, 80u64];\n    let outcome = processor.execute(&input_data);\n    println!(\"Outcome: {}\", outcome);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Product {\n    price: u32,\n    quantity: u32,\n    discount_rate: u32,\n}\nimpl Product {\n    fn new(price: u32, quantity: u32, discount_rate: u32) -> Self {\n        Self {\n            price,\n            quantity,\n            discount_rate,\n        }\n    }\n}\nfn compute_total(product: &Product) -> u32 {\n    unsafe {\n        let ptr: *const Product = product;\n        let prod_ref: &Product = &*ptr;\n        let result = (prod_ref.price - (prod_ref.price * prod_ref.discount_rate / 100)) * prod_ref.quantity;\n        result\n    }\n}\nfn run_app() -> u32 {\n    let product = Arc::new(Product::new(100, 2, 15));\n    let mut handles = vec![];\n    for _ in 0..4 {\n        let prod_clone = Arc::clone(&product);\n        handles.push(thread::spawn(move || {\n            compute_total(&*prod_clone)\n        }));\n    }\n    let mut aggregate = 0;\n    for handle in handles {\n        aggregate += handle.join().unwrap();\n    }\n    aggregate\n}\nfn main() {\n    let total = run_app();\n    println!(\"Total: {}\", total);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Engine {\n    factor: i32,\n}\nimpl Engine {\n    fn new(f: i32) -> Self {\n        Engine { factor: f }\n    }\n    unsafe fn compute(&self, input: i32) -> i32 {\n        let diff = input - self.factor;\n        (diff * 100) / input\n    }\n}\nfn run(input: i32, factor: i32) -> i32 {\n    let eng = Arc::new(Mutex::new(Engine::new(factor)));\n    let eng_clone = Arc::clone(&eng);\n    let handler = thread::spawn(move || {\n        let engine = eng_clone.lock().unwrap();\n        let ptr: *const i32 = &engine.factor as *const i32;\n        let _ = unsafe { *ptr };\n        unsafe { engine.compute(input) }\n    });\n    handler.join().unwrap()\n}\nfn main() {\n    let result = run(120, 100);\n    println!(\"Final result: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\npub struct Calc {\n    rate: u32,\n}\nimpl Calc {\n    pub fn compute(&self, revenue: u32) -> u32 {\n        unsafe {\n            let rate_ptr: *const u32 = &self.rate as *const u32;\n            let r = *rate_ptr;\n            (revenue * r) / 100\n        }\n    }\n}\nfn main() {\n    let calc = Arc::new(Calc { rate: 5 });\n    let calc_clone = Arc::clone(&calc);\n    let handle = thread::spawn(move || {\n        let result = calc_clone.compute(200);\n        println!(\"Thread computed result: {}\", result);\n        result\n    });\n    let thread_result = handle.join().unwrap();\n    println!(\"Main thread received result: {}\", thread_result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nstruct Computor {\n    data: Vec<i32>,\n}\nimpl Computor {\n    fn new(data: Vec<i32>) -> Self {\n        Computor { data }\n    }\n    fn compute(&self) -> i32 {\n        let len = self.data.len() as i32;\n        let mut sum: i32 = 0;\n        unsafe {\n            let ptr = self.data.as_ptr();\n            for i in 0..len {\n                sum += *ptr.add(i as usize);\n            }\n        }\n        if len > 0 {\n            return sum / len;\n        }\n        0\n    }\n}\nfn main() {\n    let data = vec![1, 2, 3];  \n    let comp = Computor::new(data);\n    let handle = thread::spawn(move || comp.compute());\n    let result = handle.join().unwrap();\n    println!(\"Result: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct TimeProcessor {\n    unit: u64,\n}\nimpl TimeProcessor {\n    fn new() -> Self {\n        TimeProcessor { unit: 1000 }\n    }\n    fn compute(&self, secs: u64) -> u64 {\n        secs * self.unit\n    }\n}\nfn main() {\n    let processor = Arc::new(Mutex::new(TimeProcessor::new()));\n    let proc_clone = Arc::clone(&processor);\n    let handle = thread::spawn(move || {\n        proc_clone.lock().unwrap().compute(500)\n    });\n    let thread_result = handle.join().unwrap();\n    println!(\"Thread computation result: {}\", thread_result);\n    let direct_result = processor.lock().unwrap().compute(1500);\n    println!(\"Direct computation result: {}\", direct_result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Calculation {\n    base: u32,\n    current: u32,\n    percent: u32,\n}\nimpl Calculation {\n    fn new(base: u32, current: u32) -> Self {\n        Calculation { base, current, percent: 0 }\n    }\n    unsafe fn calculate(&mut self) {\n        let percent_ptr: *mut u32 = &mut self.percent;\n        *percent_ptr = (self.current - self.base) * 100 / self.base;\n    }\n}\nfn main() {\n    let calc = Arc::new(Mutex::new(Calculation::new(200, 250)));\n    let calc_clone = Arc::clone(&calc);\n    let handler = thread::spawn(move || {\n        let mut calc_instance = calc_clone.lock().unwrap();\n        unsafe {\n            calc_instance.calculate();\n        }\n    });\n    handler.join().unwrap();\n    let calc_final = calc.lock().unwrap();\n    println!(\"Percentage increase: {}%\", calc_final.percent);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Calculation {\n    value: i64,\n}\nimpl Calculation {\n    fn compute(&self, factor: i64) -> i64 {\n        unsafe {\n            let ptr: *const i64 = &self.value;\n            (*ptr + factor) / 2\n        }\n    }\n}\nfn main() {\n    let shared = Arc::new(Mutex::new(Calculation { value: 10 }));\n    let operation_factor = 5; \n    let shared_clone = Arc::clone(&shared);\n    let handle = thread::spawn(move || {\n        let result;\n        {\n            let calc = shared_clone.lock().unwrap();\n            result = calc.compute(operation_factor);\n        }\n        result\n    });\n    let final_result = handle.join().unwrap();\n    println!(\"Computed result: {}\", final_result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process::{Command, Stdio};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Executor;\nimpl Executor {\n    fn new() -> Self {\n        Executor\n    }\n    fn run_exec(&self) -> String {\n        let secure_path = \"/usr/bin\".to_string();\n        let output = Command::new(\"echo\")\n            .arg(\"secure\")\n            .env(\"PATH\", secure_path)\n            .stdout(Stdio::piped())\n            .output()\n            .expect(\"failed to execute process\");\n        String::from_utf8_lossy(&output.stdout).trim().to_string()\n    }\n}\nfn main() {\n    let executor = Arc::new(Executor::new());\n    let results = Arc::new(Mutex::new(Vec::new()));\n    let mut handles = vec![];\n    for _ in 0..4 {\n        let executor_clone = Arc::clone(&executor);\n        let results_clone = Arc::clone(&results);\n        let handle = thread::spawn(move || {\n            let result = executor_clone.run_exec();\n            results_clone.lock().unwrap().push(result);\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    let final_result = results.lock().unwrap().get(0).cloned().unwrap_or_default();\n    println!(\"{}\", final_result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::process::Command;\nuse std::thread;\nuse std::sync::Arc;\nfn main() {\n    let safe_path = \"/usr/bin:/bin\";\n    let shared_data = Arc::new(safe_path.to_string());\n    let data_clone = Arc::clone(&shared_data);\n    let handle = thread::spawn(move || {\n        let status = Command::new(\"echo\")\n            .env(\"PATH\", data_clone.as_str())\n            .status();\n        if let Ok(st) = status {\n            std::process::exit(if st.success() { 0 } else { 1 });\n        }\n        std::process::exit(1);\n    });\n    let _ = handle.join();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "------------------ fixed.rs ------------------\nuse std::env;\nuse std::process::Command;\nuse std::thread;\nstruct Executor;\nimpl Executor {\n    fn launch(&self, path: &str) -> i32 {\n        let mut child = Command::new(\"sh\")\n            .arg(\"-c\")\n            .arg(\"echo Execution\")\n            .env(\"PATH\", path)\n            .spawn()\n            .expect(\"failed to spawn process\");\n        let status = child.wait().expect(\"process wasn't running\");\n        status.code().unwrap_or(-1)\n    }\n}\nfn main() {\n    let exec = Executor{};\n    let secure_path = \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\";\n    let handle = thread::spawn(move || {\n        exec.launch(secure_path)\n    });\n    let result = handle.join().expect(\"Thread panicked\");\n    println!(\"Process exited with code: {}\", result);\n}\n----------------------------------------------------\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process::Command;\nuse std::thread;\nfn run_protected() {\n    let command_input = env::var(\"CMD_NAME\").unwrap_or_else(|_| \"echo\".to_string());\n    let allowed_commands = [\"echo\", \"safe\"];\n    if !allowed_commands.contains(&command_input.as_str()) {\n        panic!(\"Command not allowed\");\n    }\n    let shell = command_input.as_str();\n    let secure_path = \"/usr/bin:/bin\";\n    let handler = thread::spawn(move || {\n        let output = Command::new(shell)\n            .env(\"PATH\", secure_path)\n            .arg(\"fixed\")\n            .output()\n            .expect(\"failed to execute command\");\n        output\n    });\n    let result = handler.join().unwrap();\n    println!(\"Output: {:?}\", result);\n}\nfn main() {\n    run_protected();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process::Command;\nuse std::thread;\nuse std::time::Duration;\nstruct SafeExecutor;\nimpl SafeExecutor {\n    fn trusted_path() -> String {\n        \"/usr/bin:/bin\".to_string()\n    }\n    fn launch() -> Result<String, String> {\n        let safe_path = Self::trusted_path();\n        let output = Command::new(\"echo\")\n            .env(\"PATH\", safe_path)\n            .arg(\"hello\")\n            .output();\n        match output {\n            Ok(result) => {\n                let out_str = String::from_utf8_lossy(&result.stdout).to_string();\n                Ok(out_str)\n            },\n            Err(e) => Err(format!(\"Command execution failed: {:?}\", e)),\n        }\n    }\n}\nfn main() {\n    let modifier = thread::spawn(|| {\n        for i in 0..5 {\n            env::set_var(\"PATH\", format!(\"/malicious/path{}\", i));\n            thread::sleep(Duration::from_millis(40));\n        }\n    });\n    modifier.join().unwrap();\n    match SafeExecutor::launch() {\n        Ok(result) => println!(\"Output: {}\", result.trim()),\n        Err(err) => println!(\"Error: {}\", err),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::process::Command;\nuse std::thread;\nconst SECURE_PATH: &str = \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\";\nfn establish_safe_env() -> String {\n    SECURE_PATH.to_string()\n}\nfn spawn_process() -> bool {\n    let safe_path = establish_safe_env();\n    let output = Command::new(\"sh\")\n        .arg(\"-c\")\n        .arg(\"which ls\")\n        .env(\"PATH\", safe_path)\n        .output();\n    match output {\n        Ok(out) => out.status.success(),\n        Err(_) => false,\n    }\n}\npub fn do_action() -> bool {\n    let handle = thread::spawn(|| spawn_process());\n    handle.join().unwrap_or(false)\n}\nfn main() {\n    if do_action() {\n        println!(\"Operation completed successfully.\");\n    } else {\n        println!(\"Operation failed.\");\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::thread;\ntrait Executor {\n    fn run(&self) -> String;\n}\nstruct Worker;\nimpl Executor for Worker {\n    fn run(&self) -> String {\n        let path = env::var(\"PATH\").unwrap_or_default();\n        if path.contains(\"attacker\") {\n            \"ATTACK\".to_string()\n        } else {\n            \"safe_output\".to_string()\n        }\n    }\n}\nfn update_env() {\n    if let Ok(custom) = env::var(\"CUSTOM_PATH\") {\n        if custom == \"/usr/bin\" || custom == \"/bin\" {\n            env::set_var(\"PATH\", custom);\n        } else {\n        }\n    }\n}\nfn execute_threads() -> Vec<String> {\n    let worker = Worker;\n    let mut handles = vec![];\n    for _ in 0..4 {\n        let handle = thread::spawn(move || {\n            worker.run()\n        });\n        handles.push(handle);\n    }\n    handles.into_iter().map(|h| h.join().unwrap()).collect()\n}\nfn main() {\n    update_env();\n    let results = execute_threads();\n    for res in results {\n        println!(\"{}\", res);\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process::Command;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nconst SAFE_PATH: &str = \"/usr/bin\";\nstruct ExecManager {\n    path: String,\n}\nimpl ExecManager {\n    fn new() -> ExecManager {\n        ExecManager {\n            path: String::from(SAFE_PATH),\n        }\n    }\n    fn spawn_process(&self) -> std::io::Result<()> {\n        let mut cmd = Command::new(\"ls\");\n        cmd.env(\"PATH\", &self.path);\n        let status = cmd.status()?;\n        unsafe { simulate_unsafe() };\n        if !status.success() {\n            Err(std::io::Error::new(std::io::ErrorKind::Other, \"command execution failed\"))\n        } else {\n            Ok(())\n        }\n    }\n}\nunsafe fn simulate_unsafe() {\n    let mut value = 10;\n    let pointer = &mut value as *mut i32;\n    *pointer += 1;\n}\ntrait Execute {\n    fn execute(&self) -> std::io::Result<()>;\n}\nimpl Execute for ExecManager {\n    fn execute(&self) -> std::io::Result<()> {\n        self.spawn_process()\n    }\n}\nfn main() {\n    let manager = Arc::new(Mutex::new(ExecManager::new()));\n    let mut handles = vec![];\n    for _ in 0..2 {\n        let mgr = Arc::clone(&manager);\n        let handle = thread::spawn(move || {\n            let instance = mgr.lock().unwrap();\n            instance.execute().unwrap();\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::process::Command;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::ffi::CString;\nstruct Executor;\nimpl Executor {\n    fn run(&self, program: &str, args: &[&str]) -> std::io::Result<()> {\n        let safe_path = \"/usr/bin:/bin\";\n        let c_safe = CString::new(safe_path).expect(\"Failed to create CString\");\n        let mut cmd = Command::new(program);\n        cmd.env(\"PATH\", c_safe.to_str().unwrap())\n           .args(args);\n        let shared_cmd = Arc::new(Mutex::new(cmd));\n        let thread_cmd = Arc::clone(&shared_cmd);\n        let handle = thread::spawn(move || {\n            let mut guard = thread_cmd.lock().unwrap();\n            guard.spawn().and_then(|mut child| child.wait())\n        });\n        handle.join().unwrap()\n    }\n}\nfn main() {\n    let executor = Executor;\n    executor.run(\"echo\", &[\"Hello from safe execution!\"]).unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process::Command;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct AppConfig {\n    search_path: String,\n}\nimpl AppConfig {\n    fn new() -> Self {\n        let safe_path = \"/usr/bin\".to_string();\n        AppConfig {\n            search_path: safe_path,\n        }\n    }\n}\nfn spawn_process(config: Arc<Mutex<AppConfig>>) -> bool {\n    let config_guard = config.lock().unwrap();\n    let output = Command::new(\"echo\")\n        .env(\"PATH\", &config_guard.search_path)\n        .arg(\"Hello\")\n        .output();\n    match output {\n        Ok(out) if out.status.success() => true,\n        _ => false,\n    }\n}\nfn run_app() -> bool {\n    let config = Arc::new(Mutex::new(AppConfig::new()));\n    let config_clone = Arc::clone(&config);\n    let handle = thread::spawn(move || {\n        spawn_process(config_clone)\n    });\n    handle.join().unwrap_or(false)\n}\nfn main() {\n    let result = run_app();\n    if result {\n        println!(\"Process spawned successfully\");\n    } else {\n        println!(\"Failed to spawn process\");\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::env;\nuse std::process::{Command, Stdio};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Runner {\n    prog: String,\n}\nimpl Runner {\n    fn execute(&self) -> Result<String, String> {\n        let trusted_path = \"/usr/bin:/bin\";\n        let output = Command::new(&self.prog)\n            .env(\"PATH\", trusted_path) \n            .arg(\"--version\")\n            .stdout(Stdio::piped())\n            .output()\n            .map_err(|e| format!(\"Execution failure: {:?}\", e))?;\n        if output.status.success() {\n            Ok(String::from_utf8_lossy(&output.stdout).trim().to_string())\n        } else {\n            Err(\"Command exited with a non-zero status\".into())\n        }\n    }\n}\nfn main() {\n    let runner = Arc::new(Mutex::new(Runner { prog: \"ls\".to_string() }));\n    let mut threads = vec![];\n    for _ in 0..4 {\n        let runner_clone = Arc::clone(&runner);\n        let handle = thread::spawn(move || {\n            let guard = runner_clone.lock().unwrap();\n            match guard.execute() {\n                Ok(output) => println!(\"Output: {}\", output),\n                Err(err) => eprintln!(\"Error: {}\", err),\n            }\n        });\n        threads.push(handle);\n    }\n    for t in threads {\n        t.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process::Command;\nuse std::thread;\ntrait Executor {\n    fn launch(&self) -> Result<(), std::io::Error>;\n}\nstruct Application;\nimpl Application {\n    fn resolve_path(&self) -> String {\n        let custom = env::var(\"MALICIOUS_PATH\").unwrap_or_default();\n        if !custom.is_empty() && custom.starts_with(\"/usr/bin\") {\n            if let Ok(valid) = std::str::from_utf8(custom.as_bytes()) {\n                return valid.to_string();\n            }\n        }\n        String::from(\"/usr/bin:/bin\")\n    }\n}\nimpl Executor for Application {\n    fn launch(&self) -> Result<(), std::io::Error> {\n        let chosen_path = self.resolve_path();\n        let mut cmd = Command::new(\"ls\");\n        cmd.env(\"PATH\", chosen_path);\n        let handler = thread::spawn(move || {\n            cmd.output().expect(\"failed to run process\")\n        });\n        handler.join().unwrap();\n        Ok(())\n    }\n}\nfn main() {\n    let app = Application;\n    if let Err(e) = app.launch() {\n        eprintln!(\"Error occurred: {:?}\", e);\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process::Command;\nuse std::thread;\nuse std::sync::{Arc, Mutex};\nstruct Runner {\n    input_search: String,\n}\nimpl Runner {\n    fn sanitize(&self) -> String {\n        let safe_whitelist = vec![\"/usr/bin\", \"/bin\", \"/usr/local/bin\"];\n        let parts: Vec<&str> = self.input_search.split(':').collect();\n        let validated: Vec<&str> = parts.into_iter()\n            .filter(|d| safe_whitelist.contains(d))\n            .collect();\n        if validated.is_empty() {\n            safe_whitelist.join(\":\")\n        } else {\n            validated.join(\":\")\n        }\n    }\n    fn execute(&self) {\n        let validated_search = self.sanitize();\n        env::set_var(\"PATH\", &validated_search);\n        let raw_ptr = validated_search.as_ptr();\n        let len = validated_search.len();\n        let shared_ptr = Arc::new(Mutex::new(raw_ptr));\n        let handle = {\n            let sp = Arc::clone(&shared_ptr);\n            thread::spawn(move || {\n                unsafe {\n                    let stored_ptr = *sp.lock().unwrap();\n                    let slice = std::slice::from_raw_parts(stored_ptr, len);\n                    let path_str = std::str::from_utf8(slice).unwrap();\n                    println!(\"Validated search path: {}\", path_str);\n                }\n            })\n        };\n        handle.join().unwrap();\n        let output = Command::new(\"echo\")\n            .arg(\"Executing secure command\")\n            .output()\n            .expect(\"command execution failed\");\n        println!(\"{}\", String::from_utf8_lossy(&output.stdout));\n    }\n}\nfn main() {\n    let input_search = env::var(\"BAD_PATH\")\n        .unwrap_or_else(|_| \"/usr/bin:/bin\".to_string());\n    let runner = Runner { input_search };\n    runner.execute();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::env;\nuse std::thread;\nstruct Runner;\nimpl Runner {\n    fn execute(&self) -> Result<String, String> {\n        let default_safe_path = \"/usr/bin:/bin\".to_string();\n        let user_input = env::var(\"SEARCH_PATH\").unwrap_or_else(|_| default_safe_path.clone());\n        let sanitized: Vec<&str> = user_input.split(':').filter(|segment| segment.starts_with('/')).collect();\n        let safe_value = if sanitized.is_empty() {\n            default_safe_path\n        } else {\n            sanitized.join(\":\")\n        };\n        let safe_clone = safe_value.clone();\n        let handle = thread::spawn(move || {\n            env::set_var(\"PATH\", safe_clone);\n        });\n        handle.join().unwrap();\n        let current_path = env::var(\"PATH\").unwrap_or_default();\n        Ok(current_path)\n    }\n}\nfn main() {\n    let runner = Runner;\n    match runner.execute() {\n        Ok(result) => println!(\"Result: {}\", result),\n        Err(err) => eprintln!(\"Error: {}\", err),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process::Command;\nuse std::sync::Arc;\nuse std::thread;\nstruct Executor<'a> {\n    info: &'a str,\n}\nimpl<'a> Executor<'a> {\n    fn new(text: &'a str) -> Executor<'a> {\n        Executor { info: text }\n    }\n    unsafe fn run_command(&self, lib: &str) -> Result<String, String> {\n        let allowed = [\"/usr/lib\", \"/usr/local/lib\"];\n        if !allowed.contains(&lib) {\n            return Err(\"Library path not allowed\".to_string());\n        }\n        let mut current = env::var(\"PATH\").unwrap_or_default();\n        current.push_str(\":\");\n        current.push_str(lib);\n        env::set_var(\"PATH\", &current);\n        let output = Command::new(\"echo\").arg(self.info).output();\n        match output {\n            Ok(out) => Ok(String::from_utf8_lossy(&out.stdout).to_string()),\n            Err(e) => Err(format!(\"Command execution error: {}\", e)),\n        }\n    }\n}\nfn main() {\n    let executor = Executor::new(\"safe run\");\n    let lib_input = env::var(\"CUSTOM_PATH\").unwrap_or_else(|_| \"/usr/lib\".to_string());\n    let shared = Arc::new(executor);\n    let cloned = Arc::clone(&shared);\n    let handler = thread::spawn(move || {\n        unsafe { cloned.run_command(&lib_input) }\n    });\n    match handler.join() {\n        Ok(Ok(result)) => println!(\"Output: {}\", result),\n        _ => println!(\"Execution error occurred\"),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "-------------------------------------------------\nuse std::env;\nuse std::process;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::process::Command;\nstruct Executor {\n    search_path: String,\n}\nimpl Executor {\n    fn new(input: String) -> Self {\n        let allowed = vec![\"/usr/bin\", \"/bin\"];\n        let sanitized = if allowed.contains(&input.as_str()) {\n            input\n        } else {\n            \"/usr/bin\".to_string()\n        };\n        Executor { search_path: sanitized }\n    }\n    fn update_env(&self) {\n        env::set_var(\"PATH\", &self.search_path);\n    }\n    fn run(&self) -> i32 {\n        self.update_env();\n        let output = Command::new(\"echo\")\n            .arg(\"safe_exec\")\n            .output()\n            .expect(\"Failed to run command\");\n        output.status.code().unwrap_or(-1)\n    }\n}\nfn worker(exec: Arc<Executor>, results: Arc<Mutex<Vec<i32>>>) {\n    let ret = exec.run();\n    let mut lock = results.lock().unwrap();\n    lock.push(ret);\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let input_path = if args.len() > 1 {\n        args[1].clone()\n    } else {\n        \"/usr/bin\".to_string()\n    };\n    let exec = Arc::new(Executor::new(input_path));\n    let results = Arc::new(Mutex::new(Vec::new()));\n    let mut threads = vec![];\n    for _ in 0..3 {\n        let exec_clone = Arc::clone(&exec);\n        let results_clone = Arc::clone(&results);\n        let handle = thread::spawn(move || {\n            worker(exec_clone, results_clone);\n        });\n        threads.push(handle);\n    }\n    for handle in threads {\n        handle.join().expect(\"Thread panicked\");\n    }\n    if let Some(&first) = results.lock().unwrap().get(0) {\n        println!(\"Execution result: {}\", first);\n    }\n    process::exit(0);\n}\n-------------------------------------------------\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process::Command;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Runner {\n    prog: String,\n    params: Vec<String>,\n}\nimpl Runner {\n    fn new(prog: &str, params: Vec<String>) -> Self {\n        Runner { \n            prog: prog.to_string(), \n            params \n        }\n    }\n    fn execute(&self) -> Result<String, String> {\n        let secure_path = \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\";\n        env::set_var(\"PATH\", secure_path);\n        let output = Command::new(&self.prog)\n            .args(&self.params)\n            .output()\n            .map_err(|e| e.to_string())?;\n        if output.status.success() {\n            Ok(String::from_utf8_lossy(&output.stdout).to_string())\n        } else {\n            Err(format!(\n                \"Process error: {}\",\n                String::from_utf8_lossy(&output.stderr)\n            ))\n        }\n    }\n}\nfn main() {\n    let shared_runner = Arc::new(Mutex::new(Runner::new(\"echo\", vec![\"Hello\".to_string()])));\n    let mut threads = vec![];\n    for _ in 0..4 {\n        let runner_copy = Arc::clone(&shared_runner);\n        let handle = thread::spawn(move || {\n            let guard = runner_copy.lock().unwrap();\n            match guard.execute() {\n                Ok(result) => println!(\"Result: {}\", result),\n                Err(err) => eprintln!(\"Error: {}\", err),\n            }\n        });\n        threads.push(handle);\n    }\n    for handle in threads {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process::Command;\nuse std::sync::Arc;\nuse std::thread;\npub struct Executor;\nimpl Executor {\n    pub fn new() -> Self {\n        Executor\n    }\n    fn is_safe_path(path: &str) -> bool {\n        path.split(':').all(|p| p.starts_with('/'))\n    }\n    pub fn run(&self, cmd: &str) -> std::io::Result<String> {\n        let untrusted = env::var(\"UNTRUSTED_PATH\").unwrap_or_else(|_| \"/usr/bin\".to_string());\n        let safe_path = if Self::is_safe_path(&untrusted) {\n            untrusted\n        } else {\n            \"/usr/bin\".to_string()\n        };\n        let mut command = Command::new(cmd);\n        command.env(\"PATH\", safe_path);\n        let output = command.output()?;\n        if !output.status.success() {\n            return Err(std::io::Error::new(\n                std::io::ErrorKind::Other,\n                \"Command execution failed\",\n            ));\n        }\n        Ok(String::from_utf8_lossy(&output.stdout).to_string())\n    }\n}\nfn main() {\n    let executor = Arc::new(Executor::new());\n    let exec_clone = Arc::clone(&executor);\n    let handle = thread::spawn(move || {\n        let output = exec_clone.run(\"env\").expect(\"Failed to run command\");\n        println!(\"{}\", output);\n    });\n    handle.join().expect(\"Thread panicked\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process::{Command, Stdio};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Config {\n    command: String,\n    timeout: u64,\n}\nimpl Config {\n    fn new(cmd: &str, timeout: u64) -> Self {\n        Config {\n            command: cmd.to_string(),\n            timeout,\n        }\n    }\n}\nunsafe fn process_static_path(input: *const u8, len: usize) -> String {\n    let slice = std::slice::from_raw_parts(input, len);\n    String::from_utf8_lossy(slice).into_owned()\n}\npub fn spawn_process(cfg: Config) -> Result<String, String> {\n    let secure_path = \"/usr/bin:/bin\".to_string();\n    let mut processed_path = String::new();\n    unsafe {\n        let ptr = secure_path.as_ptr();\n        let len = secure_path.len();\n        processed_path = process_static_path(ptr, len);\n    }\n    let output_data = Arc::new(std::sync::Mutex::new(String::new()));\n    let thread_data = std::sync::Arc::clone(&output_data);\n    let child = thread::spawn(move || {\n        let res = Command::new(&cfg.command)\n            .arg(\"PATH\")\n            .env_clear()\n            .env(\"PATH\", processed_path)\n            .stdout(Stdio::piped())\n            .spawn();\n        match res {\n            Ok(mut child_proc) => {\n                if let Ok(out) = child_proc.wait_with_output() {\n                    let text = String::from_utf8_lossy(&out.stdout).into_owned();\n                    let mut guard = thread_data.lock().unwrap();\n                    *guard = text;\n                }\n            }\n            Err(_) => {}\n        }\n    });\n    let _ = child.join();\n    let final_output = output_data.lock().unwrap();\n    Ok(final_output.clone())\n}\nfn main() {\n    let cfg = Config::new(\"printenv\", 10);\n    match spawn_process(cfg) {\n        Ok(out) => println!(\"Process output: {}\", out),\n        Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::process::Command;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Settings {\n    search_dirs: String,\n}\nimpl Settings {\n    fn new() -> Self {\n        let raw = env::var(\"MALICIOUS_PATH\").unwrap_or_else(|_| \"\".to_string());\n        let valid = raw.chars().all(|c| c.is_alphanumeric() || c == '/' || c == ':' || c == '-' || c == '.');\n        let safe_path = if valid && !raw.is_empty() {\n            raw\n        } else {\n            \"/usr/bin\".to_string()\n        };\n        Settings {\n            search_dirs: safe_path,\n        }\n    }\n}\nfn execute(cmd: &str, settings: Arc<Mutex<Settings>>) -> Result<(), Box<dyn std::error::Error>> {\n    let s = settings.lock().unwrap();\n    let dirs = s.search_dirs.clone();\n    drop(s);\n    let child = Command::new(cmd)\n        .env(\"PATH\", dirs)\n        .arg(\"--version\")\n        .spawn()?;\n    let output = child.wait_with_output()?;\n    if output.status.success() {\n        Ok(())\n    } else {\n        Err(\"Command execution failed\".into())\n    }\n}\nfn main() {\n    let settings = Arc::new(Mutex::new(Settings::new()));\n    let threads: Vec<_> = (0..2)\n        .map(|_| {\n            let settings_clone = Arc::clone(&settings);\n            thread::spawn(move || {\n                execute(\"echo\", settings_clone).unwrap();\n            })\n        })\n        .collect();\n    for t in threads {\n        t.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Renderer {}\nimpl Renderer {\n    fn new() -> Self {\n        Self {}\n    }\n    fn escape(&self, input: &str) -> String {\n        input\n            .replace('&', \"&amp;\")\n            .replace('<', \"&lt;\")\n            .replace('>', \"&gt;\")\n            .replace('\\\"', \"&quot;\")\n            .replace('\\'', \"&#x27;\")\n    }\n    fn render(&self, input: &str) -> String {\n        let safe_input = self.escape(input);\n        let mut html = String::new();\n        html.push_str(\"<html><body>\");\n        html.push_str(\"User input: \");\n        html.push_str(&safe_input);\n        html.push_str(\"</body></html>\");\n        html\n    }\n}\nfn main() {\n    let renderer = Arc::new(Renderer::new());\n    let input = std::env::args().nth(1).unwrap_or_else(|| String::new());\n    let r = renderer.clone();\n    let handle = thread::spawn(move || {\n        let output = r.render(&input);\n        println!(\"{}\", output);\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::env;\nfn html_escape(input: &str) -> String {\n    input.chars().fold(String::new(), |mut acc, ch| {\n        match ch {\n            '<' => acc.push_str(\"&lt;\"),\n            '>' => acc.push_str(\"&gt;\"),\n            '&' => acc.push_str(\"&amp;\"),\n            '\"' => acc.push_str(\"&quot;\"),\n            '\\'' => acc.push_str(\"&#x27;\"),\n            _ => acc.push(ch),\n        }\n        acc\n    })\n}\nstruct Processor {\n    data: Arc<Mutex<String>>,\n}\nimpl Processor {\n    fn new() -> Self {\n        Self {\n            data: Arc::new(Mutex::new(String::new())),\n        }\n    }\n    fn process(&self, input: &str) -> String {\n        let mut result = String::new();\n        unsafe {\n            let ptr = input.as_ptr();\n            let len = input.len();\n            let slice = std::slice::from_raw_parts(ptr, len);\n            let s = std::str::from_utf8(slice).unwrap();\n            let safe = html_escape(s);\n            result.push_str(\"Hello, \");\n            result.push_str(&safe);\n        }\n        result\n    }\n    fn run(&self, processed: String) -> String {\n        let arc = Arc::clone(&self.data);\n        let handle = thread::spawn(move || {\n            let mut guard = arc.lock().unwrap();\n            *guard = format!(\"<html><body>{}</body></html>\", processed);\n            guard.clone()\n        });\n        handle.join().unwrap()\n    }\n}\npub fn process_input(input: &str) -> String {\n    let processor = Processor::new();\n    processor.run(processor.process(input))\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let raw = if args.len() > 1 { args[1].clone() } else { String::from(\"default\") };\n    let output = process_input(&raw);\n    println!(\"{}\", output);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nfn escape_html(input: &str) -> String {\n    input.replace('&', \"&amp;\")\n         .replace('<', \"&lt;\")\n         .replace('>', \"&gt;\")\n         .replace('\\\"', \"&quot;\")\n         .replace('\\'', \"&#x27;\")\n}\nstruct Renderer;\nimpl Renderer {\n    pub fn build_html(&self, input: &str) -> String {\n        let safe_input = escape_html(input);\n        let mut html = String::from(\"<html><body>User: \");\n        html.push_str(&safe_input);\n        html.push_str(\"</body></html>\");\n        html\n    }\n}\nfn process_input(input: &str) -> String {\n    let renderer = Renderer;\n    let inp = input.to_owned();\n    let handle = thread::spawn(move || renderer.build_html(&inp));\n    handle.join().unwrap()\n}\nfn main() {\n    let malicious = \"<script>alert('XSS');</script>\";\n    let output = process_input(malicious);\n    println!(\"{}\", output);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Renderer {\n    template: String,\n}\nimpl Renderer {\n    pub fn new() -> Self {\n        Renderer { template: \"<html><body>{content}</body></html>\".to_string() }\n    }\n    fn escape(input: &str) -> String {\n        input.chars().map(|c| match c {\n            '<' => \"&lt;\".to_string(),\n            '>' => \"&gt;\".to_string(),\n            '&' => \"&amp;\".to_string(),\n            '\"' => \"&quot;\".to_string(),\n            '\\'' => \"&#x27;\".to_string(),\n            _ => c.to_string(),\n        }).collect()\n    }\n    pub fn render(&self, user_input: &str) -> String {\n        let safe_input = Self::escape(user_input);\n        let placeholder = \"{content}\";\n        if let Some(pos) = self.template.find(placeholder) {\n            let before = &self.template[..pos];\n            let after = &self.template[pos + placeholder.len()..];\n            format!(\"{}{}{}\", before, safe_input, after)\n        } else {\n            self.template.clone()\n        }\n    }\n}\nfn main() {\n    let renderer = Arc::new(Mutex::new(Renderer::new()));\n    let untrusted_input = \"<script>alert('XSS');</script>\";\n    let mut handles = Vec::new();\n    for _ in 0..5 {\n        let render_clone = Arc::clone(&renderer);\n        let input_clone = untrusted_input.to_string();\n        let handle = thread::spawn(move || {\n            let guard = render_clone.lock().unwrap();\n            let output = guard.render(&input_clone);\n            output\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        let output = handle.join().unwrap();\n        println!(\"{}\", output);\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Renderer {\n    template: String,\n}\nimpl Renderer {\n    fn render(&self, user_input: &str) -> String {\n        let escaped = html_escape(user_input);\n        let mut output = self.template.clone();\n        output = output.replace(\"{input}\", &escaped);\n        output\n    }\n}\nfn html_escape(input: &str) -> String {\n    input.replace('&', \"&amp;\")\n         .replace('<', \"&lt;\")\n         .replace('>', \"&gt;\")\n         .replace('\\\"', \"&quot;\")\n         .replace('\\'', \"&#x27;\")\n}\nfn run() {\n    let template = \"<html><body>Welcome, {input}!</body></html>\".to_string();\n    let renderer = Renderer { template };\n    let shared = Arc::new(Mutex::new(renderer));\n    let handles: Vec<_> = (0..4)\n        .map(|_| {\n            let lock = Arc::clone(&shared);\n            thread::spawn(move || {\n                let user_input = \"<script>alert('xss');</script>\"; \n                let guard = lock.lock().unwrap();\n                let result = guard.render(user_input);\n                println!(\"{}\", result);\n            })\n        })\n        .collect();\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\nfn main() {\n    run();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nuse std::sync::{Arc, Mutex};\nstruct WebTemplate {\n    header: String,\n    footer: String,\n}\nimpl WebTemplate {\n    fn new() -> Self {\n        WebTemplate {\n            header: \"<html><head><title>Demo</title></head><body>\".to_string(),\n            footer: \"</body></html>\".to_string(),\n        }\n    }\n    fn render(&self, user_content: &str) -> String {\n        let mut output = String::with_capacity(1024);\n        output.push_str(&self.header);\n        output.push_str(&escape_html(user_content));\n        output.push_str(&self.footer);\n        output\n    }\n}\nfn escape_html(input: &str) -> String {\n    input.chars().map(|c| {\n        match c {\n            '<'  => \"&lt;\".to_string(),\n            '>'  => \"&gt;\".to_string(),\n            '&'  => \"&amp;\".to_string(),\n            '\"'  => \"&quot;\".to_string(),\n            '\\'' => \"&#x27;\".to_string(),\n            _    => c.to_string(),\n        }\n    }).collect::<String>()\n}\nfn process_request(user_input: &str) -> String {\n    let template = WebTemplate::new();\n    template.render(user_input)\n}\nfn main() {\n    let shared_response = Arc::new(Mutex::new(String::new()));\n    let input = if cfg!(test) { \"<script>alert('XSS')</script>\" } else { \"<script>alert('XSS')</script>\" };\n    let shared_clone = Arc::clone(&shared_response);\n    let handler = thread::spawn(move || {\n        let response = process_request(input);\n        let mut guard = shared_clone.lock().unwrap();\n        *guard = response;\n    });\n    handler.join().expect(\"Thread panicked\");\n    let result = shared_response.lock().unwrap();\n    println!(\"{}\", *result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct PageTemplate {\n    content: String,\n}\nimpl PageTemplate {\n    fn new() -> Self {\n        PageTemplate {\n            content: \"<html><body>{content}</body></html>\".to_string(),\n        }\n    }\n    fn render(&self, user_input: &str) -> String {\n        let safe_input = escape_html(user_input);\n        self.content.replace(\"{content}\", &safe_input)\n    }\n}\nfn escape_html(input: &str) -> String {\n    input.chars().map(|c| match c {\n        '<' => \"&lt;\".to_string(),\n        '>' => \"&gt;\".to_string(),\n        '&' => \"&amp;\".to_string(),\n        '\"' => \"&quot;\".to_string(),\n        '\\'' => \"&#x27;\".to_string(),\n        _ => c.to_string(),\n    }).collect()\n}\nfn process_request(input: String) -> String {\n    let template = Arc::new(PageTemplate::new());\n    let user_data = Arc::new(input);\n    let result = Arc::new(Mutex::new(String::new()));\n    let template_clone = Arc::clone(&template);\n    let user_clone = Arc::clone(&user_data);\n    let result_clone = Arc::clone(&result);\n    let handle = thread::spawn(move || {\n        let page = template_clone.render(&user_clone);\n        let mut res = result_clone.lock().unwrap();\n        *res = page;\n    });\n    handle.join().unwrap();\n    Arc::try_unwrap(result).ok().unwrap().into_inner().unwrap()\n}\nfn main() {\n    let malicious = \"<script>alert('XSS');</script>\".to_string();\n    let response = process_request(malicious);\n    println!(\"{}\", response);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Renderer {\n    content: Arc<Mutex<String>>,\n}\nimpl Renderer {\n    fn new() -> Self {\n        Renderer {\n            content: Arc::new(Mutex::new(String::new())),\n        }\n    }\n    fn escape_html(&self, input: &str) -> String {\n        input.chars()\n            .map(|c| match c {\n                '<' => \"&lt;\".to_string(),\n                '>' => \"&gt;\".to_string(),\n                '&' => \"&amp;\".to_string(),\n                '\"' => \"&quot;\".to_string(),\n                '\\''=> \"&#x27;\".to_string(),\n                _ => c.to_string(),\n            })\n            .collect()\n    }\n    fn build_page(&self, input: &str) -> String {\n        let mut page = String::from(\"<html><body>\");\n        let safe_input = self.escape_html(input);\n        page.push_str(&format!(\"<div>{}</div>\", safe_input));\n        page.push_str(\"</body></html>\");\n        page\n    }\n    fn update_content(&self, text: String) {\n        let shared = Arc::clone(&self.content);\n        let handle = thread::spawn(move || {\n            let mut guard = shared.lock().unwrap();\n            *guard = text;\n        });\n        handle.join().unwrap();\n    }\n}\nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n    let user_input = if args.len() > 1 { &args[1] } else { \"default\" };\n    let renderer = Renderer::new();\n    let page = renderer.build_page(user_input);\n    println!(\"{}\", page);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\npub struct Page {\n    template: String,\n}\nimpl Page {\n    pub fn new(template: &str) -> Self {\n        Page {\n            template: template.to_string(),\n        }\n    }\n    fn escape_html(input: &str) -> String {\n        input.chars().map(|c| {\n            match c {\n                '&'  => \"&amp;\".to_string(),\n                '<'  => \"&lt;\".to_string(),\n                '>'  => \"&gt;\".to_string(),\n                '\"'  => \"&quot;\".to_string(),\n                '\\'' => \"&#x27;\".to_string(),\n                _    => c.to_string(),\n            }\n        }).collect::<String>()\n    }\n    pub fn assemble(&self, user_input: &str) -> String {\n        let ptr = user_input.as_ptr();\n        let len = user_input.len();\n        let raw_input = unsafe {\n            let raw_slice = std::slice::from_raw_parts(ptr, len);\n            std::str::from_utf8_unchecked(raw_slice)\n        };\n        let safe_input = Self::escape_html(raw_input);\n        format!(\"{}{} </body></html>\", self.template, safe_input)\n    }\n}\nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n    let user_data = if args.len() > 1 {\n        args[1].clone()\n    } else {\n        \"Default Content\".to_string()\n    };\n    let page = Arc::new(Page::new(\"<html><body>\"));\n    let page_clone = Arc::clone(&page);\n    let handle = thread::spawn(move || {\n        page_clone.assemble(&user_data)\n    });\n    let result = handle.join().unwrap();\n    println!(\"{}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Renderer {\n    buffer: Arc<Mutex<String>>,\n}\nimpl Renderer {\n    fn new() -> Self {\n        Renderer {\n            buffer: Arc::new(Mutex::new(String::new())),\n        }\n    }\n    fn escape(input: &str) -> String {\n        input.chars().fold(String::new(), |mut acc, c| {\n            match c {\n                '&' => acc.push_str(\"&amp;\"),\n                '<' => acc.push_str(\"&lt;\"),\n                '>' => acc.push_str(\"&gt;\"),\n                '\"' => acc.push_str(\"&quot;\"),\n                '\\'' => acc.push_str(\"&#x27;\"),\n                _ => acc.push(c),\n            }\n            acc\n        })\n    }\n    fn render(&self, input: &str) -> String {\n        let cloned_buffer = Arc::clone(&self.buffer);\n        let input_owned = input.to_owned();\n        let handle = thread::spawn(move || {\n            unsafe {\n                let ptr = input_owned.as_ptr();\n                let len = input_owned.len();\n                let slice = std::str::from_utf8_unchecked(std::slice::from_raw_parts(ptr, len));\n                let mut lock = cloned_buffer.lock().unwrap();\n                lock.push_str(slice);\n            }\n        });\n        handle.join().unwrap();\n        let current = self.buffer.lock().unwrap();\n        let safe_content = Self::escape(&current);\n        format!(\"<html><body><div>{}</div></body></html>\", safe_content)\n    }\n}\nfn main() {\n    let input = env::args().nth(1).unwrap_or_else(|| \"default\".to_string());\n    let engine = Renderer::new();\n    let result = engine.render(&input);\n    println!(\"{}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Renderer {\n    template: String,\n}\nimpl Renderer {\n    fn new() -> Self {\n        Renderer { template: \"<html><body>{}</body></html>\".to_string() }\n    }\n    fn generate(&self, input: &str) -> String {\n        let safe_input = html_escape(input);\n        self.template.replace(\"{}\", &safe_input)\n    }\n}\nfn html_escape(input: &str) -> String {\n    let mut escaped = String::with_capacity(input.len());\n    for c in input.chars() {\n        match c {\n            '<' => escaped.push_str(\"&lt;\"),\n            '>' => escaped.push_str(\"&gt;\"),\n            '&' => escaped.push_str(\"&amp;\"),\n            '\"' => escaped.push_str(\"&quot;\"),\n            '\\'' => escaped.push_str(\"&#x27;\"),\n            _ => escaped.push(c),\n        }\n    }\n    escaped\n}\nfn main() {\n    let renderer = Arc::new(Mutex::new(Renderer::new()));\n    let renderer_clone = Arc::clone(&renderer);\n    let handle = thread::spawn(move || {\n        let input = \"<script>alert('XSS');</script>\";\n        let html = renderer_clone.lock().unwrap().generate(input);\n        println!(\"{}\", html);\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::thread;\nuse std::sync::{Arc, Mutex};\nstruct Renderer {\n    template: String,\n}\nimpl Renderer {\n    fn new() -> Self {\n        Renderer { template: \"<html><body>{content}</body></html>\".to_string() }\n    }\n    fn render(&self, input: &str) -> String {\n        let safe_input = escape_html(input);\n        self.template.replace(\"{content}\", &safe_input)\n    }\n}\nfn escape_html(input: &str) -> String {\n    input.replace('&', \"&amp;\")\n         .replace('<', \"&lt;\")\n         .replace('>', \"&gt;\")\n         .replace('\"', \"&quot;\")\n         .replace('\\'', \"&#x27;\")\n}\nfn handle_input(input: String) -> String {\n    let renderer = Renderer::new();\n    let shared_output = Arc::new(Mutex::new(String::new()));\n    let shared_clone = Arc::clone(&shared_output);\n    let handle = thread::spawn(move || {\n        let rendered = renderer.render(&input);\n        let mut guard = shared_clone.lock().unwrap();\n        *guard = rendered;\n    });\n    handle.join().unwrap();\n    Arc::try_unwrap(shared_output).unwrap().into_inner().unwrap()\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let user_input = if args.len() > 1 { args[1].clone() } else { \"default\".to_string() };\n    let output = handle_input(user_input);\n    println!(\"{}\", output);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nfn escape_html(input: &str) -> String {\n    let mut escaped = String::with_capacity(input.len());\n    for ch in input.chars() {\n        match ch {\n            '<' => escaped.push_str(\"&lt;\"),\n            '>' => escaped.push_str(\"&gt;\"),\n            '&' => escaped.push_str(\"&amp;\"),\n            '\"' => escaped.push_str(\"&quot;\"),\n            '\\'' => escaped.push_str(\"&#x27;\"),\n            '/' => escaped.push_str(\"&#x2F;\"),\n            _ => escaped.push(ch),\n        }\n    }\n    escaped\n}\nfn render(input: &str) -> String {\n    let safe_str = escape_html(input);\n    format!(\"<html><body><h1>Welcome {}</h1></body></html>\", safe_str)\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let user_input = if args.len() > 1 { args[1].clone() } else { String::new() };\n    let shared = Arc::new(Mutex::new(user_input));\n    let shared_clone = Arc::clone(&shared);\n    let handle = thread::spawn(move || {\n        let input = shared_clone.lock().unwrap();\n        let page = render(&input);\n        println!(\"{}\", page);\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fmt::Write;\npub struct Template {\n    header: String,\n    footer: String,\n}\nimpl Template {\n    pub fn new() -> Self {\n        Template {\n            header: \"<html><body>\".to_string(),\n            footer: \"</body></html>\".to_string(),\n        }\n    }\n    fn escape(input: &str) -> String {\n        let mut escaped = String::with_capacity(input.len());\n        for c in input.chars() {\n            match c {\n                '<' => escaped.push_str(\"&lt;\"),\n                '>' => escaped.push_str(\"&gt;\"),\n                '&' => escaped.push_str(\"&amp;\"),\n                '\"' => escaped.push_str(\"&quot;\"),\n                '\\'' => escaped.push_str(\"&#x27;\"),\n                '/' => escaped.push_str(\"&#x2F;\"),\n                _ => escaped.push(c),\n            }\n        }\n        escaped\n    }\n    pub fn render(&self, content: &str) -> String {\n        let mut out = String::with_capacity(self.header.len() + self.footer.len() + content.len());\n        out.push_str(&self.header);\n        let safe_content = Self::escape(content);\n        out.push_str(&safe_content);\n        out.push_str(&self.footer);\n        out\n    }\n}\npub fn main() {\n    let tmpl = Template::new();\n    let user_input = <script>alert('XSS');</script>\"#;\n    let html = tmpl.render(user_input);\n    println!(\"{}\", html);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct TemplateRenderer {\n    data: Arc<Mutex<String>>,\n}\nimpl TemplateRenderer {\n    pub fn new() -> Self {\n        TemplateRenderer {\n            data: Arc::new(Mutex::new(String::from(\"<html><body>\"))),\n        }\n    }\n    pub fn escape_html(input: &str) -> String {\n        input.replace('&', \"&amp;\")\n             .replace('<', \"&lt;\")\n             .replace('>', \"&gt;\")\n             .replace('\\\"', \"&quot;\")\n             .replace('\\'', \"&#x27;\")\n    }\n    pub fn append_user_input(&self, input: &str) {\n        let sanitized = TemplateRenderer::escape_html(input);\n        {\n            let mut locked = self.data.lock().unwrap();\n            locked.push_str(&sanitized);\n        }\n    }\n    pub fn render(&self) -> String {\n        let final_html = {\n            let locked = self.data.lock().unwrap();\n            format!(\"{}{}\", *locked, \"</body></html>\")\n        };\n        final_html\n    }\n}\nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n    let user_input = if args.len() > 1 { &args[1] } else { \"\" };\n    let renderer = TemplateRenderer::new();\n    let renderer_clone = renderer.data.clone();\n    let handle = thread::spawn(move || {\n        let _ = renderer_clone.lock().unwrap().as_bytes()[0];\n    });\n    renderer.append_user_input(user_input);\n    handle.join().unwrap();\n    let output = renderer.render();\n    println!(\"{}\", output);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct TemplateEngine {\n    template: String,\n}\nimpl TemplateEngine {\n    fn new(template: &str) -> Self {\n        TemplateEngine {\n            template: template.to_string(),\n        }\n    }\n    fn escape_html(input: &str) -> String {\n        input\n            .chars()\n            .map(|ch| match ch {\n                '&' => \"&amp;\".to_string(),\n                '<' => \"&lt;\".to_string(),\n                '>' => \"&gt;\".to_string(),\n                '\"' => \"&quot;\".to_string(),\n                '\\'' => \"&#x27;\".to_string(),\n                _ => ch.to_string(),\n            })\n            .collect()\n    }\n    fn render(&self, input: &str) -> String {\n        let mut output = self.template.clone();\n        let placeholder = \"{{input}}\";\n        if output.contains(placeholder) {\n            let escaped = Self::escape_html(input);\n            output = output.replace(placeholder, &escaped);\n        }\n        output\n    }\n}\nfn main() {\n    let engine = Arc::new(Mutex::new(TemplateEngine::new(\n        \"<html><body>User: {{input}}</body></html>\",\n    )));\n    let engine_clone = engine.clone();\n    let handle = thread::spawn(move || {\n        let eng = engine_clone.lock().unwrap();\n        let user_input = \"<script>alert('xss');</script>\";\n        eng.render(user_input)\n    });\n    let result = handle.join().unwrap();\n    println!(\"{}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\ntrait Template {\n    fn render(&self, input: &str) -> String;\n}\nstruct Page {\n    header: String,\n    content: String,\n}\nimpl Template for Page {\n    fn render(&self, input: &str) -> String {\n        let safe = escape_html(input);\n        format!(\"{}<div>{}</div>{}\", self.header, safe, self.content)\n    }\n}\nfn escape_html(input: &str) -> String {\n    let mut escaped = String::with_capacity(input.len());\n    for ch in input.chars() {\n        match ch {\n            '<' => escaped.push_str(\"&lt;\"),\n            '>' => escaped.push_str(\"&gt;\"),\n            '&' => escaped.push_str(\"&amp;\"),\n            '\"' => escaped.push_str(\"&quot;\"),\n            '\\'' => escaped.push_str(\"&#x27;\"),\n            _ => escaped.push(ch),\n        }\n    }\n    escaped\n}\nfn process(input: &str, page: Arc<Mutex<Page>>) -> String {\n    let result = {\n        let guard = page.lock().unwrap();\n        guard.render(input)\n    };\n    result\n}\nfn main() {\n    let page = Arc::new(Mutex::new(Page {\n        header: \"<html><head><title>Test</title></head><body>\".to_string(),\n        content: \"</body></html>\".to_string(),\n    }));\n    let injection = \"<script>alert('XSS');</script>\";\n    let mut threads = vec![];\n    for _ in 0..4 {\n        let copy = Arc::clone(&page);\n        let text = injection.to_string();\n        threads.push(thread::spawn(move || process(&text, copy)));\n    }\n    for handle in threads {\n        let html = handle.join().unwrap();\n        println!(\"{}\", html);\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nfn escape_html(input: &str) -> String {\n    input.chars().map(|c| {\n        match c {\n            '&' => \"&amp;\".to_owned(),\n            '<' => \"&lt;\".to_owned(),\n            '>' => \"&gt;\".to_owned(),\n            '\"' => \"&quot;\".to_owned(),\n            '\\'' => \"&#x27;\".to_owned(),\n            '/' => \"&#x2F;\".to_owned(),\n            _ => c.to_string(),\n        }\n    }).collect::<String>()\n}\nstruct Renderer {\n    tpl: String,\n}\nimpl Renderer {\n    fn new(template: &str) -> Self {\n        Renderer {\n            tpl: template.to_owned(),\n        }\n    }\n    fn render(&self, input: &str) -> String {\n        let safe_input = escape_html(input);\n        self.tpl.replace(\"{user_data}\", &safe_input)\n    }\n}\nfn concurrent_process(renderer: Arc<Mutex<Renderer>>, input: String) -> String {\n    let handle = thread::spawn(move || {\n        let renderer = renderer.lock().unwrap();\n        renderer.render(&input)\n    });\n    handle.join().unwrap()\n}\nfn main() {\n    let tpl = \"<html><body>Hello, {user_data}!</body></html>\";\n    let renderer = Arc::new(Mutex::new(Renderer::new(tpl)));\n    let user_input = \"<script>alert('XSS');</script>\".to_string();\n    let result = concurrent_process(renderer, user_input);\n    println!(\"Output: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nfn escape_html(input: &str) -> String {\n    input\n        .chars()\n        .map(|c| match c {\n            '&'  => \"&amp;\".to_string(),\n            '<'  => \"&lt;\".to_string(),\n            '>'  => \"&gt;\".to_string(),\n            '\"'  => \"&quot;\".to_string(),\n            '\\'' => \"&#x27;\".to_string(),\n            '/'  => \"&#x2F;\".to_string(),\n            _    => c.to_string(),\n        })\n        .collect()\n}\nstruct App {\n}\nimpl App {\n    fn new() -> Self {\n        App {}\n    }\n    fn render(&self, input: &str) -> String {\n        let header = \"<html><body>Hello, \";\n        let footer = \"</body></html>\";\n        let safe_input = escape_html(input);\n        let total_len = header.len() + safe_input.len() + footer.len();\n        let mut buffer: Vec<u8> = Vec::with_capacity(total_len);\n        unsafe {\n            buffer.set_len(total_len);\n            std::ptr::copy_nonoverlapping(header.as_ptr(), buffer.as_mut_ptr(), header.len());\n            std::ptr::copy_nonoverlapping(\n                safe_input.as_ptr(),\n                buffer.as_mut_ptr().add(header.len()),\n                safe_input.len(),\n            );\n            std::ptr::copy_nonoverlapping(\n                footer.as_ptr(),\n                buffer.as_mut_ptr().add(header.len() + safe_input.len()),\n                footer.len(),\n            );\n        }\n        String::from_utf8(buffer).unwrap()\n    }\n    fn handle(&self, payload: String) -> String {\n        self.render(&payload)\n    }\n}\nfn main() {\n    let app = Arc::new(App::new());\n    let app_clone = Arc::clone(&app);\n    let handle = thread::spawn(move || {\n        let attack_payload = \"<script>alert('XSS');</script>\";\n        app_clone.handle(attack_payload.to_string())\n    });\n    let output = handle.join().unwrap();\n    println!(\"{}\", output);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nfn escape_html(input: &str) -> String {\n    input.chars().map(|c| {\n        match c {\n            '<' => \"&lt;\".to_owned(),\n            '>' => \"&gt;\".to_owned(),\n            '&' => \"&amp;\".to_owned(),\n            '\"' => \"&quot;\".to_owned(),\n            '\\'' => \"&#x27;\".to_owned(),\n            _ => c.to_string()\n        }\n    }).collect()\n}\nstruct Renderer {\n    data: Arc<Mutex<String>>,\n}\nimpl Renderer {\n    fn new() -> Self {\n        Renderer {\n            data: Arc::new(Mutex::new(String::new())),\n        }\n    }\n    fn render(&self, input: &str) -> String {\n        let safe_input = escape_html(input);\n        format!(\"<html><body>Hello, {}!</body></html>\", safe_input)\n    }\n}\nfn main() {\n    let renderer = Renderer::new();\n    let inputs = vec![\"Alice\", \"<script>alert('XSS')</script>\"];\n    let threads: Vec<_> = inputs\n        .into_iter()\n        .map(|text| {\n            let clone = renderer.data.clone();\n            let instance = Renderer { data: clone };\n            let payload = text.to_string();\n            thread::spawn(move || {\n                instance.render(&payload)\n            })\n        })\n        .collect();\n    for t in threads {\n        let result = t.join().expect(\"Thread panicked\");\n        let mut locked = renderer.data.lock().unwrap();\n        *locked = result.clone();\n        println!(\"{}\", result);\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::cell::UnsafeCell;\nuse std::sync::Arc;\nuse std::thread;\nstruct Counter {\n    count: UnsafeCell<u32>,\n}\nunsafe impl Sync for Counter {}\nimpl Counter {\n    fn new() -> Self {\n        Counter { count: UnsafeCell::new(1) }\n    }\n    fn update(&self, factor: u32) {\n        unsafe {\n            let ptr = self.count.get();\n            let current = *ptr;\n            let computed = match (current as u64).checked_mul(factor as u64) {\n                Some(val) if val <= (u32::MAX as u64) => val as u32,\n                _ => u32::MAX, \n            };\n            *ptr = computed;\n        }\n    }\n    fn value(&self) -> u32 {\n        unsafe { *self.count.get() }\n    }\n}\nfn run_and_fetch() -> u32 {\n    let counter = Arc::new(Counter::new());\n    let mut threads = Vec::new();\n    for _ in 0..4 {\n        let cnt = counter.clone();\n        threads.push(thread::spawn(move || {\n            for _ in 0..5 {\n                cnt.update(0x4000_0000);\n            }\n        }));\n    }\n    for t in threads {\n        t.join().unwrap();\n    }\n    counter.value()\n}\nfn run_app() {\n    let final_val = run_and_fetch();\n    println!(\"Final value: {}\", final_val);\n}\nfn main() {\n    run_app();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\npub struct Engine {\n    value: u32,\n}\nimpl Engine {\n    pub fn compute(&self, factor: u32) -> u32 {\n        match self.value.checked_mul(factor) {\n            Some(result) => result,\n            None => panic!(\"Arithmetic overflow detected\"),\n        }\n    }\n    pub fn process(&self, factor: u32) -> u32 {\n        self.compute(factor)\n    }\n}\nfn main() {\n    let engine = Arc::new(Engine { value: u32::MAX / 2 + 1 });\n    let engine_clone = Arc::clone(&engine);\n    let handle = thread::spawn(move || {\n        engine_clone.process(2)\n    });\n    let result = handle.join().unwrap();\n    println!(\"Result: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::alloc::{alloc, dealloc, Layout};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\npub struct Buffer {\n    pub data: *mut u8,\n    pub size: usize,\n}\nimpl Buffer {\n    pub fn new(count: usize, elem_size: usize) -> Result<Buffer, &'static str> {\n        let total = count.checked_mul(elem_size).ok_or(\"Overflow detected\")?;\n        let shared = Arc::new(Mutex::new(Some(total)));\n        let shared_clone = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            let mut val = shared_clone.lock().unwrap();\n            *val = Some(total);\n        });\n        handle.join().unwrap();\n        let total_size = shared.lock().unwrap().unwrap();\n        let layout = Layout::from_size_align(total_size, 8).map_err(|_| \"Layout error\")?;\n        let ptr = unsafe { alloc(layout) };\n        if ptr.is_null() && total_size != 0 {\n            return Err(\"Allocation failed\");\n        }\n        Ok(Buffer { data: ptr, size: total_size })\n    }\n    pub fn fill(&self, value: u8) {\n        unsafe {\n            for i in 0..self.size {\n                *self.data.add(i) = value;\n            }\n        }\n    }\n}\nimpl Drop for Buffer {\n    fn drop(&mut self) {\n        if self.size != 0 {\n            unsafe {\n                let layout = Layout::from_size_align(self.size, 8).unwrap();\n                dealloc(self.data, layout);\n            }\n        }\n    }\n}\nfn main() {\n    match Buffer::new(usize::MAX / 2 + 1, 2) {\n        Ok(buf) => {\n            buf.fill(0xAA);\n            println!(\"Buffer filled with 0xAA\");\n        },\n        Err(e) => {\n            println!(\"Error: {}\", e);\n        }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\npub struct Matrix {\n    data: Box<[u8]>,\n    rows: u32,\n    cols: u32,\n}\nimpl Matrix {\n    pub fn create(rows: u32, cols: u32) -> Result<Matrix, &'static str> {\n        let total = rows.checked_mul(cols).ok_or(\"Arithmetic overflow\")?;   \n        let expected = (rows as u64 * cols as u64) as usize;\n        let alloc_size = total as usize;\n        if alloc_size != expected {\n            return Err(\"Mismatch in allocated size; possible overflow\");\n        }\n        let mut buf = Vec::with_capacity(alloc_size);\n        unsafe {\n            buf.set_len(alloc_size);\n        }\n        Ok(Matrix {\n            data: buf.into_boxed_slice(),\n            rows,\n            cols,\n        })\n    }\n    pub fn size(&self) -> usize {\n        self.data.len()\n    }\n    pub fn fill(&mut self, value: u8) {\n        let ptr = self.data.as_mut_ptr();\n        unsafe {\n            for i in 0..self.data.len() {\n                *ptr.add(i) = value;\n            }\n        }\n    }\n}\nfn main() {\n    let rows = 100_000;\n    let cols = 200_000;\n    let matrix = Matrix::create(rows, cols).unwrap_or_else(|e| {\n        println!(\"Error: {}\", e);\n        std::process::exit(1);\n    });\n    let mut handle_matrix = matrix;\n    handle_matrix.fill(42);\n    let shared = Arc::new(Mutex::new(handle_matrix));\n    let thread_shared = Arc::clone(&shared);\n    let th = thread::spawn(move || {\n        let matrix = thread_shared.lock().unwrap();\n        println!(\"Matrix size (elements): {}\", matrix.size());\n    });\n    th.join().unwrap();\n    println!(\"Main thread: Matrix created with {} rows and {} cols\", rows, cols);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\npub trait Multiply {\n    fn calc(&self, x: u32) -> Result<u32, &'static str>;\n}\npub struct Operator;\nimpl Multiply for Operator {\n    fn calc(&self, x: u32) -> Result<u32, &'static str> {\n        match x.checked_mul(x) {\n            Some(product) => Ok(product),\n            None => Err(\"overflow\"),\n        }\n    }\n}\npub fn get_result(x: u32) -> Result<u32, &'static str> {\n    let op = Operator;\n    op.calc(x)\n}\nfn main() {\n    let value = 70000;\n    let op = Arc::new(Operator);\n    let mut handles = Vec::new();\n    for _ in 0..4 {\n        let op_clone = Arc::clone(&op);\n        let val = value;\n        handles.push(thread::spawn(move || {\n            let res = op_clone.calc(val);\n            println!(\"Result: {:?}\", res);\n            res\n        }));\n    }\n    for handle in handles {\n        let _ = handle.join();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\n#![allow(unused_variables)]\nuse std::thread;\npub mod calc {\n    pub fn compute(a: u64, b: u64) -> Result<u32, &'static str> {\n        if let Some(prod) = a.checked_mul(b) {\n            if prod <= u32::MAX as u64 {\n                Ok(prod as u32)\n            } else {\n                Err(\"Overflow detected\")\n            }\n        } else {\n            Err(\"Overflow detected\")\n        }\n    }\n}\nfn main() {\n    let a: u64 = 3_000_000_000; \n    let b: u64 = 4;\n    let handle = thread::spawn(move || {\n        match calc::compute(a, b) {\n            Ok(val) => {\n                println!(\"Computed value: {}\", val);\n                val\n            },\n            Err(err) => {\n                println!(\"Error: {}\", err);\n                0\n            }\n        }\n    });\n    let result = handle.join().expect(\"Thread panicked\");\n    if result == 0 {\n        std::process::exit(0);\n    } else {\n        std::process::exit(1);\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Processor {\n    value: u32,\n}\nimpl Processor {\n    pub fn compute(&self) -> u64 {\n        let val = self.value as u64;\n        val.checked_mul(100_000).expect(\"Overflow detected during multiplication!\")\n    }\n}\nfn simulate(input: u32) -> u64 {\n    let proc = Processor { value: input };\n    let shared = Arc::new(Mutex::new(proc));\n    let shared_clone = Arc::clone(&shared);\n    let handle = thread::spawn(move || {\n        let proc_guard = shared_clone.lock().unwrap();\n        proc_guard.compute()\n    });\n    handle.join().unwrap()\n}\nfn main() {\n    let input = 50_000; \n    let result = simulate(input);\n    println!(\"Result: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#!/usr/bin/env rust\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::mem;\nstruct Buffer {\n    data: Box<[u32]>,\n}\nimpl Buffer {\n    fn new(count: u32) -> Option<Self> {\n        let size = mem::size_of::<u32>() as u32;\n        let bytes = count.checked_mul(size)?; \n        let allocation = bytes as usize;\n        let num_elements = allocation / mem::size_of::<u32>();\n        let data = vec![0u32; num_elements].into_boxed_slice();\n        Some(Buffer { data })\n    }\n    fn write_all(&mut self, value: u32) {\n        for i in 0..self.data.len() {\n            self.data[i] = value;\n        }\n    }\n    fn sum(&self) -> u32 {\n        self.data.iter().fold(0, |acc, &v| acc.wrapping_add(v))\n    }\n}\npub fn run(input: u32) -> Result<u32, String> {\n    let buf = Buffer::new(input).ok_or(\"Allocation size overflow\")?;\n    let arc = Arc::new(Mutex::new(buf));\n    let arc_clone = Arc::clone(&arc);\n    let handle = thread::spawn(move || {\n        let mut b = arc_clone.lock().unwrap();\n        b.write_all(1);\n    });\n    handle.join().unwrap();\n    let b_locked = arc.lock().unwrap();\n    Ok(b_locked.sum())\n}\nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n    let input: u32 = if args.len() > 1 {\n        args[1].parse().unwrap_or(10)\n    } else {\n        10\n    };\n    match run(input) {\n        Ok(s) => println!(\"Sum: {}\", s),\n        Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Calculator {}\nimpl Calculator {\n    pub fn compute(&self, a: u64, b: u64) -> Result<u32, &'static str> {\n        let product = a.checked_mul(b).ok_or(\"Multiplication overflow\")?;\n        if product > u32::MAX as u64 {\n            return Err(\"Result exceeds u32 bounds\");\n        }\n        Ok(product as u32)\n    }\n}\nfn main() {\n    let calc = Calculator {};\n    let a = 100_000;\n    let b = 100_000;\n    let shared_calc = Arc::new(calc);\n    let mut handles = Vec::new();\n    for _ in 0..4 {\n        let calc_clone = Arc::clone(&shared_calc);\n        let handle = thread::spawn(move || {\n            calc_clone.compute(a, b)\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        match handle.join().unwrap() {\n            Ok(val) => println!(\"Result: {}\", val),\n            Err(e) => println!(\"Error: {}\", e),\n        }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Engine {\n    factor: u32,\n}\nimpl Engine {\n    fn compute(&self, input: u32) -> u32 {\n        let input_val = input as u64;\n        let factor_val = self.factor as u64;\n        let product = input_val.wrapping_mul(factor_val);\n        if product > std::u32::MAX as u64 {\n            std::u32::MAX\n        } else {\n            product as u32\n        }\n    }\n}\nfn concurrent_process(engine: Arc<Engine>, inputs: Vec<u32>) -> Vec<u32> {\n    let results = Arc::new(Mutex::new(vec![]));\n    let mut handles = vec![];\n    for inp in inputs {\n        let engine_clone = Arc::clone(&engine);\n        let results_clone = Arc::clone(&results);\n        let handle = thread::spawn(move || {\n            let value = engine_clone.compute(inp);\n            let mut res_guard = results_clone.lock().unwrap();\n            res_guard.push(value);\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    Arc::try_unwrap(results).unwrap().into_inner().unwrap()\n}\npub fn compute_total() -> u32 {\n    let engine = Arc::new(Engine { factor: 1_000_000 });\n    let inputs = vec![5_000; 10];\n    let results = concurrent_process(engine, inputs);\n    results.into_iter().fold(0u32, |acc, x| acc.saturating_add(x))\n}\nfn main() {\n    let total = compute_total();\n    println!(\"Total: {}\", total);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Calculator {\n    sum: u32,\n}\nimpl Calculator {\n    fn add(&mut self, value: u32) {\n        self.sum = self.sum.checked_add(value).unwrap_or(u32::MAX);\n    }\n    fn get(&self) -> u32 {\n        self.sum\n    }\n}\nfn main() {\n    let calc = Arc::new(Mutex::new(Calculator { sum: u32::MAX - 5 }));\n    let mut handles = Vec::new();\n    for _ in 0..2 {\n        let calc_clone = Arc::clone(&calc);\n        let handle = thread::spawn(move || {\n            let mut calc_lock = calc_clone.lock().unwrap();\n            calc_lock.add(10);\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    let final_result = calc.lock().unwrap().get();\n    println!(\"Final result: {}\", final_result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::alloc;\nuse std::thread;\ntrait Processor {\n    fn process(&self, count: u32) -> Result<usize, &'static str>;\n}\nstruct BufferProcessor;\nimpl BufferProcessor {\n    fn new() -> Self {\n        BufferProcessor\n    }\n}\nimpl Processor for BufferProcessor {\n    fn process(&self, count: u32) -> Result<usize, &'static str> {\n        let elem_size = std::mem::size_of::<u32>();\n        let checked = count.checked_mul(elem_size as u32)\n            .ok_or(\"Integer overflow in allocation size\")?;\n        let total_size = checked as usize;\n        let layout = alloc::Layout::from_size_align(total_size, std::mem::align_of::<u32>())\n            .map_err(|_| \"Invalid layout\")?;\n        let ptr = unsafe { alloc::alloc(layout) as *mut u32 };\n        if ptr.is_null() {\n            return Err(\"Allocation failed\");\n        }\n        unsafe {\n            for i in 0..count as usize {\n                *ptr.add(i) = i as u32;\n            }\n        }\n        unsafe {\n            alloc::dealloc(ptr as *mut u8, layout);\n        }\n        println!(\"Processed {} items with capacity {}\", count, total_size);\n        Ok(total_size)\n    }\n}\nfn main() {\n    let processor = BufferProcessor::new();\n    let count = 0x40000000;\n    let handle = thread::spawn(move || {\n        match processor.process(count) {\n            Ok(size) => println!(\"Computation successful: capacity = {}\", size),\n            Err(e) => println!(\"Error: {}\", e),\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Engine {\n    value: u32,\n}\nimpl Engine {\n    fn new(initial: u32) -> Self {\n        Engine { value: initial }\n    }\n    fn process(&mut self, a: u32, b: u32) {\n        let product: u64 = (a as u64) * (b as u64);\n        if product > (u32::MAX as u64) {\n            return;\n        }\n        self.value = self.value.wrapping_add(product as u32);\n    }\n}\nfn main() {\n    let engine = Arc::new(Mutex::new(Engine::new(0)));\n    let engine_cloned = Arc::clone(&engine);\n    let handle = thread::spawn(move || {\n        let a: u32 = 30000;\n        let b: u32 = 150000;\n        let mut eng = engine_cloned.lock().unwrap();\n        eng.process(a, b);\n    });\n    handle.join().unwrap();\n    let final_val = engine.lock().unwrap().value;\n    println!(\"Final value: {}\", final_val);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Processor {\n    total: Arc<Mutex<u32>>,\n}\nimpl Processor {\n    fn new() -> Self {\n        Processor {\n            total: Arc::new(Mutex::new(0)),\n        }\n    }\n    fn combine(&self, x: u32, y: u32) {\n        if let Some(prod) = x.checked_mul(y) {\n            let mut guard = self.total.lock().unwrap();\n            *guard = guard.wrapping_add(prod);\n        } else {\n        }\n    }\n    fn get_total(&self) -> u32 {\n        *self.total.lock().unwrap()\n    }\n}\nfn main() {\n    let proc = Processor::new();\n    let handles: Vec<_> = (0..4)\n        .map(|_| {\n            let clone = Processor {\n                total: Arc::clone(&proc.total),\n            };\n            thread::spawn(move || {\n                clone.combine(3000000000, 2);\n            })\n        })\n        .collect();\n    for h in handles {\n        h.join().unwrap();\n    }\n    println!(\"Total: {}\", proc.get_total());\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::thread;\nstruct Processor;\nimpl Processor {\n    fn compute(&self, input: i32) -> i32 {\n        input.checked_mul(100_000).unwrap_or(i32::MAX)\n    }\n    fn dispatch(&self, input: i32) -> i32 {\n        let mut result = 0;\n        let handle = thread::spawn({\n            let input_clone = input;\n            move || {\n                input_clone.checked_mul(100_000).unwrap_or(i32::MAX)\n            }\n        });\n        result = self.compute(input);\n        let thread_result = handle.join().unwrap();\n        result.checked_add(thread_result).unwrap_or(i32::MAX)\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let input_val: i32 = if args.len() > 1 {\n        args[1].parse().unwrap_or(50000)\n    } else {\n        50000\n    };\n    let processor = Processor;\n    let final_result = processor.dispatch(input_val);\n    println!(\"Result: {}\", final_result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Calculator {\n    total: i64,\n}\nimpl Calculator {\n    fn new() -> Self {\n        Calculator { total: 0 }\n    }\n    fn accumulate(&mut self, a: i32, b: i32) {\n        let product = (a as i64)\n            .checked_mul(b as i64)\n            .expect(\"Multiplication overflow\");\n        self.total = self\n            .total\n            .checked_add(product)\n            .expect(\"Addition overflow\");\n    }\n}\npub fn run_accumulation(a: i32, b: i32, iterations: usize, threads: usize) -> i64 {\n    let calc = Arc::new(Mutex::new(Calculator::new()));\n    let mut handles = Vec::with_capacity(threads);\n    for _ in 0..threads {\n        let calc_clone = Arc::clone(&calc);\n        let a_copy = a;\n        let b_copy = b;\n        let handle = thread::spawn(move || {\n            for _ in 0..iterations {\n                let mut calc = calc_clone.lock().unwrap();\n                calc.accumulate(a_copy, b_copy);\n            }\n        });\n        handles.push(handle);\n    }\n    for h in handles {\n        h.join().unwrap();\n    }\n    let result = calc.lock().unwrap().total;\n    result\n}\nfn main() {\n    let result = run_accumulation(50000, 100000, 1000, 4);\n    println!(\"Computed total: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\npub struct Processor {\n    buffer: Vec<u8>,\n}\nimpl Processor {\n    pub fn new(size: usize) -> Self {\n        Processor { buffer: vec![0u8; size] }\n    }\n    pub fn compute_offset(&self, index: u32) -> Result<usize, &'static str> {\n        let factor: usize = 0x4000_0000; \n        let offset = (index as usize)\n            .checked_mul(factor)\n            .ok_or(\"Integer overflow during offset calculation\")?;\n        if offset >= self.buffer.len() {\n            return Err(\"Computed offset is out-of-bounds\");\n        }\n        Ok(offset)\n    }\n    pub fn process(&mut self, index: u32, value: u8) -> Result<(), &'static str> {\n        let offset = self.compute_offset(index)?;\n        unsafe {\n            let ptr = self.buffer.as_mut_ptr().add(offset);\n            *ptr = value;\n        }\n        Ok(())\n    }\n}\nfn concurrent_process(proc_arc: Arc<Mutex<Processor>>, index: u32, value: u8) -> Result<(), &'static str> {\n    let proc_clone = Arc::clone(&proc_arc);\n    let handle = thread::spawn(move || {\n        let mut guard = proc_clone.lock().unwrap();\n        guard.process(index, value)\n    });\n    handle.join().unwrap()\n}\nfn main() {\n    let processor = Arc::new(Mutex::new(Processor::new(1024)));\n    let input: u32 = u32::MAX;\n    match concurrent_process(processor, input, 42) {\n        Ok(_) => println!(\"Operation successful.\"),\n        Err(e) => println!(\"Operation failed: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\ntrait Operation {\n    fn compute(&self, factor: u32) -> u64;\n}\nstruct Processor {\n    data: u32,\n}\nimpl Operation for Processor {\n    fn compute(&self, factor: u32) -> u64 {\n        (self.data as u64)\n            .checked_mul(factor as u64)\n            .expect(\"Multiplication overflow\")\n    }\n}\nfn run_concurrency(proc: Arc<Processor>, factor: u32) -> u64 {\n    let handle = thread::spawn(move || {\n        proc.compute(factor)\n    });\n    handle.join().unwrap()\n}\nfn run_app() -> u64 {\n    let proc = Arc::new(Processor { data: 100_000 });\n    run_concurrency(proc, 50_000)\n}\nfn main() {\n    let result = run_app();\n    println!(\"Outcome: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nstruct Processor {\n    factor: u32,\n}\nimpl Processor {\n    fn new() -> Self {\n        Processor { factor: 100_000 }\n    }\n    fn compute(&self, x: u32) -> u64 {\n        (x as u64) * (self.factor as u64)\n    }\n}\npub fn execute() -> u64 {\n    let engine = Processor::new();\n    let inputs = vec![50_000u32, 100, 200];\n    let mut threads = Vec::new();\n    for &val in &inputs {\n        let eng = Processor { factor: engine.factor };\n        threads.push(thread::spawn(move || {\n            eng.compute(val)\n        }));\n    }\n    let mut total: u64 = 0;\n    for th in threads {\n        total = total.wrapping_add(th.join().unwrap());\n    }\n    total\n}\nfn main() {\n    let result = execute();\n    println!(\"Total: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Data {\n    num: u32,\n}\nimpl Data {\n    fn new(val: u32) -> Self {\n        Data { num: val }\n    }\n    fn process(&mut self, factor: u32) {\n        let prod = self.num.saturating_mul(factor);\n        self.num = self.num.saturating_add(prod);\n    }\n    fn value(&self) -> u32 {\n        self.num\n    }\n}\nfn update_concurrently(shared: Arc<Mutex<Data>>, factor: u32) {\n    let mut threads = Vec::new();\n    for _ in 0..2 {\n        let clone = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            let mut data = clone.lock().unwrap();\n            data.process(factor);\n        });\n        threads.push(handle);\n    }\n    for t in threads {\n        t.join().unwrap();\n    }\n}\nfn main() {\n    let data = Arc::new(Mutex::new(Data::new(0x40000000)));\n    update_concurrently(Arc::clone(&data), 4);\n    let final_value = data.lock().unwrap().value();\n    println!(\"Final value: {}\", final_value);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "--------------------------------------------------\nuse std::env;\nuse std::sync::{Arc, Mutex, mpsc};\nuse std::thread;\nuse std::time::Duration;\nuse std::ffi::c_void;\nstruct Executor;\nimpl Executor {\n    pub fn run(input: &str) -> Result<(), String> {\n        let shared_counter = Arc::new(Mutex::new(0));\n        let (tx, rx) = mpsc::channel();\n        let mut threads = vec![];\n        for i in 0..4 {\n            let counter = Arc::clone(&shared_counter);\n            let param = input.to_owned();\n            let thread_tx = tx.clone();\n            let handle = thread::spawn(move || {\n                let op_result = unsafe { risky_operation(i, &param) };\n                if let Err(e) = op_result {\n                    let _ = thread_tx.send(Err(e.to_owned()));\n                    return;\n                } else {\n                    let _ = thread_tx.send(Ok(()));\n                }\n                let mut num = counter.lock().unwrap();\n                *num += 1;\n            });\n            threads.push(handle);\n        }\n        drop(tx);\n        for result in rx {\n            if let Err(msg) = result {\n                for th in threads {\n                    let _ = th.join();\n                }\n                return Err(format!(\"A task failed: {}\", msg));\n            }\n        }\n        for th in threads {\n            let _ = th.join();\n        }\n        if *shared_counter.lock().unwrap() == 4 {\n            Ok(())\n        } else {\n            Err(\"Not all tasks completed correctly\".to_owned())\n        }\n    }\n}\nunsafe fn risky_operation(task_id: u32, param: &str) -> Result<(), &'static str> {\n    if param.contains(\"fail\") && task_id == 2 {\n        Err(\"Operation failed in unsafe block\")\n    } else {\n        Ok(())\n    }\n}\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let input = if args.len() > 1 {\n        args[1].clone()\n    } else {\n        \"pass\".to_owned()\n    };\n    match Executor::run(&input) {\n        Ok(()) => println!(\"Execution finished successfully.\"),\n        Err(e) => println!(\"Execution encountered an error: {}\", e),\n    }\n}\n--------------------------------------------------\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs;\nuse std::thread;\nuse std::sync::Arc;\nuse std::io;\nstruct Processor;\nimpl Processor {\n    fn run(&self, data: &str) -> io::Result<()> {\n        let len = data.len();\n        let mut buffer = Vec::with_capacity(len);\n        unsafe {\n            buffer.set_len(len);\n            std::ptr::copy_nonoverlapping(data.as_ptr(), buffer.as_mut_ptr(), len);\n        }\n        let message = format!(\"Processed: {}\", String::from_utf8_lossy(&buffer));\n        let msg_arc = Arc::new(message);\n        let mut handles = Vec::new();\n        for _ in 0..2 {\n            let msg_clone = Arc::clone(&msg_arc);\n            let handle = thread::spawn(move || -> io::Result<()> {\n                unsafe {\n                    Self::update_file(&msg_clone)?\n                }\n                Ok(())\n            });\n            handles.push(handle);\n        }\n        for handle in handles {\n            handle.join()\n                  .map_err(|_| io::Error::new(io::ErrorKind::Other, \"thread join failed\"))??\n        }\n        Ok(())\n    }\n    unsafe fn update_file(msg: &str) -> io::Result<()> {\n        if msg.contains(\"fail\") {\n            return Err(io::Error::new(io::ErrorKind::Other, \"simulated failure\"));\n        }\n        fs::write(\"log.txt\", msg)\n    }\n}\nfn main() {\n    let processor = Processor;\n    let input = \"test input\";\n    if let Err(e) = processor.run(input) {\n        eprintln!(\"Error: {}\", e);\n        std::process::exit(1);\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Processor {\n    config: Arc<Mutex<Config>>,\n}\nstruct Config {\n    value: i32,\n}\nimpl Processor {\n    unsafe fn modify(&self, new_val: i32) -> Result<(), &'static str> {\n        if new_val < 0 {\n            return Err(\"value cannot be negative\");\n        }\n        let mut cfg = self.config.lock().unwrap();\n        let ptr = &mut *cfg as *mut Config;\n        (*ptr).value = new_val;\n        Ok(())\n    }\n    fn execute(&self, new_val: i32) {\n        unsafe {\n            self.modify(new_val).unwrap();\n        }\n    }\n}\nfn main() {\n    let cfg = Arc::new(Mutex::new(Config { value: 0 }));\n    let proc_inst = Processor { config: cfg.clone() };\n    let t1_config = cfg.clone();\n    let t1 = thread::spawn(move || {\n        let proc_obj = Processor { config: t1_config };\n        proc_obj.execute(10);\n    });\n    t1.join().unwrap();\n    let res = unsafe { proc_inst.modify(-5) };\n    if res.is_err() {\n        println!(\"Negative update rejected safely\");\n    }\n    let final_val = cfg.lock().unwrap().value;\n    if final_val < 0 {\n        panic!(\"Invariant violation: negative value detected\");\n    }\n    println!(\"Final value: {}\", final_val);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Machine {\n    active: bool,\n    counter: u32,\n}\nimpl Machine {\n    unsafe fn init(&mut self) -> Result<(), &'static str> {\n        if self.active {\n            Ok(())\n        } else {\n            Err(\"machine inactive\")\n        }\n    }\n    fn operate(&self, shared: Arc<Mutex<Machine>>) -> Result<i32, &'static str> {\n        {\n            let mut mach = shared.lock().unwrap();\n            unsafe { mach.init()? };\n            mach.counter += 1;\n        }\n        let shared_clone = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            let mut mach = shared_clone.lock().unwrap();\n            mach.counter += 2;\n        });\n        handle.join().unwrap();\n        let mach = shared.lock().unwrap();\n        Ok(mach.counter as i32)\n    }\n}\npub fn execute() -> Result<i32, &'static str> {\n    let machine = Machine { active: false, counter: 0 };\n    let shared = Arc::new(Mutex::new(machine));\n    let result = {\n        let mach = shared.lock().unwrap();\n        mach.operate(Arc::clone(&shared))?\n    };\n    Ok(result)\n}\nfn main() {\n    match execute() {\n        Ok(val) => println!(\"Result: {}\", val),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct SecureData {\n    value: i32,\n}\nimpl SecureData {\n    unsafe fn update(&mut self, delta: i32) -> Result<(), &'static str> {\n        if self.value + delta < 0 || self.value + delta > 100 {\n            return Err(\"value out of range\");\n        }\n        self.value += delta;\n        Ok(())\n    }\n}\nfn process(data: Arc<Mutex<SecureData>>, delta: i32) {\n    let mut handles = Vec::new();\n    for _ in 0..5 {\n        let data_cloned = Arc::clone(&data);\n        let h = thread::spawn(move || {\n            unsafe {\n                let mut guard = data_cloned.lock().unwrap();\n                if guard.update(delta).is_err() {\n                    return;\n                }\n            }\n        });\n        handles.push(h);\n    }\n    for h in handles {\n        h.join().unwrap();\n    }\n}\npub fn run() -> i32 {\n    let initial = SecureData { value: 50 };\n    let shared = Arc::new(Mutex::new(initial));\n    process(Arc::clone(&shared), 10);\n    process(Arc::clone(&shared), 60);\n    let final_val = shared.lock().unwrap().value;\n    final_val\n}\nfn main() {\n    let final_value = run();\n    println!(\"Final value: {}\", final_value);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "--------------------------------------------------\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Buffer {\n    data: [u8; 1024],\n}\nimpl Buffer {\n    unsafe fn copy_into(&mut self, src: &[u8]) -> Result<(), &'static str> {\n        if src.len() > self.data.len() {\n            return Err(\"source too long\");\n        }\n        std::ptr::copy_nonoverlapping(src.as_ptr(), self.data.as_mut_ptr(), src.len());\n        Ok(())\n    }\n}\nfn execute_task(input: &[u8]) -> Result<(), &'static str> {\n    let shared = Arc::new(Mutex::new(Buffer { data: [0; 1024] }));\n    let shared_clone = Arc::clone(&shared);\n    let handle = thread::spawn(move || {\n        let mut guard = shared_clone.lock().unwrap();\n        unsafe { guard.copy_into(input) }\n    });\n    let thread_result = handle.join().map_err(|_| \"thread panicked\")?;\n    thread_result\n}\npub fn run_processing(input: &[u8]) -> Result<(), &'static str> {\n    execute_task(input)\n}\nfn main() {\n    let input = vec![1u8; 2048];\n    match run_processing(&input) {\n        Ok(_) => println!(\"Operation completed successfully (fixed).\"),\n        Err(err) => {\n            println!(\"Error encountered: {}\", err);\n            std::process::exit(1);\n        }\n    }\n}\n--------------------------------------------------\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::ptr;\nstruct Data {\n    count: Arc<Mutex<u32>>,\n}\nimpl Data {\n    unsafe fn update(&self, new_val: u32) -> Result<(), &'static str> {\n        let mut guard = self.count.lock().unwrap();\n        let raw_ptr = &mut *guard as *mut u32;\n        if new_val > 100 {\n            return Err(\"Value exceeds maximum allowed threshold\");\n        }\n        ptr::write(raw_ptr, new_val);\n        Ok(())\n    }\n}\nfn run() {\n    let data = Data { count: Arc::new(Mutex::new(0)) };\n    let data_clone = Data { count: Arc::clone(&data.count) };\n    let handle = thread::spawn(move || {\n        unsafe {\n            match data_clone.update(150) {\n                Ok(_) => {},\n                Err(e) => {\n                    panic!(\"Update failed: {}\", e);\n                }\n            };\n        }\n    });\n    handle.join().unwrap();\n    let final_value = *data.count.lock().unwrap();\n    println!(\"Final value: {}\", final_value);\n}\nfn main() {\n    run();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nstatic mut GLOBAL: u32 = 0;\nunsafe fn unsafe_update(value: u32) -> Result<(), &'static str> {\n    if value > 1000 {\n        Err(\"value too high\")\n    } else {\n        Ok(())\n    }\n}\nfn execute() -> u32 {\n    let value: u32 = 1500;\n    unsafe {\n        match unsafe_update(value) {\n            Ok(()) => {\n                GLOBAL = GLOBAL.wrapping_add(value);\n            },\n            Err(e) => {\n                println!(\"Update failed: {}\", e);\n            }\n        }\n        GLOBAL\n    }\n}\nfn main() {\n    let handle = thread::spawn(|| {\n        let res = execute();\n        println!(\"Result in thread: {}\", res);\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::fs::OpenOptions;\nuse std::io::{Write, Result, Error, ErrorKind};\nstruct Worker {\n    shared: Arc<Mutex<u32>>,\n}\nimpl Worker {\n    unsafe fn update(&self, val: u32) -> Result<()> {\n        let raw = Arc::as_ptr(&self.shared) as *const Mutex<u32>;\n        let lock = &*raw;\n        let _guard = lock.lock().map_err(|_| Error::new(ErrorKind::Other, \"mutex poisoned\"))?;\n        let mut file = OpenOptions::new().create(true).append(true).open(\"data.log\")?;\n        write!(file, \"{}\", val)?;\n        Ok(())\n    }\n    fn run(&self, iterations: u32) -> Result<()> {\n        let mut threads = Vec::new();\n        for i in 0..iterations {\n            let shared_clone = self.shared.clone();\n            let handle = thread::spawn(move || -> Result<()> {\n                unsafe {\n                    let raw = Arc::as_ptr(&shared_clone) as *const Mutex<u32>;\n                    let lock = &*raw;\n                    let mut guard = lock.lock().map_err(|_| Error::new(ErrorKind::Other, \"mutex poisoned\"))?;\n                    *guard += i;\n                }\n                let mut file = OpenOptions::new().create(true).append(true).open(\"data.log\")?;\n                write!(file, \"{}\", i)?;\n                Ok(())\n            });\n            threads.push(handle);\n        }\n        for th in threads {\n            th.join().map_err(|_| Error::new(ErrorKind::Other, \"thread panicked\"))??;\n        }\n        Ok(())\n    }\n}\nfn main() -> Result<()> {\n    let counter = Arc::new(Mutex::new(0));\n    let worker = Worker { shared: counter };\n    unsafe {\n        worker.update(100)?;\n    }\n    worker.run(10)?;\n    Ok(())\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::cell::UnsafeCell;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\npub trait Task {\n    fn execute(&self) -> Result<(), &'static str>;\n}\npub struct Worker {\n    manager: Arc<Manager>,\n    val: u8,\n}\nimpl Task for Worker {\n    fn execute(&self) -> Result<(), &'static str> {\n        let res = self.manager.append(self.val);\n        unsafe {\n            let ptr = self.manager.raw_data();\n            let _ = *ptr;\n        }\n        res\n    }\n}\npub struct Manager {\n    data: Mutex<Vec<u8>>,\n    capacity: usize,\n}\nimpl Manager {\n    pub fn new(cap: usize) -> Self {\n        Self {\n            data: Mutex::new(Vec::with_capacity(cap)),\n            capacity: cap,\n        }\n    }\n    pub fn append(&self, byte: u8) -> Result<(), &'static str> {\n        let mut guard = self.data.lock().unwrap();\n        if guard.len() >= self.capacity {\n            return Err(\"capacity exceeded\");\n        }\n        guard.push(byte);\n        Ok(())\n    }\n    pub unsafe fn raw_data(&self) -> *const u8 {\n        self.data.lock().unwrap().as_ptr()\n    }\n    pub fn len(&self) -> usize {\n        let guard = self.data.lock().unwrap();\n        guard.len()\n    }\n}\nfn run() {\n    let mgr = Arc::new(Manager::new(10));\n    let mut threads = vec![];\n    for i in 0..20 {\n        let worker = Worker {\n            manager: mgr.clone(),\n            val: i as u8,\n        };\n        let handle = thread::spawn(move || {\n            match worker.execute() {\n                Ok(()) => {}\n                Err(err) => {\n                    panic!(\"Operation failed: {}\", err);\n                }\n            }\n        });\n        threads.push(handle);\n    }\n    for handle in threads {\n        handle.join().expect(\"A thread panicked\");\n    }\n    println!(\"Final data length: {}\", mgr.len());\n}\nfn main() {\n    run();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct DataBuffer {\n    buffer: Arc<Mutex<Vec<u8>>>,\n}\nimpl DataBuffer {\n    fn new(capacity: usize) -> Self {\n        DataBuffer {\n            buffer: Arc::new(Mutex::new(vec![0; capacity])),\n        }\n    }\n    unsafe fn copy_data(&self, data: &[u8]) -> Result<(), &'static str> {\n        let mut guard = self.buffer.lock().unwrap();\n        if data.len() > guard.len() {\n            return Err(\"Buffer too small\");\n        }\n        std::ptr::copy_nonoverlapping(data.as_ptr(), guard.as_mut_ptr(), data.len());\n        Ok(())\n    }\n    pub fn run_task() -> bool {\n        let instance = DataBuffer::new(10); \n        let data = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]; \n        let expected = data.clone();\n        let inst_clone = DataBuffer {\n            buffer: instance.buffer.clone(),\n        };\n        let dclone = data.clone();\n        let handle = thread::spawn(move || {\n            unsafe {\n                match inst_clone.copy_data(&dclone) {\n                    Ok(()) => {}\n                    Err(e) if e == \"Buffer too small\" => {\n                        let mut guard = inst_clone.buffer.lock().unwrap();\n                        guard.resize(dclone.len(), 0);\n                        std::ptr::copy_nonoverlapping(dclone.as_ptr(), guard.as_mut_ptr(), dclone.len());\n                    }\n                    _ => {}\n                }\n            }\n        });\n        handle.join().unwrap();\n        let guard = instance.buffer.lock().unwrap();\n        if guard.len() != expected.len() {\n            return false;\n        }\n        for (a, b) in guard.iter().zip(expected.iter()) {\n            if a != b {\n                return false;\n            }\n        }\n        true\n    }\n}\nfn main() {\n    let success = DataBuffer::run_task();\n    if success {\n        println!(\"Operation succeeded.\");\n    } else {\n        println!(\"Operation failed.\");\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::atomic::{AtomicBool, Ordering};\nuse std::sync::Arc;\nuse std::thread;\nstruct Executor {\n    flag: Arc<AtomicBool>,\n}\nimpl Executor {\n    fn new() -> Self {\n        Executor { flag: Arc::new(AtomicBool::new(false)) }\n    }\n    fn run(&self, input: u32) -> bool {\n        let flag = self.flag.clone();\n        let handle = thread::spawn(move || {\n            let result = unsafe { Self::unsafe_op(input) };\n            if result.is_ok() {\n                flag.store(true, Ordering::Relaxed);\n            }\n        });\n        handle.join().unwrap();\n        self.flag.load(Ordering::Relaxed)\n    }\n    unsafe fn unsafe_op(input: u32) -> Result<(), &'static str> {\n        if input == 42 {\n            Err(\"Operation encountered an error\")\n        } else {\n            Ok(())\n        }\n    }\n}\nfn process_input(input: u32) -> bool {\n    let exec = Executor::new();\n    exec.run(input)\n}\nfn main() {\n    let input = 42;\n    let outcome = process_input(input);\n    println!(\"Outcome: {}\", outcome);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nconst MAX_LEN: usize = 5;\nstruct Resource {\n    data: Mutex<String>,\n}\nimpl Resource {\n    fn update(&self, new_data: &str) -> Result<(), &'static str> {\n        if new_data.len() > MAX_LEN {\n            Err(\"Input too long\")\n        } else {\n            let mut d = self.data.lock().unwrap();\n            *d = new_data.to_string();\n            Ok(())\n        }\n    }\n}\nfn process(res: Arc<Resource>, input: &str) {\n    let res_ref = &res;\n    unsafe {\n        if let Err(e) = res_ref.update(input) {\n            let truncated = &input[..MAX_LEN];\n            res_ref.update(truncated)\n                .expect(\"Fallback update failed\");\n        }\n    }\n    let res_clone = Arc::clone(&res);\n    let handle = thread::spawn(move || {\n        unsafe {\n            if let Err(e) = res_clone.update(input) {\n                let truncated = &input[..MAX_LEN];\n                res_clone.update(truncated)\n                    .expect(\"Fallback update in thread failed\");\n            }\n        }\n    });\n    handle.join().unwrap();\n}\nfn main() {\n    let resource = Arc::new(Resource {\n        data: Mutex::new(\"init\".to_string()),\n    });\n    process(Arc::clone(&resource), \"123456\");\n    let final_state = resource.data.lock().unwrap();\n    println!(\"Resulting state: {}\", *final_state);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::env;\nuse std::fs::OpenOptions;\nuse std::io::{self, Write};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nfn run() -> io::Result<()> {\n    let counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n    for i in 0..5 {\n        let counter = Arc::clone(&counter);\n        let handle = thread::spawn(move || -> io::Result<()> {\n            unsafe {\n                let path = if env::var(\"SIM_FAILURE\").is_ok() {\n                    \"invalid_dir/log.txt\"\n                } else {\n                    \"log.txt\"\n                };\n                let mut file = OpenOptions::new().write(true).create(true).open(path)?;\n                file.write_all(format!(\"Thread {} writing\\n\", i).as_bytes())?;\n            }\n            let mut num = counter.lock().unwrap();\n            *num += 1;\n            Ok(())\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().map_err(|_| io::Error::new(io::ErrorKind::Other, \"Thread panicked\"))??;\n    }\n    Ok(())\n}\nfn main() {\n    if let Err(e) = run() {\n        eprintln!(\"Critical error: {}\", e);\n        std::process::exit(1);\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nfn critical(input: u32) -> Result<(), &'static str> {\n    if input < 100 {\n        Ok(())\n    } else {\n        Err(\"Input too high\")\n    }\n}\nfn execute(input: u32) -> Result<u32, &'static str> {\n    unsafe {\n        critical(input)?;\n    }\n    let outcome = Arc::new(Mutex::new(0));\n    let outcome_thread = Arc::clone(&outcome);\n    let h = thread::spawn(move || {\n        let mut val = outcome_thread.lock().unwrap();\n        *val = 42;\n    });\n    h.join().unwrap();\n    Ok(*outcome.lock().unwrap())\n}\nfn main() {\n    let args: Vec<String> = std::env::args().collect();\n    let input_val: u32 = if args.len() > 1 {\n        args[1].parse().unwrap_or(0)\n    } else {\n        0\n    };\n    match execute(input_val) {\n        Ok(v) => println!(\"Success: {}\", v),\n        Err(e) => println!(\"Failure: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Holder {\n    data: i32,\n}\nimpl Holder {\n    fn modify(&mut self, val: i32) -> Result<(), &'static str> {\n        if val < 0 {\n            return Err(\"negative value not allowed\");\n        }\n        unsafe {\n            let ptr: *mut i32 = &mut self.data;\n            *ptr = val;\n        }\n        Ok(())\n    }\n}\nfn main() {\n    let holder = Arc::new(Mutex::new(Holder { data: 0 }));\n    let holder_clone = Arc::clone(&holder);\n    let handle = thread::spawn(move || {\n        let mut h = holder_clone.lock().unwrap();\n        h.modify(-10).expect(\"update failed due to negative value\");\n    });\n    let _ = handle.join();\n    let final_value = holder.lock().unwrap().data;\n    println!(\"Final value: {}\", final_value);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Resource {\n    data: Mutex<Vec<u8>>,\n}\nimpl Resource {\n    fn new() -> Self {\n        Resource { data: Mutex::new(Vec::new()) }\n    }\n    unsafe fn write_data(&self, bytes: &[u8]) -> Result<(), &'static str> {\n        if bytes.is_empty() {\n            return Err(\"No data to write\");\n        }\n        let mut lock = self.data.lock().unwrap();\n        lock.extend_from_slice(bytes);\n        Ok(())\n    }\n}\nfn run_update(resource: &Arc<Resource>, input: &[u8]) -> Result<(), &'static str> {\n    let res_clone = Arc::clone(resource);\n    let handle = thread::spawn(move || {\n        unsafe {\n            res_clone.write_data(input)\n        }\n    });\n    let thread_result = handle.join().map_err(|_| \"Thread panicked\")?;\n    thread_result\n}\npub fn process_update(resource: &Arc<Resource>, input: &[u8]) -> bool {\n    match run_update(resource, input) {\n        Ok(()) => true,\n        Err(_) => false,\n    }\n}\nfn main() {\n    let res = Arc::new(Resource::new());\n    let outcome = process_update(&res, b\"\");\n    if !outcome {\n        eprintln!(\"Update failed due to invalid input.\");\n        std::process::exit(1);\n    }\n    println!(\"Outcome: {}\", outcome);\n    println!(\"Data: {:?}\", res.data.lock().unwrap());\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::fs::OpenOptions;\nuse std::io;\nuse std::io::Write;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct SharedData {\n    count: usize,\n}\nimpl SharedData {\n    fn new() -> Self {\n        SharedData { count: 0 }\n    }\n}\nunsafe fn simulate_write(file: &mut std::fs::File, count: usize) -> io::Result<()> {\n    if count == 3 {\n        return Err(io::Error::new(io::ErrorKind::Other, \"Simulated write failure\"));\n    }\n    file.write_all(format!(\"count: {}\\n\", count).as_bytes())\n}\ntrait Operations {\n    fn increase(&self) -> io::Result<()>;\n}\nimpl Operations for Arc<Mutex<SharedData>> {\n    fn increase(&self) -> io::Result<()> {\n        let mut data = self.lock().unwrap();\n        data.count += 1;\n        let mut file = OpenOptions::new().append(true).create(true).open(\"log.txt\")?;\n        unsafe {\n            simulate_write(&mut file, data.count)?;\n        }\n        Ok(())\n    }\n}\nfn main() {\n    let shared = Arc::new(Mutex::new(SharedData::new()));\n    let mut handles = vec![];\n    for _ in 0..5 {\n        let handle_shared = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            for _ in 0..10 {\n                handle_shared.increase().unwrap();\n            }\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    println!(\"Final count: {}\", shared.lock().unwrap().count);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Core {\n    data: Arc<Mutex<Vec<i32>>>,\n}\nimpl Core {\n    fn new(size: usize) -> Self {\n        Core {\n            data: Arc::new(Mutex::new(vec![0; size])),\n        }\n    }\n    fn update(&self, index: usize, value: i32) -> Result<(), &'static str> {\n        let mut lock = self.data.lock().map_err(|_| \"Lock poisoned\")?;\n        if index >= lock.len() {\n            return Err(\"Index out of bounds\");\n        }\n        unsafe {\n            let ptr = lock.as_mut_ptr();\n            *ptr.add(index) = value;\n        }\n        Ok(())\n    }\n    fn concurrent_update(&self, index: usize, value: i32) -> thread::JoinHandle<Result<(), &'static str>> {\n        let data_clone = self.data.clone();\n        thread::spawn(move || {\n            let mut lock = data_clone.lock().map_err(|_| \"Lock poisoned\")?;\n            if index >= lock.len() {\n                return Err(\"Index out of bounds\");\n            }\n            unsafe {\n                let ptr = lock.as_mut_ptr();\n                *ptr.add(index) = value;\n            }\n            Ok(())\n        })\n    }\n}\nfn main() {\n    let engine = Core::new(10);\n    if let Err(e) = engine.update(9, 42) {\n        eprintln!(\"update error: {}\", e);\n        return;\n    }\n    let handle = engine.concurrent_update(8, 55);\n    match handle.join() {\n        Ok(Ok(())) => {},\n        Ok(Err(e)) => {\n            eprintln!(\"concurrent update error: {}\", e);\n            return;\n        },\n        Err(_) => {\n            eprintln!(\"Thread panicked\");\n            return;\n        }\n    }\n    assert!(engine.update(15, 99).is_err(), \"Expected error for out-of-bound update\");\n    println!(\"Processing complete\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::io::{Result, Error, ErrorKind};\nuse std::thread;\nstruct DataProcessor {\n    data: Arc<Mutex<Vec<u8>>>,\n}\nimpl DataProcessor {\n    unsafe fn add_data(&self, input: &[u8]) -> Result<()> {\n        let mut vec_guard = self.data.lock().unwrap();\n        if input.len() > vec_guard.len() {\n            return Err(Error::new(ErrorKind::Other, \"Buffer overflow\"));\n        }\n        let raw_ptr = vec_guard.as_mut_ptr();\n        for (i, &value) in input.iter().enumerate() {\n            *raw_ptr.add(i) = value;\n        }\n        Ok(())\n    }\n    fn process(&self, input: &[u8]) -> Result<()> {\n        {\n            let vec_guard = self.data.lock().unwrap();\n            if input.len() > vec_guard.len() {\n                return Err(Error::new(ErrorKind::Other, \"Buffer overflow\"));\n            }\n        }\n        unsafe { self.add_data(input) }\n    }\n}\nfn main() {\n    let data = Arc::new(Mutex::new(vec![0u8; 10])); \n    let processor = DataProcessor { data: data.clone() };\n    let clone_processor = DataProcessor { data: data.clone() };\n    let thread_handle = thread::spawn(move || {\n        let res = clone_processor.process(&[1,2,3,4,5,6,7,8,9,10,11]); \n        assert!(res.is_err(), \"Thread: Invalid input did not produce an error as expected.\");\n    });\n    let res_valid = processor.process(&[100,101,102]);\n    assert!(res_valid.is_ok());\n    thread_handle.join().unwrap();\n    println!(\"Processing complete safely.\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "struct Data {\n    value: i32,\n}\nimpl Data {\n    fn new(val: i32) -> Self {\n        Data { value: val }\n    }\n}\nfn calculate() -> i32 {\n    let boxed = Box::new(Data::new(42));\n    let ptr = Box::into_raw(boxed);\n    unsafe {\n        let result = (*ptr).value;\n        Box::from_raw(ptr);\n        result\n    }\n}\nfn main() {\n    let result = calculate();\n    println!(\"Result: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nstruct Data {\n    value: u32,\n}\nfn compute() -> u32 {\n    let resource = Box::new(Data { value: 100 });\n    let extracted = resource.value;\n    drop(resource);\n    let handle = thread::spawn(|| {\n        let _ = Box::new(Data { value: 200 });\n    });\n    handle.join().unwrap();\n    extracted\n}\nfn main() {\n    let result = compute();\n    println!(\"{}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nuse std::time::Duration;\n#[derive(Debug)]\nstruct Record {\n    value: i32,\n}\nimpl Record {\n    fn new(val: i32) -> Self {\n        Record { value: val }\n    }\n}\nfn compute() -> i32 {\n    let boxed = Box::new(Record::new(42));\n    let value = boxed.value;\n    let handle = thread::spawn(|| {\n        thread::sleep(Duration::from_millis(10));\n        let _temp = Box::new(Record::new(100));\n    });\n    handle.join().unwrap();\n    value\n}\nfn main() {\n    let result = compute();\n    println!(\"Result: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "struct Data {\n    value: i32,\n}\nfn compute() -> i32 {\n    let b = Box::new(Data { value: 42 });\n    let result = b.value;\n    result\n}\nfn main() {\n    let res = compute();\n    println!(\"Result: {}\", res);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "struct DataHolder {\n    ptr: Option<*mut i32>, \n}\nimpl DataHolder {\n    fn new(value: i32) -> Self {\n        let boxed = Box::new(value);\n        Self { ptr: Some(Box::into_raw(boxed)) }\n    }\n    unsafe fn release(&mut self) -> i32 {\n        if let Some(raw) = self.ptr.take() {\n            let value = *raw;\n            let _ = Box::from_raw(raw);\n            value\n        } else {\n            panic!(\"Memory already released\");\n        }\n    }\n}\npub fn compute_value() -> i32 {\n    let mut holder = DataHolder::new(123);\n    unsafe {\n        holder.release()\n    }\n}\nfn main() {\n    let res = compute_value();\n    println!(\"Computed result: {}\", res);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::boxed::Box;\nstruct Info {\n    value: i32,\n}\nimpl Info {\n    pub fn crunch() -> i32 {\n        let original = Box::new(Info { value: 42 });\n        let ret = original.value;\n        ret\n    }\n}\nfn main() {\n    let res = Info::crunch();\n    println!(\"Result: {}\", res);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::boxed::Box;\nstruct Resource {\n    value: i32,\n}\nimpl Resource {\n    fn new(v: i32) -> Self {\n        Resource { value: v }\n    }\n}\nfn process() -> i32 {\n    unsafe {\n        let resource = Box::new(Resource::new(42));\n        let raw_ptr: *mut Resource = Box::into_raw(resource);\n        let result = (*raw_ptr).value;\n        let _ = Box::from_raw(raw_ptr);\n        result\n    }\n}\nfn main() {\n    let result = process();\n    println!(\"Result: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "struct Memory {\n    ptr: *mut i32,\n}\nimpl Memory {\n    fn new(val: i32) -> Self {\n        let b = Box::new(val);\n        let raw = Box::into_raw(b);\n        Memory { ptr: raw }\n    }\n    unsafe fn get(&self) -> i32 {\n        *self.ptr\n    }\n}\nimpl Drop for Memory {\n    fn drop(&mut self) {\n        unsafe {\n            let _ = Box::from_raw(self.ptr);\n        }\n    }\n}\nfn run() -> i32 {\n    let mem = Memory::new(256);\n    let value = unsafe { mem.get() };\n    drop(mem);\n    value\n}\nfn main() {\n    println!(\"Result: {}\", run());\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nuse std::time::Duration;\nstruct Data {\n    number: i32,\n}\nfn acquire_shared() -> Arc<Data> {\n    Arc::new(Data { number: 1337 })\n}\nfn safe_compute(shared: &Data) -> i32 {\n    shared.number\n}\npub fn get_result() -> i32 {\n    let shared = acquire_shared();\n    safe_compute(&shared)\n}\nfn main() {\n    let result = get_result();\n    println!(\"Computed result: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\n#[derive(Debug)]\npub struct Data {\n    pub value: i32,\n}\npub fn process() -> i32 {\n    let data = Arc::new(Data { value: 512 });\n    let data_clone = Arc::clone(&data);\n    data_clone.value\n}\nfn main() {\n    let result = process();\n    println!(\"Result: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct Resource {\n    memory: Box<i32>,\n}\nimpl Resource {\n    fn obtain(&self) -> i32 {\n        *self.memory\n    }\n}\nfn allocate() -> Resource {\n    let boxed = Box::new(42);\n    Resource { memory: boxed }\n}\nfn execute() {\n    let resource = allocate();\n    let val = resource.obtain();\n    println!(\"Value: {}\", val);\n}\nfn main() {\n    execute();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\nstruct Resource {\n    data: Arc<Mutex<i32>>,\n}\nimpl Resource {\n    fn new(val: i32) -> Self {\n        Resource {\n            data: Arc::new(Mutex::new(val)),\n        }\n    }\n    fn read(&self) -> i32 {\n        *self.data.lock().unwrap()\n    }\n}\npub fn execute() -> i32 {\n    let res = Resource::new(123);\n    let data_clone = Arc::clone(&res.data);\n    let handle = thread::spawn(move || {\n        thread::sleep(Duration::from_millis(10));\n        *data_clone.lock().unwrap()\n    });\n    let main_val = res.read();\n    let thread_val = handle.join().unwrap();\n    assert_eq!(main_val, thread_val);\n    main_val\n}\nfn main() {\n    let result = execute();\n    println!(\"Value: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\nuse std::thread;\ntrait Action {\n    fn execute(&self) -> i32;\n}\nstruct Holder {\n    ptr: *const i32,\n}\nimpl Holder {\n    fn new(value: i32) -> Self {\n        let b = Box::new(value);\n        let ptr = Box::into_raw(b);\n        Holder { ptr }\n    }\n    unsafe fn deallocate(&mut self) {\n        if !self.ptr.is_null() {\n            let _ = Box::from_raw(self.ptr as *mut i32);\n            self.ptr = std::ptr::null();\n        }\n    }\n    fn read(&self) -> i32 {\n        if self.ptr.is_null() {\n            -1\n        } else {\n            unsafe { *self.ptr }\n        }\n    }\n}\nimpl Action for Holder {\n    fn execute(&self) -> i32 {\n        self.read()\n    }\n}\nfn process(holder: &Holder) -> i32 {\n    holder.execute()\n}\nfn main() {\n    let mut resource = Holder::new(12345);\n    let handle = thread::spawn(|| {\n        let dummy = Box::new(99999);\n        drop(dummy);\n    });\n    handle.join().unwrap();\n    unsafe {\n        resource.deallocate();\n    }\n    let res = process(&resource);\n    println!(\"Result: {}\", res);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Object {\n    data: i32,\n}\nimpl Object {\n    fn new(val: i32) -> Self {\n        Object { data: val }\n    }\n}\nstruct Handler {\n    handle: Arc<Object>,\n}\nimpl Handler {\n    fn new(handle: Arc<Object>) -> Self {\n        Handler { handle }\n    }\n    fn fetch(&self) -> i32 {\n        self.handle.data\n    }\n}\npub fn run() -> i32 {\n    let obj = Arc::new(Object::new(123));\n    let handler = Handler::new(Arc::clone(&obj));\n    drop(obj);\n    handler.fetch()\n}\nfn main() {\n    let handle = thread::spawn(|| {\n        let val = run();\n        println!(\"Final value: {}\", val);\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::rc::Rc;\n#[derive(Debug)]\nstruct Data {\n    value: i32,\n}\ntrait Action {\n    fn execute(&self) -> i32;\n}\nstruct Handler {\n    data: Rc<Data>,\n}\nimpl Action for Handler {\n    fn execute(&self) -> i32 {\n        self.data.value\n    }\n}\npub fn compute() -> i32 {\n    let data_rc = Rc::new(Data { value: 42 });\n    let handler = Handler { data: Rc::clone(&data_rc) };\n    let result = handler.execute();\n    result\n}\nfn main() {\n    let res = compute();\n    println!(\"Computed result: {}\", res);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\ntrait Arithmetic {\n    fn compute(&self) -> i32;\n}\nstruct Container {\n    data: i32,\n}\nimpl Arithmetic for Container {\n    fn compute(&self) -> i32 {\n        self.data + 1\n    }\n}\nfn process() -> i32 {\n    let resource = Box::new(Container { data: 99 });\n    resource.compute()\n}\nfn main() {\n    let val = process();\n    println!(\"Result: {}\", val);\n    let handle = thread::spawn(|| {\n        let boxed = Box::new(Container { data: 50 });\n        let result = boxed.compute();\n        println!(\"Thread result: {}\", result);\n    });\n    handle.join().unwrap();\n    thread::sleep(std::time::Duration::from_millis(50));\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nuse std::time::Duration;\nstruct Data {\n    value: i32,\n}\nimpl Data {\n    fn new(val: i32) -> Self {\n        Data { value: val }\n    }\n}\nfn compute() -> i32 {\n    let boxed = Box::new(Data::new(42));\n    boxed.value\n}\nfn main() {\n    let handle = thread::spawn(|| {\n        thread::sleep(Duration::from_millis(10));\n        compute()\n    });\n    let result = handle.join().expect(\"Thread panicked\");\n    println!(\"Computed result: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Data {\n    value: u32,\n}\nstruct Holder {\n    data: Arc<Data>,\n}\nimpl Holder {\n    fn new(val: u32) -> Self {\n        Self { data: Arc::new(Data { value: val }) }\n    }\n    fn read(&self) -> u32 {\n        self.data.value\n    }\n}\npub fn run_op() -> u32 {\n    let holder = Holder::new(100);\n    let data_clone = holder.data.clone();\n    let handle = thread::spawn(move || {\n        data_clone.value\n    });\n    let result = handle.join().unwrap();\n    result\n}\nfn main() {\n    let res = run_op();\n    println!(\"Result: {}\", res);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nuse std::sync::Arc;\ntrait Operation {\n    fn process(&self) -> i32;\n}\nstruct Handler;\nimpl Operation for Handler {\n    fn process(&self) -> i32 {\n        let shared = Arc::new(42);\n        let shared_clone = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            *shared_clone\n        });\n        handle.join().unwrap()\n    }\n}\npub fn compute() -> i32 {\n    let proc = Handler;\n    proc.process()\n}\nfn main() {\n    let result = compute();\n    println!(\"Result: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\npub trait Worker {\n    fn evaluate(&self) -> u32;\n}\npub struct Processor {\n    data: Arc<u32>,\n}\nimpl Processor {\n    pub fn new(val: u32) -> Self {\n        Self {\n            data: Arc::new(val),\n        }\n    }\n    pub fn compute(&self) -> u32 {\n        *self.data\n    }\n}\npub fn execute() -> u32 {\n    let job = Processor::new(42);\n    job.compute()\n}\nfn main() {\n    let res = execute();\n    println!(\"Result is: {}\", res);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::alloc::{alloc, dealloc, Layout};\nstruct Block {\n    ptr: *mut u32,\n    len: usize,\n}\nimpl Block {\n    unsafe fn from_slice(slice: &[u32]) -> Self {\n        let len = slice.len();\n        let layout = Layout::array::<u32>(len).unwrap();\n        let ptr = alloc(layout) as *mut u32;\n        if ptr.is_null() {\n            panic!(\"Allocation failed\");\n        }\n        for i in 0..len {\n            *ptr.add(i) = slice[i];\n        }\n        Block { ptr, len }\n    }\n    unsafe fn compute_sum(&self) -> u32 {\n        let mut total = 0;\n        for i in 0..self.len {\n            total += *self.ptr.add(i);\n        }\n        total\n    }\n}\nfn process_data(data: &[u32]) -> u32 {\n    unsafe {\n        let block = Block::from_slice(data);\n        let result = block.compute_sum();\n        let layout = Layout::array::<u32>(block.len).unwrap();\n        dealloc(block.ptr as *mut u8, layout);\n        result\n    }\n}\nfn main() {\n    let input = vec![1, 2, 3, 4];\n    let res = process_data(&input);\n    println!(\"Resulting sum: {}\", res);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\n#[repr(C)]\npub struct MemoryBlock {\n    data: [u8; 10],\n    flag: u8,\n}\nimpl MemoryBlock {\n    pub fn update(&mut self, index: usize, value: u8) {\n        if index < self.data.len() {\n            unsafe {\n                let ptr = self.data.as_mut_ptr();\n                *ptr.add(index) = value;\n            }\n        } else {\n        }\n    }\n}\nfn main() {\n    let block = Arc::new(Mutex::new(MemoryBlock { data: [0; 10], flag: 0 }));\n    let block_clone = Arc::clone(&block);\n    let handle = thread::spawn(move || {\n        let mut guarded = block_clone.lock().unwrap();\n        guarded.update(10, 255);\n    });\n    handle.join().unwrap();\n    let guarded = block.lock().unwrap();\n    println!(\"flag value: {}\", guarded.flag);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct BufferProcessor {\n    buffer: [u8; 10],\n}\nimpl BufferProcessor {\n    fn new() -> Self {\n        BufferProcessor { buffer: [0; 10] }\n    }\n    fn update(&mut self, input: &[u8]) -> Result<(), &'static str> {\n        if input.len() > self.buffer.len() {\n            return Err(\"Input exceeds buffer capacity\");\n        }\n        unsafe {\n            let dest = self.buffer.as_mut_ptr();\n            for i in 0..input.len() {\n                ptr::write(dest.add(i), input[i]);\n            }\n        }\n        Ok(())\n    }\n    fn read(&self) -> &[u8] {\n        &self.buffer\n    }\n}\nfn main() {\n    let mut processor = BufferProcessor::new();\n    let data = b\"HELLO\"; \n    match processor.update(data) {\n        Ok(()) => println!(\"Content: {:?}\", processor.read()),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Buffer {\n    data: Vec<u8>,\n    size: usize, \n}\nunsafe impl Send for Buffer {}\nunsafe impl Sync for Buffer {}\nimpl Buffer {\n    fn new(size: usize) -> Self {\n        let data = vec![0u8; size + 1];\n        Buffer { data, size }\n    }\n    unsafe fn fill(&self, value: u8) {\n        let ptr = self.data.as_ptr() as *mut u8;\n        for i in 0..self.size {\n            *ptr.add(i) = value;\n        }\n    }\n    fn get(&self, index: usize) -> u8 {\n        self.data[index]\n    }\n}\nfn main() {\n    let buffer = Arc::new(Buffer::new(10));\n    let buffer_clone = Arc::clone(&buffer);\n    let handle = thread::spawn(move || {\n        unsafe {\n            buffer_clone.fill(0xAA);\n        }\n    });\n    unsafe {\n        buffer.fill(0xAA);\n    }\n    handle.join().unwrap();\n    println!(\"Finished operation\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nstruct MemoryManager {\n    data: Box<[u8; 10]>,\n}\nimpl MemoryManager {\n    pub fn new() -> Self {\n        MemoryManager { data: Box::new([0; 10]) }\n    }\n    pub fn update(&mut self, index: usize, value: u8) -> Result<(), &'static str> {\n        if index < self.data.len() {\n            unsafe {\n                let ptr = self.data.as_mut_ptr();\n                *ptr.add(index) = value;\n            }\n            Ok(())\n        } else {\n            Err(\"Index out of bounds\")\n        }\n    }\n    pub fn sum(&self) -> u32 {\n        self.data.iter().map(|&x| x as u32).sum()\n    }\n}\nfn process() -> Result<u32, &'static str> {\n    let mut mgr = MemoryManager::new();\n    mgr.update(10, 42)?;\n    Ok(mgr.sum())\n}\nfn main() {\n    match process() {\n        Ok(result) => println!(\"Result: {}\", result),\n        Err(err) => println!(\"Error: {}\", err),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::boxed::Box;\nstruct MemoryBlock {\n    internal: Box<[u8]>,\n    cap: usize,\n}\nimpl MemoryBlock {\n    fn new(cap: usize) -> Self {\n        let total = cap + 1;\n        let data = vec![0u8; total].into_boxed_slice();\n        MemoryBlock { internal: data, cap }\n    }\n    fn update(&mut self, index: usize, value: u8) {\n        if index < self.cap {\n            unsafe {\n                let ptr = self.internal.as_mut_ptr();\n                *ptr.add(index) = value;\n            }\n        }\n    }\n    fn prepare(&mut self) {\n        self.internal[self.cap] = 0xFF;\n    }\n    fn validate(&self) -> bool {\n        self.internal[self.cap] == 0xFF\n    }\n}\nfn run() -> bool {\n    let mut mb = MemoryBlock::new(10);\n    mb.prepare();\n    mb.update(10, 42);\n    mb.validate()\n}\nfn main() {\n    let result = run();\n    println!(\"Integrity check: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\ntrait Operations {\n    fn update(&self, index: usize, value: i32);\n}\nstruct Buffer {\n    data: Mutex<Vec<i32>>,\n}\nimpl Buffer {\n    fn new(size: usize) -> Self {\n        Self {\n            data: Mutex::new(vec![0; size]),\n        }\n    }\n}\nimpl Operations for Buffer {\n    fn update(&self, index: usize, value: i32) {\n        let mut guard = self.data.lock().unwrap();\n        if index < guard.len() {\n            unsafe {\n                let ptr = guard.as_mut_ptr();\n                *ptr.add(index) = value;\n            }\n        } else {\n            panic!(\"Attempt to write outside of buffer bounds\");\n        }\n    }\n}\nfn main() {\n    let buf = Arc::new(Buffer::new(10));\n    let handles: Vec<_> = (0..2)\n        .map(|_| {\n            let b = Arc::clone(&buf);\n            thread::spawn(move || {\n                b.update(15, 99);\n            })\n        })\n        .collect();\n    for h in handles {\n        h.join().expect(\"Thread panicked as expected due to invalid access\");\n    }\n    let guard = buf.data.lock().unwrap();\n    println!(\"Buffer contents: {:?}\", *guard);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\n#[derive(Debug)]\nstruct Buffer {\n    data: [u8; 32],\n}\nimpl Buffer {\n    fn new() -> Self {\n        Buffer { data: [0; 32] }\n    }\n    fn update(&mut self, offset: usize, buf: &[u8]) -> Result<(), &'static str> {\n        if offset.checked_add(buf.len()).filter(|&sum| sum <= self.data.len()).is_none() {\n            return Err(\"Buffer overflow attempt detected\");\n        }\n        unsafe {\n            let dest = self.data.as_mut_ptr().add(offset);\n            std::ptr::copy_nonoverlapping(buf.as_ptr(), dest, buf.len());\n        }\n        Ok(())\n    }\n    fn read(&self) -> &[u8] {\n        &self.data\n    }\n}\n#[repr(C)]\n#[derive(Debug)]\nstruct Container {\n    buf: Buffer,\n    sentinel: u32,\n}\nimpl Container {\n    fn new() -> Self {\n        Container {\n            buf: Buffer::new(),\n            sentinel: 0xDEADBEEF,\n        }\n    }\n}\nfn main() {\n    let container = Arc::new(Mutex::new(Container::new()));\n    let thread_container = Arc::clone(&container);\n    let handle = thread::spawn(move || {\n        let data: [u8; 16] = [1; 16];\n        let mut guard = thread_container.lock().unwrap();\n        let _ = guard.buf.update(20, &data);\n    });\n    handle.join().unwrap();\n    let guard = container.lock().unwrap();\n    println!(\"Sentinel: {:#X}\", guard.sentinel);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct Container {\n    inner: Vec<u8>,\n}\nimpl Container {\n    fn new(size: usize) -> Self {\n        Container { inner: vec![0; size] }\n    }\n    fn modify(&mut self, start: isize, count: usize, val: u8) -> Result<(), &'static str> {\n        if start < 0 {\n            return Err(\"start index is negative\");\n        }\n        let start = start as usize;\n        if start.checked_add(count).filter(|&end| end <= self.inner.len()).is_none() {\n            return Err(\"Attempt to write beyond buffer boundaries\");\n        }\n        unsafe {\n            let ptr = self.inner.as_mut_ptr().add(start);\n            for i in 0..count {\n                *ptr.add(i) = val;\n            }\n        }\n        Ok(())\n    }\n}\nfn main() {\n    let mut obj = Container::new(10);\n    match obj.modify(0, 10, 42) {\n        Ok(_) => println!(\"Modification completed safely.\"),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nstruct MemoryHandler {\n    buffer: *mut u32,\n    capacity: usize,\n}\nimpl MemoryHandler {\n    pub fn new(size: usize) -> Self {\n        let mut vec = Vec::with_capacity(size);\n        vec.resize(size, 0);\n        let boxed = vec.into_boxed_slice();\n        let ptr = Box::into_raw(boxed) as *mut u32;\n        MemoryHandler {\n            buffer: ptr,\n            capacity: size,\n        }\n    }\n    pub fn write_checked(&mut self, index: usize, value: u32) -> Result<(), &'static str> {\n        if index < self.capacity {\n            unsafe {\n                *self.buffer.add(index) = value;\n            }\n            Ok(())\n        } else {\n            Err(\"Index out of bounds\")\n        }\n    }\n    pub unsafe fn read(&self, index: usize) -> u32 {\n        *self.buffer.add(index)\n    }\n    pub fn free(self) {\n        unsafe {\n            let _ = Box::from_raw(std::slice::from_raw_parts_mut(self.buffer, self.capacity));\n        }\n    }\n}\npub fn process_operation(index: usize) -> Result<u32, &'static str> {\n    let mut handler = MemoryHandler::new(10);\n    handler.write_checked(index, 99)?;\n    let res = unsafe { handler.read(index) };\n    handler.free();\n    Ok(res)\n}\nfn main() {\n    let handle = thread::spawn(|| {\n        let r = process_operation(5);\n        println!(\"Thread operation result: {:?}\", r);\n    });\n    let result = process_operation(10);\n    handle.join().unwrap();\n    println!(\"Main thread operation result: {:?}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "struct MemoryBuffer {\n    data: Vec<u32>,\n}\nimpl MemoryBuffer {\n    fn new(size: usize) -> Self {\n        Self { data: vec![0; size] }\n    }\n    pub fn update(&mut self, idx: usize, val: u32) -> Result<(), &'static str> {\n        if idx >= self.data.len() {\n            return Err(\"index out of bounds\");\n        }\n        self.data[idx] = val;\n        Ok(())\n    }\n}\nfn run() -> Result<(), &'static str> {\n    let mut buf = MemoryBuffer::new(10);\n    buf.update(10, 100)?;\n    Ok(())\n}\nfn main() {\n    match run() {\n        Ok(_) => println!(\"Operation succeeded\"),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Buffer {\n    data: Vec<u32>,\n}\nimpl Buffer {\n    fn new(size: usize) -> Self {\n        Buffer { data: vec![0u32; size] }\n    }\n    fn write_data(&mut self, idx: usize, value: u32) {\n        if idx < self.data.len() {\n            self.data[idx] = value;\n        }\n    }\n    fn read_data(&self, idx: usize) -> Option<u32> {\n        self.data.get(idx).copied()\n    }\n}\ntrait Process {\n    fn process(&self, count: usize) -> u32;\n}\nimpl Process for Buffer {\n    fn process(&self, count: usize) -> u32 {\n        self.data\n            .iter()\n            .take(count.min(self.data.len()))\n            .copied()\n            .fold(0, |acc, x| acc.wrapping_add(x))\n    }\n}\nfn execute(input: usize) -> u32 {\n    let size = 10;\n    let buffer = Arc::new(Mutex::new(Buffer::new(size)));\n    {\n        let buffer_clone = Arc::clone(&buffer);\n        thread::spawn(move || {\n            let mut buf = buffer_clone.lock().unwrap();\n            if input < buf.data.len() {\n                buf.write_data(input, 42);\n            }\n        })\n        .join()\n        .unwrap();\n    }\n    let buf = buffer.lock().unwrap();\n    buf.process((input + 1).min(buf.data.len()))\n}\nfn main() {\n    let input = 10;\n    let result = execute(input);\n    println!(\"Result: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct ManagedBuffer {\n    data: Vec<u32>,\n}\nimpl ManagedBuffer {\n    fn new(size: usize) -> Self {\n        ManagedBuffer { data: vec![0; size] }\n    }\n    fn update(&mut self, src: &[u32], start: usize, len: usize) -> Result<(), &'static str> {\n        if start.checked_add(len).filter(|&sum| sum <= self.data.len()).is_none() {\n            return Err(\"Destination buffer index out of bounds\");\n        }\n        if len > src.len() {\n            return Err(\"Source slice does not have enough elements\");\n        }\n        unsafe {\n            let dst_ptr = self.data.as_mut_ptr().add(start);\n            let src_ptr = src.as_ptr();\n            ptr::copy_nonoverlapping(src_ptr, dst_ptr, len);\n        }\n        Ok(())\n    }\n    fn get(&self) -> &[u32] {\n        &self.data\n    }\n}\nfn main() {\n    let mut buf = ManagedBuffer::new(10);\n    let source = vec![1, 2, 3, 4, 5];\n    match buf.update(&source, 8, 5) {\n        Ok(_) => println!(\"Buffer state: {:?}\", buf.get()),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\nuse std::ptr;\npub fn do_process(input: &[u8]) -> Result<u32, &'static str> {\n    let mut buf = [0u8; 16];\n    if input.len() > buf.len() {\n        return Err(\"Input too large\");\n    }\n    unsafe {\n        ptr::copy_nonoverlapping(input.as_ptr(), buf.as_mut_ptr(), input.len());\n    }\n    let sum: u32 = buf.iter().map(|&b| b as u32).sum();\n    Ok(sum)\n}\nfn main() {\n    let input = vec![1u8; 20]; \n    match do_process(&input) {\n        Ok(s) => println!(\"Sum computed: {}\", s),\n        Err(e) => println!(\"Error encountered: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Holder {\n    data: Vec<u8>,\n}\nimpl Holder {\n    fn new(size: usize) -> Self {\n        Holder { data: vec![0u8; size] }\n    }\n    fn update(&mut self, index: usize, value: u8) {\n        if index < self.data.len() {\n            unsafe {\n                let ptr = self.data.as_mut_ptr();\n                *ptr.add(index) = value;\n            }\n        } else {\n            panic!(\"Index out of bounds: {} for length {}\", index, self.data.len());\n        }\n    }\n    fn get(&self, index: usize) -> u8 {\n        self.data[index]\n    }\n}\nfn operate(holder: Arc<Mutex<Holder>>, index: usize, value: u8) {\n    let mut instance = holder.lock().unwrap();\n    instance.update(index, value);\n}\nfn main() {\n    let instance = Arc::new(Mutex::new(Holder::new(10)));\n    let instance_thread = Arc::clone(&instance);\n    let handle = thread::spawn(move || {\n        operate(instance_thread, 9, 42);\n    });\n    handle.join().unwrap();\n    println!(\"Stored value at index 9: {}\", instance.lock().unwrap().get(9));\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Buffer {\n    data: Vec<u8>,\n}\nimpl Buffer {\n    fn new(size: usize) -> Self {\n        Buffer { data: vec![0; size] }\n    }\n    pub fn update(&mut self, index: usize, val: u8) -> Result<(), &'static str> {\n        if index < self.data.len() {           \n            unsafe {\n                let ptr = self.data.as_mut_ptr().add(index);\n                *ptr = val;\n            }\n            Ok(())\n        } else {\n            Err(\"index out-of-bound\")\n        }\n    }\n    pub fn read(&self, index: usize) -> Result<u8, &'static str> {\n        if index < self.data.len() {\n            unsafe {\n                let ptr = self.data.as_ptr().add(index);\n                Ok(*ptr)\n            }\n        } else {\n            Err(\"index out-of-bound\")\n        }\n    }\n}\nfn main() {\n    let buf = Arc::new(Mutex::new(Buffer::new(5)));\n    let mut handles = vec![];\n    for i in 0..10 {\n        let buf_clone = Arc::clone(&buf);\n        let handle = thread::spawn(move || {\n            let mut locked = buf_clone.lock().unwrap();\n            let _ = locked.update(i, i as u8);\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    println!(\"Execution completed in fixed build.\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\npub struct MemoryHandler {\n    data: Vec<u8>,\n}\nimpl MemoryHandler {\n    pub fn new() -> Self {\n        MemoryHandler { data: vec![0u8; 100] }\n    }\n    pub fn update(&mut self, idx: usize, value: u8) -> bool {\n        if idx < self.data.len() {\n            unsafe {\n                *self.data.get_unchecked_mut(idx) = value;\n            }\n            true\n        } else {\n            false\n        }\n    }\n    pub fn fetch(&self, idx: usize) -> u8 {\n        if idx < self.data.len() {\n            unsafe { *self.data.get_unchecked(idx) }\n        } else {\n            0\n        }\n    }\n}\nfn main() {\n    let handler = Arc::new(Mutex::new(MemoryHandler::new()));\n    let mut threads = vec![];\n    for i in 0..10 {\n        let h = Arc::clone(&handler);\n        threads.push(thread::spawn(move || {\n            let mut mgr = h.lock().unwrap();\n            let idx = 95 + i;\n            let result = mgr.update(idx, 42);\n            if !result {\n                eprintln!(\"Attempted to update invalid index: {}\", idx);\n            }\n        }));\n    }\n    for th in threads {\n        th.join().unwrap();\n    }\n    let mgr = handler.lock().unwrap();\n    println!(\"Buffer value at index 95: {}\", mgr.fetch(95));\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\npub struct Buffer {\n    data: Box<[u8]>,\n}\nimpl Buffer {\n    pub fn new(size: usize) -> Self {\n        let vec = vec![0u8; size];\n        Buffer { data: vec.into_boxed_slice() }\n    }\n    pub fn copy_from(&mut self, input: &[u8]) -> Result<(), &'static str> {\n        if input.len() > self.data.len() {\n            return Err(\"Input length exceeds allocated memory size\");\n        }\n        unsafe {\n            let dest = self.data.as_mut_ptr();\n            for i in 0..input.len() {\n                ptr::write(dest.add(i), input[i]);\n            }\n        }\n        Ok(())\n    }\n    pub fn first(&self) -> u8 {\n        self.data[0]\n    }\n    pub fn checksum(&self) -> u32 {\n        self.data.iter().map(|&b| b as u32).sum()\n    }\n}\nfn main() {\n    let input: Vec<u8> = vec![42, 10, 20, 30, 40];\n    let mut buf = Buffer::new(input.len());\n    match buf.copy_from(&input) {\n        Ok(()) => {\n            println!(\"Buffer first element: {}\", buf.first());\n            println!(\"Buffer checksum: {}\", buf.checksum());\n        }\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct Data {\n    buffer: [u8; 64],\n    magic: u32,\n}\nimpl Data {\n    pub fn new() -> Self {\n        Self {\n            buffer: [0; 64],\n            magic: 0xDEADBEEF,\n        }\n    }\n    pub fn operate(&mut self, input: &[u8]) -> Result<(), &'static str> {\n        if input.len() > self.buffer.len() {\n            return Err(\"Input size exceeds buffer capacity\");\n        }\n        unsafe {\n            let dest = self.buffer.as_mut_ptr();\n            for i in 0..input.len() {\n                *dest.add(i) = input[i];\n            }\n        }\n        Ok(())\n    }\n    pub fn check(&self) -> bool {\n        self.magic == 0xDEADBEEF\n    }\n}\nfn main() {\n    let mut obj = Data::new();\n    let input = vec![1u8; 100];\n    let res = obj.operate(&input);\n    assert!(res.is_err(), \"Operation should fail for oversized input\");\n    println!(\"Operation rejected oversized input safely\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\npub struct Buffer {\n    data: Box<[u8]>,\n    len: usize,\n}\nimpl Buffer {\n    pub fn new(n: usize) -> Self {\n        let vec = vec![0; n + 1];\n        Buffer { data: vec.into_boxed_slice(), len: n }\n    }\n    pub unsafe fn write_byte(&mut self, index: usize, value: u8) {\n        *self.data.as_mut_ptr().add(index) = value;\n    }\n    pub fn update_range(&mut self, start: usize, count: usize, value: u8) -> Result<(), &'static str> {\n        if start.checked_add(count).filter(|&sum| sum <= self.len).is_none() {\n            return Err(\"Write range exceeds buffer bounds\");\n        }\n        for i in 0..count {\n            unsafe { self.write_byte(start + i, value); }\n        }\n        Ok(())\n    }\n    pub fn guard(&self) -> u8 {\n        self.data[self.len]\n    }\n}\nfn main() {\n    let mut buf = Buffer::new(10);\n    match buf.update_range(5, 5, 42) {\n        Ok(()) => {\n            println!(\"Buffer: {:?}\", &buf.data[..buf.len]);\n            println!(\"Guard byte: {}\", buf.guard());\n        },\n        Err(e) => {\n            println!(\"Error: {}\", e);\n        }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(dead_code)]\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::thread;\nunsafe fn constant_time_compare(stored: &str, provided: &str) -> bool {\n    let n = stored.len().max(provided.len());\n    let mut result: u8 = 0;\n    for i in 0..n {\n        let sc = if i < stored.len() { *stored.as_ptr().add(i) } else { 0 };\n        let pc = if i < provided.len() { *provided.as_ptr().add(i) } else { 0 };\n        result |= sc ^ pc;\n    }\n    (result == 0) && (stored.len() == provided.len())\n}\npub struct AccessControl {\n    accounts: HashMap<String, String>, \n}\nimpl AccessControl {\n    pub fn new() -> Self {\n        let mut map = HashMap::new();\n        map.insert(\"alice\".to_string(), \"secret\".to_string());\n        AccessControl { accounts: map }\n    }\n    pub fn authenticate(&self, username: &str, password: &str) -> Result<(), &'static str> {\n        let stored = self.accounts.get(username).map(|s| s.as_str()).unwrap_or(\"\");\n        if !stored.is_empty() && unsafe { constant_time_compare(stored, password) } {\n            Ok(())\n        } else {\n            Err(\"Invalid credentials\")\n        }\n    }\n}\nfn main() {\n    let auth = AccessControl::new();\n    let auth_arc = Arc::new(auth);\n    let cloned = Arc::clone(&auth_arc);\n    let handle = thread::spawn(move || {\n        match cloned.authenticate(\"alice\", \"wrongpass\") {\n            Ok(_) => println!(\"Authenticated\"),\n            Err(e) => println!(\"Error: {}\", e)\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\ntrait Validate {\n    fn check(&self, user: &str, pass: &str) -> Result<(), &'static str>;\n}\nstruct Repository {\n    data: Arc<Mutex<HashMap<String, String>>>,\n}\nimpl Repository {\n    fn new() -> Self {\n        let mut map = HashMap::new();\n        map.insert(\"alice\".to_string(), \"wonderland\".to_string());\n        map.insert(\"bob\".to_string(), \"builder\".to_string());\n        Repository {\n            data: Arc::new(Mutex::new(map)),\n        }\n    }\n    fn verify(&self, username: &str, password: &str) -> Result<(), &'static str> {\n        let guard = self.data.lock().unwrap();\n        let raw_map = &*guard as *const HashMap<String, String>;\n        unsafe {\n            match (*raw_map).get(username) {\n                Some(stored) if stored == password => Ok(()),\n                _ => Err(\"Invalid credentials\"),\n            }\n        }\n    }\n}\nimpl Validate for Repository {\n    fn check(&self, user: &str, pass: &str) -> Result<(), &'static str> {\n        let handle = {\n            let data_clone = self.data.clone();\n            thread::spawn(move || {\n                let _ = data_clone.lock().unwrap().len();\n            })\n        };\n        handle.join().unwrap();\n        self.verify(user, pass)\n    }\n}\nfn main() {\n    let repo = Repository::new();\n    match repo.check(\"bob\", \"wrongpass\") {\n        Ok(_) => println!(\"Access granted\"),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n#[derive(Debug, Clone)]\nstruct Record {\n    username: String,\n    password: String,\n}\nstruct Database {\n    users: Arc<Mutex<HashMap<String, Record>>>,\n}\nimpl Database {\n    fn new() -> Self {\n        let mut map = HashMap::new();\n        map.insert(\n            \"alice\".to_string(),\n            Record {\n                username: \"alice\".into(),\n                password: \"secret123\".into(),\n            },\n        );\n        Database {\n            users: Arc::new(Mutex::new(map)),\n        }\n    }\n    fn search(&self, uname: &str) -> Option<Record> {\n        let guard = self.users.lock().unwrap();\n        guard.get(uname).cloned()\n    }\n}\nfn verify(db: &Database, username: &str, password: &str) -> Result<(), String> {\n    if let Some(record) = db.search(username) {\n        if record.password == password {\n            Ok(())\n        } else {\n            Err(\"Invalid credentials\".to_string())\n        }\n    } else {\n        Err(\"Invalid credentials\".to_string())\n    }\n}\nfn main() {\n    let db = Database::new();\n    let db_arc = Arc::new(db);\n    let db_clone = db_arc.clone();\n    let handle = thread::spawn(move || {\n        thread::sleep(Duration::from_millis(10));\n        match verify(&db_clone, \"alice\", \"wrongpass\") {\n            Ok(_) => println!(\"Login succeeded\"),\n            Err(e) => println!(\"Login failed: {}\", e),\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\n#[derive(Debug)]\nstruct User {\n    username: String,\n    password: String,\n    secret: String,\n}\nstruct AuthManager {\n    users: Arc<Mutex<HashMap<String, User>>>,\n}\nimpl AuthManager {\n    fn new() -> Self {\n        AuthManager {\n            users: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n    fn add_user(&self, user: User) {\n        let mut users = self.users.lock().unwrap();\n        users.insert(user.username.clone(), user);\n    }\n    fn verify(&self, username: &str, password: &str) -> Result<&'static str, String> {\n        let users = self.users.lock().unwrap();\n        if let Some(user) = users.get(username) {\n            if user.password == password {\n                return Ok(\"Login successful\");\n            } else {\n                return Err(\"Authentication failed: invalid credentials\".to_string());\n            }\n        }\n        Err(\"Authentication failed: invalid credentials\".to_string())\n    }\n}\nfn main() {\n    let manager = AuthManager::new();\n    manager.add_user(User {\n        username: \"alice\".to_string(),\n        password: \"secret123\".to_string(),\n        secret: \"ALICE_SECRET\".to_string(),\n    });\n    match manager.verify(\"alice\", \"wrongpwd\") {\n        Ok(msg) => println!(\"{}\", msg),\n        Err(err) => println!(\"Error: {}\", err),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Account {\n    username: String,\n    password: String,\n}\nstruct Authenticator {\n    accounts: Vec<Account>,\n}\nimpl Authenticator {\n    fn new(accounts: Vec<Account>) -> Self {\n        Self { accounts }\n    }\n    fn verify(&self, user: &str, pass: &str) -> Result<(), &'static str> {\n        for account in &self.accounts {\n            if account.username == user && account.password == pass {\n                return Ok(());\n            }\n        }\n        Err(\"Authentication failed\")\n    }\n}\nfn main() {\n    let auth = Authenticator::new(vec![\n        Account { username: \"alice\".to_string(), password: \"wonderland\".to_string() },\n        Account { username: \"bob\".to_string(),  password: \"builder\".to_string() },\n    ]);\n    let auth_shared = Arc::new(auth);\n    let handles: Vec<_> = (0..2).map(|_| {\n        let auth_clone = Arc::clone(&auth_shared);\n        thread::spawn(move || {\n            let _ = auth_clone.verify(\"alice\", \"wrong\");\n        })\n    }).collect();\n    for handle in handles {\n        let _ = handle.join();\n    }\n    println!(\"Authentication check complete.\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::collections::HashMap;\nuse std::thread;\n#[derive(Debug)]\nstruct Record {\n    name: String,\n    secret_hash: u64,\n}\nstruct Manager {\n    records: Arc<Mutex<HashMap<String, Record>>>,\n}\nimpl Manager {\n    fn new() -> Self {\n        let mut map = HashMap::new();\n        map.insert(\"alice\".to_string(), Record {\n            name: \"alice\".to_string(),\n            secret_hash: Manager::compute(\"SecureP@ssw0rd\"),\n        });\n        Manager { records: Arc::new(Mutex::new(map)) }\n    }\n    fn compute(input: &str) -> u64 {\n        unsafe {\n            let bytes = input.as_bytes();\n            let mut hash: u64 = 0;\n            for i in 0..bytes.len() {\n                let ptr = bytes.as_ptr().offset(i as isize);\n                hash = hash.wrapping_add(*ptr as u64);\n            }\n            hash\n        }\n    }\n    fn verify(&self, name: &str, secret: &str) -> Result<(), &'static str> {\n        let records = self.records.lock().unwrap();\n        let valid = if let Some(record) = records.get(name) {\n            record.secret_hash == Manager::compute(secret)\n        } else {\n            false\n        };\n        if valid {\n            Ok(())\n        } else {\n            Err(\"Invalid credentials\")\n        }\n    }\n}\nfn main() {\n    let handler = Manager::new();\n    let shared = handler.records.clone();\n    let threads: Vec<_> = (0..5).map(|i| {\n        let instance = Manager { records: shared.clone() };\n        thread::spawn(move || {\n            unsafe {\n                if i % 2 == 0 {\n                    let num_ptr: *const u32 = &i;\n                    let _ = *num_ptr;\n                }\n            }\n            let _ = instance.verify(\"alice\", \"SecureP@ssw0rd\");\n        })\n    }).collect();\n    for t in threads {\n        t.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::{\n    collections::HashMap,\n    sync::Arc,\n    thread,\n    time::Duration,\n};\nstruct LoginManager {\n    users: HashMap<String, String>,\n}\nimpl LoginManager {\n    fn new() -> Self {\n        let mut users = HashMap::new();\n        users.insert(\"admin\".to_string(), \"secret123\".to_string());\n        Self { users }\n    }\n    fn validate(&self, username: &str, password: &str) -> Result<(), String> {\n        unsafe {\n            let pwd_ptr = password.as_ptr();\n            let _dummy = *pwd_ptr;\n        }\n        if let Some(stored) = self.users.get(username) {\n            if stored == password {\n                return Ok(());\n            } else {\n                return Err(\"Invalid credentials.\".to_string());\n            }\n        } else {\n            return Err(\"Invalid credentials.\".to_string());\n        }\n    }\n}\nfn main() {\n    let manager = Arc::new(LoginManager::new());\n    let mut handles = vec![];\n    let test_cases = vec![\n        (\"admin\", \"wrongpass\"),\n        (\"nonexistent\", \"anything\"),\n    ];\n    for (username, password) in test_cases {\n        let mgr = Arc::clone(&manager);\n        let uname = username.to_string();\n        let pwd = password.to_string();\n        let handle = thread::spawn(move || {\n            thread::sleep(Duration::from_millis(10));\n            match mgr.validate(&uname, &pwd) {\n                Ok(()) => println!(\"Access granted.\"),\n                Err(e) => println!(\"Access denied: {}\", e),\n            }\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused_unsafe)]\nuse std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\n#[derive(Clone)]\nstruct Account {\n    name: String,\n    secret: u64, \n}\nstruct Engine {\n    data: Arc<Mutex<HashMap<String, Account>>>,\n}\nimpl Engine {\n    fn new() -> Self {\n        Engine {\n            data: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n    unsafe fn fetch<'a>(&'a self, key: &str) -> Option<Account> {\n        let guard = self.data.lock().unwrap();\n        let ptr = &*guard as *const HashMap<String, Account>;\n        (*ptr).get(key).cloned()\n    }\n    fn verify(&self, username: &str, pwd: &str) -> Result<(), String> {\n        let account = unsafe { self.fetch(username) };\n        unsafe {\n            let computed = pwd.bytes().fold(0u64, |accum, b| {\n                accum.wrapping_mul(31).wrapping_add(b as u64)\n            });\n            let expected = account.as_ref().map(|acc| acc.secret).unwrap_or(0);\n            if computed != expected {\n                return Err(String::from(\"Authentication failed\"));\n            }\n        }\n        Ok(())\n    }\n}\nfn main() {\n    let engine = Engine::new();\n    {\n        let mut db = engine.data.lock().unwrap();\n        unsafe {\n            let hash = \"secret\".bytes().fold(0u64, |accum, b| {\n                accum.wrapping_mul(31).wrapping_add(b as u64)\n            });\n            db.insert(\"alice\".to_string(), Account { name: \"alice\".into(), secret: hash });\n        }\n    }\n    let user = \"alice\";\n    let input = \"guess\";\n    match engine.verify(user, input) {\n        Ok(_) => println!(\"Access granted for {}\", user),\n        Err(err) => println!(\"Access denied: {}\", err),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct AuthService {\n    users: Arc<Mutex<HashMap<String, String>>>,\n}\nimpl AuthService {\n    fn new() -> Self {\n        let mut m = HashMap::new();\n        m.insert(\"alice\".to_string(), \"secret\".to_string());\n        AuthService {\n            users: Arc::new(Mutex::new(m)),\n        }\n    }\n    fn authenticate(&self, username: &str, password: &str) -> Result<(), String> {\n        let users = self.users.lock().unwrap();\n        unsafe {\n            let raw_users = &*(&*users as *const HashMap<String, String>);\n            if !raw_users.contains_key(username) {\n                let _dummy = \"static_dummy\";\n            }\n        }\n        if let Some(stored) = users.get(username) {\n            if stored == password {\n                return Ok(());\n            }\n        }\n        Err(\"Invalid credentials\".to_string())\n    }\n}\nfn main() {\n    let service = AuthService::new();\n    let service_arc = Arc::new(service);\n    let mut handles = Vec::new();\n    for _ in 0..5 {\n        let service_clone = Arc::clone(&service_arc);\n        handles.push(thread::spawn(move || {\n            match service_clone.authenticate(\"bob\", \"any\") {\n                Ok(_) => println!(\"Access granted\"),\n                Err(e) => println!(\"Access denied: {}\", e),\n            }\n        }));\n    }\n    for h in handles {\n        h.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\n#[derive(Debug, PartialEq)]\nenum AuthError {\n    Failure, \n}\nstruct AuthSystem {\n    users: HashMap<String, String>, \n}\nimpl AuthSystem {\n    fn new() -> Self {\n        let mut users = HashMap::new();\n        users.insert(\"alice\".to_string(), \"password123\".to_string());\n        Self { users }\n    }\n    fn constant_time_eq(a: &str, b: &str) -> bool {\n        if a.len() != b.len() {\n            return false;\n        }\n        let mut diff = 0;\n        for (x, y) in a.as_bytes().iter().zip(b.as_bytes().iter()) {\n            diff |= x ^ y;\n        }\n        diff == 0\n    }\n    fn authenticate(&self, username: &str, password: &str) -> Result<(), AuthError> {\n        let stored = self.users.get(username);\n        let auth_success = if let Some(stored_pass) = stored {\n            Self::constant_time_eq(stored_pass, password)\n        } else {\n            Self::constant_time_eq(\"dummy_string\", password)\n        };\n        if auth_success {\n            Ok(())\n        } else {\n            Err(AuthError::Failure)\n        }\n    }\n}\nfn main() {\n    let auth = Arc::new(Mutex::new(AuthSystem::new()));\n    let auth_clone = auth.clone();\n    let handle = std::thread::spawn(move || {\n        let system = auth_clone.lock().unwrap();\n        match system.authenticate(\"alice\", \"wrongpass\") {\n            Ok(_) => println!(\"Access granted\"),\n            Err(e) => println!(\"Access denied: {:?}\", e),\n        }\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\nstruct Database {\n    users: Arc<Mutex<Vec<(String, String)>>>,\n}\nimpl Database {\n    fn new() -> Self {\n        Self {\n            users: Arc::new(Mutex::new(Vec::new())),\n        }\n    }\n    fn add_user(&self, username: &str, password: &str) {\n        self.users\n            .lock()\n            .expect(\"mutex poisoned\")\n            .push((username.to_string(), password.to_string()));\n    }\n    unsafe fn check_credentials(&self, username: &str, password: &str) -> Result<(), String> {\n        let users = self.users.lock().expect(\"mutex poisoned\");\n        let handle = thread::spawn(|| {\n            thread::sleep(Duration::from_millis(10));\n        });\n        handle.join().expect(\"Thread panicked\");\n        for (user, pass) in users.iter() {\n            if user == username {\n                let pass_ptr: *const String = pass;\n                if *pass_ptr == password {\n                    return Ok(());\n                } else {\n                    return Err(\"Invalid credentials\".to_string());\n                }\n            }\n        }\n        Err(\"Invalid credentials\".to_string())\n    }\n}\nfn main() {\n    let db = Database::new();\n    db.add_user(\"alice\", \"secret123\");\n    let result = unsafe { db.check_credentials(\"alice\", \"wrongpassword\") };\n    println!(\"{:?}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct AuthService {\n    users: Arc<Mutex<HashMap<String, String>>>,\n}\nimpl AuthService {\n    fn new() -> Self {\n        let mut user_map = HashMap::new();\n        user_map.insert(\"alice\".to_string(), \"password123\".to_string());\n        AuthService {\n            users: Arc::new(Mutex::new(user_map)),\n        }\n    }\n    fn login_auth(&self, username: &str, password: &str) -> Result<(), &'static str> {\n        let users_clone = self.users.clone();\n        let handle = thread::spawn(move || {\n            let _guard = users_clone.lock().unwrap();\n        });\n        let _ = handle.join().unwrap();\n        let valid = {\n            let guard = self.users.lock().unwrap();\n            if let Some(correct) = guard.get(username) {\n                correct == password\n            } else {\n                false\n            }\n        };\n        if valid {\n            Ok(())\n        } else {\n            Err(\"Invalid credentials\")\n        }\n    }\n}\nfn main() {\n    let service = AuthService::new();\n    match service.login_auth(\"alice\", \"wrongpassword\") {\n        Ok(_) => println!(\"Access granted\"),\n        Err(e) => println!(\"Access denied: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::{Arc, RwLock};\nuse std::thread;\nuse std::time::Duration;\nstruct Credentials {\n    data: Arc<RwLock<HashMap<String, String>>>,\n}\nimpl Credentials {\n    fn create() -> Self {\n        let mut map = HashMap::new();\n        map.insert(\"alice\".to_string(), \"secure_password\".to_string());\n        Credentials {\n            data: Arc::new(RwLock::new(map)),\n        }\n    }\n    fn authenticate(&self, user: &str, pass: &str) -> Result<(), String> {\n        let data_ref = unsafe { &*(&*self.data as *const RwLock<HashMap<String, String>>) };\n        let guard = data_ref.read().unwrap();\n        if let Some(stored_pass) = guard.get(user) {\n            if stored_pass == pass {\n                return Ok(());\n            }\n        }\n        Err(\"Invalid credentials\".to_string())\n    }\n}\nfn main() {\n    let system = Credentials::create();\n    let system_shared = Arc::new(system);\n    let system_for_thread = system_shared.clone();\n    let handle = thread::spawn(move || {\n        for _ in 0..3 {\n            let _ = system_for_thread.authenticate(\"alice\", \"wrong_password\");\n            thread::sleep(Duration::from_millis(50));\n        }\n    });\n    let _ = system_shared.authenticate(\"bob\", \"whatever\");\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Store {\n    data: Mutex<HashMap<String, String>>,\n}\nimpl Store {\n    fn new() -> Self {\n        let mut map = HashMap::new();\n        map.insert(\"alice\".to_string(), \"secret123\".to_string());\n        Store {\n            data: Mutex::new(map),\n        }\n    }\n    fn fetch(&self, user: &str) -> Option<String> {\n        let guard = self.data.lock().unwrap();\n        guard.get(user).cloned()\n    }\n}\nstruct Service {\n    store: Arc<Store>,\n}\nimpl Service {\n    fn new() -> Self {\n        Service {\n            store: Arc::new(Store::new()),\n        }\n    }\n    fn authenticate(&self, username: &str, password: &str) -> Result<String, String> {\n        let store_clone = Arc::clone(&self.store);\n        let name = username.to_string();\n        let handle = thread::spawn(move || {\n            store_clone.fetch(&name)\n        });\n        let stored = handle.join().unwrap();\n        match stored {\n            Some(stored_pass) if stored_pass == password => {\n                Ok(format!(\"User {} authenticated successfully.\", username))\n            },\n            _ => Err(\"Authentication failed: Invalid username or password.\".to_string()),\n        }\n    }\n}\nfn main() {\n    let svc = Service::new();\n    let res = svc.authenticate(\"alice\", \"wrongpassword\");\n    match res {\n        Ok(msg) => println!(\"{}\", msg),\n        Err(err) => println!(\"Error: {}\", err),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Credential {\n    username: String,\n    password: String,\n}\nstruct Auth {\n    accounts: Arc<Mutex<HashMap<String, String>>>,\n}\nimpl Auth {\n    fn new() -> Self {\n        let mut map = HashMap::new();\n        map.insert(\"alice\".to_string(), \"alice_secret\".to_string());\n        map.insert(\"bob\".to_string(), \"bob_secret\".to_string());\n        Auth {\n            accounts: Arc::new(Mutex::new(map)),\n        }\n    }\n    fn login(&self, user: &str, pass: &str) -> Result<(), String> {\n        let accounts = self.accounts.clone();\n        let user_ptr = user.as_ptr();\n        unsafe {\n            let _ = *user_ptr;\n        }\n        let acc = accounts.lock().unwrap();\n        if let Some(stored) = acc.get(user) {\n            if stored == pass {\n                return Ok(());\n            }\n        }\n        Err(\"invalid credentials\".to_string())\n    }\n}\nfn main() {\n    let auth = Auth::new();\n    let username = \"alice\";\n    let password = \"wrong_password\"; \n    match auth.login(username, password) {\n        Ok(_) => println!(\"Logged in successfully.\"),\n        Err(e) => println!(\"Login error: {}\", e),\n    }\n    let cloned_accounts = auth.accounts.clone();\n    let handle = thread::spawn(move || {\n        let acc = cloned_accounts.lock().unwrap();\n        println!(\"Total registered users: {}\", acc.len());\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct User {\n    username: String,\n    password: String,\n}\nstruct AuthSystem {\n    users: Arc<Mutex<HashMap<String, User>>>,\n}\nimpl AuthSystem {\n    fn new() -> Self {\n        AuthSystem {\n            users: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n    fn register(&self, username: &str, password: &str) {\n        let mut users = self.users.lock().unwrap();\n        users.insert(\n            username.to_string(),\n            User {\n                username: username.to_string(),\n                password: password.to_string(),\n            },\n        );\n    }\n    fn verify(&self, username: &str, password: &str) -> Result<(), String> {\n        let users = self.users.lock().unwrap();\n        let stored = users\n            .get(username)\n            .map(|user| user.password.as_str())\n            .unwrap_or(\"dummy\");\n        unsafe {\n            let input_ptr = password.as_ptr();\n            let stored_ptr = stored.as_ptr();\n            let input_len = password.len();\n            let stored_len = stored.len();\n            let mut diff = (input_len as i32) ^ (stored_len as i32);\n            let min_len = if input_len < stored_len {\n                input_len\n            } else {\n                stored_len\n            };\n            for i in 0..min_len {\n                diff |= (*input_ptr.add(i)) as i32 ^ (*stored_ptr.add(i)) as i32;\n            }\n            if diff != 0 {\n                return Err(\"Authentication failed\".to_string());\n            }\n        }\n        Ok(())\n    }\n}\nfn main() {\n    let auth = AuthSystem::new();\n    auth.register(\"alice\", \"secret\");\n    let handles: Vec<_> = (0..5)\n        .map(|_| {\n            let auth_clone = AuthSystem {\n                users: Arc::clone(&auth.users),\n            };\n            thread::spawn(move || {\n                let _ = auth_clone.verify(\"alice\", \"secret\");\n            })\n        })\n        .collect();\n    for handle in handles {\n        let _ = handle.join();\n    }\n    match auth.verify(\"alice\", \"wrong\") {\n        Ok(_) => println!(\"Logged in successfully.\"),\n        Err(e) => println!(\"Error: {}\", e),\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct AuthService {\n    users: Arc<Mutex<HashMap<String, String>>>,\n}\nimpl AuthService {\n    fn new() -> Self {\n        let mut map = HashMap::new();\n        map.insert(\"alice\".to_string(), \"wonderland\".to_string());\n        map.insert(\"bob\".to_string(), \"builder\".to_string());\n        AuthService {\n            users: Arc::new(Mutex::new(map)),\n        }\n    }\n    fn verify(&self, username: &str, password: &str) -> Result<bool, &'static str> {\n        let users_ptr = Arc::as_ptr(&self.users);\n        unsafe {\n            let users_ref = &*users_ptr;\n            let map_lock = users_ref.lock().unwrap();\n            if let Some(stored) = map_lock.get(username) {\n                if stored == password {\n                    Ok(true)\n                } else {\n                    Err(\"Authentication failed\")\n                }\n            } else {\n                Err(\"Authentication failed\")\n            }\n        }\n    }\n}\nfn main() {\n    let svc = AuthService::new();\n    let svc_arc = Arc::new(svc);\n    let handles: Vec<_> = vec![\n        {\n            let svc_clone = svc_arc.clone();\n            thread::spawn(move || {\n                let _ = svc_clone.verify(\"alice\", \"wonderland\");\n            })\n        },\n        {\n            let svc_clone = svc_arc.clone();\n            thread::spawn(move || {\n                let _ = svc_clone.verify(\"charlie\", \"chocolate\");\n            })\n        },\n    ];\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    println!(\"Execution complete: Fixed variant.\");\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::fmt;\n#[derive(Debug)]\nstruct Account {\n    username: String,\n    password: String,\n}\n#[derive(Debug)]\nstruct AuthError;\nimpl fmt::Display for AuthError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"Invalid credentials\")\n    }\n}\nstruct Authenticator {\n    accounts: Arc<Mutex<Vec<Account>>>,\n}\nimpl Authenticator {\n    fn new() -> Self {\n        let accounts = vec![\n            Account {\n                username: \"alice\".to_string(),\n                password: \"secret\".to_string(),\n            },\n            Account {\n                username: \"bob\".to_string(),\n                password: \"hunter2\".to_string(),\n            },\n        ];\n        Authenticator { accounts: Arc::new(Mutex::new(accounts)) }\n    }\n    fn verify(&self, user: &str, pass: &str) -> Result<(), AuthError> {\n        let accounts = self.accounts.lock().unwrap();\n        for acc in accounts.iter() {\n            if acc.username == user {\n                unsafe {\n                    let _ptr = acc.password.as_ptr();\n                }\n                if acc.password == pass {\n                    return Ok(());\n                }\n            }\n        }\n        Err(AuthError)\n    }\n}\nfn main() {\n    let auth = Authenticator::new();\n    let username = \"alice\";\n    let password = \"wrong_password\";\n    match auth.verify(username, password) {\n        Ok(_) => println!(\"Login successful\"),\n        Err(e) => {\n            println!(\"Error: {}\", e);\n            std::process::exit(1);\n        }\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct App {\n    storage: Arc<Mutex<HashMap<String, String>>>,\n}\n#[derive(Debug, PartialEq)]\nenum ErrorType {\n    InvalidInput,\n}\nimpl App {\n    fn new() -> Self {\n        let mut users = HashMap::new();\n        users.insert(\"alice\".to_string(), \"secret\".to_string());\n        App {\n            storage: Arc::new(Mutex::new(users)),\n        }\n    }\n    fn verify(&self, account: &str, secret: &str) -> Result<(), ErrorType> {\n        let users = self.storage.lock().unwrap();\n        let is_valid = if let Some(valid_secret) = users.get(account) {\n            unsafe {\n                let ptr = valid_secret.as_ptr();\n                let len = valid_secret.len();\n                let slice = std::slice::from_raw_parts(ptr, len);\n                let valid_str = std::str::from_utf8_unchecked(slice);\n                valid_str == secret\n            }\n        } else {\n            false\n        };\n        if is_valid {\n            Ok(())\n        } else {\n            Err(ErrorType::InvalidInput)\n        }\n    }\n}\nfn main() {\n    let service = App::new();\n    let service_arc = Arc::new(service);\n    let handles: Vec<_> = (0..5)\n        .map(|i| {\n            let srv = service_arc.clone();\n            thread::spawn(move || {\n                let _ = srv.verify(\"alice\", if i % 2 == 0 { \"wrong\" } else { \"secret\" });\n            })\n        })\n        .collect();\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Record {\n    username: String,\n    pass_hash: u64,\n}\nstruct Service {\n    users: Arc<Mutex<Vec<Record>>>,\n}\nimpl Service {\n    fn new() -> Self {\n        Service {\n            users: Arc::new(Mutex::new(Vec::new())),\n        }\n    }\n    fn register(&self, name: &str, password: &str) {\n        let hash = self.compute_hash(password);\n        let rec = Record {\n            username: name.to_string(),\n            pass_hash: hash,\n        };\n        self.users.lock().unwrap().push(rec);\n    }\n    fn authenticate(&self, name: &str, password: &str) -> Result<&'static str, &'static str> {\n        let input_hash = self.compute_hash(password);\n        let data = self.users.lock().unwrap();\n        for rec in data.iter() {\n            if rec.username == name && rec.pass_hash == input_hash {\n                return Ok(\"Access granted\");\n            }\n        }\n        Err(\"Invalid credentials\")\n    }\n    fn compute_hash(&self, input: &str) -> u64 {\n        let bytes = input.as_bytes();\n        let mut sum = 0u64;\n        unsafe {\n            let mut ptr = bytes.as_ptr();\n            for _ in 0..bytes.len() {\n                sum = sum.wrapping_add(*ptr as u64);\n                ptr = ptr.offset(1);\n            }\n        }\n        sum\n    }\n}\nfn main() {\n    let svc = Service::new();\n    svc.register(\"alice\", \"secret\");\n    let svc_clone = Service {\n        users: svc.users.clone(),\n    };\n    let handle = thread::spawn(move || {\n        let res = svc_clone.authenticate(\"alice\", \"wrongpass\");\n        println!(\"Thread result: {:?}\", res);\n    });\n    let res_main = svc.authenticate(\"nonexistent\", \"nopass\");\n    println!(\"Main thread result: {:?}\", res_main);\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct DataBuffer {\n    data: Vec<u8>,\n}\nimpl DataBuffer {\n    fn new(size: usize) -> Self {\n        let mut data = Vec::with_capacity(size);\n        for i in 0..size {\n            data.push(i as u8);\n        }\n        Self { data }\n    }\n    fn process(&self) -> u8 {\n        *self.data.last().expect(\"Vector should not be empty\")\n    }\n}\nfn main() {\n    let buffer = Arc::new(Mutex::new(DataBuffer::new(10)));\n    let clone = Arc::clone(&buffer);\n    let handle = thread::spawn(move || {\n        let guard = clone.lock().unwrap();\n        guard.process()\n    });\n    let result = handle.join().unwrap();\n    println!(\"Result: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\nstruct DataHandler;\nimpl DataHandler {\n    pub fn combine(&self, input: &[u8]) -> Vec<u8> {\n        let len = input.len();\n        let mut output = Vec::with_capacity(len + 1);\n        unsafe {\n            std::ptr::copy_nonoverlapping(input.as_ptr(), output.as_mut_ptr(), len);\n            *output.as_mut_ptr().add(len) = 0;\n            output.set_len(len + 1);\n        }\n        output\n    }\n}\nfn main() {\n    let handler = DataHandler;\n    let input = b\"test\";\n    let handle = thread::spawn(move || {\n        let result = handler.combine(input);\n        println!(\"Combined output: {:?}\", result);\n    });\n    handle.join().unwrap();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Buffer {\n    data: Vec<u32>,\n}\nimpl Buffer {\n    fn new(size: usize) -> Buffer {\n        Buffer {\n            data: Vec::with_capacity(size),\n        }\n    }\n    fn fill(&mut self) {\n        let size = self.data.capacity();\n        unsafe {\n            self.data.set_len(size);\n            let ptr = self.data.as_mut_ptr();\n            for i in 0..size {\n                *ptr.add(i) = i as u32;\n            }\n        }\n    }\n    fn sum(&self) -> u32 {\n        self.data.iter().sum()\n    }\n}\npub fn process() -> u32 {\n    let mut buffer = Buffer::new(10);\n    buffer.fill();\n    buffer.sum()\n}\nfn main() {\n    let result = process();\n    println!(\"Result: {}\", result);\n    let shared = Arc::new(Mutex::new(Buffer {\n        data: Vec::with_capacity(10),\n    }));\n    {\n        let mut temp = shared.lock().unwrap();\n        temp.fill();\n    }\n    let mut handles = Vec::new();\n    for _ in 0..5 {\n        let shared_clone = Arc::clone(&shared);\n        handles.push(thread::spawn(move || {\n            let lock = shared_clone.lock().unwrap();\n            lock.sum()\n        }));\n    }\n    for handle in handles {\n        let res = handle.join().unwrap();\n        println!(\"Thread result: {}\", res);\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct DataProcessor;\nimpl DataProcessor {\n    pub fn process(&self, input: &[u8]) -> Vec<u8> {\n        let mut result: Vec<u8> = Vec::with_capacity(input.len());\n        unsafe {\n            std::ptr::copy_nonoverlapping(input.as_ptr(), result.as_mut_ptr(), input.len());\n            result.set_len(input.len());\n        }\n        result\n    }\n}\nfn run(input: &[u8]) -> Vec<u8> {\n    let processor = Arc::new(DataProcessor);\n    let data = Arc::new(input.to_vec());\n    let output = Arc::new(Mutex::new(Vec::new()));\n    let mut handles = vec![];\n    for _ in 0..4 {\n        let proc_clone = Arc::clone(&processor);\n        let data_clone = Arc::clone(&data);\n        let out_clone = Arc::clone(&output);\n        let handle = thread::spawn(move || {\n            let res = proc_clone.process(&data_clone);\n            let mut guard = out_clone.lock().unwrap();\n            *guard = res;\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n    Arc::try_unwrap(output).unwrap().into_inner().unwrap()\n}\nfn main() {\n    let input = b\"abcdef\"; \n    let output = run(input);\n    println!(\"Output length: {}\", output.len());\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Container {\n    data: Arc<Mutex<Vec<u8>>>,\n}\nimpl Container {\n    fn new() -> Self {\n        Container { data: Arc::new(Mutex::new(Vec::with_capacity(10))) }\n    }\n    fn process(&self, value: u8) -> Result<(), &'static str> {\n        let mut guard = self.data.lock().unwrap();\n        let vec_ref = &mut *guard;\n        let len = vec_ref.len();\n        if len >= vec_ref.capacity() {\n            return Err(\"Buffer full\");\n        }\n        unsafe {\n            let ptr = vec_ref.as_mut_ptr().add(len);\n            *ptr = value;\n            vec_ref.set_len(len + 1);\n        }\n        Ok(())\n    }\n    fn inspect(&self) -> Vec<u8> {\n        self.data.lock().unwrap().clone()\n    }\n}\nfn main() {\n    let inst = Container::new();\n    for _ in 0..5 {\n        inst.process(42).expect(\"Write failed\");\n    }\n    let mut threads = Vec::new();\n    for i in 0..3 {\n        let clone = Container { data: Arc::clone(&inst.data) };\n        threads.push(thread::spawn(move || {\n            for _ in 0..2 {\n                clone.process(10 + i as u8).expect(\"Write failed\");\n            }\n        }));\n    }\n    for th in threads {\n        th.join().unwrap();\n    }\n    let snapshot = inst.inspect();\n    println!(\"Snapshot: {:?}\", snapshot);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Accumulator {\n    data: Arc<Mutex<Vec<i32>>>,\n}\nimpl Accumulator {\n    fn new(size: usize) -> Self {\n        let mut vec = Vec::with_capacity(size);\n        vec.resize(size, 0); \n        Self { data: Arc::new(Mutex::new(vec)) }\n    }\n    fn process(&self) {\n        let len = self.data.lock().unwrap().len();\n        let mut handles = Vec::new();\n        for i in 0..len {\n            let arc_clone = Arc::clone(&self.data);\n            handles.push(thread::spawn(move || {\n                let mut vec = arc_clone.lock().unwrap();\n                vec[i] = i as i32;\n            }));\n        }\n        for handle in handles {\n            handle.join().unwrap();\n        }\n    }\n    fn total(&self) -> i32 {\n        let vec = self.data.lock().unwrap();\n        vec.iter().sum()\n    }\n}\nfn main() {\n    let aggregator = Accumulator::new(10);\n    aggregator.process();\n    println!(\"Sum: {}\", aggregator.total());\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Data {\n    buffer: Vec<u8>,\n}\nimpl Data {\n    fn new(size: usize) -> Self {\n        let mut vec = Vec::with_capacity(size);\n        for i in 0..size {\n            vec.push(i as u8);\n        }\n        Data { buffer: vec }\n    }\n    fn sum(&self) -> u64 {\n        self.buffer.iter().map(|&x| x as u64).sum()\n    }\n}\nfn main() {\n    let shared = Arc::new(Mutex::new(Data::new(10)));\n    let mut threads = vec![];\n    for _ in 0..4 {\n        let clone = shared.clone();\n        threads.push(thread::spawn(move || {\n            let guard = clone.lock().unwrap();\n            println!(\"Total: {}\", guard.sum());\n        }));\n    }\n    for t in threads {\n        t.join().unwrap();\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\nstruct Buffer {\n    data: Vec<u32>,\n}\nimpl Buffer {\n    fn new(n: usize) -> Self {\n        let data = vec![0; n];\n        Buffer { data }\n    }\n    fn populate(&mut self) {\n        let n = self.data.len();\n        for i in 0..n {\n            self.data[i] = (i + 1) as u32;\n        }\n    }\n    fn concurrent_sum(&self) -> u32 {\n        let shared = Arc::new(self.data.clone());\n        let shared_clone = Arc::clone(&shared);\n        let handle = thread::spawn(move || {\n            let mut total = 0;\n            for &val in shared_clone.iter() {\n                total += val;\n            }\n            total\n        });\n        handle.join().unwrap()\n    }\n}\nfn main() {\n    let mut buf = Buffer::new(10);\n    buf.populate();\n    let total = buf.concurrent_sum();\n    println!(\"Total: {}\", total);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\npub struct DataContainer {\n    data: Vec<u8>,\n}\nimpl DataContainer {\n    pub fn new(size: usize) -> Self {\n        let mut v = Vec::with_capacity(size);\n        unsafe { v.set_len(size); }\n        for i in 0..size {\n            v[i] = i as u8;\n        }\n        DataContainer { data: v }\n    }\n    pub fn sum(&self) -> u32 {\n        self.data.iter().map(|&b| b as u32).sum()\n    }\n}\nfn main() {\n    let container = Arc::new(Mutex::new(DataContainer::new(10)));\n    let c = Arc::clone(&container);\n    let handle = thread::spawn(move || {\n        let locked = c.lock().unwrap();\n        println!(\"Sum in thread: {}\", locked.sum());\n    });\n    handle.join().unwrap();\n    let locked = container.lock().unwrap();\n    println!(\"Final Sum: {}\", locked.sum());\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::vec::Vec;\nstruct Processor;\nimpl Processor {\n    pub fn execute(&self, input: &[u32]) -> u32 {\n        let n = input.len();\n        let mut storage: Vec<u32> = Vec::with_capacity(n);\n        unsafe {\n            let ptr = storage.as_mut_ptr();\n            for i in 0..n {\n                *ptr.add(i) = input[i];\n            }\n            storage.set_len(n);\n        }\n        storage.iter().sum()\n    }\n}\nfn main() {\n    let proc = Processor;\n    let data = vec![1, 2, 3, 4];\n    let result = proc.execute(&data);\n    println!(\"Result: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct Core {\n    size: usize,\n}\nimpl Core {\n    pub fn new(size: usize) -> Self {\n        Core { size }\n    }\n    pub fn generate(&self) -> u32 {\n        let mut construct = Vec::with_capacity(self.size);\n        unsafe {\n            construct.set_len(self.size);\n            for index in 0..self.size {\n                *construct.get_unchecked_mut(index) = index as u32;\n            }\n        }\n        construct.iter().sum()\n    }\n}\nfn main() {\n    let entity = Arc::new(Mutex::new(Core::new(10)));\n    let clone_entity = Arc::clone(&entity);\n    let thread_handle = thread::spawn(move || {\n        let guard = clone_entity.lock().unwrap();\n        let total = guard.generate();\n        println!(\"Computed sum in thread: {}\", total);\n        total\n    });\n    let main_total = {\n        let guard = entity.lock().unwrap();\n        guard.generate()\n    };\n    let thread_total = thread_handle.join().unwrap();\n    println!(\"Computed sum in main: {}\", main_total);\n    if main_total != thread_total {\n        println!(\"Inconsistency detected.\");\n        std::process::exit(1);\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::ptr;\nstruct DataManager {\n    data: Arc<Mutex<Vec<u8>>>,\n}\nimpl DataManager {\n    fn new(capacity: usize) -> Self {\n        let mut v = Vec::with_capacity(capacity);\n        unsafe {\n            v.set_len(capacity);\n        }\n        DataManager {\n            data: Arc::new(Mutex::new(v)),\n        }\n    }\n    fn process(&self, input: &[u8]) {\n        let mut lock = self.data.lock().unwrap();\n        if input.len() > lock.capacity() {\n            panic!(\"Input too large\");\n        }\n        unsafe {\n            ptr::copy_nonoverlapping(input.as_ptr(), lock.as_mut_ptr(), input.len());\n            lock.set_len(input.len());\n        }\n    }\n    fn fetch(&self) -> Vec<u8> {\n        let lock = self.data.lock().unwrap();\n        lock.clone()\n    }\n}\npub fn main() {\n    let manager = DataManager::new(10);\n    let manager_clone = manager.data.clone();\n    let reader = thread::spawn(move || {\n        thread::sleep(std::time::Duration::from_millis(50));\n        let data = manager_clone.lock().unwrap();\n        println!(\"Concurrent read sees: {:?}\", &*data);\n    });\n    let src = vec![1, 2, 3, 4, 5];\n    manager.process(&src);\n    reader.join().unwrap();\n    println!(\"Operation complete, vector length: {}\", manager.fetch().len());\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nuse std::thread;\nstruct Processor;\nimpl Processor {\n    pub fn process(data: &[u32]) -> Vec<u32> {\n        let n = data.len();\n        let mut out: Vec<u32> = Vec::with_capacity(n);\n        unsafe {\n            let ptr_out = out.as_mut_ptr();\n            for i in 0..n {\n                ptr_out.add(i).write(data[i].wrapping_add(1));\n            }\n            out.set_len(n);\n        }\n        out\n    }\n}\nfn main() {\n    let data = vec![10, 20, 30, 40];\n    let handles: Vec<_> = (0..4)\n        .map(|_| {\n            let data_thread = data.clone();\n            thread::spawn(move || {\n                let result = Processor::process(&data_thread);\n                println!(\"Result: {:?}\", result);\n            })\n        })\n        .collect();\n    for handle in handles {\n        handle.join().expect(\"Thread panicked\");\n    }\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::vec::Vec;\nstruct DataBuffer {\n    data: Vec<u8>,\n}\nimpl DataBuffer {\n    fn new(n: usize) -> Self {\n        let mut v = Vec::with_capacity(n);\n        unsafe {\n            v.set_len(n);\n        }\n        DataBuffer { data: v }\n    }\n    fn fill(&mut self, value: u8) {\n        for i in 0..self.data.len() {\n            self.data[i] = value;\n        }\n    }\n}\nfn main() {\n    let mut buf = DataBuffer::new(5);\n    buf.fill(10);\n    println!(\"Buffer contents: {:?}\", buf.data);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::thread;\n#[repr(C)]\npub struct Holder {\n    pub data: [u8; 5],\n    pub extra: u8,\n}\nimpl Holder {\n    pub fn new() -> Self {\n        Self {\n            data: [1, 2, 3, 4, 5],\n            extra: 99,\n        }\n    }\n}\npub fn compute_total(holder: &Holder) -> u32 {\n    unsafe {\n        let ptr = holder.data.as_ptr();\n        let slice = std::slice::from_raw_parts(ptr, holder.data.len());\n        slice.iter().map(|&x| x as u32).sum()\n    }\n}\npub fn run() {\n    let holder = Holder::new();\n    let handle = thread::spawn(move || compute_total(&holder));\n    let total = handle.join().unwrap();\n    println!(\"Total: {}\", total);\n}\nfn main() {\n    run();\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::Arc;\nuse std::thread;\ntrait Summable {\n    fn calculate(&self) -> u32;\n}\nstruct BufferHandler {\n    buf: Vec<u8>,\n}\nimpl BufferHandler {\n    fn new() -> Self {\n        BufferHandler { buf: Vec::new() }\n    }\n    fn load(&mut self, data: &[u8]) {\n        self.buf.extend_from_slice(data);\n    }\n}\nimpl Summable for BufferHandler {\n    fn calculate(&self) -> u32 {\n        let len = self.buf.len();\n        let ptr = self.buf.as_ptr();\n        unsafe {\n            let mut total: u32 = 0;\n            for i in 0..len {\n                total += *ptr.add(i) as u32;\n            }\n            total\n        }\n    }\n}\nfn main() {\n    let mut handler = BufferHandler::new();\n    handler.load(&[1, 2, 3, 4]);\n    let shared_handler = Arc::new(handler);\n    let handler_clone = Arc::clone(&shared_handler);\n    let worker = thread::spawn(move || {\n        handler_clone.calculate()\n    });\n    let result = worker.join().expect(\"Worker thread panicked\");\n    println!(\"Computed sum: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::ptr;\nstruct DataHandler;\nimpl DataHandler {\n    pub fn process(&self, input: &[u8]) -> Vec<u8> {\n        let mut buffer: Vec<u8> = Vec::with_capacity(input.len());\n        unsafe {\n            let dest = buffer.as_mut_ptr();\n            for i in 0..input.len() {\n                let value = *input.get_unchecked(i);\n                ptr::write(dest.add(i), value);\n            }\n            buffer.set_len(input.len());\n        }\n        buffer\n    }\n}\nfn main() {\n    let handler = DataHandler;\n    let sample = vec![10, 20, 30, 40];\n    let result = handler.process(&sample);\n    println!(\"Processed output: {:?}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::sync::{Arc, Mutex};\nuse std::thread;\nstruct DataBuffer {\n    data: Vec<u32>,\n}\nimpl DataBuffer {\n    fn new(size: usize) -> Self {\n        let mut data = Vec::with_capacity(size);\n        data.resize(size, 0);\n        Self { data }\n    }\n    fn populate(&mut self) {\n        for i in 0..self.data.len() {\n            self.data[i] = i as u32;\n        }\n    }\n    fn total(&self) -> u32 {\n        self.data.iter().sum()\n    }\n}\nfn compute() -> u32 {\n    let shared = Arc::new(Mutex::new(DataBuffer::new(10)));\n    let shared_clone = Arc::clone(&shared);\n    let handler = thread::spawn(move || {\n        let mut guard = shared_clone.lock().expect(\"failed to lock\");\n        guard.populate();\n    });\n    handler.join().expect(\"Thread panicked\");\n    let guard = shared.lock().expect(\"failed to lock after join\");\n    guard.total()\n}\nfn main() {\n    let result = compute();\n    println!(\"Result: {}\", result);\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "#![allow(unused)]\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nstruct BufferProcessor {\n    data: Vec<u32>,\n}\nimpl BufferProcessor {\n    fn new(capacity: usize) -> Self {\n        BufferProcessor {\n            data: Vec::with_capacity(capacity),\n        }\n    }\n    fn load_data(&mut self, src: &[u32]) {\n        unsafe {\n            self.data.set_len(src.len());\n            let dst_ptr = self.data.as_mut_ptr();\n            for i in 0..src.len() {\n                *dst_ptr.add(i) = *src.get_unchecked(i);\n            }\n        }\n    }\n    fn process(&mut self, src: &[u32]) -> u32 {\n        self.load_data(src);\n        self.data.iter().sum()\n    }\n}\nfn main() {\n    let input = vec![10, 20, 30, 40];\n    let mut processor = BufferProcessor::new(input.len());\n    let result = processor.process(&input);\n    println!(\"Result: {}\", result);\n    let sum = run_concurrent();\n    println!(\"Concurrent Total: {}\", sum);\n}\nfn run_concurrent() -> u32 {\n    let input = vec![10, 20, 30, 40];\n    let processor = Arc::new(Mutex::new(BufferProcessor::new(input.len())));\n    let input_arc = Arc::new(input);\n    let mut handles = Vec::new();\n    for _ in 0..2 {\n        let proc_clone = Arc::clone(&processor);\n        let in_clone = Arc::clone(&input_arc);\n        let handle = thread::spawn(move || {\n            let mut proc = proc_clone.lock().expect(\"Lock poisoned\");\n            proc.process(&in_clone)\n        });\n        handles.push(handle);\n    }\n    let mut total = 0;\n    for handle in handles {\n        total += handle.join().expect(\"Thread panicked\");\n    }\n    total\n}\n",
    "output": "fixed"
  },
  {
    "instruction": "Classify the Rust snippet as exactly one word: vulnerable or fixed.",
    "input": "use std::vec::Vec;\nuse std::sync::{Arc, Mutex};\nstruct DataBlock {\n    data: Vec<u32>,\n}\nimpl DataBlock {\n    fn new(size: usize) -> Self {\n        let mut vec = Vec::with_capacity(size);\n        unsafe {\n            vec.set_len(size);\n        }\n        Self { data: vec }\n    }\n    fn fill(&mut self) {\n        unsafe {\n            let ptr = self.data.as_mut_ptr();\n            for i in 0..self.data.len() {\n                *ptr.add(i) = i as u32;\n            }\n        }\n    }\n    fn verify(&self) -> bool {\n        let len = self.data.len();\n        for i in 0..len {\n            if self.data[i] != i as u32 {\n                return false;\n            }\n        }\n        true\n    }\n}\nfn main() {\n    let shared = Arc::new(Mutex::new(DataBlock::new(10)));\n    {\n        let shared_clone = Arc::clone(&shared);\n        let handle = std::thread::spawn(move || {\n            let mut db = shared_clone.lock().unwrap();\n            db.fill();\n        });\n        handle.join().unwrap();\n    }\n    let db = shared.lock().unwrap();\n    println!(\"Buffer contents (fixed): {:?}\", db.data);\n}\n",
    "output": "fixed"
  }
]