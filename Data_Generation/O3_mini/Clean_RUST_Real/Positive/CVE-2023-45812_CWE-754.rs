async fn process_supergraph_response_stage<C>(
    http_client: C,
    coprocessor_url: String,
    sdl: Arc<String>,
    response: supergraph::Response,
    response_config: SupergraphResponseConf,
) -> Result<supergraph::Response, BoxError>
where
    C: Service<hyper::Request<Body>, Response = hyper::Response<Body>, Error = BoxError>
        + Clone
        + Send
        + Sync
        + 'static,
    <C as tower::Service<http::Request<Body>>>::Future: Send + 'static,
{
    
    let (mut parts, body) = response.response.into_parts();
    
    
    let (first, rest): (Option<response::Response>, graphql::ResponseStream) =
        body.into_future().await;
    
    let first = first.ok_or_else(|| {
        BoxError::from("Coprocessor cannot convert body into future due to problem with first part")
    })?;
    
    
    let headers_to_send = response_config
        .headers
        .then(|| externalize_header_map(&parts.headers))
        .transpose()?;
    let body_to_send = response_config
        .body
        .then(|| serde_json::to_value(&first).expect("serialization will not fail"));
    let status_to_send = response_config.status_code.then(|| parts.status.as_u16());
    let context_to_send = response_config.context.then(|| response.context.clone());
    let sdl_to_send = response_config.sdl.then(|| sdl.clone().to_string());
    let payload = Externalizable::supergraph_builder()
        .stage(PipelineStep::SupergraphResponse)
        .and_id(TraceId::maybe_new().map(|id| id.to_string()))
        .and_headers(headers_to_send)
        .and_body(body_to_send)
        .and_context(context_to_send)
        .and_status_code(status_to_send)
        .and_sdl(sdl_to_send.clone())
        .build();
    
    tracing::debug!(?payload, "externalized output");
    let guard = response.context.enter_active_request();
    let start = Instant::now();
    let co_processor_result = payload.call(http_client.clone(), &coprocessor_url).await;
    let duration = start.elapsed().as_secs_f64();
    drop(guard);
    tracing::info!(
        histogram.apollo.router.operations.coprocessor.duration = duration,
        coprocessor.stage = %PipelineStep::SupergraphResponse,
    );
    tracing::debug!(?co_processor_result, "co-processor returned");
    let co_processor_output = co_processor_result?;
    validate_coprocessor_output(&co_processor_output, PipelineStep::SupergraphResponse)?;
    
    
    
    
    let new_body: crate::response::Response = match co_processor_output.body {
        Some(value) => serde_json::from_value(value)?,
        None => first,
    };
    if let Some(control) = co_processor_output.control {
        parts.status = control.get_http_status()?
    }
    if let Some(context) = co_processor_output.context {
        for (key, value) in context.try_into_iter()? {
            response
                .context
                .upsert_json_value(key, move |_current| value);
        }
    }
    if let Some(headers) = co_processor_output.headers {
        parts.headers = internalize_header_map(headers)?;
    }
    
    let context = response.context.clone();
    let map_context = response.context.clone();
    
    let mapped_stream = rest
        .then(move |deferred_response| {
            let generator_client = http_client.clone();
            let generator_coprocessor_url = coprocessor_url.clone();
            let generator_map_context = map_context.clone();
            let generator_sdl_to_send = sdl_to_send.clone();
            async move {
                let body_to_send = response_config.body.then(|| {
                    serde_json::to_value(&deferred_response).expect("serialization will not fail")
                });
                let context_to_send = response_config
                    .context
                    .then(|| generator_map_context.clone());
                
                
                
                let payload = Externalizable::router_builder()
                    .stage(PipelineStep::SupergraphResponse)
                    .and_id(TraceId::maybe_new().map(|id| id.to_string()))
                    .and_body(body_to_send)
                    .and_context(context_to_send)
                    .and_sdl(generator_sdl_to_send)
                    .build();
                
                tracing::debug!(?payload, "externalized output");
                let guard = generator_map_context.enter_active_request();
                let co_processor_result = payload
                    .call(generator_client, &generator_coprocessor_url)
                    .await;
                drop(guard);
                tracing::debug!(?co_processor_result, "co-processor returned");
                let co_processor_output = co_processor_result?;
                validate_coprocessor_output(
                    &co_processor_output,
                    PipelineStep::SupergraphResponse,
                )?;
                
                
                
                
                let new_deferred_response: crate::response::Response =
                    match co_processor_output.body {
                        Some(value) => serde_json::from_value(value)?,
                        None => deferred_response,
                    };
                if let Some(context) = co_processor_output.context {
                    for (key, value) in context.try_into_iter()? {
                        generator_map_context.upsert_json_value(key, move |_current| value);
                    }
                }
                
                Ok(new_deferred_response)
            }
        })
        .map(|res: Result<response::Response, BoxError>| match res {
            Ok(response) => response,
            Err(e) => {
                tracing::error!("coprocessor error handling deferred supergraph response: {e}");
                response::Response::builder()
                    .error(
                        Error::builder()
                            .message("Internal error handling deferred response")
                            .extension_code("INTERNAL_ERROR")
                            .build(),
                    )
                    .build()
            }
        });
    
    
    let stream = once(ready(new_body)).chain(mapped_stream).boxed();
    
    Ok(supergraph::Response {
        context,
        response: http::Response::from_parts(parts, stream),
    })
}
