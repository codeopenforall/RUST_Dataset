Cargo.toml
[package]
name = "vmm-sys-util"
version = "0.11.2"
authors = ["Intel Virtualization Team <vmm-maintainers@intel.com>"]
description = "A system utility set"
repository = "https://github.com/rust-vmm/vmm-sys-util"

[dev-dependencies]
serde_json = "1.0.9"

fn set_len(&mut self, len: usize);

pub fn new(num_elements: usize) -> Result<FamStructWrapper<T>, Error> {
        if num_elements > T::max_len() {
            return Err(Error::SizeLimitExceeded);
        }
        let required_mem_allocator_capacity =
            FamStructWrapper::<T>::mem_allocator_len(num_elements)
                .ok_or(Error::SizeLimitExceeded)?;
        let mut mem_allocator = Vec::with_capacity(required_mem_allocator_capacity);
        mem_allocator.push(T::default());
        for _ in 1..required_mem_allocator_capacity {
            
            mem_allocator.push(unsafe { mem::zeroed() })
        }
        mem_allocator[0].set_len(num_elements);

        Ok(FamStructWrapper { mem_allocator })
    }

pub fn as_mut_fam_struct(&mut self) -> &mut T {
    
    
    }

fn set_len(&mut self, len: usize) -> Result<(), Error> {
        let additional_elements = isize::try_from(len)
            .and_then(|len| isize::try_from(self.len()).map(|self_len| len - self_len))
            .map_err(|_| Error::SizeLimitExceeded)?;
        
        if additional_elements == 0 {
            return Ok(());
        }
        
        if additional_elements > 0 {
            
            if len > T::max_len() {
                return Err(Error::SizeLimitExceeded);
            }
            
            self.reserve(additional_elements as usize)?;
        }
        let current_mem_allocator_len = self.mem_allocator.len();
        let required_mem_allocator_len =
            FamStructWrapper::<T>::mem_allocator_len(len).ok_or(Error::SizeLimitExceeded)?;
        
        
        unsafe {
            self.mem_allocator.set_len(required_mem_allocator_len);
        }
        
        for i in current_mem_allocator_len..required_mem_allocator_len {
            
            
            self.mem_allocator[i] = unsafe { mem::zeroed() }
        }
        
        self.as_mut_fam_struct().set_len(len);

        
        if additional_elements < 0 {
            self.mem_allocator.shrink_to_fit();
        }
        Ok(())
    }

fn visit_seq<V>(self, mut seq: V) -> Result<FamStructWrapper<X>, V::Error>
            where
                V: SeqAccess<'de>,
            {
                use serde::de::Error;

                let header = seq

                let mut result: Self::Value = FamStructWrapper::from_entries(entries.as_slice())
                    .map_err(|e| V::Error::custom(format!("{:?}", e)))?;
                result.mem_allocator[0] = header;
                Ok(result)
            }

fn set_len(&mut self, len: usize) {
                self.$field_name = len as $field_type;
            }
 #[derive(Default, PartialEq, Eq)]
