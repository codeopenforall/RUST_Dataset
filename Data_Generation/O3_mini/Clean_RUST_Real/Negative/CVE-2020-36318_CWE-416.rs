pub fn make_contiguous(&mut self) -> &mut [T] {
        if self.is_contiguous() {
            let tail = self.tail;
            let head = self.head;
            return unsafe { RingSlices::ring_slices(self.buffer_as_mut_slice(), head, tail).0 };
        }

        let buf = self.buf.ptr();
        let cap = self.cap();
        let len = self.len();
        let free = self.tail - self.head;
        let tail_len = cap - self.tail;
        if free >= tail_len {
            
            
            
            
            
            
            unsafe {
                ptr::copy(buf, buf.add(tail_len), self.head);
                
                ptr::copy_nonoverlapping(buf.add(self.tail), buf, tail_len);
                
                self.tail = 0;
                self.head = len;
            }
        } else if free > self.head {
            
            
            
            
            

            
            
            
            
            
            
            unsafe {
                ptr::copy(buf.add(self.tail), buf.add(self.head), tail_len);
                
                ptr::copy_nonoverlapping(buf, buf.add(self.head + tail_len), self.head);
                

                self.tail = self.head;
                self.head = self.wrap_add(self.tail, len);
            }
        } else {
            
            
            
            
            
            let mut left_edge: usize = 0;
            let mut right_edge: usize = self.tail;
            unsafe {
                
                
                
                
                
                
                
                
                
                
                while left_edge < len && right_edge != cap {
                    let mut right_offset = 0;
                    for i in left_edge..right_edge {
                        right_offset = (i - left_edge) % (cap - right_edge);
                        let src: isize = (right_edge + right_offset) as isize;
                        ptr::swap(buf.add(i), buf.offset(src));
                    }
                    let n_ops = right_edge - left_edge;
                    left_edge += n_ops;
                    right_edge += right_offset + 1;
                }
                self.tail = 0;
                self.head = len;
            }
        }

        let tail = self.tail;
        let head = self.head;
        unsafe { RingSlices::ring_slices(self.buffer_as_mut_slice(), head, tail).0 }
    }

fn from(mut other: VecDeque<T>) -> Self {
        other.make_contiguous();
        unsafe {
            let other = ManuallyDrop::new(other);
            let buf = other.buf.ptr();
            let len = other.len();
            let cap = other.cap();

            if other.tail != 0 {
                    ptr::copy(buf.add(other.tail), buf, len);
            }
            Vec::from_raw_parts(buf, len, cap)
        }
    }
