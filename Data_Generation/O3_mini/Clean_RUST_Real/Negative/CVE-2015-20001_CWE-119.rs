
    
    
    
    
    
    fn sift_up(&mut self, start: usize, pos: usize) {
        unsafe {
            
            let mut hole = Hole::new(&mut self.data, pos);

           
            while hole.pos() > start {
                let parent = (hole.pos() - 1) / 2;
                if hole.removed() <= hole.get(parent) { break }
                hole.move_to(parent);
            }
        }
    }

fn sift_down_range(&mut self, mut pos: usize, end: usize) {
        let start = pos;
        unsafe {
           
            let mut hole = Hole::new(&mut self.data, pos);
            let mut child = 2 * pos + 1;
            while child < end {
                let right = child + 1;
                if right < end && !(hole.get(child) > hole.get(right)) {
                    child = right;
                }
               
                hole.move_to(child);
                child = 2 * hole.pos() + 1;
            }

            
            pos = hole.pos;
        }
        self.sift_up(start, pos);
    }
